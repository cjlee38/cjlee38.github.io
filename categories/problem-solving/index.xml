<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>problem-solving on cjlee38</title>
    <link>https://cjlee38.github.io/categories/problem-solving/</link>
    <description>Recent content in problem-solving on cjlee38</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Jan 2021 22:17:00 +0000</lastBuildDate><atom:link href="https://cjlee38.github.io/categories/problem-solving/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title># 백준[No.1676] - 팩토리얼 0의 개수 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2021-01-02-problem_solving_22/</link>
      <pubDate>Sat, 02 Jan 2021 22:17:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2021-01-02-problem_solving_22/</guid>
      <description>문제링크
Problem Solve 접근 방법 : 문제를 푸는 원리만 이해하면, 구현은 쉽게 할수 있는 문제다.
우선, 주어진 문제의 이해를 위해 factorial(10) 을 구해보면, 3628800 이라는 숫자가 나온다. 그리고 가장 뒤쪽에서부터 0의 개수를 세보면, 2개 라는 정답을 얻을 수 있다.
그러나, 이를 직접 계산해서 0의 개수를 세는, 즉 시뮬레이션을 하게 되면 아주 치명적인 문제가 발생하는데, 문제의 입력 조건에서도 보이듯이 최대 factorial(500)까지 갈 수 있고, 이는
122013682599111006870123878542304692625357434280319284219241358838584537315388 199760549644750220328186301361647714820358416337872207817720048078520515932928 547790757193933060377296085908627042917454788242491272634430567017327076946106 280231045264421887878946575477714986349436778103764427403382736539747138647787 849543848959553753799042324106127132698432774571554630997720278101456108118837 370953101635632443298702956389662891165897476957208792692887128178007026517450 776841071962439039432253642260523494585012991857150124870696156814162535905669 342381300885624924689156412677565448188650659384795177536089400574523894033579 847636394490531306232374906644504882466507594673586207463792518420045936969298 102226397195259719094521782333175693458150855233282076282002340262690789834245 171200620771464097945611612762914595123722991334016955236385094288559201872743 379517301458635757082835578015873543276888868012039988238470215146760544540766 353598417443048012893831389688163948746965881750450692636533817505547812864000 000000000000000000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000</description>
    </item>
    
    <item>
      <title># 알고스팟 [ID:PICNIC] 소풍 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-12-10-problem_solving_21/</link>
      <pubDate>Thu, 10 Dec 2020 13:39:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-12-10-problem_solving_21/</guid>
      <description>문제 링크
Problem 문제
안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다. 원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다. 그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 항상 서로 친구인 학생들끼리만 짝을 지어 줘야 합니다.
각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝지어줄 수 있는 방법의 수를 계산하는 프로그램을 작성하세요. 짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.4] - 숫자 블록 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-18-problem_solving_20/</link>
      <pubDate>Wed, 18 Nov 2020 12:43:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-18-problem_solving_20/</guid>
      <description>문제 링크
Problem 문제 설명
그렙시에는 0으로 된 도로에 숫자 블록을 설치하기로 하였습니다. 숫자 블록의 규칙은 다음과 같습니다.
블록의 번호가 n 일 때, 가장 처음 블록은 n * 2번째 위치에 설치합니다. 그다음은 n * 3, 그다음은 n * 4, &amp;hellip;로 진행합니다.만약 기존에 블록이 깔려있는 자리라면 그 블록을빼고 새로운 블록으로 집어넣습니다.
예를 들어 1번 블록은 2,3,4,5, &amp;hellip; 인 위치에 우선 설치합니다. 그다음 2번 블록은 4,6,8,10, &amp;hellip; 인 위치에 설치하고, 3번 블록은 6,9,12&amp;hellip; 인 위치에 설치합니다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.3] - 순위 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-18-problem_solving_19/</link>
      <pubDate>Wed, 18 Nov 2020 11:52:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-18-problem_solving_19/</guid>
      <description>문제 링크
Problem 문제 설명
n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.
선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title># 백준[No.10227] - 삶의 질 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-06-problem_solving_18/</link>
      <pubDate>Fri, 06 Nov 2020 09:05:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-06-problem_solving_18/</guid>
      <description>문제 링크
Problem Solve : 처음에는 한 5분 정도는 문제가 무슨 뜻인지 잘 이해가 되지 않았다.
문제의 예제를 기준으로 설명하자면,
 R * C 크기의 2차원 배열에서, 각 배열의 요소는 1 ~ R * C 까지의 중복되지 않는 값을 가진다. H * W (H와 W는 홀수) 의 크기만큼의 영역이 여러 개 존재하는데, 그 중 중앙값이 가장 낮은 값을 골라야 한다.  즉, 문제의 예제를 기준으로 설명하자면,
5 11 12
17 18 2</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] [1차] 뉴스 클러스터링 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-03-problem_solving_17/</link>
      <pubDate>Tue, 03 Nov 2020 10:52:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-11-03-problem_solving_17/</guid>
      <description>문제 링크
Problem 문제 설명
뉴스 클러스터링
여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.
개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 카카오 신입 개발자 공채 관련 기사를 검색해보았다.
카카오 첫 공채..&amp;lsquo;블라인드&amp;rsquo; 방식 채용
카카오, 합병 후 첫 공채.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] 더 맵게 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-30-problem_solving_16/</link>
      <pubDate>Fri, 30 Oct 2020 08:01:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-30-problem_solving_16/</guid>
      <description>문제 링크
Problem. 문제 설명
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] 숫자의 표현 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-19-problem_solving_15/</link>
      <pubDate>Mon, 19 Oct 2020 19:45:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-19-problem_solving_15/</guid>
      <description>문제 링크
Problem 문제 설명
Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.
 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15  자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.3] 최고의 집합 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-12-problem_solving_14/</link>
      <pubDate>Mon, 12 Oct 2020 05:27:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-12-problem_solving_14/</guid>
      <description>문제 링크
Problem 문제 설명
자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 집합으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.
 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합  예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다.
{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 }</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.3] 야근지수 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-11-problem_solving_13/</link>
      <pubDate>Sun, 11 Oct 2020 23:45:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-11-problem_solving_13/</guid>
      <description>문제 링크
Problem 문제 설명
회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.
제한 사항
works는 길이 1 이상, 20,000 이하인 배열입니다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.3] 단속카메라 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-04-problem_solving_12/</link>
      <pubDate>Sun, 04 Oct 2020 22:11:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-10-04-problem_solving_12/</guid>
      <description>Problem 문제 설명
고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.
고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.
제한사항
 차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다.</description>
    </item>
    
    <item>
      <title># 백준[No.17144] - 미세먼지 안녕! ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-28-problem_solving_10/</link>
      <pubDate>Mon, 28 Sep 2020 21:00:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-28-problem_solving_10/</guid>
      <description>Problem {: .alignCenter}
Answer : 문제가 좀 복잡한데, 어쨌든 시뮬레이션으로 풀었다.
이 문제에서 신경써야 할 부분은, 보다시피 딱 두 가지다.
 미세먼지의 확산 공기청정기의 작동  처음에는 공기청정기가 로봇청소기처럼 돌아다니면서 청소하는 개념인줄 알았더니,
그게 아니고 제자리 Fix된 상태에서 공기를 순환시키는 방식으로 동작하는 것이었다.
아무튼, 하나씩 풀어보자.
미세먼지의 확산 : 미세먼지는 인접한 네 방향으로만 확산하고,
벽 혹은 공기청정기에 가로막혀 있으면 확산되지 않는다.
또한, 본래 자리에 있던 미세먼지는 빠져나간 미세먼지 만큼만
감소하므로, 이를 유의해야 한다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] N진수 게임( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-28-problem_solving_11/</link>
      <pubDate>Mon, 28 Sep 2020 20:13:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-28-problem_solving_11/</guid>
      <description>문제 링크
Problem N진수 게임
튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다.
이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.
 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.  이렇게 게임을 진행할 경우,</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] - 카펫 ( java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-23-problem_solving_9/</link>
      <pubDate>Wed, 23 Sep 2020 22:12:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-23-problem_solving_9/</guid>
      <description>문제 링크
PROBLEM : 문제 설명
Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.
Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.
Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.
제한사항</description>
    </item>
    
    <item>
      <title># 백준[No.17140] - 이차원 배열과 연산 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-18-problem_solving_8/</link>
      <pubDate>Fri, 18 Sep 2020 20:12:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-18-problem_solving_8/</guid>
      <description>문제 링크
Problem {: .alignCenter}
Solve : 문제 자체를 푸는데도 꽤 걸렸지만, 쓸데 없는 부분에서 고생했던 문제라서, 살짝 열받아서 가져왔다.
문제의 지문 자체가 그리 어렵지는 않지만, 시뮬레이션해서 이를 만들어줘야 하기 때문에, 이 부분에서 난이도가 좀 오르는 것 같다.
접근 방법 : 다음의 순서를 반복하면 된다
 행과 열 중, size가 더 긴 곳(같다면 행)을 선택한다. 더 긴 곳을 기준으로 돌면서(즉, 행이라면 하나의 행을 가져와서) 정렬을 수행한다.  정렬은 &amp;ldquo;숫자의 등장 횟수를 기준으로 오름차순&amp;rdquo; 숫자의 등장 횟수가 같다면, 숫자 자체의 크기를 기준으로 오름차순   각 정렬을 수행하면서, 달라진 최대 길이를 구한다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] - 튜플 ( java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-07-problem_solving_7/</link>
      <pubDate>Mon, 07 Sep 2020 01:51:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-07-problem_solving_7/</guid>
      <description>문제 링크
PROBLEM {% raw %} 문제 설명
셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.
(a1, a2, a3, &amp;hellip;, an)
튜플은 다음과 같은 성질을 가지고 있습니다.
중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.
ex : (1, 2, 3) ≠ (1, 3, 2)</description>
    </item>
    
    <item>
      <title># 백준[No.2457] - 공주님의 정원 ( Java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-04-problem_solving_6/</link>
      <pubDate>Fri, 04 Sep 2020 08:38:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-04-problem_solving_6/</guid>
      <description>문제 링크
PROBLEM {: .alignCenter}
예제 입력 4
1 1 5 31
1 1 6 30
5 15 8 31
6 10 12 10
예제 출력 2
SOLVE 1) 주의점 : 처음에는 &amp;ldquo;꽃들의 총 개수&amp;rdquo; 라는 말이, literal 하게 꽃의 count 인 줄 알았는데, 곰곰히 생각해보니 &amp;ldquo;꽃의 종류의 개수&amp;rdquo; 라는 말이 더 정확한 것 같다. 즉, &amp;ldquo;3월 1일부터 11월 30일까지 최소 한 가지 이상의 꽃이 피어있어야 함을 의미한다.
아무튼, 해당 문제에서 주의해야 할 점은 다음과 같다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] - 오픈채팅방 ( java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-03-problem_solving_5/</link>
      <pubDate>Thu, 03 Sep 2020 07:19:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-09-03-problem_solving_5/</guid>
      <description>문제 링크
PROBLEM 오픈채팅방 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.
신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.
[닉네임]님이 들어왔습니다.
채팅방에서 누군가 나가면 다음 메시지가 출력된다.
[닉네임]님이 나갔습니다.
채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.
 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.2] - 올바른 괄호 ( java )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-29-problem_solving_4/</link>
      <pubDate>Sat, 29 Aug 2020 17:16:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-29-problem_solving_4/</guid>
      <description>PROBLEM 문제 설명
괄호가 바르게 짝지어졌다는 것은 &amp;lsquo;(&amp;rsquo; 문자로 열렸으면 반드시 짝지어서 &amp;lsquo;)&amp;rsquo; 문자로 닫혀야 한다는 뜻입니다. 예를 들어
 ()() 또는 (())() 는 올바른 괄호입니다. )()( 또는 (()( 는 올바르지 않은 괄호입니다.  &amp;lsquo;(&amp;rsquo; 또는 &amp;lsquo;)&amp;rsquo; 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.
제한사항
 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 &amp;lsquo;(&amp;rsquo; 또는 &amp;lsquo;)&amp;rsquo; 로만 이루어져 있습니다.</description>
    </item>
    
    <item>
      <title># 백준[No.1748] - 수 이어 쓰기 1 ( Python )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_3/</link>
      <pubDate>Thu, 27 Aug 2020 23:58:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_3/</guid>
      <description>문제 링크
PROBLEM {: .alignCenter}
SOLVE : 이번 문제는 이해 하기에 그리 어렵지 않으므로, 바로 해결 방법으로 진행한다.
1) 첫 번째 방법 ( feat. Out of Memory ) : 첫 번째 잘못된 접근은, 모든 숫자를 다 구해서 String으로 캐스팅해서 리스트에 담은 뒤, 이를 모두 concatenate 하는 것이다. 문제를 그대로 이해하고 그대로 해결하고자 하는 것이다. N = int(input()) numbers = [str(i) for i in range(1, N+1)] print(len(&amp;#39;&amp;#39;.join(numbers))) 그러나, 입력의 최대 값이 1억이므로, 이를 모두 이어 붙이게 되면 굉~장히 긴 String이 등장할 것이다.</description>
    </item>
    
    <item>
      <title># 백준[No.2477] - 참외밭 ( python )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_2/</link>
      <pubDate>Thu, 27 Aug 2020 22:41:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_2/</guid>
      <description>문제 링크
PROBLEM {: .alignCenter} {: .alignCenter}
SOLVE ** 1) 주의사항** : 해당 문제에서 주의해야 할 요소는 다음과 같다.
 참외밭은 ㄱ자 모양, 혹은 이를 회전한 ┏, ┗, ┛ 모양의 육각형이다. 참외밭의 둘레를 돌면서 지나는 변의 방향은 반시계방향으로 주어진다. 변의 방향은 동,서,남,북 순서로 1,2,3,4의 값을 가진다. 출발 꼭지점은 &amp;ldquo;임의&amp;quot;로 주어진다.  2) 해결법 : 처음 문제를 보았을 때, 위 두가지 방법이 떠올랐다.
 1. 해당 모형의 육각형을 3등분하여 각 넓이를 구한뒤, 합산한다.</description>
    </item>
    
    <item>
      <title># 프로그래머스[Lv.1] - 크레인 인형 뽑기 ( python )</title>
      <link>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_1/</link>
      <pubDate>Thu, 27 Aug 2020 20:58:00 +0000</pubDate>
      
      <guid>https://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_1/</guid>
      <description>문제 링크
알고리즘 공부를 어제부터 시작해서, Lv.1 문제부터 차근차근 풀어나가고 있다. 첫 번째 문제로 선택한 크레인 인형뽑기 게임 문제의 다음과 같다.
PROBLEM  게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.
죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.
{: .alignCenter}
게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다).</description>
    </item>
    
  </channel>
</rss>
