<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 깃 서브모듈 트러블슈팅 | cjlee38</title><meta name=keywords content="git,submodule,trouble-shooting"><meta name=description content="깃 서브모듈 트러블슈팅 : 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby & ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 jekyll 대신, hugo 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/git/git-submodule/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-174927148-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="# 깃 서브모듈 트러블슈팅"><meta property="og:description" content="깃 서브모듈 트러블슈팅 : 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby & ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 jekyll 대신, hugo 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/git/git-submodule/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-07-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-01T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 깃 서브모듈 트러블슈팅"><meta name=twitter:description content="깃 서브모듈 트러블슈팅 : 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby & ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 jekyll 대신, hugo 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 깃 서브모듈 트러블슈팅","item":"https://cjlee38.github.io/post/git/git-submodule/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 깃 서브모듈 트러블슈팅","name":"# 깃 서브모듈 트러블슈팅","description":"깃 서브모듈 트러블슈팅 : 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby \u0026amp; ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 jekyll 대신, hugo 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다.","keywords":["git","submodule","trouble-shooting"],"articleBody":"깃 서브모듈 트러블슈팅 : 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby \u0026 ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 jekyll 대신, hugo 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다.\nhugo 블로그는 보통 submodule을 기반으로 제작됩니다. jekyll의 경우 깃허브 자체에서 지원해주는 정적 사이트 생성기이기 때문에, 따로 빌드를 하지 않아도 됐던 것으로 기억합니다. 하지만 hugo는 그렇지 않습니다. 따라서 hugo 자체에서 지원해주는 기능으로 정적 사이트를 빌드한 뒤, 빌드 결과물을 깃허브에 업로드해야 합니다. 대개 다음과 같은 구조를 가집니다.\n메인 모듈에서 테마를 include 해온 뒤, 블로그 글을 작성하고, static site를 생성한 뒤, 그 결과물을 github에 업로드하는 방식입니다. 제가 블로그를 생성한 상황에서는 위와 같이 메인, 그리고 public 이라는 빌드 결과물이 깃허브에 업로드된 상태였습니다. 앞으로 메인 모듈을 ‘메인’, public을 ‘서브’ 로 축약해서 이야기하도록 하겠습니다.\n이전 생성 경험을 토대로 제작하는데에 큰 무리가 없었는데, 팀원들이 테스트를 시작하자 문제가 발생했습니다. 제가 혼자 사용할 때는 문제가 없었는데, 팀원들이 사용하려고 깃허브에서 clone 해오는 순간 문제가 발생한 것이죠. 프로젝트에서도 서브모듈을 활용하기로 결정되어 있었기 때문에, 해당 문제는 꼭 해결해야 한다는 생각이 들어, 이를 해결한 기록을 남겨보고자 합니다.\n발생한 문제는 총 두 가지였습니다. 하나씩 살펴보도록 하겠습니다.\n메인 git clone 시 submodule을 가져오지 않는다. : 메인을 clone 해오는 경우, 자연스럽게 submodule도 가져올 것이라고 예상할 수 있습니다. 하지만 예상과 달리 submodule은 가져오지 않고, 가져오려고 해도 제대로 동작하지 않았습니다. 서브모듈에 대한 개념이 부족했던 지라, ‘서브모듈에 대한 정보를 가져오지 않는걸까?’ 라는 생각이 들어 서브모듈을 직접 추가해보았습니다.\ngit submodule add -b ${branch} https://github.com/${organization}/${sub_repository} public\n위 명령어는 서브모듈이 존재하는 repository 를 현재 깃 프로젝트에 추가하되, ${branch} 라는 이름의 브랜치를 가져오고, 그 이름을 public 으로 설정하겠다는 의미입니다. 따라서 public 이라는 디렉토리에 서브모듈로 등록됩니다. (public은 hugo에서 빌드 결과물을 생성해놓는 디렉토리입니다.) 그런데 위와 같은 명령어를 실행할 경우, 다음과 같은 메세지가 등장합니다.\n'public' already exists in the index 뭔가 이상합니다. public에 대한 정보를 이미 가져온 것일까요 ? 이는 반만 맞습니다. 정확히는, submodule이 존재한다는 것, 그리고 그 녀석의 이름이 public 이라는 것 까지는 알고 있습니다. 코드를 한 곳에서 관리하는 것이 효율적이기 때문에, submodule의 소스코드는 별도의 repository에서 관리하는 상태입니다. 따라서 서브가 이미 존재하니, 깃은 ‘인덱스에 이미 존재한다’ 라고 대답합니다. git submodule status 를 입력하면 다음과 같습니다.\ngit submodule status  -d2d76400942ad9fe3616f60775053a32750d3bbb public -9af128a8a638d139771afc30a8f331a73ce810b1 themes/PaperMod submodule에 대한, 즉 ‘서브’ 프로젝트에 대한 상세 정보는 가져오지 못한 상태입니다. 이는 프로젝트의 .git 디렉토리를 확인해보면 알 수 있습니다. 프로젝트를 생성한 제 로컬에서는 .git/modules 디렉토리를 가보면 public, 그리고 테마와 관련된 /themes/${theme} 이 있는 것을 확인할 수 있습니다. 하지만 clone 해온 팀원의 프로젝트에서는 위 modules 디렉토리 자체가 없거나, 있더라도 그 내부가 비어있음을 확인할 수 있습니다.\n아무튼 이 정보를 알려주기 위해선 .gitmodules 라는 특수한 파일이 필요합니다. 해당 파일을 생성한 뒤, 다음과 같은 내용을 추가해주었습니다.\n[submodule \"public\"] \tpath = public \turl = https://github.com/${organization}/${sub_repository} \tbranch = ${branch} [submodule \"themes/${theme}\"] \tpath = themes/${theme} \turl = https://github.com/${organization}/${theme_repository} \tbranch = ${branch} 그리고, 다음의 두 명령어를 통해 submodule의 상세정보를 등록하고, 가져옵니다.\ngit submodule init git submodule update 이렇게 하면, 이제 public 디렉토리에 서브모듈에 대한 소스코드까지 포함되어 있는 것을 확인할 수 있습니다. 만약 .gitmodules 라는 파일이 remote(깃허브)에도 작성되어 있다면, 다음부터는 clone 해올 때 --recursive 혹은 --resurse-submodules 라는 옵션을 줘서 init 과 update 를 한번에 진행할 수 있습니다.\ngit clone ${main_repo} --recursive # 혹은 git clone ${main_repo} --recurse-submodules 메인 git clone 시 ref 에러가 발생한다. : 정확한 에러 문구는 다음과 같습니다.\nfatal: remote error: upload-pack: not our ref ${commit-id}\n대충 다음과 같이 생겼습니다.\n이 또한 submodule 의 특수성으로 인해 발생하는 문제입니다. 결론부터 말씀드리자면, ‘메인’ 프로젝트에서 갖고 있는 submodule 의 정보는 ‘서브’ 프로젝트(레포지토리) 자체가 아닌, ‘서브’ 프로젝트의 ‘특정 commit-id’ 를 갖고 있습니다.\n위에서 hugo 특성상 submodule을 활용한다고 말씀드렸습니다. 따라서 보통 아래와 같은 shell script를 활용합니다.\n# 정적 사이트 생성 hugo -t PaperMod  # '서브' 프로젝트 commit \u0026 push cd public git add . git commit -m ${commit-message} git push ${origin} ${branch}  # '메인' 프로젝트 commit \u0026 push cd .. git add . git commit -m ${commit-message} git push ${origin} ${branch} 그림, 예시와 함께 문제 상황이 발생한 이유를 설명해보겠습니다. (아래 예시에서의 push는 말 그대로의 push를, deploy는 위 스크립트를 실행하는 것이라고 생각해주시면 되겠습니다. )\n 팀원 ‘갑’이 로컬에서 ‘메인’ repository에 ‘서브’ repository를 submodule로 추가하고, ‘부모’의 repository에 deploy 했습니다. 그 순간, ‘메인’ repository에서는 ‘서브’ repository의 특정 commit-id(SA(sub-A)라고 하겠습니다)를 가져갑니다. (이 때 중요한 것은, ‘부모’의 repository에 push 할 때, ‘서브’ repository는 push되지 않는다는 것입니다. ‘서브’ repository는 별도로 push 과정을 거쳐야 하기 때문에 push가 아닌 deploy를 사용합니다.) 다음으로, 팀원 ‘을’이 부모 repository를 clone 해옵니다. 이 때, ‘서브’ repository 또한 --recursive 옵션을 통해 가져왔습니다. 해당 옵션을 통해 가져왔기 때문에, ‘서브’ repository의 SA 커밋을 가져와서, HEAD로 가리킵니다. 3-1. 그런데 현재 ‘을’의 local에 있는 ‘서브’가 가리키고 있는 HEAD는 특정 브랜치가 아닙니다. 임시로 생성된 ‘커밋 브랜치’의 SA 커밋입니다.(커밋 브랜치는 임의로 붙인 이름입니다. 정확한 이름은 모르겠습니다.) 여기까지는 문제가 없습니다.  4. 이 상태에서, ‘을’이 ‘서브’에 새로운 파일을 추가하고, commit 합니다.(해당 commit-id 를 SB라고 하겠습니다.)\n4-1. 그런데 이 SB commit-id 는 ‘서브’의 특정 브랜치 다음에 생긴 브랜치가 아닙니다. 위에서 언급한 임시의 ‘커밋 브랜치’ 다음에 위치합니다.\n5. 그리고 ‘을’ 이 ‘메인’ repository에 push합니다.\n5-1. ‘메인’ 입장에서는, ‘서브’의 commit-id가 SB 라는 정보를 가져갑니다. 즉, 가리키는 commit-id는 SA에서 SB로 바꿔치기됩니다.\n6. 이번에는 팀원 ‘병’ 이 ‘메인’ repository를 clone 해옵니다. 역시 마찬가지로, --recursive 옵션을 통해 가져왔고, ‘서브’ repository의 SB commit을 가져오려하는 순간 문제가 발생합니다.\n7. 왜냐하면, ‘서브’ repository의 그 어디에도 SB commit은 존재하지 않기 때문입니다.\n그렇다면 “6~7번 사이에서 ‘서브’ repository에 push 하면 되지 않나요?”(=7번에서 push가 아닌 deploy를 하면 되지 않나요?) 라고 의문을 제시할 수 있습니다만, 불가능합니다. 왜냐하면, 위 4번과 6번에서 말씀드렸다시피 commit의 위치가 특수한 곳에 존재하기 때문입니다. 따라서, push를 하려고 하면 다음과 같은 메시지를 볼 수 있습니다.\n이를 해결하기 위한 방법은 간단합니다. ‘서브’ repository에 push하기 전에, 브랜치를 바꿔주면 됩니다. 즉, 위 쉘 스크립트를 수정하면 다음과 같이 됩니다.\n# 정적 사이트 생성 hugo -t PaperMod  # '서브' 프로젝트 commit \u0026 push cd public git checkout ${branch} # git add . git commit -m ${commit-message} git push ${origin} ${branch}  # '메인' 프로젝트 commit \u0026 push cd .. git add . git commit -m ${commit-message} git push ${origin} ${branch} 여담 : github에서 clone 해올 때, 항상 특정 브랜치의 최신 커밋을 가져오도록 하면 좋을 것 같은데, 왜 이렇게 commit을 가져오도록 되어있는지 의문이 들었습니다. 그런데, 다시 생각해보면 이는 당연합니다.\n 말씀드렸던 대로, ‘메인’ repository를 clone 할 때, 항상 ‘서브’ repository의 최신 commit을 가져오게 된다고 가정해보겠습니다. ‘메인’ repository를 개발한 사람이 정상적으로 잘 동작하는 것을 확인하고 push를 했는데, 시간이 지나 ‘메인’ 에서 참조하고있는 ‘서브’ repository가 업데이트 되었습니다. 그런데 ‘서브’ repository 개발자의 실수로 버그가 있는 코드를 push했습니다.\n‘메인’ repository를 추가로 개발하려는 다른 사람이 clone 해왔는데, ‘메인’ repository 또한 문제가 발생합니다. 왜냐하면, ‘서브’ repository의 가장 최신 커밋을 가져왔기 때문에 ‘메인’ 또한 버그가 발생했기 때문입니다.\n 우리가 Java 진영에서 흔히 사용하는 gradle이나 maven, 혹은 파이썬에서 pip 와 같은 툴들이 ‘특정 버전’을 관리하도록 한 이유도 이와 같겠죠. 또 다른 예시는 하단 reference 2번의 예시를 참고해주시면 되겠습니다. 이상으로 글을 마치겠습니다. 감사합니다.\nreference   git submodule update needed only initially?\n  How can I specify a branch/tag when adding a Git submodule?\n This does make some sense when you think about it, though. Let’s say I create repository foo with submodule bar. I push my changes and tell you to check out commit a7402be from repository foo.\nThen imagine that someone commits a change to repository bar before you can make your clone.\nWhen you check out commit a7402be from repository foo, you expect to get the same code I pushed. That’s why submodules don’t update until you tell them to explicitly and then make a new commit.    git submodule 브랜치 추적\n  git submodule 이해하기\n  ","wordCount":"1226","inLanguage":"en","datePublished":"2022-07-01T00:00:00Z","dateModified":"2022-07-01T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/git/git-submodule/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 깃 서브모듈 트러블슈팅</h1><div class=post-meta><span title="2022-07-01 00:00:00 +0000 UTC">July 1, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/git/git-submodule.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b9%83-%ec%84%9c%eb%b8%8c%eb%aa%a8%eb%93%88-%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85 aria-label="깃 서브모듈 트러블슈팅">깃 서브모듈 트러블슈팅</a><ul><li><a href=#%eb%a9%94%ec%9d%b8-git-clone-%ec%8b%9c-submodule%ec%9d%84-%ea%b0%80%ec%a0%b8%ec%98%a4%ec%a7%80-%ec%95%8a%eb%8a%94%eb%8b%a4 aria-label="메인 git clone 시 submodule을 가져오지 않는다.">메인 git clone 시 submodule을 가져오지 않는다.</a></li><li><a href=#%eb%a9%94%ec%9d%b8-git-clone-%ec%8b%9c-ref-%ec%97%90%eb%9f%ac%ea%b0%80-%eb%b0%9c%ec%83%9d%ed%95%9c%eb%8b%a4 aria-label="메인 git clone 시 ref 에러가 발생한다.">메인 git clone 시 ref 에러가 발생한다.</a></li><li><a href=#%ec%97%ac%eb%8b%b4 aria-label=여담>여담</a></li></ul></li><li><a href=#reference aria-label=reference>reference</a></li></ul></div></details></div><div class=post-content><h1 id=깃-서브모듈-트러블슈팅>깃 서브모듈 트러블슈팅<a hidden class=anchor aria-hidden=true href=#깃-서브모듈-트러블슈팅>#</a></h1><p>: 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby & ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 <code>jekyll</code> 대신, <code>hugo</code> 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다.</p><p><code>hugo</code> 블로그는 보통 submodule을 기반으로 제작됩니다. <code>jekyll</code>의 경우 깃허브 자체에서 지원해주는 정적 사이트 생성기이기 때문에, 따로 빌드를 하지 않아도 됐던 것으로 기억합니다. 하지만 hugo는 그렇지 않습니다. 따라서 hugo 자체에서 지원해주는 기능으로 정적 사이트를 빌드한 뒤, 빌드 결과물을 깃허브에 업로드해야 합니다. 대개 다음과 같은 구조를 가집니다.</p><p><img loading=lazy src=/assets/images/2022-07-02-23-22-23.png alt></p><p>메인 모듈에서 테마를 include 해온 뒤, 블로그 글을 작성하고, static site를 생성한 뒤, 그 결과물을 github에 업로드하는 방식입니다. 제가 블로그를 생성한 상황에서는 위와 같이 메인, 그리고 public 이라는 빌드 결과물이 깃허브에 업로드된 상태였습니다. 앞으로 메인 모듈을 &lsquo;메인&rsquo;, public을 &lsquo;서브&rsquo; 로 축약해서 이야기하도록 하겠습니다.</p><p>이전 생성 경험을 토대로 제작하는데에 큰 무리가 없었는데, 팀원들이 테스트를 시작하자 문제가 발생했습니다. 제가 혼자 사용할 때는 문제가 없었는데, 팀원들이 사용하려고 깃허브에서 clone 해오는 순간 문제가 발생한 것이죠. 프로젝트에서도 서브모듈을 활용하기로 결정되어 있었기 때문에, 해당 문제는 꼭 해결해야 한다는 생각이 들어, 이를 해결한 기록을 남겨보고자 합니다.</p><p>발생한 문제는 총 두 가지였습니다. 하나씩 살펴보도록 하겠습니다.</p><h2 id=메인-git-clone-시-submodule을-가져오지-않는다>메인 git clone 시 submodule을 가져오지 않는다.<a hidden class=anchor aria-hidden=true href=#메인-git-clone-시-submodule을-가져오지-않는다>#</a></h2><p>: 메인을 clone 해오는 경우, 자연스럽게 submodule도 가져올 것이라고 예상할 수 있습니다. 하지만 예상과 달리 submodule은 가져오지 않고, 가져오려고 해도 제대로 동작하지 않았습니다. 서브모듈에 대한 개념이 부족했던 지라, &lsquo;서브모듈에 대한 정보를 가져오지 않는걸까?&rsquo; 라는 생각이 들어 서브모듈을 직접 추가해보았습니다.</p><p><code>git submodule add -b ${branch} https://github.com/${organization}/${sub_repository} public</code></p><p>위 명령어는 서브모듈이 존재하는 repository 를 현재 깃 프로젝트에 추가하되, <code>${branch}</code> 라는 이름의 브랜치를 가져오고, 그 이름을 <code>public</code> 으로 설정하겠다는 의미입니다. 따라서 public 이라는 디렉토리에 서브모듈로 등록됩니다. (public은 hugo에서 빌드 결과물을 생성해놓는 디렉토리입니다.) 그런데 위와 같은 명령어를 실행할 경우, 다음과 같은 메세지가 등장합니다.</p><pre tabindex=0><code>&#39;public&#39; already exists in the index
</code></pre><p>뭔가 이상합니다. <code>public</code>에 대한 정보를 이미 가져온 것일까요 ? 이는 반만 맞습니다. 정확히는, submodule이 존재한다는 것, 그리고 그 녀석의 이름이 <code>public</code> 이라는 것 까지는 알고 있습니다. 코드를 한 곳에서 관리하는 것이 효율적이기 때문에, submodule의 소스코드는 별도의 repository에서 관리하는 상태입니다. 따라서 서브가 이미 존재하니, 깃은 &lsquo;인덱스에 이미 존재한다&rsquo; 라고 대답합니다. <code>git submodule status</code> 를 입력하면 다음과 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git submodule status 
</span></span><span style=display:flex><span>                                                              
</span></span><span style=display:flex><span>-d2d76400942ad9fe3616f60775053a32750d3bbb public
</span></span><span style=display:flex><span>-9af128a8a638d139771afc30a8f331a73ce810b1 themes/PaperMod
</span></span></code></pre></div><p>submodule에 대한, 즉 &lsquo;서브&rsquo; 프로젝트에 대한 상세 정보는 가져오지 못한 상태입니다. 이는 프로젝트의 <code>.git</code> 디렉토리를 확인해보면 알 수 있습니다. 프로젝트를 생성한 제 로컬에서는 <code>.git/modules</code> 디렉토리를 가보면 <code>public</code>, 그리고 테마와 관련된 <code>/themes/${theme}</code> 이 있는 것을 확인할 수 있습니다. 하지만 clone 해온 팀원의 프로젝트에서는 위 <code>modules</code> 디렉토리 자체가 없거나, 있더라도 그 내부가 비어있음을 확인할 수 있습니다.</p><p>아무튼 이 정보를 알려주기 위해선 <code>.gitmodules</code> 라는 특수한 파일이 필요합니다. 해당 파일을 생성한 뒤, 다음과 같은 내용을 추가해주었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>submodule <span style=color:#e6db74>&#34;public&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>	path <span style=color:#f92672>=</span> public
</span></span><span style=display:flex><span>	url <span style=color:#f92672>=</span> https://github.com/<span style=color:#e6db74>${</span>organization<span style=color:#e6db74>}</span>/<span style=color:#e6db74>${</span>sub_repository<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>	branch <span style=color:#f92672>=</span> <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>submodule <span style=color:#e6db74>&#34;themes/</span><span style=color:#e6db74>${</span>theme<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>	path <span style=color:#f92672>=</span> themes/<span style=color:#e6db74>${</span>theme<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>	url <span style=color:#f92672>=</span> https://github.com/<span style=color:#e6db74>${</span>organization<span style=color:#e6db74>}</span>/<span style=color:#e6db74>${</span>theme_repository<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>	branch <span style=color:#f92672>=</span> <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span>
</span></span></code></pre></div><p>그리고, 다음의 두 명령어를 통해 submodule의 상세정보를 등록하고, 가져옵니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git submodule init
</span></span><span style=display:flex><span>git submodule update
</span></span></code></pre></div><p>이렇게 하면, 이제 <code>public</code> 디렉토리에 서브모듈에 대한 소스코드까지 포함되어 있는 것을 확인할 수 있습니다. 만약 <code>.gitmodules</code> 라는 파일이 remote(깃허브)에도 작성되어 있다면, 다음부터는 clone 해올 때 <code>--recursive</code> 혹은 <code>--resurse-submodules</code> 라는 옵션을 줘서 <code>init</code> 과 <code>update</code> 를 한번에 진행할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone <span style=color:#e6db74>${</span>main_repo<span style=color:#e6db74>}</span> --recursive
</span></span><span style=display:flex><span><span style=color:#75715e># 혹은</span>
</span></span><span style=display:flex><span>git clone <span style=color:#e6db74>${</span>main_repo<span style=color:#e6db74>}</span> --recurse-submodules
</span></span></code></pre></div><h2 id=메인-git-clone-시-ref-에러가-발생한다>메인 git clone 시 ref 에러가 발생한다.<a hidden class=anchor aria-hidden=true href=#메인-git-clone-시-ref-에러가-발생한다>#</a></h2><p>: 정확한 에러 문구는 다음과 같습니다.</p><p><code>fatal: remote error: upload-pack: not our ref ${commit-id}</code></p><p>대충 다음과 같이 생겼습니다.</p><p><img loading=lazy src=/assets/images/2022-07-03-00-04-18.png alt></p><p>이 또한 submodule 의 특수성으로 인해 발생하는 문제입니다. 결론부터 말씀드리자면, &lsquo;메인&rsquo; 프로젝트에서 갖고 있는 submodule 의 정보는 &lsquo;서브&rsquo; 프로젝트(레포지토리) 자체가 아닌, &lsquo;서브&rsquo; 프로젝트의 &lsquo;특정 commit-id&rsquo; 를 갖고 있습니다.</p><p>위에서 hugo 특성상 submodule을 활용한다고 말씀드렸습니다. 따라서 보통 아래와 같은 shell script를 활용합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 정적 사이트 생성</span>
</span></span><span style=display:flex><span>hugo -t PaperMod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># &#39;서브&#39; 프로젝트 commit &amp; push</span>
</span></span><span style=display:flex><span>cd public
</span></span><span style=display:flex><span>git add .
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>${</span>commit-message<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>git push <span style=color:#e6db74>${</span>origin<span style=color:#e6db74>}</span> <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># &#39;메인&#39; 프로젝트 commit &amp; push</span>
</span></span><span style=display:flex><span>cd ..
</span></span><span style=display:flex><span>git add .
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>${</span>commit-message<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>git push <span style=color:#e6db74>${</span>origin<span style=color:#e6db74>}</span> <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span>
</span></span></code></pre></div><p>그림, 예시와 함께 문제 상황이 발생한 이유를 설명해보겠습니다. (아래 예시에서의 <code>push</code>는 말 그대로의 push를, <code>deploy</code>는 위 스크립트를 실행하는 것이라고 생각해주시면 되겠습니다. )</p><p><img loading=lazy src=/assets/images/2022-07-03-01-04-33.png alt></p><ol><li>팀원 &lsquo;갑&rsquo;이 로컬에서 &lsquo;메인&rsquo; repository에 &lsquo;서브&rsquo; repository를 submodule로 추가하고, &lsquo;부모&rsquo;의 repository에 deploy 했습니다.</li><li>그 순간, &lsquo;메인&rsquo; repository에서는 &lsquo;서브&rsquo; repository의 특정 commit-id(<code>SA</code>(sub-A)라고 하겠습니다)를 가져갑니다. (이 때 중요한 것은, &lsquo;부모&rsquo;의 repository에 push 할 때, &lsquo;서브&rsquo; repository는 push되지 않는다는 것입니다. &lsquo;서브&rsquo; repository는 별도로 push 과정을 거쳐야 하기 때문에 push가 아닌 deploy를 사용합니다.)</li><li>다음으로, 팀원 &lsquo;을&rsquo;이 부모 repository를 clone 해옵니다. 이 때, &lsquo;서브&rsquo; repository 또한 <code>--recursive</code> 옵션을 통해 가져왔습니다. 해당 옵션을 통해 가져왔기 때문에, &lsquo;서브&rsquo; repository의 <code>SA</code> 커밋을 가져와서, HEAD로 가리킵니다.<br>3-1. 그런데 현재 &lsquo;을&rsquo;의 local에 있는 &lsquo;서브&rsquo;가 가리키고 있는 HEAD는 특정 브랜치가 아닙니다. 임시로 생성된 &lsquo;커밋 브랜치&rsquo;의 <code>SA</code> 커밋입니다.(커밋 브랜치는 임의로 붙인 이름입니다. 정확한 이름은 모르겠습니다.) 여기까지는 문제가 없습니다.</li></ol><p><img loading=lazy src=/assets/images/2022-07-03-01-04-48.png alt>
4. 이 상태에서, &lsquo;을&rsquo;이 &lsquo;서브&rsquo;에 새로운 파일을 추가하고, commit 합니다.(해당 commit-id 를 <code>SB</code>라고 하겠습니다.)<br>4-1. 그런데 이 <code>SB</code> commit-id 는 &lsquo;서브&rsquo;의 특정 브랜치 다음에 생긴 브랜치가 아닙니다. 위에서 언급한 임시의 &lsquo;커밋 브랜치&rsquo; 다음에 위치합니다.<br>5. 그리고 &lsquo;을&rsquo; 이 &lsquo;메인&rsquo; repository에 push합니다.<br>5-1. &lsquo;메인&rsquo; 입장에서는, &lsquo;서브&rsquo;의 commit-id가 <code>SB</code> 라는 정보를 가져갑니다. 즉, 가리키는 commit-id는 <code>SA</code>에서 <code>SB</code>로 바꿔치기됩니다.<br>6. 이번에는 팀원 &lsquo;병&rsquo; 이 &lsquo;메인&rsquo; repository를 clone 해옵니다. 역시 마찬가지로, <code>--recursive</code> 옵션을 통해 가져왔고, &lsquo;서브&rsquo; repository의 <code>SB</code> commit을 가져오려하는 순간 문제가 발생합니다.<br>7. 왜냐하면, &lsquo;서브&rsquo; repository의 그 어디에도 <code>SB</code> commit은 존재하지 않기 때문입니다.</p><p>그렇다면 &ldquo;6~7번 사이에서 &lsquo;서브&rsquo; repository에 push 하면 되지 않나요?&rdquo;(=7번에서 push가 아닌 deploy를 하면 되지 않나요?) 라고 의문을 제시할 수 있습니다만, 불가능합니다. 왜냐하면, 위 4번과 6번에서 말씀드렸다시피 commit의 위치가 특수한 곳에 존재하기 때문입니다. 따라서, push를 하려고 하면 다음과 같은 메시지를 볼 수 있습니다.</p><p><img loading=lazy src=/assets/images/2022-07-03-00-14-15.png alt></p><p>이를 해결하기 위한 방법은 간단합니다. &lsquo;서브&rsquo; repository에 push하기 전에, 브랜치를 바꿔주면 됩니다. 즉, 위 쉘 스크립트를 수정하면 다음과 같이 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 정적 사이트 생성</span>
</span></span><span style=display:flex><span>hugo -t PaperMod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># &#39;서브&#39; 프로젝트 commit &amp; push</span>
</span></span><span style=display:flex><span>cd public
</span></span><span style=display:flex><span>git checkout <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span> <span style=color:#75715e># &lt;- 이 부분을 추가합니다.</span>
</span></span><span style=display:flex><span>git add .
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>${</span>commit-message<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>git push <span style=color:#e6db74>${</span>origin<span style=color:#e6db74>}</span> <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># &#39;메인&#39; 프로젝트 commit &amp; push</span>
</span></span><span style=display:flex><span>cd ..
</span></span><span style=display:flex><span>git add .
</span></span><span style=display:flex><span>git commit -m <span style=color:#e6db74>${</span>commit-message<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>git push <span style=color:#e6db74>${</span>origin<span style=color:#e6db74>}</span> <span style=color:#e6db74>${</span>branch<span style=color:#e6db74>}</span>
</span></span></code></pre></div><h2 id=여담>여담<a hidden class=anchor aria-hidden=true href=#여담>#</a></h2><p>: github에서 clone 해올 때, 항상 특정 브랜치의 최신 커밋을 가져오도록 하면 좋을 것 같은데, 왜 이렇게 commit을 가져오도록 되어있는지 의문이 들었습니다. 그런데, 다시 생각해보면 이는 당연합니다.</p><blockquote><p>말씀드렸던 대로, &lsquo;메인&rsquo; repository를 clone 할 때, 항상 &lsquo;서브&rsquo; repository의 최신 commit을 가져오게 된다고 가정해보겠습니다. &lsquo;메인&rsquo; repository를 개발한 사람이 정상적으로 잘 동작하는 것을 확인하고 push를 했는데, 시간이 지나 &lsquo;메인&rsquo; 에서 참조하고있는 &lsquo;서브&rsquo; repository가 업데이트 되었습니다. 그런데 &lsquo;서브&rsquo; repository 개발자의 실수로 버그가 있는 코드를 push했습니다.<br>&lsquo;메인&rsquo; repository를 추가로 개발하려는 다른 사람이 clone 해왔는데, &lsquo;메인&rsquo; repository 또한 문제가 발생합니다. 왜냐하면, &lsquo;서브&rsquo; repository의 가장 최신 커밋을 가져왔기 때문에 &lsquo;메인&rsquo; 또한 버그가 발생했기 때문입니다.</p></blockquote><p>우리가 Java 진영에서 흔히 사용하는 <code>gradle</code>이나 <code>maven</code>, 혹은 파이썬에서 <code>pip</code> 와 같은 툴들이 &lsquo;특정 버전&rsquo;을 관리하도록 한 이유도 이와 같겠죠. 또 다른 예시는 하단 reference 2번의 예시를 참고해주시면 되겠습니다. 이상으로 글을 마치겠습니다. 감사합니다.</p><h1 id=reference>reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ol><li><p><a href=https://stackoverflow.com/questions/1992018/git-submodule-update-needed-only-initially>git submodule update needed only initially?</a></p></li><li><p><a href=https://stackoverflow.com/questions/1777854/how-can-i-specify-a-branch-tag-when-adding-a-git-submodule>How can I specify a branch/tag when adding a Git submodule?</a></p><ul><li>This does make some sense when you think about it, though. Let&rsquo;s say I create repository <em>foo</em> with submodule <em>bar</em>. I push my changes and tell you to check out commit a7402be from repository <em>foo</em>.<br>Then imagine that someone commits a change to repository <em>bar</em> before you can make your clone.<br>When you check out commit a7402be from repository <em>foo</em>, you expect to get the same code I pushed. That&rsquo;s why submodules don&rsquo;t update until you tell them to explicitly and then make a new commit.</li></ul></li><li><p><a href=https://zeddios.tistory.com/718>git submodule 브랜치 추적</a></p></li><li><p><a href=https://ohgyun.com/711>git submodule 이해하기</a></p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/git/>git</a></li><li><a href=https://cjlee38.github.io/tags/submodule/>submodule</a></li><li><a href=https://cjlee38.github.io/tags/trouble-shooting/>trouble-shooting</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/tech/spring/2022-08-13-spring-environment-seperation/><span class=title>« Prev Page</span><br><span># 스프링에서 환경을 분리하는 방법</span></a>
<a class=next href=https://cjlee38.github.io/post/kotlin/kotlin-property/><span class=title>Next Page »</span><br><span># Kotlin Property</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 깃 서브모듈 트러블슈팅 on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%ea%b9%83%20%ec%84%9c%eb%b8%8c%eb%aa%a8%eb%93%88%20%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85&url=https%3a%2f%2fcjlee38.github.io%2fpost%2fgit%2fgit-submodule%2f&hashtags=git%2csubmodule%2ctrouble-shooting"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 깃 서브모듈 트러블슈팅 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcjlee38.github.io%2fpost%2fgit%2fgit-submodule%2f&title=%23%20%ea%b9%83%20%ec%84%9c%eb%b8%8c%eb%aa%a8%eb%93%88%20%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85&summary=%23%20%ea%b9%83%20%ec%84%9c%eb%b8%8c%eb%aa%a8%eb%93%88%20%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85&source=https%3a%2f%2fcjlee38.github.io%2fpost%2fgit%2fgit-submodule%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 깃 서브모듈 트러블슈팅 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2fgit%2fgit-submodule%2f&title=%23%20%ea%b9%83%20%ec%84%9c%eb%b8%8c%eb%aa%a8%eb%93%88%20%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 깃 서브모듈 트러블슈팅 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2fgit%2fgit-submodule%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 깃 서브모듈 트러블슈팅 on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%ea%b9%83%20%ec%84%9c%eb%b8%8c%eb%aa%a8%eb%93%88%20%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2fgit%2fgit-submodule%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 깃 서브모듈 트러블슈팅 on telegram" href="https://telegram.me/share/url?text=%23%20%ea%b9%83%20%ec%84%9c%eb%b8%8c%eb%aa%a8%eb%93%88%20%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85&url=https%3a%2f%2fcjlee38.github.io%2fpost%2fgit%2fgit-submodule%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>