<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>도메인과 레이어드 아키텍처 | cjlee38</title>
<meta name=keywords content="layered-architecture"><meta name=description content="주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 &lsquo;정론&rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !
약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/code/domain-layered-architecture/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cjlee38.github.io/post/code/domain-layered-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta property="og:title" content="도메인과 레이어드 아키텍처"><meta property="og:description" content="주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 &lsquo;정론&rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !
약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/code/domain-layered-architecture/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-25T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="도메인과 레이어드 아키텍처"><meta name=twitter:description content="주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 &lsquo;정론&rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !
약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"도메인과 레이어드 아키텍처","item":"https://cjlee38.github.io/post/code/domain-layered-architecture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"도메인과 레이어드 아키텍처","name":"도메인과 레이어드 아키텍처","description":"주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 \u0026lsquo;정론\u0026rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !\n약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.","keywords":["layered-architecture"],"articleBody":" 주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 ‘정론’ 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !\n약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.\n정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다. 그런데 잠깐, 여기서 도메인이란 무엇일까 ?\n도메인에 대한 정의 도메인은 결국, “내가 문제를 해결하고자 하는 영역\"으로 정의할 수 있다. 가령 쇼핑몰 사이트를 만든다고 하면, 쇼핑의 대상이 되는 상품과 이에 따른 주문/결제 시스템이 바로 도메인이다. 이 과정에서 사용되는 jackson과 같은 라이브러리들은 나의 관심사가 아니다. 한편, jackson과 같은 소프트웨어를 만든다고 하면, 이러한 직렬화/역직렬화 과정을 처리하는 과정이 도메인이다.\n나는 도메인에 도움을 주는 이런 부가 기술들을 ‘코드 레벨’, 혹은 ‘코드 관점’ 이라고 표현하는데, 정확한 용어가 있는지는 모르겠다.\n그렇다면 왜 도메인이 중요할까요 ? 우리가 소프트웨어로 문제를 해결하고자 하는 이유는, 만들어낸 소프트웨어가 가치를 창출해내기 때문이다. 주어진 문제를 코드로 해결하기 위해선 여러 방법이 존재한다. main 메소드에 수천라인의 코드를 박아넣을 수도 있고, 단 하나의 데이터베이스 쿼리로 해결할 수도 있다. 단 한번만 만들어지고, 절대 변하지 않을 예정이라면 이렇게 해도 문제가 되지 않을것이다. 문제가 되는 경우는, 나를 포함한 누군가가 이 코드를 수정해야할 일이 생겼을 때 발생한다.\n그리고 이러한 코드를 특정한 곳에 모아두지 않으면, 새로운 요구사항을 반영하고, 버그를 수정할 때 여러 곳을 살펴봐야 한다. 사람의 인지능력은 한계가 있기 때문에 수백개가 넘어가는 클래스와 수천, 수만 라인의 코드를 모두 파악하는 것은 어렵다. ‘관심사의 분리’ 라는 개념이 바로 여기서 등장한다.\n이에 비해 단기 기억은 보관돼 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적인 측면 모두에서 제약을 받는다. 공간적인 제약은 조지 밀러(George Miller)의 매직넘버 7(7 ± 2 규칙)로 널리 알려져 있다. 조지 밀러의 이론에 따르면 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 5개에서 많아 봐야 9개 정도를 넘지 못한다고 한다.\n또한 허버트 사이먼(Herbert A. Simon)에 따르면 사람이 새로운 정보를 받아들이는 데 5초 정도의 시간이 소요된다고 한다. 컴퓨터 프로그램을 작성할 때는 시간과 공간의 트레이드오프를 통해 효율을 향상시킬 수 있지만 사람의 경우에는 트레이드오프의 여지가 전혀 없다. 사람의 단기 기억에 있어 시간과 공간의 두 측면 모두가 병목지점으로 작용하는 것이다.\n(출처 : 오브젝트, 조영호 저)\n그리고 이러한 비즈니스 규칙을 모아놓는 곳, 소프트웨어의 본질과 정수를 담아둔 곳이 바로 도메인이다. 그렇기에 우리는 도메인을 보호하고, 변경의 여지가 높은 외부 환경으로부터 격리하는 것을 두 번째 우선순위로 잡아야한다. (당연히 첫 번째는, 올바르게 동작하는 것이다.)\n레이어드 아키텍처 도메인이 가장 중요하고, 우리가 보호해야할 대상이란 점은 알았다. 이번에는 practical 한 이야기를 해보자. 바로 이 글의 타이틀에도 작성되어 있는 레이어드 아키텍쳐이다. 레이어드 아키텍쳐는 Spring MVC 에서 주로(그리고 거의 대부분) 채택되는 아키텍쳐이기도 하다. 우리에게는 @Controller, @Service, @Repository 과 같은 친숙한 어노테이션으로도 알려져있다.\n참고로 위 세 개의 어노테이션을 들어가보면 모두 DDD 에 어느정도 근간을 두고 있음을 알 수 있다.\n구글에 layered architecture 를 검색해보면 여러 글이 나오지만, 결국 논하고자 하는 바는 “의존성은 한 쪽으로만 이루어져야 한다\"는 것이다. 가령 컨트롤러에서 레포지토리를 곧바로 의존한다고 하더라도 순수한 레이어드 아키텍쳐 관점에서는 문제가 되지 않는다. 컨트롤러는 레포지토리보다 상위에 위치한다.\n이제 각 세 개의 레이어가 중점적으로 다뤄야 할 관심사에 대해서 알아보겠다.\n참고로 본 글에서는 presentation == controller, application == service 로 취급한다.\nController 컨트롤러는 외부 API 요청을 받아내는 역할을 한다. 개발자 입장에서는 외부 통신을 받아내는 가장 첫 번째 관문이기도 하다.(물론 interceptor나 filter 도 있긴 한다만, 여기선 신경쓰지 않겠다.) 컨트롤러 level 에서 주로 처리해야할 사항은 주로 ‘코드 관점’에 집중되어 있다. 내가 원하는 올바른 값이 들어 왔는지? 올바른 사용자가 요청을 보낸 것인지? 내가 원하는 양식(e.g. json)대로 값을 요청했는지? 등을 확인하고, 이에 걸맞게 코드의 객체로 역직렬화하는 과정이 주요 관심사이다.\n때로는 컨트롤러의 코드가 너무 짧아서 아무것도 하는 일이 없어보이기도 한다. 그저 서비스로의 메소드를 호출하고, return 받은 결과를 곧바로 상태코드와 함께 넘겨주는 작업밖에 하지 않는다. 하지만 ‘코드 관점’의 작업은 ‘라이브러리’, 혹은 ‘프레임워크’가 개입하기 아주 좋은 환경이기도 한다. 모든 개발자가 json 오브젝트를 역직렬화하고, 모든 개발자가 내가 정의한 URI 에 요청이 들어오기를 바란다. 따라서 “하는 일이 없는 것 처럼 보이는 것” 일 뿐, 실제로는 여러 작업이 발생하고 있다.\nService 서비스는 도메인의 시작점 역할을 한다. 서비스 상위에 위치하는 컨트롤러로부터 특정한 요청을 받고, 하위에 위치하는 도메인을 모아서, 내가 원하는 비즈니스를 처리한다.\n이 글을 읽는 많은 분들이 객체지향의 5가지 원칙인 SOLID에 대해 알고 계실 것이라 생각한다. 그리고 이러한 SOLID 원칙을 지키기 위한 방법 중 하나로 의존성 주입(Dependency Injection) 이 있다. 의존성을 주입받는다는 것은, A 라는 클래스가 B 라는 클래스를 사용할 때, 어떠한 구현체가 들어오는지에 대해선 관심이 없고, 그저 (A 입장에서)‘주어진 객체가 내가 원하는 것을 알아서 잘 수행해주기를 바라는 태도’ 로 이해할 수 있다. 비슷한 주제로 ‘메소드를 호출하는 것이 아니라 메세지를 전달하는 것’ 이라는 내용도 있는데, 여기서는 생략하겠다.\n아무튼 간에, 이렇듯 의존성을 주입받게 되면, 생성의 책임은 ‘나를 만드는 곳’으로 위임하게 된다. 아래 그림과 같이 의존성의 방향성이 있다고 가정해보겠다.\nclass A { B b; public A(B b) { this.b = b; } } class B { C c; public B(C c) { this.c = c; } } 여기서 A 클래스는 B 클래스를, B 클래스는 C 클래스를 의존하고 있다. 위와 같은 구조가 주어졌을 때, A 클래스의 인스턴스를 생성하고, 사용하려면 아래와 같이 작성해야 한다.\nA a = new A(new B(new C())); 그런데 생각해보면, 이렇게 생성하는 것이 괜찮을까 ? 결국 이 A 객체를 사용하는 곳도 의존성을 주입받아야 하는 것은 아닐까? 이를 바꿔 말하면, 이렇게 객체의 생성을 미루고 미루다 보면 최종적으로 도착하는 지점이 어딘가에서 주어져야 한다. 이 지점을 바로 composition root 라고 부른다. 그리고 우리는 DI 컨테이너 라는 이름으로 Composition Root라는 개념을 구현한다.\n참고로, 의존성 주입에는 세 가지 방법이 있는데, 메소드 주입의 경우 composition root 관점으로 바라봤을 때 해결할 수 없기 때문에 논란의 여지가 있다고 말하는 듯 한다.\n따라서 의존성 주입에는 의존성을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.\n생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결 setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결 메서드 주입(method injection): 메소드 실행시 인자를 이용한 의존성 해결 메소드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있다. 개인적으로는 외부에서 객체가 필요로 하는 의존성을 해결한다는 측면에서 의존성 주입의 한 종류로 간주한다.\n(출처 : 오브젝트, 조영호 저) Controller 나 Service와 같은 객체들의 조립은 spring에서 처리해주지만, 우리가 만든 도메인은 조립해주지 않는다.\n모든 도메인 객체를 spring bean으로 등록할 수도 있지만, spring 이라는 프레임워크에 대한 의존성이 생긴다. spring bean 으로 등록하는 것이 반드시 나쁜 것만은 아니다. 하지만 spring 프레임워크에 예기치 못한 버그가 발생한다면 어떨까 ? 도메인이 보호해야 할 중요한 대상이라는 점을 감안하면, 일말의 가능성이라도 배제하는 것이 좋다는 입장이 있는 반면, 생산성을 위해 spring에게 맡기는 것도 하나의 방법이 될 수 있다. 결국은 마법의 단어, ‘트레이드오프’ 다.\n그리고 제가 생각하는 ‘도메인 객체’의 composition root 가 바로 ‘서비스’ 레이어 이다.\nRepository repository 는 과연 어느 레이어에 속할까요 ? Repository 와 Dao의 차이점에 대해 조금이라도 찾아본 사람은 repository 를 도메인이라고 부른다. 왜 레포지토리는 도메인 레이어에 속할까요? 자꾸 DDD 이야기가 나와서 조금 불편한데, 에릭 에반스의 도메인 주도 설계에서는 레포지토리를 다음과 같이 정의한다.\n“repository is a mechanism for encapsulating storage, retrieval, and search behavior, which emulates a collection of objects.”\n레포지토리는 저장, 검색 및 검색 동작을 캡슐화하는 메커니즘으로, 객체 모음을 모방한다.\n즉, 레포지토리는 “어디에 저장되어 있는지는 모르지만 아무튼 내가 원하는 객체가 저장된 곳” 으로 이야기할 수 있다. 말인 즉슨, 도메인 객체의 생명 주기를 관리한다는 것이다. 이는 바꿔 말하면 레포지토리는 도메인 객체를 알고 있어야 함을, 즉 도메인을 의존해야 함을 의미한다. (앞서, 레이어드 아키텍쳐가 의존성을 한 방향으로만 향하게 했다는 점을 감안하면, 그 하위 infrastructure layer에 속할 수 없다.)\n하지만 여기서 한 가지 문제가 발생한다. “어디에 저장되어 있는지는 모르겠는데”, 도대체 어디서부터 데이터를 가져올 수 있을까 ? 우리는 소중하디 소중한 데이터베이스에 객체에 대한 정보가 저장되어 있음을 알고 있다. 그러면 레포지토리가 도메인에 대한 정보를 알고 있으면서 동시에 데이터베이스에 요청을 필요로 하는 모순이 발생한다. 그리고 이 지점에서 객체지향의 특성이 한 가지 발휘된다. 바로 ‘다형성’ 이다.\n그림 5.2에서 HL1 모듈은 ML1 모듈의 F() 함수를 호출한다. 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않는다. HL1은 단순히 ML1 모듈의 F()를 호출할 뿐이다.\n하지만 ML1 과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.\n(출처 : 클린 아키텍쳐, 로버트 C 마틴 저)\n위 그림에서 HL1 객체를 서비스로, I 인터페이스를 레포지토리 인터페이스로, ML1 객체를 I 인터페이스를 상속하는, 실제 데이터베이스 요청을 진행하는 객체로 바라보면 이야기했던 모순을 해결할 수 있다. 실제 코드를 보더라도, 서비스 객체는 레포지토리 인터페이스를 import할 뿐, 구현체에 대한 정보는 그 어디에서도 찾아볼 수 없다.\n이러한 점에서 객체지향은 절차지향과 차이점을 보인다. 절차지향은 실행 제어 흐름에 따라 의존성의 방향이 일방적으로 향할 수 밖에 없다. ","wordCount":"1382","inLanguage":"en","datePublished":"2022-10-25T00:00:00Z","dateModified":"2022-10-25T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/code/domain-layered-architecture/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">도메인과 레이어드 아키텍처</h1><div class=post-meta><span title='2022-10-25 00:00:00 +0000 UTC'>October 25, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/code/domain-layered-architecture.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%8f%84%eb%a9%94%ec%9d%b8%ec%97%90-%eb%8c%80%ed%95%9c-%ec%a0%95%ec%9d%98 aria-label="도메인에 대한 정의">도메인에 대한 정의</a></li><li><a href=#%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98 aria-label="레이어드 아키텍처">레이어드 아키텍처</a><ul><li><a href=#controller aria-label=Controller>Controller</a></li><li><a href=#service aria-label=Service>Service</a></li><li><a href=#repository aria-label=Repository>Repository</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 &lsquo;정론&rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !</p></blockquote><p>약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 <a href=https://sparkjava.com/>Spark Java</a> 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.</p><p>정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다. 그런데 잠깐, 여기서 도메인이란 무엇일까 ?</p><h2 id=도메인에-대한-정의>도메인에 대한 정의<a hidden class=anchor aria-hidden=true href=#도메인에-대한-정의>#</a></h2><p>도메인은 결국, &ldquo;내가 문제를 해결하고자 하는 영역"으로 정의할 수 있다. 가령 쇼핑몰 사이트를 만든다고 하면, 쇼핑의 대상이 되는 상품과 이에 따른 주문/결제 시스템이 바로 도메인이다. 이 과정에서 사용되는 <code>jackson</code>과 같은 라이브러리들은 나의 관심사가 아니다. 한편, <code>jackson</code>과 같은 소프트웨어를 만든다고 하면, 이러한 직렬화/역직렬화 과정을 처리하는 과정이 도메인이다.</p><blockquote><p>나는 도메인에 도움을 주는 이런 부가 기술들을 <strong>&lsquo;코드 레벨&rsquo;</strong>, 혹은 <strong>&lsquo;코드 관점&rsquo;</strong> 이라고 표현하는데, 정확한 용어가 있는지는 모르겠다.</p></blockquote><p>그렇다면 왜 도메인이 중요할까요 ? 우리가 소프트웨어로 문제를 해결하고자 하는 이유는, 만들어낸 소프트웨어가 <strong>가치를 창출</strong>해내기 때문이다. 주어진 문제를 코드로 해결하기 위해선 여러 방법이 존재한다. main 메소드에 수천라인의 코드를 박아넣을 수도 있고, 단 하나의 데이터베이스 쿼리로 해결할 수도 있다. 단 한번만 만들어지고, 절대 변하지 않을 예정이라면 이렇게 해도 문제가 되지 않을것이다. 문제가 되는 경우는, 나를 포함한 누군가가 이 코드를 수정해야할 일이 생겼을 때 발생한다.</p><p>그리고 이러한 코드를 특정한 곳에 모아두지 않으면, 새로운 요구사항을 반영하고, 버그를 수정할 때 여러 곳을 살펴봐야 한다. 사람의 인지능력은 한계가 있기 때문에 수백개가 넘어가는 클래스와 수천, 수만 라인의 코드를 모두 파악하는 것은 어렵다. <strong>&lsquo;관심사의 분리&rsquo;</strong> 라는 개념이 바로 여기서 등장한다.</p><blockquote><p>이에 비해 단기 기억은 보관돼 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적인 측면 모두에서 제약을 받는다. 공간적인 제약은 조지 밀러(George Miller)의 매직넘버 7(7 ± 2 규칙)로 널리 알려져 있다. 조지 밀러의 이론에 따르면 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 5개에서 많아 봐야 9개 정도를 넘지 못한다고 한다.<br>또한 허버트 사이먼(Herbert A. Simon)에 따르면 사람이 새로운 정보를 받아들이는 데 5초 정도의 시간이 소요된다고 한다. 컴퓨터 프로그램을 작성할 때는 시간과 공간의 트레이드오프를 통해 효율을 향상시킬 수 있지만 사람의 경우에는 트레이드오프의 여지가 전혀 없다. 사람의 단기 기억에 있어 시간과 공간의 두 측면 모두가 병목지점으로 작용하는 것이다.<br>(출처 : 오브젝트, 조영호 저)</p></blockquote><p>그리고 이러한 비즈니스 규칙을 모아놓는 곳, 소프트웨어의 본질과 정수를 담아둔 곳이 바로 도메인이다. 그렇기에 우리는 <strong>도메인을 보호</strong>하고, <strong>변경의 여지가 높은 외부 환경으로부터 격리하는 것</strong>을 두 번째 우선순위로 잡아야한다. (<em>당연히 첫 번째는, 올바르게 동작하는 것이다.</em>)</p><p><img loading=lazy src=/assets/images/layered-architecture/2022-10-25-22-33-10.png alt></p><h2 id=레이어드-아키텍처>레이어드 아키텍처<a hidden class=anchor aria-hidden=true href=#레이어드-아키텍처>#</a></h2><p>도메인이 가장 중요하고, 우리가 보호해야할 대상이란 점은 알았다. 이번에는 practical 한 이야기를 해보자. 바로 이 글의 타이틀에도 작성되어 있는 레이어드 아키텍쳐이다. 레이어드 아키텍쳐는 <code>Spring MVC</code> 에서 주로(그리고 거의 대부분) 채택되는 아키텍쳐이기도 하다. 우리에게는 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> 과 같은 친숙한 어노테이션으로도 알려져있다.</p><p><img loading=lazy src=/assets/images/layered-architecture/2022-10-25-22-39-11.png alt></p><blockquote><p>참고로 위 세 개의 어노테이션을 들어가보면 모두 <code>DDD</code> 에 어느정도 근간을 두고 있음을 알 수 있다.</p></blockquote><p>구글에 layered architecture 를 검색해보면 여러 글이 나오지만, 결국 논하고자 하는 바는 &ldquo;의존성은 한 쪽으로만 이루어져야 한다"는 것이다. 가령 컨트롤러에서 레포지토리를 곧바로 의존한다고 하더라도 순수한 레이어드 아키텍쳐 관점에서는 문제가 되지 않는다. 컨트롤러는 레포지토리보다 상위에 위치한다.</p><figure class=align-center><img loading=lazy src=/assets/images/layered-architecture/2022-10-25-23-14-24.png#center width=300px></figure><p>이제 각 세 개의 레이어가 중점적으로 다뤄야 할 관심사에 대해서 알아보겠다.</p><blockquote><p>참고로 본 글에서는 <code>presentation == controller</code>, <code>application == service</code> 로 취급한다.</p></blockquote><h3 id=controller>Controller<a hidden class=anchor aria-hidden=true href=#controller>#</a></h3><p>컨트롤러는 외부 API 요청을 받아내는 역할을 한다. 개발자 입장에서는 외부 통신을 받아내는 가장 첫 번째 관문이기도 하다.(물론 interceptor나 filter 도 있긴 한다만, 여기선 신경쓰지 않겠다.) 컨트롤러 level 에서 주로 처리해야할 사항은 주로 &lsquo;코드 관점&rsquo;에 집중되어 있다. 내가 원하는 올바른 값이 들어 왔는지? 올바른 사용자가 요청을 보낸 것인지? 내가 원하는 양식(e.g. json)대로 값을 요청했는지? 등을 확인하고, 이에 걸맞게 코드의 객체로 역직렬화하는 과정이 주요 관심사이다.</p><p>때로는 컨트롤러의 코드가 너무 짧아서 아무것도 하는 일이 없어보이기도 한다. 그저 서비스로의 메소드를 호출하고, return 받은 결과를 곧바로 상태코드와 함께 넘겨주는 작업밖에 하지 않는다. 하지만 &lsquo;코드 관점&rsquo;의 작업은 &lsquo;라이브러리&rsquo;, 혹은 &lsquo;프레임워크&rsquo;가 개입하기 아주 좋은 환경이기도 한다. 모든 개발자가 json 오브젝트를 역직렬화하고, 모든 개발자가 내가 정의한 URI 에 요청이 들어오기를 바란다. 따라서 &ldquo;하는 일이 없는 것 처럼 보이는 것&rdquo; 일 뿐, 실제로는 여러 작업이 발생하고 있다.</p><p><img loading=lazy src=/assets/images/layered-architecture/2022-10-25-23-20-31.png alt></p><h3 id=service>Service<a hidden class=anchor aria-hidden=true href=#service>#</a></h3><p>서비스는 도메인의 시작점 역할을 한다. 서비스 상위에 위치하는 컨트롤러로부터 특정한 요청을 받고, 하위에 위치하는 도메인을 모아서, 내가 원하는 비즈니스를 처리한다.</p><p>이 글을 읽는 많은 분들이 객체지향의 5가지 원칙인 <code>SOLID</code>에 대해 알고 계실 것이라 생각한다. 그리고 이러한 <code>SOLID</code> 원칙을 지키기 위한 방법 중 하나로 의존성 주입(Dependency Injection) 이 있다. 의존성을 주입받는다는 것은, A 라는 클래스가 B 라는 클래스를 사용할 때, 어떠한 구현체가 들어오는지에 대해선 관심이 없고, 그저 (A 입장에서)&lsquo;주어진 객체가 내가 원하는 것을 알아서 잘 수행해주기를 바라는 태도&rsquo; 로 이해할 수 있다. 비슷한 주제로 &lsquo;메소드를 호출하는 것이 아니라 메세지를 전달하는 것&rsquo; 이라는 내용도 있는데, 여기서는 생략하겠다.</p><p>아무튼 간에, 이렇듯 의존성을 주입받게 되면, 생성의 책임은 &lsquo;나를 만드는 곳&rsquo;으로 위임하게 된다. 아래 그림과 같이 의존성의 방향성이 있다고 가정해보겠다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>	B b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>A</span>(B b) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
</span></span><span style=display:flex><span>	C c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>B</span>(C c) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>여기서 <code>A</code> 클래스는 <code>B</code> 클래스를, <code>B</code> 클래스는 <code>C</code> 클래스를 의존하고 있다. 위와 같은 구조가 주어졌을 때, <code>A</code> 클래스의 인스턴스를 생성하고, 사용하려면 아래와 같이 작성해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>A a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> A(<span style=color:#66d9ef>new</span> B(<span style=color:#66d9ef>new</span> C()));
</span></span></code></pre></div><p>그런데 생각해보면, 이렇게 생성하는 것이 괜찮을까 ? 결국 이 <code>A</code> 객체를 사용하는 곳도 의존성을 주입받아야 하는 것은 아닐까? 이를 바꿔 말하면, 이렇게 <strong>객체의 생성을 미루고 미루다 보면</strong> 최종적으로 도착하는 지점이 어딘가에서 주어져야 한다. 이 지점을 바로 <a href=https://freecontent.manning.com/dependency-injection-in-net-2nd-edition-understanding-the-composition-root/>composition root</a> 라고 부른다. 그리고 우리는 <code>DI 컨테이너</code> 라는 이름으로 <code>Composition Root</code>라는 개념을 구현한다.</p><blockquote><p>참고로, 의존성 주입에는 세 가지 방법이 있는데, 메소드 주입의 경우 composition root 관점으로 바라봤을 때 해결할 수 없기 때문에 논란의 여지가 있다고 말하는 듯 한다.</p></blockquote><blockquote><p>따라서 의존성 주입에는 의존성을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.</p><ul><li>생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결</li><li>setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결</li><li>메서드 주입(method injection): 메소드 실행시 인자를 이용한 의존성 해결
메소드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있다. 개인적으로는 외부에서 객체가 필요로 하는 의존성을 해결한다는 측면에서 의존성 주입의 한 종류로 간주한다.<br>(출처 : 오브젝트, 조영호 저)</li></ul></blockquote><p><code>Controller</code> 나 <code>Service</code>와 같은 객체들의 조립은 spring에서 처리해주지만, 우리가 만든 도메인은 조립해주지 않는다.</p><blockquote><p>모든 도메인 객체를 spring bean으로 등록할 수도 있지만, spring 이라는 프레임워크에 대한 의존성이 생긴다. spring bean 으로 등록하는 것이 반드시 나쁜 것만은 아니다. 하지만 spring 프레임워크에 예기치 못한 버그가 발생한다면 어떨까 ? 도메인이 보호해야 할 중요한 대상이라는 점을 감안하면, 일말의 가능성이라도 배제하는 것이 좋다는 입장이 있는 반면, 생산성을 위해 spring에게 맡기는 것도 하나의 방법이 될 수 있다. 결국은 마법의 단어, &lsquo;트레이드오프&rsquo; 다.</p></blockquote><p>그리고 제가 생각하는 <strong>&lsquo;도메인 객체&rsquo;의 composition root 가 바로 &lsquo;서비스&rsquo; 레이어</strong> 이다.</p><h3 id=repository>Repository<a hidden class=anchor aria-hidden=true href=#repository>#</a></h3><p>repository 는 과연 어느 레이어에 속할까요 ? Repository 와 Dao의 차이점에 대해 조금이라도 찾아본 사람은 repository 를 도메인이라고 부른다. 왜 레포지토리는 도메인 레이어에 속할까요? 자꾸 DDD 이야기가 나와서 조금 불편한데, 에릭 에반스의 <em>도메인 주도 설계</em>에서는 레포지토리를 다음과 같이 정의한다.</p><blockquote><p>“repository is a mechanism for encapsulating storage, retrieval, and search behavior, which emulates a collection of objects.”<br>레포지토리는 저장, 검색 및 검색 동작을 캡슐화하는 메커니즘으로, 객체 모음을 모방한다.</p></blockquote><p>즉, 레포지토리는 <strong>&ldquo;어디에 저장되어 있는지는 모르지만 아무튼 내가 원하는 객체가 저장된 곳&rdquo;</strong> 으로 이야기할 수 있다. 말인 즉슨, 도메인 객체의 생명 주기를 관리한다는 것이다. 이는 바꿔 말하면 레포지토리는 도메인 객체를 알고 있어야 함을, 즉 도메인을 의존해야 함을 의미한다. (앞서, 레이어드 아키텍쳐가 의존성을 한 방향으로만 향하게 했다는 점을 감안하면, 그 하위 infrastructure layer에 속할 수 없다.)</p><p>하지만 여기서 한 가지 문제가 발생한다. <strong>&ldquo;어디에 저장되어 있는지는 모르겠는데&rdquo;</strong>, 도대체 어디서부터 데이터를 가져올 수 있을까 ? 우리는 소중하디 소중한 데이터베이스에 객체에 대한 정보가 저장되어 있음을 알고 있다. 그러면 레포지토리가 도메인에 대한 정보를 알고 있으면서 동시에 데이터베이스에 요청을 필요로 하는 모순이 발생한다. 그리고 이 지점에서 객체지향의 특성이 한 가지 발휘된다. 바로 <strong>&lsquo;다형성&rsquo;</strong> 이다.</p><p><img loading=lazy src=/assets/images/layered-architecture/2022-10-25-23-29-55.png alt></p><blockquote><p>그림 5.2에서 <code>HL1</code> 모듈은 <code>ML1</code> 모듈의 <code>F()</code> 함수를 호출한다. 소스 코드에서는 <code>HL1</code> 모듈은 인터페이스를 통해 <code>F()</code> 함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않는다. <code>HL1</code>은 단순히 <code>ML1</code> 모듈의 <code>F()</code>를 호출할 뿐이다.<br>하지만 <code>ML1</code> 과 <code>I</code> 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.<br>(출처 : 클린 아키텍쳐, 로버트 C 마틴 저)</p></blockquote><p>위 그림에서 <code>HL1</code> 객체를 서비스로, <code>I</code> 인터페이스를 레포지토리 인터페이스로, <code>ML1</code> 객체를 <code>I</code> 인터페이스를 상속하는, 실제 데이터베이스 요청을 진행하는 객체로 바라보면 이야기했던 모순을 해결할 수 있다. 실제 코드를 보더라도, 서비스 객체는 레포지토리 인터페이스를 <code>import</code>할 뿐, 구현체에 대한 정보는 그 어디에서도 찾아볼 수 없다.</p><blockquote><p>이러한 점에서 객체지향은 절차지향과 차이점을 보인다. 절차지향은 실행 제어 흐름에 따라 의존성의 방향이 일방적으로 향할 수 밖에 없다.
<img loading=lazy src=/assets/images/layered-architecture/2022-10-25-23-37-14.png alt></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/layered-architecture/>Layered-Architecture</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/lang/java-memory-model-explained/><span class=title>« Prev</span><br><span>Java Memory Model explained (feat. Effective Java, Item 78)</span>
</a><a class=next href=https://cjlee38.github.io/post/database/encoding-with-mysql/><span class=title>Next »</span><br><span>문자 인코딩과 MySQL varchar</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 도메인과 레이어드 아키텍처 on x" href="https://x.com/intent/tweet/?text=%eb%8f%84%eb%a9%94%ec%9d%b8%ea%b3%bc%20%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f&amp;hashtags=layered-architecture"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 도메인과 레이어드 아키텍처 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f&amp;title=%eb%8f%84%eb%a9%94%ec%9d%b8%ea%b3%bc%20%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98&amp;summary=%eb%8f%84%eb%a9%94%ec%9d%b8%ea%b3%bc%20%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98&amp;source=https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 도메인과 레이어드 아키텍처 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f&title=%eb%8f%84%eb%a9%94%ec%9d%b8%ea%b3%bc%20%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 도메인과 레이어드 아키텍처 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 도메인과 레이어드 아키텍처 on whatsapp" href="https://api.whatsapp.com/send?text=%eb%8f%84%eb%a9%94%ec%9d%b8%ea%b3%bc%20%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 도메인과 레이어드 아키텍처 on telegram" href="https://telegram.me/share/url?text=%eb%8f%84%eb%a9%94%ec%9d%b8%ea%b3%bc%20%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 도메인과 레이어드 아키텍처 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%eb%8f%84%eb%a9%94%ec%9d%b8%ea%b3%bc%20%eb%a0%88%ec%9d%b4%ec%96%b4%eb%93%9c%20%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98&u=https%3a%2f%2fcjlee38.github.io%2fpost%2fcode%2fdomain-layered-architecture%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://cjlee38.github.io/>cjlee38</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>