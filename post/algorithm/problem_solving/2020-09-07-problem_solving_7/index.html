<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 프로그래머스[Lv.2] - 튜플 ( java ) | cjlee38</title><meta name=keywords content="programmers"><meta name=description content="문제 링크
PROBLEM {% raw %} 문제 설명
셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.
(a1, a2, a3, &mldr;, an)
튜플은 다음과 같은 성질을 가지고 있습니다.
중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.
ex : (1, 2, 3) ≠ (1, 3, 2)"><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-07-problem_solving_7/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="# 프로그래머스[Lv.2] - 튜플 ( java )"><meta property="og:description" content="문제 링크
PROBLEM {% raw %} 문제 설명
셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.
(a1, a2, a3, &mldr;, an)
튜플은 다음과 같은 성질을 가지고 있습니다.
중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.
ex : (1, 2, 3) ≠ (1, 3, 2)"><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-07-problem_solving_7/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-09-07T01:51:00+00:00"><meta property="article:modified_time" content="2020-09-07T01:51:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 프로그래머스[Lv.2] - 튜플 ( java )"><meta name=twitter:description content="문제 링크
PROBLEM {% raw %} 문제 설명
셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.
(a1, a2, a3, &mldr;, an)
튜플은 다음과 같은 성질을 가지고 있습니다.
중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.
ex : (1, 2, 3) ≠ (1, 3, 2)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 프로그래머스[Lv.2] - 튜플 ( java )","item":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-07-problem_solving_7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 프로그래머스[Lv.2] - 튜플 ( java )","name":"# 프로그래머스[Lv.2] - 튜플 ( java )","description":"문제 링크\nPROBLEM {% raw %} 문제 설명\n셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.\n(a1, a2, a3, \u0026hellip;, an)\n튜플은 다음과 같은 성질을 가지고 있습니다.\n중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)\n원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.\nex : (1, 2, 3) ≠ (1, 3, 2)","keywords":["programmers"],"articleBody":"문제 링크\nPROBLEM {% raw %} 문제 설명\n셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.\n(a1, a2, a3, …, an)\n튜플은 다음과 같은 성질을 가지고 있습니다.\n중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)\n원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.\nex : (1, 2, 3) ≠ (1, 3, 2)\n튜플의 원소 개수는 유한합니다.\n원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, …, an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{’, ‘}‘를 이용해 표현할 수 있습니다.\n{{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, … {a1, a2, a3, a4, …, an}}\n예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는\n{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}\n와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로\n{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}\n{{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}\n{{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}\n는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.\n특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.\n[제한사항]  s의 길이는 5 이상 1,000,000 이하입니다. s는 숫자와 ‘{’, ‘}’, ‘,’ 로만 이루어져 있습니다. 숫자가 0으로 시작하는 경우는 없습니다. s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다. s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다. return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.  [입출력 예]  “{{2},{2,1},{2,1,3},{2,1,3,4}}” - [2, 1, 3, 4] “{{1,2,3},{2,1},{1,2,4,3},{2}}” - [2, 1, 3, 4] “{{20,111},{111}}” - [111, 20] “{{123}}”\t- [123] “{{4,2,3},{3},{2,3,4,1},{2,3}}” - [3, 2, 4, 1]  SOLVE : 문제에서 설명하는대로, 튜플은 **“순서”**를 따져야 한다. 처음 30초간은 “그냥 가장 긴놈 return하면 되는거 아닌가?” 싶었는데, 예제 2번과 같이, “set 내에서의 순서는 무관” 하다는 걸 보고 아니라는 것을 알았다.\n1. 접근 방법 : 즉, 어떻게 접근해야 하느냐?\n“길이가 1인 set에서 등장하는 녀석” - “길이가 2인 set에서 처음 등장하는 녀석” - … “길이가 n인 set에서 처음 등장하는 녀석” 순서로 담아줘야, 올바른 tuple이 된다.\n다시, 입출력 예제 2번을 보자\n“{{1,2,3},{2,1},{1,2,4,3},{2}}”\n원소의 길이가 1인 set은 {2} 이므로, 처음에 2를 담는다.\n다음으로, 원소의 길이가 2인 set은 {2,1} 이므로, 처음 등장하는 1을 담는다.\n다음으로, 원소의 길이가 3인 set은 {1,2,3} 이므로, 처음 등장하는 3을 담는다.\n마지막으로, 원소의 길이가 4(n)인 set은 {1,2,4,3} 이므로, 처음 등장하는 4를 담는다.\n따라서, 최종적으로 [2, 1, 3, 4]가 된다.\n이를 위해선, 다음의 두 가지 과정이 필요하다.\nA. 입력이 “문자열” 이므로, 이를 잘 나눠서 이중 배열에 담아야 한다.\nB. 위에서 언급한대로, tuple에 잘 담는다.\n문자열 파싱하기 : 간단하게, set을 구분하는 구분자는 “},{” 이므로, 이 구분자를 기준으로 split 한 뒤에, 남은 brackets를 삭제하고, 담으면 된다. 즉\nArrayListString[] list = new ArrayList(); String str = \"{{1,2,3},{2,1},{1,2,4,3},{2}}\"; // String[] sets = str.split(\"},{\"); // wrong. String[] sets = str.split(\"\\\\},\\\\{\"); // split 할 때, bracket을 character로 받으려면 이와 같이 escape를 붙여줘야 한다. sets = sets.replace(\"{\",\"\").replace(\"}\"); list.add(sets.split(\",\")); 문자열을 파싱하는 방법은 이것 말고도 여러 방법이 있을 것이다.\n2. 첫 번째 방법 위 순서를 그대로 따르는 전체 코드는 다음과 같다.\npackage Programmers;  import java.util.ArrayList; import java.util.LinkedList;  public class p64065 {  public int[] solution(String s) {  ArrayListString[] list = new ArrayList();  LinkedListString tuple = new LinkedList();  String[] sets = s.split(\"\\\\},\\\\{\");   for (String set : sets) {  set = set.replace(\"{\",\"\").replace(\"}\",\"\");  list.add(set.split(\",\"));  } // 문자열 파싱 \u0026 배열형태로 ArrayList에 담는다.   for(int i = 1; i  sets.length; i++) { // set의 개수 만큼 i번 반복  for (String[] set : list) {  if (set.length == i) { // set 중에서, 현재의 길이(i)와 같다면  for (String num : set) {  if (!tuple.contains(num)) { // 새로 등장하는 요소를 추가.  tuple.add(num);  break;  }  }  }  }  }   int[] answer = new int[tuple.size()]; // LinkedList를 Array로 변환해서 제출  for(int i=0; ituple.size(); i++) {  answer[i] = Integer.parseInt(tuple.get(i));  }    return answer;  } } } 3. 두 번째 방법 : 근데, 뭔가 찝찝하다. 중간에 배열에 담는 과정을 보면, for문이 세번이나 중첩되어 있다. if문까지 보면 indentation이 5번이나 되는데, 이런 코드를 보고 있노라면 굉장히 심적으로 불안해진다.\n물론, list를 돌 때마다, 이미 확인한 set은 삭제하는 방법을 사용할 수도 있지만, 근본적인 해결책은 되지 않는다.\n문제를 해결하자마자, 다른 사람의 코드를 찾아 보니, HashMap을 쓰는 방법도 있다는 것을 알게 되었다.\njson(혹은 dictionary) 형태로 HashMap을 들여다보면 다음과 같이 생겼다. Key는 원소로, Value는 원소의 등장 횟수로 보는 것이다.\nmap = {  2 : 4,  1 : 3,  3 : 2,  4 : 1 } 처음에 주어진 문자열에서, curly brackets가 한 개이던, 두 개이던 신경쓰지 않는다(즉, flatten 한다.)\n그리고, 등장하는대로, 없으면 새로 만들고, 있으면 ++ 시킨다.\n이제 tuple이라는 이름의 배열에 담을 때에는, “숫자가 많은 순서\"대로 담기만 하면 되는 것이다.\n아주 신묘한 해결책인 것 같다. 이를 코드로 표현하면 다음과 같다.(원 코드는 Java 8 문법을 사용해서 아주 우아하고 멋있게 짰지만, 그대로 copy \u0026 paste 하기엔 양심에 찔려서.. 동일 아이디어로, 나만의 아주아주 허접한 방식대로 코드를 작성했다.)\npackage Programmers;  import java.util.HashMap;  public class p64065 {  public int[] solution(String s) {  HashMapInteger, Integer map = new HashMap();  String[] elements = s.replace(\"{\",\"\").replace(\"}\",\"\").split(\",\"); // 문자열 파싱   // HashMap에 저장  for (String e : elements) {  Integer key = Integer.parseInt(e);  Integer value = map.get(key);  if (value == null) { map.put(key, 1); }  else { map.put(key, value + 1); }  }   // Key-Value를 Reversing  HashMapInteger, Integer reversed = new HashMap();  for (Integer i : map.keySet()) {  reversed.put(map.get(i), i);  }   // 배열의 0번부터 n번까지, element의 개수가 n개부터 1개인 녀석까지 담음.  int[] answer = new int[reversed.size()];  for(int i = 0; i  reversed.size(); i++) {  answer[i] = reversed.get(reversed.size() - i);  }  return answer;  } } 마치며 : 아마 첫 번째 코드는 실제로 효율성까지 체크 했다면 바로 나가리였을 것이다. 항상 느끼지만, 문제를 곧이 곧대로 받아들이기보다는, 한 단계 더 Develop 해서 다른 각도에서 쳐다볼 수 있어야 진정한 PS 고수로 거듭날 수 있지 않을까 싶다.\n{% endraw %}\n","wordCount":"942","inLanguage":"en","datePublished":"2020-09-07T01:51:00Z","dateModified":"2020-09-07T01:51:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-07-problem_solving_7/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 프로그래머스[Lv.2] - 튜플 ( java )</h1><div class=post-meta><span title="2020-09-07 01:51:00 +0000 UTC">September 7, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Algorithm/Problem_Solving/2020-09-07-problem_solving_7.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#problem aria-label=PROBLEM>PROBLEM</a><ul><ul><ul><li><a href=#%ec%a0%9c%ed%95%9c%ec%82%ac%ed%95%ad aria-label=[제한사항]>[제한사항]</a></li><li><a href=#%ec%9e%85%ec%b6%9c%eb%a0%a5-%ec%98%88 aria-label="[입출력 예]">[입출력 예]</a></li></ul></ul></ul></li><li><a href=#solve aria-label=SOLVE>SOLVE</a><ul><ul><li><a href=#1-%ec%a0%91%ea%b7%bc-%eb%b0%a9%eb%b2%95 aria-label="1. 접근 방법">1. 접근 방법</a><ul><li><a href=#%eb%ac%b8%ec%9e%90%ec%97%b4-%ed%8c%8c%ec%8b%b1%ed%95%98%ea%b8%b0 aria-label="문자열 파싱하기">문자열 파싱하기</a></li></ul></li><li><a href=#2-%ec%b2%ab-%eb%b2%88%ec%a7%b8-%eb%b0%a9%eb%b2%95 aria-label="2. 첫 번째 방법">2. 첫 번째 방법</a></li><li><a href=#3-%eb%91%90-%eb%b2%88%ec%a7%b8-%eb%b0%a9%eb%b2%95 aria-label="3. 두 번째 방법">3. 두 번째 방법</a></li></ul></ul></li><li><a href=#%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label=마치며>마치며</a></li></ul></div></details></div><div class=post-content><p><a href=https://programmers.co.kr/learn/courses/30/lessons/64065>문제 링크</a></p><h1 id=problem>PROBLEM<a hidden class=anchor aria-hidden=true href=#problem>#</a></h1><p>{% raw %}
문제 설명</p><p>셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.</p><p>(a1, a2, a3, &mldr;, an)<br>튜플은 다음과 같은 성질을 가지고 있습니다.</p><p>중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)<br>원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.<br>ex : (1, 2, 3) ≠ (1, 3, 2)</p><p>튜플의 원소 개수는 유한합니다.<br>원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, &mldr;, an)이 주어질 때(단, a1, a2, &mldr;, an은 자연수), 이는 다음과 같이 집합 기호 &lsquo;{&rsquo;, &lsquo;}&lsquo;를 이용해 표현할 수 있습니다.</p><p>{{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, &mldr; {a1, a2, a3, a4, &mldr;, an}}</p><p>예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는</p><p>{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}<br>와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로</p><p>{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}<br>{{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}<br>{{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}<br>는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.</p><p>특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.</p><h4 id=제한사항>[제한사항]<a hidden class=anchor aria-hidden=true href=#제한사항>#</a></h4><ul><li>s의 길이는 5 이상 1,000,000 이하입니다.</li><li>s는 숫자와 &lsquo;{&rsquo;, &lsquo;}&rsquo;, &lsquo;,&rsquo; 로만 이루어져 있습니다.</li><li>숫자가 0으로 시작하는 경우는 없습니다.</li><li>s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.</li><li>s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.</li><li>return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.</li></ul><h4 id=입출력-예>[입출력 예]<a hidden class=anchor aria-hidden=true href=#입출력-예>#</a></h4><ul><li>&ldquo;{{2},{2,1},{2,1,3},{2,1,3,4}}&rdquo; -> [2, 1, 3, 4]</li><li>&ldquo;{{1,2,3},{2,1},{1,2,4,3},{2}}&rdquo; -> [2, 1, 3, 4]</li><li>&ldquo;{{20,111},{111}}&rdquo; -> [111, 20]</li><li>&ldquo;{{123}}&rdquo; -> [123]</li><li>&ldquo;{{4,2,3},{3},{2,3,4,1},{2,3}}&rdquo; -> [3, 2, 4, 1]</li></ul><h1 id=solve>SOLVE<a hidden class=anchor aria-hidden=true href=#solve>#</a></h1><p>: 문제에서 설명하는대로, 튜플은 **&ldquo;순서&rdquo;**를 따져야 한다. 처음 30초간은 &ldquo;그냥 가장 긴놈 return하면 되는거 아닌가?&rdquo; 싶었는데, 예제 2번과 같이, &ldquo;set 내에서의 순서는 무관&rdquo; 하다는 걸 보고 아니라는 것을 알았다.</p><h3 id=1-접근-방법>1. 접근 방법<a hidden class=anchor aria-hidden=true href=#1-접근-방법>#</a></h3><p>: 즉, 어떻게 접근해야 하느냐?</p><p>&ldquo;길이가 1인 set에서 등장하는 녀석&rdquo; -> &ldquo;길이가 2인 set에서 처음 등장하는 녀석&rdquo; -> &mldr; &ldquo;길이가 n인 set에서 처음 등장하는 녀석&rdquo; 순서로 담아줘야, 올바른 tuple이 된다.</p><p>다시, 입출력 예제 2번을 보자</p><p>&ldquo;{{1,2,3},{2,1},{1,2,4,3},{2}}&rdquo;</p><p>원소의 길이가 1인 set은 {2} 이므로, 처음에 2를 담는다.<br>다음으로, 원소의 길이가 2인 set은 {2,1} 이므로, 처음 등장하는 1을 담는다.<br>다음으로, 원소의 길이가 3인 set은 {1,2,3} 이므로, 처음 등장하는 3을 담는다.<br>마지막으로, 원소의 길이가 4(n)인 set은 {1,2,4,3} 이므로, 처음 등장하는 4를 담는다.</p><p>따라서, 최종적으로 [2, 1, 3, 4]가 된다.</p><p>이를 위해선, 다음의 두 가지 과정이 필요하다.</p><p>A. 입력이 &ldquo;문자열&rdquo; 이므로, 이를 잘 나눠서 이중 배열에 담아야 한다.<br>B. 위에서 언급한대로, tuple에 잘 담는다.</p><h4 id=문자열-파싱하기>문자열 파싱하기<a hidden class=anchor aria-hidden=true href=#문자열-파싱하기>#</a></h4><p>: 간단하게, set을 구분하는 구분자는 &ldquo;},{&rdquo; 이므로, 이 구분자를 기준으로 split 한 뒤에, 남은 brackets를 삭제하고, 담으면 된다. 즉</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>[]&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>String str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;{{1,2,3},{2,1},{1,2,4,3},{2}}&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// String[] sets = str.split(&#34;},{&#34;); // wrong.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>String<span style=color:#f92672>[]</span> sets <span style=color:#f92672>=</span> str<span style=color:#f92672>.</span><span style=color:#a6e22e>split</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\\},\\{&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// split 할 때, bracket을 character로 받으려면 이와 같이 escape를 붙여줘야 한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>sets <span style=color:#f92672>=</span> sets<span style=color:#f92672>.</span><span style=color:#a6e22e>replace</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;{&#34;</span><span style=color:#f92672>,</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>replace</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;}&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>sets<span style=color:#f92672>.</span><span style=color:#a6e22e>split</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;,&#34;</span><span style=color:#f92672>));</span>
</span></span></code></pre></div><p>문자열을 파싱하는 방법은 이것 말고도 여러 방법이 있을 것이다.</p><h3 id=2-첫-번째-방법>2. 첫 번째 방법<a hidden class=anchor aria-hidden=true href=#2-첫-번째-방법>#</a></h3><p>위 순서를 그대로 따르는 전체 코드는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> Programmers<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.ArrayList<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.LinkedList<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>p64065</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>solution</span><span style=color:#f92672>(</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>[]&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        LinkedList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> tuple <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> sets <span style=color:#f92672>=</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>split</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\\},\\{&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String set <span style=color:#f92672>:</span> sets<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            set <span style=color:#f92672>=</span> set<span style=color:#f92672>.</span><span style=color:#a6e22e>replace</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;{&#34;</span><span style=color:#f92672>,</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>replace</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;}&#34;</span><span style=color:#f92672>,</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            list<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>set<span style=color:#f92672>.</span><span style=color:#a6e22e>split</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;,&#34;</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#75715e>// 문자열 파싱 &amp; 배열형태로 ArrayList에 담는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> sets<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// set의 개수 만큼 i번 반복
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> set <span style=color:#f92672>:</span> list<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>set<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> i<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// set 중에서, 현재의 길이(i)와 같다면
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String num <span style=color:#f92672>:</span> set<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>tuple<span style=color:#f92672>.</span><span style=color:#a6e22e>contains</span><span style=color:#f92672>(</span>num<span style=color:#f92672>))</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// 새로 등장하는 요소를 추가.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            tuple<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>num<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> answer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>tuple<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>()];</span> <span style=color:#75715e>// LinkedList를 Array로 변환해서 제출
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0<span style=color:#f92672>;</span> i<span style=color:#f92672>&lt;</span>tuple<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            answer<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>parseInt</span><span style=color:#f92672>(</span>tuple<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> answer<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=3-두-번째-방법>3. 두 번째 방법<a hidden class=anchor aria-hidden=true href=#3-두-번째-방법>#</a></h3><p>: 근데, 뭔가 찝찝하다. 중간에 배열에 담는 과정을 보면, for문이 세번이나 중첩되어 있다. if문까지 보면 indentation이 5번이나 되는데, 이런 코드를 보고 있노라면 굉장히 심적으로 불안해진다.</p><p>물론, list를 돌 때마다, 이미 확인한 set은 삭제하는 방법을 사용할 수도 있지만, 근본적인 해결책은 되지 않는다.</p><p>문제를 해결하자마자, 다른 사람의 코드를 찾아 보니, HashMap을 쓰는 방법도 있다는 것을 알게 되었다.</p><p>json(혹은 dictionary) 형태로 HashMap을 들여다보면 다음과 같이 생겼다. Key는 원소로, Value는 원소의 등장 횟수로 보는 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>map <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>2</span> : <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> : <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>3</span> : <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>4</span> : <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>처음에 주어진 문자열에서, curly brackets가 한 개이던, 두 개이던 신경쓰지 않는다(즉, flatten 한다.)</p><p>그리고, 등장하는대로, 없으면 새로 만들고, 있으면 ++ 시킨다.</p><p>이제 tuple이라는 이름의 배열에 담을 때에는, &ldquo;숫자가 많은 순서"대로 담기만 하면 되는 것이다.</p><p>아주 신묘한 해결책인 것 같다. 이를 코드로 표현하면 다음과 같다.(원 코드는 Java 8 문법을 사용해서 아주 우아하고 멋있게 짰지만, 그대로 copy & paste 하기엔 양심에 찔려서.. 동일 아이디어로, 나만의 아주아주 허접한 방식대로 코드를 작성했다.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> Programmers<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.HashMap<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>p64065</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>solution</span><span style=color:#f92672>(</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> Integer<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> elements <span style=color:#f92672>=</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>replace</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;{&#34;</span><span style=color:#f92672>,</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>replace</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;}&#34;</span><span style=color:#f92672>,</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>split</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;,&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// 문자열 파싱
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// HashMap에 저장
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String e <span style=color:#f92672>:</span> elements<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            Integer key <span style=color:#f92672>=</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>parseInt</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            Integer value <span style=color:#f92672>=</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>key<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>value <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>key<span style=color:#f92672>,</span> 1<span style=color:#f92672>);</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>key<span style=color:#f92672>,</span> value <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Key-Value를 Reversing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        HashMap<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> Integer<span style=color:#f92672>&gt;</span> reversed <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Integer i <span style=color:#f92672>:</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>keySet</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            reversed<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>),</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 배열의 0번부터 n번까지, element의 개수가 n개부터 1개인 녀석까지 담음.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> answer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>reversed<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>()];</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> reversed<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            answer<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> reversed<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>reversed<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> answer<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h1 id=마치며>마치며<a hidden class=anchor aria-hidden=true href=#마치며>#</a></h1><p>: 아마 첫 번째 코드는 실제로 효율성까지 체크 했다면 바로 나가리였을 것이다. 항상 느끼지만, 문제를 곧이 곧대로 받아들이기보다는, 한 단계 더 Develop 해서 다른 각도에서 쳐다볼 수 있어야 진정한 PS 고수로 거듭날 수 있지 않을까 싶다.</p><p>{% endraw %}</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/programmers/>programmers</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/post/diary/2020-09-09-why_data_engineer/><span class=title>« Prev Page</span><br><span># 왜 나는 데이터 엔지니어를 바라보는가</span></a>
<a class=next href=http://cjlee38.github.io/post/language/python/2020-09-05-play_with_python_list/><span class=title>Next Page »</span><br><span># Python list 다뤄보기 ( a.k.a. 잡기술 )</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.2] - 튜플 ( java ) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.2%5d%20-%20%ed%8a%9c%ed%94%8c%20%28%20java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fproblem_solving%2f2020-09-07-problem_solving_7%2f&hashtags=programmers"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.2] - 튜플 ( java ) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fproblem_solving%2f2020-09-07-problem_solving_7%2f&title=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.2%5d%20-%20%ed%8a%9c%ed%94%8c%20%28%20java%20%29&summary=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.2%5d%20-%20%ed%8a%9c%ed%94%8c%20%28%20java%20%29&source=http%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fproblem_solving%2f2020-09-07-problem_solving_7%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.2] - 튜플 ( java ) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fproblem_solving%2f2020-09-07-problem_solving_7%2f&title=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.2%5d%20-%20%ed%8a%9c%ed%94%8c%20%28%20java%20%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.2] - 튜플 ( java ) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fproblem_solving%2f2020-09-07-problem_solving_7%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.2] - 튜플 ( java ) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.2%5d%20-%20%ed%8a%9c%ed%94%8c%20%28%20java%20%29%20-%20http%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fproblem_solving%2f2020-09-07-problem_solving_7%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.2] - 튜플 ( java ) on telegram" href="https://telegram.me/share/url?text=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.2%5d%20-%20%ed%8a%9c%ed%94%8c%20%28%20java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fproblem_solving%2f2020-09-07-problem_solving_7%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>