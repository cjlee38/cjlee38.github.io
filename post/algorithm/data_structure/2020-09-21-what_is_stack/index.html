<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 마음으로 이해하는 자료구조 : Stack ( feat. C ) | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.
아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.
따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.
쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.
1. 이론 편 : Stack 이란 말 그대로, &ldquo;쌓는 것&#34;이다. 접시쌓기를 생각해보면 된다.
접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, 가장 상위에만 쌓아야 한다.
반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, 가장 상위에서만 꺼내야 한다."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_stack/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK",{anonymize_ip:!1})}</script><meta property="og:title" content="# 마음으로 이해하는 자료구조 : Stack ( feat. C )"><meta property="og:description" content="0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.
아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.
따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.
쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.
1. 이론 편 : Stack 이란 말 그대로, &ldquo;쌓는 것&#34;이다. 접시쌓기를 생각해보면 된다.
접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, 가장 상위에만 쌓아야 한다.
반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, 가장 상위에서만 꺼내야 한다."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_stack/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-09-21T18:13:00+00:00"><meta property="article:modified_time" content="2020-09-21T18:13:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 마음으로 이해하는 자료구조 : Stack ( feat. C )"><meta name=twitter:description content="0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.
아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.
따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.
쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.
1. 이론 편 : Stack 이란 말 그대로, &ldquo;쌓는 것&#34;이다. 접시쌓기를 생각해보면 된다.
접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, 가장 상위에만 쌓아야 한다.
반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, 가장 상위에서만 꺼내야 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 마음으로 이해하는 자료구조 : Stack ( feat. C )","item":"https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_stack/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 마음으로 이해하는 자료구조 : Stack ( feat. C )","name":"# 마음으로 이해하는 자료구조 : Stack ( feat. C )","description":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n1. 이론 편 : Stack 이란 말 그대로, \u0026ldquo;쌓는 것\u0026quot;이다. 접시쌓기를 생각해보면 된다.\n접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, 가장 상위에만 쌓아야 한다.\n반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, 가장 상위에서만 꺼내야 한다.","keywords":["null"],"articleBody":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n1. 이론 편 : Stack 이란 말 그대로, “쌓는 것\"이다. 접시쌓기를 생각해보면 된다.\n접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, 가장 상위에만 쌓아야 한다.\n반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, 가장 상위에서만 꺼내야 한다.\n이를,LIFO(Last in, First out)(후입선출) 라고 한다.\n2. 구현 편 - ADT   Note. ADT란, Abstract Data Type의 약자로, 프로그램의 대상이 되는 사물이나 현상을 추상화 하여 정의 한 것을 의미한다. 이는, 해당 기능의 완성과정이 아닌 기능의 종류를 나열한 것이다. 예를 들면, 지갑의 ADT는 “현금 넣기, 현금 꺼내기, 카드 넣기, 카드 꺼내기 …” 등이 된다.\n  : Stack의 ADT는 다음과 같다.\n init()  Stack의 초기화를 진행 Stack 생성 후, 가장 먼저 호출되어야 하는 함수.   size()  해당 Stack에 데이터가 몇 개 쌓여 있는지 확인.   isEmpty()  해당 Stack이 비어있는가를 확인. 비었으면 true, 아니면 false 를 반환   push(data)  Stack에 데이터를 저장. 당연히, 가장 맨 위에 저장한다.   pop()  Stack에 있는 데이터를 반환. 꺼낸 데이터는, Stack에서 삭제한다. 역시 당연히, 가장 맨 위에서 꺼낸다. Stack에 데이터가 최소 하나는 있어야 한다.   peek()  Stack에 있는 데이터를 반환 꺼낸 데이터는 삭제하지 않는다. 물론 역시 당연히, 가장 맨 위에서 꺼낸다. Stack에 데이터가 최소 하나는 있어야 한다.    3. 구현 편 - Code : 지난 편에, LinkedList를 배웠으므로, 배열이 아닌 LinkedList 를 이용해 구현할 것이다.\n먼저, Stack을 위한 구조체를 만들어야 한다.\ntypedef struct Stack {  int size;  struct Node* head; }Stack;  typedef struct Node {  int data;  struct Node* prev; }Node; Stack 구조체는 Stack의 크기, 그리고 가장 상위에 있는 Node를 가리키는 구조체이다.\nNode 구조체는, data를 담고 있고, Pop이 되었을 경우, 이전 데이터를 가리켜야 하기 때문에, struct Node* prev; 를 가진다.\n먼저, 초기화를 시켜주는 init() 함수를 만들어보자.\nvoid SInit(Stack* pstack) {  pstack-size = 0;  pstack-head = NULL; } 처음에는 아무런 데이터도 들어있지 않으므로, size는 0, head는 NULL로 초기화 시킨다.\n그리고, 가장 단순한, size() 함수와 IsEmpty() 함수를 구현해보자.\nint SSize(Stack* pstack) {  return pstack-size; }  int SIsEmpty(Stack *pstack) {  if (pstack-size == 0) { // if (SSize(pstack) == 0) 으로 대체해도 무방.  return 1;  } else {  return 0;  } } 이정도는 코드에 대한 주석이 없어도 이해가 될 것이라 생각한다.\n다음으로, 핵심이 되는 push()와 pop() 함수를 구현해보자.\nvoid SPush(Stack *pstack, int data) {  Node* newNode = (Node *)malloc(sizeof(Node));   newNode-data = data;  newNode-prev = pstack-head;   pstack-head = newNode;  pstack-size++; } {: .alignCenter}\npush() 함수는, stack 이외에 data라는 int형 변수를 하나 받는다.\n그리고 Node 만큼의 공간을 새로이 할당하고, 이를 newNode가 가리키도록 한다.\nnewNode의 data는 인자로 전달받은 data를,\n그리고 newNode의 prev는 기존에 가장 상위에 있던 pstack-head 를 가리키도록 한다. (그림의 1번)\n마지막으로,pstack-head 가 newNode를 가리키도록 하고, (그림의 2번) pstack의 size를 하나 증가시킨다.\nint SPop(Stack *pstack) {  int data = pstack-head-data;   Node* delNode = pstack-head;  pstack-head = pstack-head-prev;  free(delNode);   pstack-size--;   return data; } {: .alignCenter} pop() 함수는 삭제하는 작업이 필요하다.\n가장 먼저, pstack-head 의 Node가 갖고 있는 data를 int data에 저장한다.\n그리고, delNode가 pstack의 head를 가리키게 하고(그림의 1번)\npstack의 head는 하나 이전의 요소를 가리키게 한다.(그림의 2번)\n마지막으로, free(delNode)를 통해, delNode가 가리키는 요소를 삭제하게 하면 된다.\n이후, pstack의 data를 하나 감소시키고, data를 return 해주면 된다.\n마지막으로, peek()은 아주 간단하다.\nint SPeek(Stack *pstack) {  return pstack-head-data; } head가 가리키고 있는 data를 return 하면 된다.\n이를 테스트 하는 코드는 다음과 같다.\nint main() {  Stack stack;  SInit(\u0026stack);   printf(\"is stack Empty ? : %d\\n\", SIsEmpty(\u0026stack));  // is stack Empty ? : 1  // stack이 비어있으므로, true인 1을 반환한다.   SPush(\u0026stack, 1);  SPush(\u0026stack, 4);  SPush(\u0026stack, 3);  SPush(\u0026stack, 15);  // 순서대로 1,4,3,15를 Push한다.   printf(\"stack size : %d\\n\", SSize(\u0026stack));  // stack size : 4  // push 이후 size는 4   int data = SPop(\u0026stack);  printf(\"data : %d, current stack size : %d\\n\", data, SSize(\u0026stack));  // data : 15, current stack size : 3  // 데이터를 하나 꺼내보면, 가장 마지막에 넣은 15가 return 되고, size는 3으로 감소하였음을 볼 수 있다.   printf(\"peek : %d\\n\", SPeek(\u0026stack));  printf(\"peek : %d\\n\", SPeek(\u0026stack));  // peek : 3  // peek : 3  // peek 함수는 여러 번 실행해도, 같은 값을 보여준다.  // 현재 Stack에는 1, 4, 3 이 들어있다.   while(!SIsEmpty(\u0026stack)) {  printf(\"pop data : %d\\n\", SPop(\u0026stack));  }  // pop data : 3  // pop data : 4  // pop data : 1  // stack이 빌 때까지, pop 하면 역순으로 3,4,1이 출력된다.   printf(\"After all, Stack Size : %d\\n\", SSize(\u0026stack));  // After all, Stack Size : 0  // Stack이 비어있으므로, size는 0이 된다.   return 0; } 전체 코드는 포스팅 가장 하단에 작성하였다.\n4. 응용 편 - 괄호 여닫기 : 우리가 프로그래밍을 할 때, () 의 소괄호가 되었든, {} 의 중괄호가 되었든, []의 대괄호가 되었든,\n괄호는 항상 열렸으면 닫아줘야 한다.\n이 소괄호가 올바르게 열고 닫혔는지 확인하는 방법은,\nStack을 이용하면 아주 간단하게 해결할 수 있다.\n프로그래머스에도 이러한 문제가 있는데,\n지난 번에 푼 여기 를 참고하자.\n  주의 : 단순히 괄호의 개수를 세는 것만으로는 이 문제를 해결할 수 없다!\n가령, 다음과 같이 괄호가 열고 닫혔다고 해보자.\n())(\n열린건 한번인데, 두번을 닫아버리면, 이는 잘못된 괄호이다.\n이럴 경우에는, 에러로 처리해야 한다.\n  Stack으로 어떻게 해결할 수 있는가, 하면\n ‘(’ 의 여는 괄호가 들어오면, stack에 Push 한다. ‘)’ 의 닫는 괄호가 들어오면, stack에서 Pop 한다. 정상적으로 끝났다면, 이는 올바른 괄호다. 만약 정상적으로 처리가 되지 않는다면, 이는 잘못된 괄호다.  기존의 코드를 살짝 수정해보자.\nint형 data 대신, char 형 data를 받도록 하고, 로직에 맞게 코드만 작성해주면 된다.\ntypedef struct Node {  char data;  struct Node* prev; }Node; 당연히, data와 관련된 다른 녀석들도 int에서 char로 바꿔주면 된다(e.g. SPop())\nchar brackets[] = \"((()))\"; int answer = isCorrectBrackets(\u0026stack, brackets, strlen(brackets));  if (answer) {  printf(\"It's correct !\\n\"); } else {  printf(\"It's wrong !\\n\"); } 먼저, brackets 라는 char 형 data의 변수를 만들고,\nisCorrectBrackets() 라는 함수를 통해, 이것이 올바른 괄호인지 아닌지 확인할 것이다.\nint isCorrectBrackets(Stack *pstack, char brackets[]) {  int answer = 1;  for (int i=0; istrlen(brackets); i++) {  char current = brackets[i];  if (current == '(') { // '(' 이 들어오면 무조건 push  SPush(pstack, current);  } else { // ')'이 들어왔다면  if (SIsEmpty(pstack)) { // ')'이 들어왔는데, stack이 비어있다면, 즉 열린 괄호가 없는데 닫으려 한다면  answer = 0; // 잘못된 괄호이므로 false  break;  } else {  SPop(pstack); // stack이 비어 있지 않다면, pop  }  }  }    // 다 돌았는데, Stack이 남아있다면, 열린 괄호가 남아 있다는 뜻.  if (!SIsEmpty(pstack)) {  answer = 0;  }   return answer; } strlen() 함수를 사용하기 위해, #include  또한 작성하였다.\n또한, 코드에 대한 설명은 주석으로 달아두었다.\n구현 코드들. stackImpl.c\n#include #include  typedef struct Stack {  int size;  struct Node* head; }Stack;  typedef struct Node {  int data;  struct Node* prev; }Node;  void SInit(Stack *pstack); int SSize(Stack *pstack); int SIsEmpty(Stack *pstack); void SPush(Stack *pstack, int data); int SPop(Stack *pstack); int SPeek(Stack *pstack);   int main() {  Stack stack;  SInit(\u0026stack);   printf(\"is stack Empty ? : %d\\n\", SIsEmpty(\u0026stack));   SPush(\u0026stack, 1);  SPush(\u0026stack, 4);  SPush(\u0026stack, 3);  SPush(\u0026stack, 15);   printf(\"stack size : %d\\n\", SSize(\u0026stack));   int data = SPop(\u0026stack);  printf(\"data : %d, current stack size : %d\\n\", data, SSize(\u0026stack));   printf(\"peek : %d\\n\", SPeek(\u0026stack));  printf(\"peek : %d\\n\", SPeek(\u0026stack));   while(!SIsEmpty(\u0026stack)) {  printf(\"pop data : %d\\n\", SPop(\u0026stack));  }   printf(\"After all, Stack Size : %d\\n\", SSize(\u0026stack));   return 0; }  void SInit(Stack* pstack) {  pstack-size = 0;  pstack-head = NULL; }   int SSize(Stack* pstack) {  return pstack-size; }  int SIsEmpty(Stack *pstack) {  if (pstack-size == 0) {  return 1;  } else {  return 0;  } }   void SPush(Stack *pstack, int data) {  Node* newNode = (Node *)malloc(sizeof(Node));   newNode-data = data;  newNode-prev = pstack-head;   pstack-head = newNode;  pstack-size++; }  int SPop(Stack *pstack) {  int data = pstack-head-data;   Node* delNode = pstack-head;  pstack-head = pstack-head-prev;  free(delNode);   pstack-size--;   return data; }  int SPeek(Stack *pstack) {  return pstack-head-data; } Brackets.c\n#include #include #include  typedef struct Stack {  int size;  struct Node* head; }Stack;  typedef struct Node {  char data;  struct Node* prev; }Node;  void SInit(Stack *pstack); int SSize(Stack *pstack); int SIsEmpty(Stack *pstack); void SPush(Stack *pstack, char data); char SPop(Stack *pstack); char SPeek(Stack *pstack); int isCorrectBrackets(Stack *pstack, char brackets[], int length);   int main() {  Stack stack;  SInit(\u0026stack);   char brackets[] = \"((()))\";  int answer = isCorrectBrackets(\u0026stack, brackets);   if (answer) {  printf(\"It's correct !\\n\");  } else {  printf(\"It's wrong !\\n\");  }     return 0; }  void SInit(Stack* pstack) {  pstack-size = 0;  pstack-head = NULL; }   int SSize(Stack* pstack) {  return pstack-size; }  int SIsEmpty(Stack *pstack) {  if (pstack-size == 0) {  return 1;  } else {  return 0;  } }  void SPush(Stack *pstack, char data) {  Node* newNode = (Node *)malloc(sizeof(Node));   newNode-data = data;  newNode-prev = pstack-head;   pstack-head = newNode;  pstack-size++; }  char SPop(Stack *pstack) {  char data = pstack-head-data;   Node* delNode = pstack-head;  pstack-head = pstack-head-prev;  free(delNode);   pstack-size--;   return data; }  char SPeek(Stack *pstack) {  return pstack-head-data; }  int isCorrectBrackets(Stack *pstack, char brackets[]) {  int answer = 1;  for (int i=0; istrlen(brackets); i++) {  char current = brackets[i];  if (current == '(') {  SPush(pstack, current);  } else {  if (SIsEmpty(pstack)) {  answer = 0;  break;  } else {  SPop(pstack);  }  }  }     if (!SIsEmpty(pstack)) {  answer = 0;  }   return answer; } ","wordCount":"1452","inLanguage":"en","datePublished":"2020-09-21T18:13:00Z","dateModified":"2020-09-21T18:13:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_stack/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 마음으로 이해하는 자료구조 : Stack ( feat. C )</h1><div class=post-meta><span title="2020-09-21 18:13:00 +0000 UTC">September 21, 2020</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Algorithm/Data_Structure/2020-09-21-what_is_stack.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label="0. 들어가며">0. 들어가며</a></li><li><a href=#1-%ec%9d%b4%eb%a1%a0-%ed%8e%b8 aria-label="1. 이론 편">1. 이론 편</a></li><li><a href=#2-%ea%b5%ac%ed%98%84-%ed%8e%b8---adt aria-label="2. 구현 편 - ADT">2. 구현 편 - ADT</a></li><li><a href=#3-%ea%b5%ac%ed%98%84-%ed%8e%b8---code aria-label="3. 구현 편 - Code">3. 구현 편 - Code</a></li><li><a href=#4-%ec%9d%91%ec%9a%a9-%ed%8e%b8---%ea%b4%84%ed%98%b8-%ec%97%ac%eb%8b%ab%ea%b8%b0 aria-label="4. 응용 편 - 괄호 여닫기">4. 응용 편 - 괄호 여닫기</a></li><li><a href=#%ea%b5%ac%ed%98%84-%ec%bd%94%eb%93%9c%eb%93%a4 aria-label="구현 코드들.">구현 코드들.</a></li></ul></div></details></div><div class=post-content><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>: Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.<br>아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.</p><p>따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.<br>쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.</p><h1 id=1-이론-편>1. 이론 편<a hidden class=anchor aria-hidden=true href=#1-이론-편>#</a></h1><p>: Stack 이란 말 그대로, &ldquo;쌓는 것"이다. <strong>접시쌓기</strong>를 생각해보면 된다.<br>접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, <strong>가장 상위에만 쌓아야 한다</strong>.<br>반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, <strong>가장 상위에서만 꺼내야 한다.</strong></p><p>이를,<strong>LIFO(Last in, First out)(후입선출)</strong> 라고 한다.</p><h1 id=2-구현-편---adt>2. 구현 편 - ADT<a hidden class=anchor aria-hidden=true href=#2-구현-편---adt>#</a></h1><hr><blockquote><p>Note. ADT란, Abstract Data Type의 약자로, 프로그램의 대상이 되는 사물이나 현상을 <strong>추상화</strong> 하여 정의 한 것을 의미한다.
이는, 해당 기능의 완성과정이 아닌 <strong>기능의 종류를 나열</strong>한 것이다.
예를 들면, 지갑의 ADT는 &ldquo;현금 넣기, 현금 꺼내기, 카드 넣기, 카드 꺼내기 &mldr;&rdquo; 등이 된다.</p></blockquote><hr><p>: Stack의 ADT는 다음과 같다.</p><ul><li>init()<ul><li>Stack의 초기화를 진행</li><li>Stack 생성 후, 가장 먼저 호출되어야 하는 함수.</li></ul></li><li>size()<ul><li>해당 Stack에 데이터가 몇 개 쌓여 있는지 확인.</li></ul></li><li>isEmpty()<ul><li>해당 Stack이 비어있는가를 확인.</li><li>비었으면 true, 아니면 false 를 반환</li></ul></li><li>push(data)<ul><li>Stack에 데이터를 저장.</li><li>당연히, 가장 맨 위에 저장한다.</li></ul></li><li>pop()<ul><li>Stack에 있는 데이터를 반환.</li><li>꺼낸 데이터는, <strong>Stack에서 삭제</strong>한다.</li><li>역시 당연히, 가장 맨 위에서 꺼낸다.</li><li><strong>Stack에 데이터가 최소 하나는 있어야 한다.</strong></li></ul></li><li>peek()<ul><li>Stack에 있는 데이터를 반환</li><li>꺼낸 데이터는 <strong>삭제하지 않는다.</strong></li><li>물론 역시 당연히, 가장 맨 위에서 꺼낸다.</li><li><strong>Stack에 데이터가 최소 하나는 있어야 한다.</strong></li></ul></li></ul><h1 id=3-구현-편---code>3. 구현 편 - Code<a hidden class=anchor aria-hidden=true href=#3-구현-편---code>#</a></h1><p>: 지난 편에, LinkedList를 배웠으므로, 배열이 아닌 LinkedList 를 이용해 구현할 것이다.<br>먼저, Stack을 위한 구조체를 만들어야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> head;
</span></span><span style=display:flex><span>}Stack;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span></code></pre></div><p>Stack 구조체는 Stack의 크기, 그리고 가장 상위에 있는 Node를 가리키는 구조체이다.<br>Node 구조체는, data를 담고 있고, Pop이 되었을 경우, 이전 데이터를 가리켜야 하기 때문에, struct Node* prev; 를 가진다.</p><p>먼저, 초기화를 시켜주는 init() 함수를 만들어보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SInit</span>(Stack<span style=color:#f92672>*</span> pstack) {
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>처음에는 아무런 데이터도 들어있지 않으므로, size는 0, head는 NULL로 초기화 시킨다.</p><p>그리고, 가장 단순한, size() 함수와 IsEmpty() 함수를 구현해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SSize</span>(Stack<span style=color:#f92672>*</span> pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pstack<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SIsEmpty</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pstack<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// if (SSize(pstack) == 0) 으로 대체해도 무방.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이정도는 코드에 대한 주석이 없어도 이해가 될 것이라 생각한다.</p><p>다음으로, 핵심이 되는 push()와 pop() 함수를 구현해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SPush</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>int</span> data) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> (Node <span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/assets/images/2020-09-21-21-28-52_2020-09-21-what_is_stack.md.png alt=stack_push>
{: .alignCenter}</p><p>push() 함수는, stack 이외에 data라는 int형 변수를 하나 받는다.<br>그리고 <strong>Node 만큼의 공간을 새로이 할당</strong>하고, 이를 <strong>newNode가 가리키도록 한다.</strong></p><p>newNode의 data는 인자로 전달받은 data를,<br>그리고 <strong>newNode의 prev</strong>는 기존에 가장 상위에 있던 <strong>pstack->head</strong> 를 가리키도록 한다. <strong>(그림의 1번)</strong></p><p>마지막으로,<strong>pstack->head 가 newNode를 가리키도록 하고</strong>, <strong>(그림의 2번)</strong>
pstack의 size를 하나 증가시킨다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SPop</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> delNode <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    free(delNode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/assets/images/2020-09-21-21-31-49_2020-09-21-what_is_stack.md.png alt=stack_pop>
{: .alignCenter}
pop() 함수는 삭제하는 작업이 필요하다.<br>가장 먼저, pstack->head 의 Node가 갖고 있는 data를 int data에 저장한다.</p><p>그리고, <strong>delNode가 pstack의 head를 가리키게 하고</strong>(그림의 1번)<br><strong>pstack의 head는 하나 이전의 요소를 가리키게 한다.</strong>(그림의 2번)<br>마지막으로, free(delNode)를 통해, delNode가 가리키는 요소를 삭제하게 하면 된다.</p><p>이후, pstack의 data를 하나 감소시키고, data를 return 해주면 된다.</p><p>마지막으로, peek()은 아주 간단하다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SPeek</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>head가 가리키고 있는 data를 return 하면 된다.</p><p>이를 테스트 하는 코드는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Stack stack;
</span></span><span style=display:flex><span>    SInit(<span style=color:#f92672>&amp;</span>stack);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;is stack Empty ? : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SIsEmpty(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// is stack Empty ? : 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// stack이 비어있으므로, true인 1을 반환한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>15</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 순서대로 1,4,3,15를 Push한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;stack size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SSize(<span style=color:#f92672>&amp;</span>stack)); 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// stack size : 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// push 이후 size는 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data <span style=color:#f92672>=</span> SPop(<span style=color:#f92672>&amp;</span>stack);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;data : %d, current stack size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, data, SSize(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// data : 15, current stack size : 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 데이터를 하나 꺼내보면, 가장 마지막에 넣은 15가 return 되고, size는 3으로 감소하였음을 볼 수 있다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;peek : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SPeek(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;peek : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SPeek(<span style=color:#f92672>&amp;</span>stack)); 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// peek : 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// peek : 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// peek 함수는 여러 번 실행해도, 같은 값을 보여준다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 현재 Stack에는 1, 4, 3 이 들어있다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>SIsEmpty(<span style=color:#f92672>&amp;</span>stack)) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;pop data : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SPop(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pop data : 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// pop data : 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// pop data : 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// stack이 빌 때까지, pop 하면 역순으로 3,4,1이 출력된다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;After all, Stack Size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SSize(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// After all, Stack Size : 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Stack이 비어있으므로, size는 0이 된다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>전체 코드는 포스팅 가장 하단에 작성하였다.</p><h1 id=4-응용-편---괄호-여닫기>4. 응용 편 - 괄호 여닫기<a hidden class=anchor aria-hidden=true href=#4-응용-편---괄호-여닫기>#</a></h1><p>: 우리가 프로그래밍을 할 때, () 의 소괄호가 되었든, {} 의 중괄호가 되었든, []의 대괄호가 되었든,<br><strong>괄호는 항상 열렸으면 닫아줘야 한다.</strong></p><p>이 소괄호가 올바르게 열고 닫혔는지 확인하는 방법은,<br>Stack을 이용하면 아주 간단하게 해결할 수 있다.</p><p>프로그래머스에도 이러한 문제가 있는데,<br><a href=https://cjlee38.github.io/problem_solving/problem_solving_4>지난 번에 푼 여기</a> 를 참고하자.</p><hr><blockquote><p><strong>주의 : 단순히 괄호의 개수를 세는 것만으로는 이 문제를 해결할 수 없다!</strong><br>가령, 다음과 같이 괄호가 열고 닫혔다고 해보자.</p><p><strong>())(</strong></p><p>열린건 한번인데, 두번을 닫아버리면, 이는 잘못된 괄호이다.<br>이럴 경우에는, 에러로 처리해야 한다.</p></blockquote><hr><p>Stack으로 어떻게 해결할 수 있는가, 하면</p><ul><li>&lsquo;(&rsquo; 의 여는 괄호가 들어오면, stack에 Push 한다.</li><li>&lsquo;)&rsquo; 의 닫는 괄호가 들어오면, stack에서 Pop 한다.</li><li>정상적으로 끝났다면, 이는 올바른 괄호다.</li><li>만약 정상적으로 처리가 되지 않는다면, 이는 잘못된 괄호다.</li></ul><p>기존의 코드를 살짝 수정해보자.</p><p>int형 data 대신, char 형 data를 받도록 하고, 로직에 맞게 코드만 작성해주면 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span></code></pre></div><p>당연히, data와 관련된 다른 녀석들도 int에서 char로 바꿔주면 된다(e.g. SPop())</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>char</span> brackets[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;((()))&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> isCorrectBrackets(<span style=color:#f92672>&amp;</span>stack, brackets, strlen(brackets));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (answer) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;It&#39;s correct !</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;It&#39;s wrong !</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>먼저, brackets 라는 char 형 data의 변수를 만들고,<br>isCorrectBrackets() 라는 함수를 통해, 이것이 올바른 괄호인지 아닌지 확인할 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>isCorrectBrackets</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>char</span> brackets[]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>strlen(brackets); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> current <span style=color:#f92672>=</span> brackets[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;(&#39;</span>) { <span style=color:#75715e>// &#39;(&#39; 이 들어오면 무조건 push
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            SPush(pstack, current);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// &#39;)&#39;이 들어왔다면
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (SIsEmpty(pstack)) { <span style=color:#75715e>// &#39;)&#39;이 들어왔는데, stack이 비어있다면, 즉 열린 괄호가 없는데 닫으려 한다면
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 잘못된 괄호이므로 false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                SPop(pstack); <span style=color:#75715e>// stack이 비어 있지 않다면, pop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 다 돌았는데, Stack이 남아있다면, 열린 괄호가 남아 있다는 뜻.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>SIsEmpty(pstack)) {
</span></span><span style=display:flex><span>        answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>strlen() 함수를 사용하기 위해, <code>#include &lt;string.h></code> 또한 작성하였다.<br>또한, 코드에 대한 설명은 주석으로 달아두었다.</p><h1 id=구현-코드들>구현 코드들.<a hidden class=anchor aria-hidden=true href=#구현-코드들>#</a></h1><p><strong>stackImpl.c</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> head;
</span></span><span style=display:flex><span>}Stack;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SInit</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SSize</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SIsEmpty</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SPush</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>int</span> data);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SPop</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SPeek</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Stack stack;
</span></span><span style=display:flex><span>    SInit(<span style=color:#f92672>&amp;</span>stack);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;is stack Empty ? : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SIsEmpty(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    SPush(<span style=color:#f92672>&amp;</span>stack, <span style=color:#ae81ff>15</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;stack size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SSize(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data <span style=color:#f92672>=</span> SPop(<span style=color:#f92672>&amp;</span>stack);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;data : %d, current stack size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, data, SSize(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;peek : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SPeek(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;peek : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SPeek(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>SIsEmpty(<span style=color:#f92672>&amp;</span>stack)) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;pop data : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SPop(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;After all, Stack Size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, SSize(<span style=color:#f92672>&amp;</span>stack));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SInit</span>(Stack<span style=color:#f92672>*</span> pstack) {
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SSize</span>(Stack<span style=color:#f92672>*</span> pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pstack<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SIsEmpty</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pstack<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SPush</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>int</span> data) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> (Node <span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SPop</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> delNode <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    free(delNode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> data;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SPeek</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Brackets.c</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stack</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> head;
</span></span><span style=display:flex><span>}Stack;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SInit</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SSize</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SIsEmpty</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SPush</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>char</span> data);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>SPop</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>SPeek</span>(Stack <span style=color:#f92672>*</span>pstack);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>isCorrectBrackets</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>char</span> brackets[], <span style=color:#66d9ef>int</span> length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Stack stack;
</span></span><span style=display:flex><span>    SInit(<span style=color:#f92672>&amp;</span>stack);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> brackets[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;((()))&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> isCorrectBrackets(<span style=color:#f92672>&amp;</span>stack, brackets);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (answer) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;It&#39;s correct !</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;It&#39;s wrong !</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SInit</span>(Stack<span style=color:#f92672>*</span> pstack) {
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SSize</span>(Stack<span style=color:#f92672>*</span> pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pstack<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>SIsEmpty</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pstack<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SPush</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>char</span> data) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> (Node <span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>SPop</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> data <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> delNode <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    free(delNode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pstack<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> data;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>SPeek</span>(Stack <span style=color:#f92672>*</span>pstack) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pstack<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>isCorrectBrackets</span>(Stack <span style=color:#f92672>*</span>pstack, <span style=color:#66d9ef>char</span> brackets[]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>strlen(brackets); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> current <span style=color:#f92672>=</span> brackets[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;(&#39;</span>) {
</span></span><span style=display:flex><span>            SPush(pstack, current);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (SIsEmpty(pstack)) {
</span></span><span style=display:flex><span>                answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                SPop(pstack);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>SIsEmpty(pstack)) {
</span></span><span style=display:flex><span>        answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_queue/><span class=title>« Prev</span><br><span># 마음으로 이해하는 자료구조 : Queue ( feat. C )</span></a>
<a class=next href=https://cjlee38.github.io/post/tech/jsp/2020-09-21-jsp_learning_04/><span class=title>Next »</span><br><span># 4. JSP 학습기록 - POST handling과 Servlet Filter</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Stack ( feat. C ) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Stack%20%28%20feat.%20C%20%29&url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_stack%2f&hashtags=null"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Stack ( feat. C ) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_stack%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Stack%20%28%20feat.%20C%20%29&summary=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Stack%20%28%20feat.%20C%20%29&source=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_stack%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Stack ( feat. C ) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_stack%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Stack%20%28%20feat.%20C%20%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Stack ( feat. C ) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_stack%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Stack ( feat. C ) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Stack%20%28%20feat.%20C%20%29%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_stack%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Stack ( feat. C ) on telegram" href="https://telegram.me/share/url?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Stack%20%28%20feat.%20C%20%29&url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_stack%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>