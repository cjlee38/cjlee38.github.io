<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 마음으로 이해하는 자료구조 : Queue ( feat. C ) | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.
아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.
따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.
쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.
지난 Stack편 에 이어집니다.
1. 이론 편 : Queue는, 편의점의 냉장고를 생각하면 된다.
편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.
창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_queue/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-174927148-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="# 마음으로 이해하는 자료구조 : Queue ( feat. C )"><meta property="og:description" content="0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.
아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.
따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.
쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.
지난 Stack편 에 이어집니다.
1. 이론 편 : Queue는, 편의점의 냉장고를 생각하면 된다.
편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.
창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_queue/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-09-21T19:38:00+00:00"><meta property="article:modified_time" content="2020-09-21T19:38:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 마음으로 이해하는 자료구조 : Queue ( feat. C )"><meta name=twitter:description content="0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.
아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.
따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.
쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.
지난 Stack편 에 이어집니다.
1. 이론 편 : Queue는, 편의점의 냉장고를 생각하면 된다.
편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.
창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 마음으로 이해하는 자료구조 : Queue ( feat. C )","item":"https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_queue/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 마음으로 이해하는 자료구조 : Queue ( feat. C )","name":"# 마음으로 이해하는 자료구조 : Queue ( feat. C )","description":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n지난 Stack편 에 이어집니다.\n1. 이론 편 : Queue는, 편의점의 냉장고를 생각하면 된다.\n편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.\n창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다.","keywords":["null"],"articleBody":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n지난 Stack편 에 이어집니다.\n1. 이론 편 : Queue는, 편의점의 냉장고를 생각하면 된다.\n편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.\n창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다.\n즉, A,B,C,D 를 넣으면, 편의점 손님이 이것을 꺼낼 때도 A,B,C,D 순서로 꺼낸다.\n이를, FIFO(First in, First out)(선입선출) 라고 한다.\n2. 구현 편 - ADT : Queue의 ADT는 다음과 같다.\n init()  Queue의 초기화를 진행 Queue 생성 후, 가장 먼저 호출되어야 하는 함수   size()  해당 Queue에 데이터가 몇 개 쌓여 있는지 확인.   isEmpty()  해당 Queue가 비어 있는가를 확인. 비었으면 true, 아니면 false를 반환.   enqueue(data)  Queue에 데이터를 저장. 당연히, 가장 마지막에 저장한다.   dequeue()  Queue에 있는 데이터를 반환 꺼낸 데이터는 Queue에서 삭제한다. 역시 당연히, 가장 오래된 데이터를 꺼낸다. Queue에 데이터가 최소 하나는 있어야 한다.   peek()  Queue에 있는 데이터를 반환. 꺼낸 데이터는 삭제하지 않는다. 물론 역시 당연히, 가장 오래된 데이터를 꺼낸다. Queue에 데이터가 최소 하나는 있어야 한다.    3. 구현 편 - Code : 역시, Queue 또한, LinkedList로 구현한다.\n  Note. 구현에 앞서\nStack과 달리, Queue에서 앞, 뒤를 구분하는 것은 헷갈린다.\nFront와 Rear로 표현하는 사람도 있고, Head와 Tail로 표현하는 사람도 있다.\n우리가 구현하는 큐는, 다음과 같은 그림을 갖고 있다고 생각하고 보자.\n {: .alignCenter}\n Stack과 마찬가지로, 구조체부터 만들자.\ntypedef struct Queue {  int size;  struct Node* head;  struct Node* tail; }Queue;  typedef struct Node {  int data;  struct Node* prev; }Node; 지난 Stack 구조체에 비해서, 추가 된 것은 tail 하나다.\nStack에서는 최상단의 대상만 삭제하고, 추가했지만,\nQueue에서는 추가할 때는 Tail, 삭제할 때는 Head를 이용할 것이므로,\nHead와 Tail이 둘다 필요하다.\n다음으로, Init() 함수는 다음과 같다.\nvoid QInit(Queue *pqueue) {  pqueue-size = 0;  pqueue-head = NULL;  pqueue-tail = NULL; } 역시, size는 0으로, head와 tail은 모두 NULL로 우선 초기화 해준다.\nint QSize(Queue *pqueue) {  return pqueue-size; }  int QIsEmpty(Queue *pqueue) {  if (pqueue-size == 0) { // if (Qsize(pqueue) == 0) 으로 대체해도 무방.  return 1;  } else {  return 0;  } } QSize()와 QIsEmpty() 또한 간단하다.\nIsEmpty() 그대로, 비어 있는지를 묻고 있으므로,\n비어 있다면, 즉 size가 0 이라면 참인 1을,\n비어 있지 않다면 거짓인 0을 return 하면 된다.\n다음으로, 핵심이 되는 Enqueue()와 Dequeue() 작업이다.\nvoid QEnqueue(Queue *pqueue, int data) {  Node* newNode = (Node*)malloc(sizeof(Node));  newNode-data = data;  newNode-prev = NULL;   if(QIsEmpty(pqueue)) {  pqueue-head = newNode;  } else {  pqueue-tail-prev = newNode; // 그림 1번  }  pqueue-tail = newNode; // 그림 2번  pqueue-size++; } {: .alignCenter}\n만약, 처음으로 데이터를 넣는 것이라면, pqueue의 head와 tail은 둘다 newNode를 가리킨다.\n그러나, 두 번째부터는, 조금 다르다.\n원래 tail이 가리키고 있던 Node가 갖고있는 prev 포인터를, 새로운 Node인 newNode를 가리키게 한다.(그림의 1번)\n그리고, Tail은 새로운 Node인 newNode를 가리킨다. (그림의 2번)\n그리고, pqueue가 갖고 있는 size라는 속성을 하나 증가시킨다.\nint QDequeue(Queue *pqueue) {  int data = pqueue-head-data;   Node* delNode = pqueue-head;  pqueue-head = pqueue-head-prev;  free(delNode);   pqueue-size--;   return data; } {: .alignCenter}\n삭제를 하는 경우는, stack과 같다.\n가장 먼저, pqueue-head 의 Node가 갖고 있는 data를 int data에 저장한다.\n그리고, delNode가 pqueue의 head를 가리키게 하고(그림의 1번)\npqueue head는 하나 이전의 요소(prev)를 가리키게 한다.(그림의 2번)\n마지막으로, free(delNode)를 통해, delNode가 가리키는 요소를 삭제하게 하면 된다.\n이후, pstack의 data를 하나 감소시키고, data를 return 해주면 된다.\n마지막으로, peek() 또한 stack과 같다\nint QPeek(Queue *pqueue) {  return pqueue-head-data; } 역시, 잘 돌아가는지 한번 테스트 해보자.\nint main() {  Queue queue;  QInit(\u0026queue);   QEnqueue(\u0026queue, 3);  QEnqueue(\u0026queue, 5);  QEnqueue(\u0026queue, 4);  QEnqueue(\u0026queue, 1);   printf(\"Q size : %d\\n\", QSize(\u0026queue));  // Q size : 4  printf(\"Q peek : %d\\n\", QPeek(\u0026queue));  // Q peek : 3   while(!QIsEmpty(\u0026queue)) {  printf(\"Dequeue : %d\\n\", QDequeue(\u0026queue));  }  // Dequeue : 3  // Dequeue : 5  // Dequeue : 4  // Dequeue : 1   return 0; } 잘 동작하는 모습을 볼 수 있다. 역시, 전체 코드는 최하단에 작성하였다.\n4. 응용 편 - 다리를 지나는 트럭 : 다리를 지나는 트럭 문제는 java 로 한번 풀었으나,\nC로도 한번 풀어보자.(프로그래머스에서 C를 지원하지 않으므로, 제시된 테스트 케이스만 통과하면 맞았다고 보자.)\n이를 위해선, 트럭이 다리에 얼마나 올라와 있었는가? 를 구분하기 위해,\nTruck 구조체를 하나 만들어야 한다.\ntypedef struct Truck {  int weight;  int time; }Truck; 또한, 이 Truck 을 Queue에 담을 것이므로,\nint 대신 Truck 구조체를 담을 수 있도록 적절히 바꿔주자.\ntypedef struct Node {  Truck truck;  struct Node* prev; }Node; 당연히, 다른 관련 함수들 또한 Truck으로 적절히 바꿔주어야 한다(e.g. QDequeue())\nmain() 함수는 다음과 같다.\nint main() {  Queue waitQ;  QInit(\u0026waitQ);   Queue bridgeQ;  QInit(\u0026bridgeQ);   int bridge_length = 100;  int weight = 100;   int truck_weights[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};  int array_length = sizeof(truck_weights) / sizeof(int);   int answer = solution(\u0026waitQ, \u0026bridgeQ, bridge_length, weight, truck_weights, array_length);  printf(\"answer : %d\\n\", answer);   return 0; } **“진입을 대기하는 waitQ”**와, “다리에 해당하는 bridgeQ” 를 만들어주고,\n문제에서 주어지는 값들과 함께 solution() 함수로 넘겨주었다.\nint solution(Queue *waitQ, Queue *bridgeQ, int bridge_length, int weight, int truck_weights[], int array_length) {  int flag = 0; // 다리를 나가야 하는 트럭이 존재하는지 확인하는 flag  int bridge = 0; // 현재 다리에 올라가 있는 트럭 무게의 합  int answer = 0;   // 처음엔 모두 Truck 구조체로 만들어서 waitQ에 넣어준다.  for(int i=0; iarray_length; i++) {  Truck truck;  truck.weight = truck_weights[i];  truck.time = bridge_length;  QEnqueue(waitQ, truck);  }   // waitQ와 bridgeQ가 모두 비어있다면, 모든 트럭이 통과한 것이므로 중단한다.  while(!QIsEmpty(waitQ) || !QIsEmpty(bridgeQ)) {  // bridgeQ를 돌면서, 다리 위에 올라가 있는 시간인 time을 1씩 감소시킨다.  // time이 0 이하 인 경우, 즉 다리를 나가야 하는 트럭이 존재하는 경우, flag는 1을 추가시킨다.  Node* p = bridgeQ-head;  while(p != NULL) {  p-truck.time--;  if (p-truck.time  0) {  flag = 1;  }  p = p-prev;  }   // flag가 존재하는 경우, 무조건 가장 앞에 있는 트럭이 나가야 하므로,  // 트럭을 하나 빼내고, 현재 다리에 올라가 있는 트럭 무게의 합인 bridge를, 빠져나가는 트럭 무게 만큼 감소시킨다.  if (flag) {  Truck outTruck = QDequeue(bridgeQ);  bridge -= outTruck.weight;  flag = 0;  }   // waitQ가 비어있지 않다면, 들어갈 수 있는지를 확인해보고,  // 들어갈 수 있다면, waitQ에서 빼서 bridgeQ에 추가한다.  // 역시, 현재 다리에 올라가 있는 트럭 무게의 합인 bridge를, 들어가는 트럭 무게 만큼 증가시킨다.  if (!QIsEmpty(waitQ)) {  Truck inTruck = QPeek(waitQ);  if (bridge + inTruck.weight  weight) {  QEnqueue(bridgeQ, QDequeue(waitQ));  bridge += inTruck.weight;  }  }   answer++;  } // end of while    return answer; } 역시, 코드에 대한 설명은 주석으로 달아놓았다.\n마치며. : C 자체로는, 생산성이 많이 떨어짐을 느꼈다. 한 번 풀었던 문제인데도,\n이렇게 시간이 오래 걸릴줄은 몰랐다 ㅠ.\n역시 나는 Java가 좋다.\n구현 코드들. queueImpl.c\n#include #include  typedef struct Queue {  int size;  struct Node* head;  struct Node* tail; }Queue;  typedef struct Node {  int data;  struct Node* prev; }Node;  void QInit(Queue *pqueue); int QSize(Queue *pqueue); int QIsEmpty(Queue *pqueue); void QEnqueue(Queue *pqueue, int data); int QDequeue(Queue *pqueue); int QPeek(Queue *pqueue);   int main() {  Queue queue;  QInit(\u0026queue);   QEnqueue(\u0026queue, 3);  QEnqueue(\u0026queue, 5);  QEnqueue(\u0026queue, 4);  QEnqueue(\u0026queue, 1);   printf(\"Q size : %d\\n\", QSize(\u0026queue));  printf(\"Q peek : %d\\n\", QPeek(\u0026queue));   while(!QIsEmpty(\u0026queue)) {  printf(\"Dequeue : %d\\n\", QDequeue(\u0026queue));  }   return 0; }    void QInit(Queue *pqueue) {  pqueue-size = 0;  pqueue-head = NULL;  pqueue-tail = NULL; }  int QSize(Queue *pqueue) {  return pqueue-size; }  int QIsEmpty(Queue *pqueue) {  if (pqueue-size == 0) {  return 1;  } else {  return 0;  } }  void QEnqueue(Queue *pqueue, int data) {  Node* newNode = (Node*)malloc(sizeof(Node));  newNode-data = data;  newNode-prev = NULL;    if(QIsEmpty(pqueue)) {  pqueue-head = newNode;  } else {  pqueue-tail-prev = newNode;  }  pqueue-tail = newNode;  pqueue-size++; }  int QDequeue(Queue *pqueue) {  int data = pqueue-head-data;   Node* delNode = pqueue-head;  pqueue-head = pqueue-head-prev;  free(delNode);   pqueue-size--;   return data; }  int QPeek(Queue *pqueue) {  return pqueue-head-data; } Trucks.c\n#include #include #include  typedef struct Truck {  int weight;  int time; }Truck;  typedef struct Queue {  int size;  struct Node* head;  struct Node* tail; }Queue;  typedef struct Node {  Truck truck;  struct Node* prev; }Node;    void QInit(Queue *pqueue); int QSize(Queue *pqueue); int QIsEmpty(Queue *pqueue); void QEnqueue(Queue *pqueue, Truck truck); Truck QDequeue(Queue *pqueue); Truck QPeek(Queue *pqueue); int solution(Queue *waitQ, Queue *bridgeQ, int bridge_length, int weight, int truck_weights[], int array_length);  int main() {  Queue waitQ;  QInit(\u0026waitQ);   Queue bridgeQ;  QInit(\u0026bridgeQ);    int bridge_length = 2;  int weight = 10;   int truck_weights[] = {7, 4, 5, 6};  int array_length = sizeof(truck_weights) / sizeof(int);   int answer = solution(\u0026waitQ, \u0026bridgeQ, bridge_length, weight, truck_weights, array_length);  printf(\"answer : %d\\n\", answer);   return 0; }    void QInit(Queue *pqueue) {  pqueue-size = 0;  pqueue-head = NULL;  pqueue-tail = NULL; }  int QSize(Queue *pqueue) {  return pqueue-size; }  int QIsEmpty(Queue *pqueue) {  if (pqueue-size == 0) {  return 1;  } else {  return 0;  } }  void QEnqueue(Queue *pqueue, Truck truck) {  Node* newNode = (Node*)malloc(sizeof(Node));  newNode-truck = truck;  newNode-prev = NULL;    if(QIsEmpty(pqueue)) {  pqueue-head = newNode;  } else {  pqueue-tail-prev = newNode;  }  pqueue-tail = newNode;  pqueue-size++; }  Truck QDequeue(Queue *pqueue) {  Truck truck = pqueue-head-truck;   Node* delNode = pqueue-head;  pqueue-head = pqueue-head-prev;  free(delNode);   pqueue-size--;   return truck; }  Truck QPeek(Queue *pqueue) {  return pqueue-head-truck; }  int solution(Queue *waitQ, Queue *bridgeQ, int bridge_length, int weight, int truck_weights[], int array_length) {  int flag = 0;  int bridge = 0;  int answer = 0;   for(int i=0; iarray_length; i++) {  Truck truck;  truck.weight = truck_weights[i];  truck.time = bridge_length;  QEnqueue(waitQ, truck);  }     while(!QIsEmpty(waitQ) || !QIsEmpty(bridgeQ)) {  Node* p = bridgeQ-head;   while(p != NULL) {  p-truck.time--;  if (p-truck.time  0) {  flag = 1;  }  p = p-prev;  }   if (flag) {  Truck outTruck = QDequeue(bridgeQ);  bridge -= outTruck.weight;  flag = 0;  }   if (!QIsEmpty(waitQ)) {  Truck inTruck = QPeek(waitQ);  if (bridge + inTruck.weight  weight) {  QEnqueue(bridgeQ, QDequeue(waitQ));  bridge += inTruck.weight;  }  }   answer++;  }   return answer; } ","wordCount":"1553","inLanguage":"en","datePublished":"2020-09-21T19:38:00Z","dateModified":"2020-09-21T19:38:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_queue/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 마음으로 이해하는 자료구조 : Queue ( feat. C )</h1><div class=post-meta><span title="2020-09-21 19:38:00 +0000 UTC">September 21, 2020</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Algorithm/Data_Structure/2020-09-21-what_is_queue.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label="0. 들어가며">0. 들어가며</a></li><li><a href=#1-%ec%9d%b4%eb%a1%a0-%ed%8e%b8 aria-label="1. 이론 편">1. 이론 편</a></li><li><a href=#2-%ea%b5%ac%ed%98%84-%ed%8e%b8---adt aria-label="2. 구현 편 - ADT">2. 구현 편 - ADT</a></li><li><a href=#3-%ea%b5%ac%ed%98%84-%ed%8e%b8---code aria-label="3. 구현 편 - Code">3. 구현 편 - Code</a></li><li><a href=#4-%ec%9d%91%ec%9a%a9-%ed%8e%b8---%eb%8b%a4%eb%a6%ac%eb%a5%bc-%ec%a7%80%eb%82%98%eb%8a%94-%ed%8a%b8%eb%9f%ad aria-label="4. 응용 편 - 다리를 지나는 트럭">4. 응용 편 - 다리를 지나는 트럭</a></li><li><a href=#%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label=마치며.>마치며.</a></li><li><a href=#%ea%b5%ac%ed%98%84-%ec%bd%94%eb%93%9c%eb%93%a4 aria-label="구현 코드들.">구현 코드들.</a></li></ul></div></details></div><div class=post-content><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>: Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.<br>아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.</p><p>따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.<br>쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.<br><a href=http://cjlee38.github.io/data_structure/what_is_stack>지난 Stack편</a> 에 이어집니다.</p><h1 id=1-이론-편>1. 이론 편<a hidden class=anchor aria-hidden=true href=#1-이론-편>#</a></h1><p>: Queue는, 편의점의 냉장고를 생각하면 된다.<br>편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.<br>창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다.</p><p>즉, A,B,C,D 를 넣으면, 편의점 손님이 이것을 꺼낼 때도 A,B,C,D 순서로 꺼낸다.</p><p>이를, <strong>FIFO(First in, First out)(선입선출)</strong> 라고 한다.</p><h1 id=2-구현-편---adt>2. 구현 편 - ADT<a hidden class=anchor aria-hidden=true href=#2-구현-편---adt>#</a></h1><p>: Queue의 ADT는 다음과 같다.</p><ul><li>init()<ul><li>Queue의 초기화를 진행</li><li>Queue 생성 후, 가장 먼저 호출되어야 하는 함수</li></ul></li><li>size()<ul><li>해당 Queue에 데이터가 몇 개 쌓여 있는지 확인.</li></ul></li><li>isEmpty()<ul><li>해당 Queue가 비어 있는가를 확인.</li><li>비었으면 true, 아니면 false를 반환.</li></ul></li><li>enqueue(data)<ul><li>Queue에 데이터를 저장.</li><li>당연히, 가장 마지막에 저장한다.</li></ul></li><li>dequeue()<ul><li>Queue에 있는 데이터를 반환</li><li>꺼낸 데이터는 <strong>Queue에서 삭제</strong>한다.</li><li>역시 당연히, <strong>가장 오래된 데이터</strong>를 꺼낸다.</li><li><strong>Queue에 데이터가 최소 하나는 있어야 한다.</strong></li></ul></li><li>peek()<ul><li>Queue에 있는 데이터를 반환.</li><li>꺼낸 데이터는 <strong>삭제하지 않는다.</strong></li><li>물론 역시 당연히, <strong>가장 오래된 데이터</strong>를 꺼낸다.</li><li><strong>Queue에 데이터가 최소 하나는 있어야 한다.</strong></li></ul></li></ul><h1 id=3-구현-편---code>3. 구현 편 - Code<a hidden class=anchor aria-hidden=true href=#3-구현-편---code>#</a></h1><p>: 역시, Queue 또한, LinkedList로 구현한다.</p><hr><blockquote><p>Note. 구현에 앞서<br>Stack과 달리, Queue에서 앞, 뒤를 구분하는 것은 헷갈린다.<br>Front와 Rear로 표현하는 사람도 있고, Head와 Tail로 표현하는 사람도 있다.<br>우리가 구현하는 큐는, 다음과 같은 그림을 갖고 있다고 생각하고 보자.</p></blockquote><p><img loading=lazy src=/assets/images/2020-09-21-21-16-35_2020-09-21-what_is_Queue.md.png alt=Queue>
{: .alignCenter}</p><hr><p>Stack과 마찬가지로, 구조체부터 만들자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Queue</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> tail;
</span></span><span style=display:flex><span>}Queue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span></code></pre></div><p>지난 Stack 구조체에 비해서, 추가 된 것은 tail 하나다.<br>Stack에서는 최상단의 대상만 삭제하고, 추가했지만,<br>Queue에서는 추가할 때는 Tail, 삭제할 때는 Head를 이용할 것이므로,<br>Head와 Tail이 둘다 필요하다.</p><p>다음으로, Init() 함수는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QInit</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>역시, size는 0으로, head와 tail은 모두 NULL로 우선 초기화 해준다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QSize</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pqueue<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QIsEmpty</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pqueue<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// if (Qsize(pqueue) == 0) 으로 대체해도 무방.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>QSize()와 QIsEmpty() 또한 간단하다.<br>IsEmpty() 그대로, 비어 있는지를 묻고 있으므로,<br>비어 있다면, 즉 size가 0 이라면 참인 1을,<br>비어 있지 않다면 거짓인 0을 return 하면 된다.</p><p>다음으로, 핵심이 되는 Enqueue()와 Dequeue() 작업이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QEnqueue</span>(Queue <span style=color:#f92672>*</span>pqueue, <span style=color:#66d9ef>int</span> data) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> (Node<span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(QIsEmpty(pqueue)) {
</span></span><span style=display:flex><span>        pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        pqueue<span style=color:#f92672>-&gt;</span>tail<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> newNode; <span style=color:#75715e>// 그림 1번
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> newNode; <span style=color:#75715e>// 그림 2번
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pqueue<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/assets/images/2020-09-21-21-42-21_2020-09-21-what_is_Queue.md.png alt=queue_enqueue>
{: .alignCenter}</p><p>만약, 처음으로 데이터를 넣는 것이라면, pqueue의 head와 tail은 둘다 newNode를 가리킨다.<br>그러나, 두 번째부터는, 조금 다르다.</p><p><strong>원래 tail이 가리키고 있던 Node가 갖고있는 prev 포인터</strong>를, 새로운 Node인 <strong>newNode를 가리키게 한다.</strong>(그림의 1번)<br>그리고, <strong>Tail은 새로운 Node인 newNode를 가리킨다.</strong> (그림의 2번)</p><p>그리고, pqueue가 갖고 있는 size라는 속성을 하나 증가시킨다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QDequeue</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> delNode <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    free(delNode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/assets/images/2020-09-21-21-44-13_2020-09-21-what_is_Queue.md.png alt=queue_dequeue>
{: .alignCenter}</p><p>삭제를 하는 경우는, stack과 같다.</p><p>가장 먼저, pqueue->head 의 Node가 갖고 있는 data를 int data에 저장한다.</p><p>그리고, <strong>delNode가 pqueue의 head를 가리키게 하고</strong>(그림의 1번)<br><strong>pqueue head는 하나 이전의 요소(prev)를 가리키게 한다.</strong>(그림의 2번)<br>마지막으로, free(delNode)를 통해, delNode가 가리키는 요소를 삭제하게 하면 된다.</p><p>이후, pstack의 data를 하나 감소시키고, data를 return 해주면 된다.</p><p>마지막으로, peek() 또한 stack과 같다</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QPeek</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>역시, 잘 돌아가는지 한번 테스트 해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Queue queue;
</span></span><span style=display:flex><span>    QInit(<span style=color:#f92672>&amp;</span>queue);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Q size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, QSize(<span style=color:#f92672>&amp;</span>queue));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Q size : 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;Q peek : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, QPeek(<span style=color:#f92672>&amp;</span>queue));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Q peek : 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>QIsEmpty(<span style=color:#f92672>&amp;</span>queue)) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Dequeue : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, QDequeue(<span style=color:#f92672>&amp;</span>queue));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Dequeue : 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Dequeue : 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Dequeue : 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Dequeue : 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>잘 동작하는 모습을 볼 수 있다.
역시, 전체 코드는 최하단에 작성하였다.</p><h1 id=4-응용-편---다리를-지나는-트럭>4. 응용 편 - 다리를 지나는 트럭<a hidden class=anchor aria-hidden=true href=#4-응용-편---다리를-지나는-트럭>#</a></h1><p>: <a href=https://programmers.co.kr/learn/courses/30/lessons/42583>다리를 지나는 트럭 문제</a>는 java 로 한번 풀었으나,<br>C로도 한번 풀어보자.(프로그래머스에서 C를 지원하지 않으므로, 제시된 테스트 케이스만 통과하면 맞았다고 보자.)</p><p>이를 위해선, <strong>트럭이 다리에 얼마나 올라와 있었는가?</strong> 를 구분하기 위해,<br>Truck 구조체를 하나 만들어야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Truck</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> weight;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> time;
</span></span><span style=display:flex><span>}Truck;
</span></span></code></pre></div><p>또한, 이 Truck 을 Queue에 담을 것이므로,<br>int 대신 Truck 구조체를 담을 수 있도록 적절히 바꿔주자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    Truck truck;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span></code></pre></div><p>당연히, 다른 관련 함수들 또한 Truck으로 적절히 바꿔주어야 한다(e.g. QDequeue())</p><p>main() 함수는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Queue waitQ;
</span></span><span style=display:flex><span>    QInit(<span style=color:#f92672>&amp;</span>waitQ);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Queue bridgeQ;
</span></span><span style=display:flex><span>    QInit(<span style=color:#f92672>&amp;</span>bridgeQ);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> bridge_length <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> truck_weights[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> array_length <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(truck_weights) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> solution(<span style=color:#f92672>&amp;</span>waitQ, <span style=color:#f92672>&amp;</span>bridgeQ, bridge_length, weight, truck_weights, array_length);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;answer : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, answer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>**&ldquo;진입을 대기하는 waitQ&rdquo;**와, <strong>&ldquo;다리에 해당하는 bridgeQ&rdquo;</strong> 를 만들어주고,<br>문제에서 주어지는 값들과 함께 solution() 함수로 넘겨주었다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>solution</span>(Queue <span style=color:#f92672>*</span>waitQ, Queue <span style=color:#f92672>*</span>bridgeQ, <span style=color:#66d9ef>int</span> bridge_length, <span style=color:#66d9ef>int</span> weight, <span style=color:#66d9ef>int</span> truck_weights[], <span style=color:#66d9ef>int</span> array_length) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 다리를 나가야 하는 트럭이 존재하는지 확인하는 flag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> bridge <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 현재 다리에 올라가 있는 트럭 무게의 합
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 처음엔 모두 Truck 구조체로 만들어서 waitQ에 넣어준다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>array_length; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        Truck truck;
</span></span><span style=display:flex><span>        truck.weight <span style=color:#f92672>=</span> truck_weights[i];
</span></span><span style=display:flex><span>        truck.time <span style=color:#f92672>=</span> bridge_length;
</span></span><span style=display:flex><span>        QEnqueue(waitQ, truck);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// waitQ와 bridgeQ가 모두 비어있다면, 모든 트럭이 통과한 것이므로 중단한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>QIsEmpty(waitQ) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>QIsEmpty(bridgeQ)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// bridgeQ를 돌면서, 다리 위에 올라가 있는 시간인 time을 1씩 감소시킨다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// time이 0 이하 인 경우, 즉 다리를 나가야 하는 트럭이 존재하는 경우, flag는 1을 추가시킨다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Node<span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> bridgeQ<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>            p<span style=color:#f92672>-&gt;</span>truck.time<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (p<span style=color:#f92672>-&gt;</span>truck.time <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// flag가 존재하는 경우, 무조건 가장 앞에 있는 트럭이 나가야 하므로,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 트럭을 하나 빼내고, 현재 다리에 올라가 있는 트럭 무게의 합인 bridge를, 빠져나가는 트럭 무게 만큼 감소시킨다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (flag) {
</span></span><span style=display:flex><span>            Truck outTruck <span style=color:#f92672>=</span> QDequeue(bridgeQ);
</span></span><span style=display:flex><span>            bridge <span style=color:#f92672>-=</span> outTruck.weight;
</span></span><span style=display:flex><span>            flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// waitQ가 비어있지 않다면, 들어갈 수 있는지를 확인해보고, 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 들어갈 수 있다면, waitQ에서 빼서 bridgeQ에 추가한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 역시, 현재 다리에 올라가 있는 트럭 무게의 합인 bridge를, 들어가는 트럭 무게 만큼 증가시킨다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>QIsEmpty(waitQ)) {
</span></span><span style=display:flex><span>            Truck inTruck <span style=color:#f92672>=</span> QPeek(waitQ);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (bridge <span style=color:#f92672>+</span> inTruck.weight <span style=color:#f92672>&lt;=</span> weight) {
</span></span><span style=display:flex><span>                QEnqueue(bridgeQ, QDequeue(waitQ));
</span></span><span style=display:flex><span>                bridge <span style=color:#f92672>+=</span> inTruck.weight;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        answer<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// end of while
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>역시, 코드에 대한 설명은 주석으로 달아놓았다.</p><h1 id=마치며>마치며.<a hidden class=anchor aria-hidden=true href=#마치며>#</a></h1><p>: C 자체로는, 생산성이 많이 떨어짐을 느꼈다. 한 번 풀었던 문제인데도,<br>이렇게 시간이 오래 걸릴줄은 몰랐다 ㅠ.<br>역시 나는 Java가 좋다.</p><h1 id=구현-코드들>구현 코드들.<a hidden class=anchor aria-hidden=true href=#구현-코드들>#</a></h1><p><strong>queueImpl.c</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Queue</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> tail;
</span></span><span style=display:flex><span>}Queue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QInit</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QSize</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QIsEmpty</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QEnqueue</span>(Queue <span style=color:#f92672>*</span>pqueue, <span style=color:#66d9ef>int</span> data);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QDequeue</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QPeek</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Queue queue;
</span></span><span style=display:flex><span>    QInit(<span style=color:#f92672>&amp;</span>queue);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    QEnqueue(<span style=color:#f92672>&amp;</span>queue, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Q size : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, QSize(<span style=color:#f92672>&amp;</span>queue));
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Q peek : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, QPeek(<span style=color:#f92672>&amp;</span>queue));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>QIsEmpty(<span style=color:#f92672>&amp;</span>queue)) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Dequeue : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, QDequeue(<span style=color:#f92672>&amp;</span>queue));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QInit</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QSize</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pqueue<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QIsEmpty</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pqueue<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QEnqueue</span>(Queue <span style=color:#f92672>*</span>pqueue, <span style=color:#66d9ef>int</span> data) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> (Node<span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(QIsEmpty(pqueue)) {
</span></span><span style=display:flex><span>        pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        pqueue<span style=color:#f92672>-&gt;</span>tail<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QDequeue</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> delNode <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    free(delNode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> data;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QPeek</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Trucks.c</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Truck</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> weight;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> time;
</span></span><span style=display:flex><span>}Truck;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Queue</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> tail;
</span></span><span style=display:flex><span>}Queue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    Truck truck;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> prev;
</span></span><span style=display:flex><span>}Node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QInit</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QSize</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QIsEmpty</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QEnqueue</span>(Queue <span style=color:#f92672>*</span>pqueue, Truck truck);
</span></span><span style=display:flex><span>Truck <span style=color:#a6e22e>QDequeue</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span>Truck <span style=color:#a6e22e>QPeek</span>(Queue <span style=color:#f92672>*</span>pqueue);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>solution</span>(Queue <span style=color:#f92672>*</span>waitQ, Queue <span style=color:#f92672>*</span>bridgeQ, <span style=color:#66d9ef>int</span> bridge_length, <span style=color:#66d9ef>int</span> weight, <span style=color:#66d9ef>int</span> truck_weights[], <span style=color:#66d9ef>int</span> array_length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Queue waitQ;
</span></span><span style=display:flex><span>    QInit(<span style=color:#f92672>&amp;</span>waitQ);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Queue bridgeQ;
</span></span><span style=display:flex><span>    QInit(<span style=color:#f92672>&amp;</span>bridgeQ);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> bridge_length <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> truck_weights[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> array_length <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(truck_weights) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> solution(<span style=color:#f92672>&amp;</span>waitQ, <span style=color:#f92672>&amp;</span>bridgeQ, bridge_length, weight, truck_weights, array_length);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;answer : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, answer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QInit</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QSize</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pqueue<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QIsEmpty</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pqueue<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>QEnqueue</span>(Queue <span style=color:#f92672>*</span>pqueue, Truck truck) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> (Node<span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(Node));
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>truck <span style=color:#f92672>=</span> truck;
</span></span><span style=display:flex><span>    newNode<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(QIsEmpty(pqueue)) {
</span></span><span style=display:flex><span>        pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        pqueue<span style=color:#f92672>-&gt;</span>tail<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>tail <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Truck <span style=color:#a6e22e>QDequeue</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    Truck truck <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>truck;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> delNode <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>    free(delNode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pqueue<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> truck;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Truck <span style=color:#a6e22e>QPeek</span>(Queue <span style=color:#f92672>*</span>pqueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pqueue<span style=color:#f92672>-&gt;</span>head<span style=color:#f92672>-&gt;</span>truck;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>solution</span>(Queue <span style=color:#f92672>*</span>waitQ, Queue <span style=color:#f92672>*</span>bridgeQ, <span style=color:#66d9ef>int</span> bridge_length, <span style=color:#66d9ef>int</span> weight, <span style=color:#66d9ef>int</span> truck_weights[], <span style=color:#66d9ef>int</span> array_length) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> bridge <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>array_length; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        Truck truck;
</span></span><span style=display:flex><span>        truck.weight <span style=color:#f92672>=</span> truck_weights[i];
</span></span><span style=display:flex><span>        truck.time <span style=color:#f92672>=</span> bridge_length;
</span></span><span style=display:flex><span>        QEnqueue(waitQ, truck);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>QIsEmpty(waitQ) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>QIsEmpty(bridgeQ)) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> bridgeQ<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(p <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>            p<span style=color:#f92672>-&gt;</span>truck.time<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (p<span style=color:#f92672>-&gt;</span>truck.time <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flag) {
</span></span><span style=display:flex><span>            Truck outTruck <span style=color:#f92672>=</span> QDequeue(bridgeQ);
</span></span><span style=display:flex><span>            bridge <span style=color:#f92672>-=</span> outTruck.weight;
</span></span><span style=display:flex><span>            flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>QIsEmpty(waitQ)) {
</span></span><span style=display:flex><span>            Truck inTruck <span style=color:#f92672>=</span> QPeek(waitQ);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (bridge <span style=color:#f92672>+</span> inTruck.weight <span style=color:#f92672>&lt;=</span> weight) {
</span></span><span style=display:flex><span>                QEnqueue(bridgeQ, QDequeue(waitQ));
</span></span><span style=display:flex><span>                bridge <span style=color:#f92672>+=</span> inTruck.weight;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        answer<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/tech/jsp/2020-09-22-jsp_learning_05/><span class=title>« Prev Page</span><br><span># 5. JSP 학습기록 - Array 와 Application, Session, Cookie</span></a>
<a class=next href=https://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_stack/><span class=title>Next Page »</span><br><span># 마음으로 이해하는 자료구조 : Stack ( feat. C )</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Queue ( feat. C ) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Queue%20%28%20feat.%20C%20%29&url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_queue%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Queue ( feat. C ) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_queue%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Queue%20%28%20feat.%20C%20%29&summary=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Queue%20%28%20feat.%20C%20%29&source=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_queue%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Queue ( feat. C ) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_queue%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Queue%20%28%20feat.%20C%20%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Queue ( feat. C ) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_queue%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Queue ( feat. C ) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Queue%20%28%20feat.%20C%20%29%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_queue%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : Queue ( feat. C ) on telegram" href="https://telegram.me/share/url?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20Queue%20%28%20feat.%20C%20%29&url=https%3a%2f%2fcjlee38.github.io%2fpost%2falgorithm%2fdata_structure%2f2020-09-21-what_is_queue%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>