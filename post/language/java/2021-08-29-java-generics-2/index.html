<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 제네릭 톺아보기 2 | cjlee38</title><meta name=keywords content="null"><meta name=description content="Java Generic 2 0. 들어가며 지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다. 그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.
public class MyList<T> {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } private Object[] array 그리고 this."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/post/language/java/2021-08-29-java-generics-2/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="# 제네릭 톺아보기 2"><meta property="og:description" content="Java Generic 2 0. 들어가며 지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다. 그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.
public class MyList<T> {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } private Object[] array 그리고 this."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/post/language/java/2021-08-29-java-generics-2/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-08-29T23:44:00+00:00"><meta property="article:modified_time" content="2021-08-29T23:44:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 제네릭 톺아보기 2"><meta name=twitter:description content="Java Generic 2 0. 들어가며 지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다. 그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.
public class MyList<T> {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } private Object[] array 그리고 this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 제네릭 톺아보기 2","item":"http://cjlee38.github.io/post/language/java/2021-08-29-java-generics-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 제네릭 톺아보기 2","name":"# 제네릭 톺아보기 2","description":"Java Generic 2 0. 들어가며 지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다. 그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.\npublic class MyList\u0026lt;T\u0026gt; {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } private Object[] array 그리고 this.","keywords":["null"],"articleBody":"Java Generic 2 0. 들어가며 지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다. 그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.\npublic class MyListT {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } private Object[] array 그리고 this.array = new Object[capacity]; 이 부분인데요. 얼핏 생각하면 private T[] array this.array = new T[capacity]; 이렇게 생성하면 더 깔끔할 것 같은데, 왜 그렇게 하지 않을까요? 여기에는 (저에게) 복잡한 엔지니어링의 철학이 스며들어있는데요. 이를 자세히 살펴보겠습니다.\n1. Basis (1) Covariant vs Contravariant vs Invariant 갑작스럽게 익숙치 않은 두 단어가 나타납니다. covariant는 공변, contravariant는 반공변, invariant는 무공변 이라는 단어로 해석되는데, 단어만 놓고 봤을때는 무슨 의미인지 파악하기가 조금 어렵습니다. 간략하게 정리하자면 다음과 같습니다.\n A, B 가 타입이고, f는 타입의 변경이라고 가정합니다.\n B가 A의 서브타입일 때, f(B)는 f(A)의 서브타입이다. - 이 때 f는 공변입니다. B가 A의 서브타입일 때, f(A)는 f(B)의 서브타입이다. - 이 때 f는 반공변입니다. A와 B가 아무런 관계를 갖지 않는다 - 이 때 f는 무공변입니다.   헷갈리니, 조금 더 자세히 풀어봅시다. 자바에서 배열은 다음과 같이 작성할 수 있습니다.\nObject[] array = new String[10]; Object와 String은 하나의 타입이고, 따라서 배열의 경우 f(Object)는 Object[] 로 만드는 것이고, f(String)은 String[] 이 되겠죠. 이러한 경우에, String[] 은 Object[] 의 서브타입이 될 수 있으므로, 공변입니다.\n한편, 제네릭은 어떨까요?\nListObject list = new ArrayListString(); 위와 같은 코드는 컴파일 되지 않습니다. 당연히, List list = new ArrayList();와 같은 반공변 코드도 안되겠죠. 따라서 제네릭은 무공변입니다. 즉, 제네릭은 타입을 가지고 상속관계를 결정지을 수 없다는 얘기가 되죠. List와 List은 얼핏 생각하기에 상속관계를 가질 것 같지만, 실제로 둘은 관계가 없습니다.\n Note 1. 하지만 같은 타입이라면 상속관계가 성립합니다. 즉, Collection과 List, 그리고 ArrayList은 추이적 관계를 갖습니다.\n  Note 2. 공변, 반공변, 무공변 등은 프로그래밍 언어의 설계적인 특성입니다. 가령, 다음과 같은 코드는 자바에서 올바르게 Override 할 수 있습니다.\nclass Super { \tObject getSomething() {} } class Sub extends Super { \tString getSomething() {} } 이를 Covariant Return Type 이라고 부르고, JDK 1.5 부터 생겨난 기능입니다.\n한편, 다음과 같은 코드는 자바에서 Override가 아닌, Overload 됩니다. 타 언어에서는 Override가 가능합니다.\nclass Super { \tvoid doSomething(String param) { ... } } class Sub extends Super { \tvoid doSomething(Object param) { ... } }  2. Basis (2) Type Erasure Type Erasure는 제네릭이 JDK 1.5부터 도입되었기 때문에, 이전 버전에 작성된 코드와의 호환성을 위해 도입된 기능입니다. Type Erasure의 기능은 다음 세 가지로 요악할 수 있습니다.\n 제네릭의 타입 파라미터(e.g. T)를 일반적인 클래스, 인터페이스 등으로 교체합니다. 만약 bound(경계)가 명시되어 있는 경우, 해당 bound로 교체하고, unbounded(경계가 없는) 인 경우 Object로 교체합니다. 필요하다면, 타입 캐스팅을 집어 넣습니다. 다형성을 유지하기 위해, 브릿지 메소드를 생성합니다.  2번은 간단하니, 1번과 3번만 살펴봅시다\n2-1. Replace Type Parameters 다음과 같은 코드가 있다고 가정해봅시다.\npublic class NodeT {   private T data;  private NodeT next;   public Node(T data, NodeT next) {  this.data = data;  this.next = next;  }   public T getData() { return data; }  // ... } 여기서 T는 unbounded, 즉 경계가 없기 때문에 다음과 같이 Object로 교체됩니다.\npublic class Node {   private Object data;  private Node next;   public Node(Object data, Node next) {  this.data = data;  this.next = next;  }   public Object getData() { return data; }  // ... } 만약 T가 다음과 같이 Comparable이라는 경계를 갖고있다면,\npublic class NodeT extends ComparableT {   private T data;  private NodeT next;   public Node(T data, NodeT next) {  this.data = data;  this.next = next;  }   public T getData() { return data; }  // ... } 해당 bound의 클래스(혹은 인터페이스) 로 교체됩니다.\npublic class Node {   private Comparable data;  private Node next;   public Node(Comparable data, Node next) {  this.data = data;  this.next = next;  }   public Comparable getData() { return data; }  // ... } 여기서 말하는 “경계” 가 무엇인지 모르셔도 괜찮습니다. 다음 3편에서(😂) 설명하겠습니다.\n2-2. Bridge Method Bridge Method는 타입 삭제로 인해 발생할 수 있는 문제를 해결하기 위해 나타난 기능입니다. 다음과 같은 코드가 있다고 가정해봅시다.\npublic class NodeT {   public T data;   public Node(T data) { this.data = data; }   public void setData(T data) {  System.out.println(\"Node.setData\");  this.data = data;  } }  public class MyNode extends NodeInteger {  public MyNode(Integer data) { super(data); }   public void setData(Integer data) {  System.out.println(\"MyNode.setData\");  super.setData(data);  } } 그리고, 위와 같이 정의된 클래스를 다음과 같이 사용하겠습니다.\nMyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. Integer x = mn.data; 타입 제거가 발생한다면, 컴파일 이후는 다음과 같은 모습일텐데요.\nMyNode mn = new MyNode(5); Node n = (MyNode)mn; // A raw type - compiler throws an unchecked warning n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. Integer x = (String)mn.data; 실제로 실행하려고 보면, ClassCastException 이라는, 다소 당황스러운 에러 메시지가 발생하게 됩니다. 그 이유는, 위에 정의된 Node, 그리고 MyNode의 타입 제거 이후의 모습과, 브릿지 메소드가 생성되었을 때의 모습을 살펴보면 알 수 있습니다. 가장 먼저, 타입 제거가 된 모습은 다음과 같습니다.\npublic class Node {   public Object data;   public Node(Object data) { this.data = data; }   public void setData(Object data) {  System.out.println(\"Node.setData\");  this.data = data;  } }  public class MyNode extends Node {   public MyNode(Integer data) { super(data); }   public void setData(Integer data) {  System.out.println(\"MyNode.setData\");  super.setData(data);  } } 위 코드를 보면, MyNode가 Node 클래스를 상속하고 있는데, Node \u001b클래스의 setData() 메소드와 MyNode 클래스의 setData() 메소드의 시그니처가 다릅니다. 하나는 Object를, 하나는 Integer를 파라미터로 받고 있는데요. 이렇게 될 경우 setData 메소드는 override가 아닌 overload 가 되겠죠. 코드가 여기까지만 변환되었다면, n 변수가 호출하는 setData 메소드는 mn 변수가 호출하는 setData는 다른 메소드이니 문제가 발생하게 됩니다. 즉, 다형성을 유지할 수 없어지게 되는데요. 이러한 문제를 해결하기 위해, 컴파일러는 다음과 같은 메소드를 클래스 내에 삽입합니다.\npublic void setData(Object data) {  setData((Integer) data); } 이러한 메소드를 브릿지 메소드라 부르고, 해당 메소드내에 있는 (Integer) 캐스팅으로 인해 ClassCastException이 발생하게 됩니다.\n3. So … 본격적으로 왜 Object[] array를 만들수 없는지에 대해 알아보겠습니다. 타입 파라미터 형태의 배열을 만들 수 없는 이유를 말하는데 뭐 이리 잡설이 기냐 라고 얘기할 수도 있겠습니다만, 이러한 요소들을 이해하고 있지 않으면, 그 이유를 이해하기가 어렵기 때문입니다.\n앞서, 자바의 배열은 공변이라고 말씀드렸습니다. 따라서, 다음과 같은 코드는 문제가 없습니다.\nObject[] array = new String[10]; 하지만, 반공변은 아니기 때문에, 다음과 같은 코드는 당연히 실행할 수 없겠죠.\nObject[] array = new Object[10]; Integer[] iarray = array; 그렇다면 지난 시간의 MyList 코드를 가져와서, 타입 파라미터의 배열을 만들 수 있다고 가정해보겠습니다. 그리고, 해당 배열을 가져오는 함수도 하나 만들어보죠.\npublic class MyListT {  private final int capacity = 10;  private int size;  private T[] array;   public MyList() {  this.array = new T[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  }   // 새로 추가한 코드  public T[] getArray() {  return array;  }  } 그리고, 다음과 같이 사용해보겠습니다.\nMyListString myList = new MyList(); String[] array = myList.getArray(); 겉보기에는 멀쩡해보이는데요. myList에서 얻어온 getArray() 는 타입 파라미터로 넣어준 String[]의 배열이고, 이를 String[] array 에서 받아내고 있으니까요.\n그런데, 앞서 이야기 했던 Type Erasure에 대해 다시 생각해보겠습니다. Type Erasure는 Unbounded인 경우 타입 파라미터를 모두 Object로 교체한다고 했었는데요. 그렇다면 실제 컴파일 이후 MyList의 생성자 부분 코드는 this.array = new Object[capacity]; 이겠네요. 역시 마찬가지로, getArray() 함수 또한 Object[] 배열을 돌려줄 것이구요. 그런데 이를 String[] 배열에서 받아내고 있습니다. 이는 금방 보았던 공변성에 어긋나게 되고, 문제가 발생하게 됩니다.\n4. Plus 4-1. Casting to Type Parameter’s array 타입 파라미터의 배열 생성이 불가능하다면, Object의 배열을 생성한 뒤, 타입 파라미터로 캐스팅하는 것은 어떨까요? 즉 다음과 같습니다.\nT[] array = (T[]) new Object[10]; 이 또한 괜찮은 선택지인 것 처럼 보이지만, 실제로는 잘못된 다운캐스팅(Downcasting) 으로 인해 실패하게 됩니다. 생성하는 객체가 Object 객체의 배열이기 때문에, 이를 다른 타입의 객체 배열로 캐스팅하는 것은 성립이 되지 않습니다. 다운캐스팅은 다음과 같이 실제로 생성하는 객체가 해당 타입이거나, 혹은 그 상위일때에만 가능합니다.\nObject[] array = new String[10]; String[] sArray = (String[]) array; 여기서 new String[10]; 을 new Object[10]; 으로 바꾸게 되면 ClassCastException이 발생합니다.\n4-2. Array of Generic Class 다음으로 살펴볼 예시는, 제네릭 클래스의 배열입니다.\nListString[] arrOfList = new ArrayListString[10]; 이와 같은 코드는 실제로 컴파일 되지 않지만, 가능하다고 가정해봅니다.\nObject[] objarr = arrOfList; objarr[0] = new ArrayListInteger(); 이 때, 위와 같이 코드를 작성하면, 문제가 발생하지 않습니다. Type Erasure로 인해 런타임 당시에는 결국 List[] 이 아닌 List[] 니까요. 위에서는 List만 받기로 했는데, List를 할당하고 있으니 예외가 발생해야 하는데, 그렇지 않죠. 애초에 제네릭의 탄생 목적이 사용하는 타입의 안정성을 보장하기 위한 것인데(즉, 제한된 종류의 타입만 한정지어서 사용하도록 하고, 이에 관련된 문제는 컴파일 도중에 잡아낼 수 있도록이죠), String을 넣기로 약속한 곳에 Integer를 넣을 수 있다면 제네릭의 안정성이 전혀 보장될 수 없습니다. 그렇기 때문에 애초에 Generic Array Creation 이라는 경고 문구가 등장합니다.\n예외가 발생한다고 해서, 다음과 같은 코드를 작성해서도 안됩니다.\nListString[] listOfArr = new ArrayList[10]; 아예 제네릭을 빼버리는건데요. 그러면 다음과 같이 흐름이 이어질 경우 역시 타입 캐스팅 도중에 ClassCastException이 발생하게 됩니다.\nObject[] objarr = listOfArr;  ListInteger iList = new ArrayList(); iList.add(123); objarr[0] = ilist;  System.out.println(strlistarr[0].get(0)); // exception occurs here 억지를 부려서 List만 받기로 약속한 listOfArr 에 List를 넣어줬는데요. 꺼낼때에는 listOfArr은 “당연히 내 안에 들어있는 녀석들은 String이겠군” 하고 캐스팅을 하려다 문제가 발생하게 됩니다. 지난 편에 제네릭을 소개할 때 보여드렸던, 실수할 수 있는 케이스와 결국 같은 맥락입니다.\n지금까지 제네릭 속에 들어있는 프로그래밍 이론에 관해서 다뤄보고, 이에 기인한 제네릭의 주의점에 대해서 알아보았습니다. 꽤나 복잡하고 많은 양을 다루었다고 생각했는데, 아직도 갈 길이 멉니다. 다음 시간에는 타입 경계, 그리고 와일드카드에 대해서 이야기해보고자 합니다. 감사합니다.\n5. Reference 공변성과 반공변성은 무엇인가? | edykim java - How to create a generic array? - Stack Overflow Covariance and contravariance (computer science) - Wikipedia\n","wordCount":"1539","inLanguage":"en","datePublished":"2021-08-29T23:44:00Z","dateModified":"2021-08-29T23:44:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/post/language/java/2021-08-29-java-generics-2/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 제네릭 톺아보기 2</h1><div class=post-meta><span title="2021-08-29 23:44:00 +0000 UTC">August 29, 2021</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Language/Java/2021-08-29-java-generics-2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=java-generic-2>Java Generic 2<a hidden class=anchor aria-hidden=true href=#java-generic-2>#</a></h1><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다.
그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyList</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> capacity <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Object<span style=color:#f92672>[]</span> array<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyList</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>array</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>capacity<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>T o<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        array<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> o<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> index<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>T<span style=color:#f92672>)</span> array<span style=color:#f92672>[</span>index<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><code>private Object[] array</code> 그리고 <code>this.array = new Object[capacity];</code> 이 부분인데요. 얼핏 생각하면 <code>private T[] array</code> <code>this.array = new T[capacity];</code> 이렇게 생성하면 더 깔끔할 것 같은데, 왜 그렇게 하지 않을까요? 여기에는 (저에게) 복잡한 엔지니어링의 철학이 스며들어있는데요. 이를 자세히 살펴보겠습니다.</p><h1 id=1-basis-1-covariant-vs-contravariant-vs-invariant>1. Basis (1) <code>Covariant</code> vs <code>Contravariant</code> vs <code>Invariant</code><a hidden class=anchor aria-hidden=true href=#1-basis-1-covariant-vs-contravariant-vs-invariant>#</a></h1><p>갑작스럽게 익숙치 않은 두 단어가 나타납니다. <code>covariant</code>는 공변, <code>contravariant</code>는 반공변, <code>invariant</code>는 무공변 이라는 단어로 해석되는데, 단어만 놓고 봤을때는 무슨 의미인지 파악하기가 조금 어렵습니다. 간략하게 정리하자면 다음과 같습니다.</p><blockquote><p>A, B 가 타입이고, f는 타입의 변경이라고 가정합니다.</p><ul><li>B가 A의 서브타입일 때, f(B)는 f(A)의 서브타입이다. -> 이 때 f는 공변입니다.</li><li>B가 A의 서브타입일 때, f(A)는 f(B)의 서브타입이다. -> 이 때 f는 반공변입니다.</li><li>A와 B가 아무런 관계를 갖지 않는다 -> 이 때 f는 무공변입니다.</li></ul></blockquote><p>헷갈리니, 조금 더 자세히 풀어봅시다. 자바에서 배열은 다음과 같이 작성할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#f92672>[]</span> array <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>10<span style=color:#f92672>];</span>
</span></span></code></pre></div><p>Object와 String은 하나의 타입이고, 따라서 배열의 경우 f(Object)는 <code>Object[]</code> 로 만드는 것이고, f(String)은 <code>String[]</code> 이 되겠죠. 이러한 경우에, <code>String[]</code> 은 <code>Object[]</code> 의 서브타입이 될 수 있으므로, 공변입니다.</p><p>한편, 제네릭은 어떨까요?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;();</span>
</span></span></code></pre></div><p>위와 같은 코드는 컴파일 되지 않습니다. 당연히, <code>List&lt;String> list = new ArrayList&lt;Object>();</code>와 같은 반공변 코드도 안되겠죠. 따라서 제네릭은 무공변입니다. 즉, 제네릭은 타입을 가지고 상속관계를 결정지을 수 없다는 얘기가 되죠. List와 List은 얼핏 생각하기에 상속관계를 가질 것 같지만, 실제로 둘은 관계가 없습니다.</p><blockquote><p>Note 1. 하지만 같은 타입이라면 상속관계가 성립합니다. 즉, Collection과 List, 그리고 ArrayList은 <a href=https://ko.wikipedia.org/wiki/%EC%B6%94%EC%9D%B4%EC%A0%81_%EA%B4%80%EA%B3%84>추이적 관계</a>를 갖습니다.</p></blockquote><blockquote><p>Note 2. 공변, 반공변, 무공변 등은 프로그래밍 언어의 설계적인 특성입니다. 가령, 다음과 같은 코드는 자바에서 올바르게 Override 할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Super</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>	Object <span style=color:#a6e22e>getSomething</span><span style=color:#f92672>()</span> <span style=color:#f92672>{}</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sub</span> <span style=color:#66d9ef>extends</span> Super <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>	String <span style=color:#a6e22e>getSomething</span><span style=color:#f92672>()</span> <span style=color:#f92672>{}</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>  
</span></span></code></pre></div><p>이를 <strong>Covariant Return Type</strong> 이라고 부르고, JDK 1.5 부터 생겨난 기능입니다.<br>한편, 다음과 같은 코드는 자바에서 Override가 아닌, Overload 됩니다. 타 언어에서는 Override가 가능합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Super</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span><span style=color:#f92672>(</span>String param<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sub</span> <span style=color:#66d9ef>extends</span> Super <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span><span style=color:#f92672>(</span>Object param<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>  
</span></span></code></pre></div></blockquote><h1 id=2-basis-2-type-erasure>2. Basis (2) Type Erasure<a hidden class=anchor aria-hidden=true href=#2-basis-2-type-erasure>#</a></h1><p>Type Erasure는 제네릭이 JDK 1.5부터 도입되었기 때문에, 이전 버전에 작성된 코드와의 호환성을 위해 도입된 기능입니다. Type Erasure의 기능은 다음 세 가지로 요악할 수 있습니다.</p><ol><li>제네릭의 타입 파라미터(e.g. T)를 일반적인 클래스, 인터페이스 등으로 교체합니다. 만약 bound(경계)가 명시되어 있는 경우, 해당 bound로 교체하고, unbounded(경계가 없는) 인 경우 Object로 교체합니다.</li><li>필요하다면, 타입 캐스팅을 집어 넣습니다.</li><li>다형성을 유지하기 위해, <code>브릿지 메소드</code>를 생성합니다.</li></ol><p>2번은 간단하니, 1번과 3번만 살펴봅시다</p><h2 id=2-1-replace-type-parameters>2-1. Replace Type Parameters<a hidden class=anchor aria-hidden=true href=#2-1-replace-type-parameters>#</a></h2><p>다음과 같은 코드가 있다고 가정해봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> T data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>(</span>T data<span style=color:#f92672>,</span> Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> next<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>getData</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> data<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>여기서 T는 unbounded, 즉 경계가 없기 때문에 다음과 같이 Object로 교체됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Object data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Node next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>(</span>Object data<span style=color:#f92672>,</span> Node next<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>getData</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> data<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>만약 T가 다음과 같이 Comparable이라는 경계를 갖고있다면,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>T <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> T data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>(</span>T data<span style=color:#f92672>,</span> Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> next<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>getData</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> data<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>해당 bound의 클래스(혹은 인터페이스) 로 교체됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Comparable data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Node next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>(</span>Comparable data<span style=color:#f92672>,</span> Node next<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Comparable <span style=color:#a6e22e>getData</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> data<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>여기서 말하는 &ldquo;경계&rdquo; 가 무엇인지 모르셔도 괜찮습니다. 다음 3편에서(😂) 설명하겠습니다.</p><h2 id=2-2-bridge-method>2-2. Bridge Method<a hidden class=anchor aria-hidden=true href=#2-2-bridge-method>#</a></h2><p>Bridge Method는 타입 삭제로 인해 발생할 수 있는 문제를 해결하기 위해 나타난 기능입니다. 다음과 같은 코드가 있다고 가정해봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>(</span>T data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span>T data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Node.setData&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyNode</span> <span style=color:#66d9ef>extends</span> Node<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyNode</span><span style=color:#f92672>(</span>Integer data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>data<span style=color:#f92672>);</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span>Integer data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MyNode.setData&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span>data<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>그리고, 위와 같이 정의된 클래스를 다음과 같이 사용하겠습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MyNode mn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyNode<span style=color:#f92672>(</span>5<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>Node n <span style=color:#f92672>=</span> mn<span style=color:#f92672>;</span>            <span style=color:#75715e>// A raw type - compiler throws an unchecked warning
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>n<span style=color:#f92672>.</span><span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Hello&#34;</span><span style=color:#f92672>);</span>     <span style=color:#75715e>// Causes a ClassCastException to be thrown.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Integer x <span style=color:#f92672>=</span> mn<span style=color:#f92672>.</span><span style=color:#a6e22e>data</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>타입 제거가 발생한다면, 컴파일 이후는 다음과 같은 모습일텐데요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MyNode mn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyNode<span style=color:#f92672>(</span>5<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>Node n <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>MyNode<span style=color:#f92672>)</span>mn<span style=color:#f92672>;</span>         <span style=color:#75715e>// A raw type - compiler throws an unchecked warning
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>n<span style=color:#f92672>.</span><span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Hello&#34;</span><span style=color:#f92672>);</span>          <span style=color:#75715e>// Causes a ClassCastException to be thrown.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Integer x <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>String<span style=color:#f92672>)</span>mn<span style=color:#f92672>.</span><span style=color:#a6e22e>data</span><span style=color:#f92672>;</span> 
</span></span></code></pre></div><p>실제로 실행하려고 보면, ClassCastException 이라는, 다소 당황스러운 에러 메시지가 발생하게 됩니다. 그 이유는, 위에 정의된 <code>Node</code>, 그리고 <code>MyNode</code>의 타입 제거 이후의 모습과, 브릿지 메소드가 생성되었을 때의 모습을 살펴보면 알 수 있습니다. 가장 먼저, 타입 제거가 된 모습은 다음과 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Object data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>(</span>Object data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span>Object data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Node.setData&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyNode</span> <span style=color:#66d9ef>extends</span> Node <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyNode</span><span style=color:#f92672>(</span>Integer data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>data<span style=color:#f92672>);</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span>Integer data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MyNode.setData&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span>data<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>위 코드를 보면, MyNode가 Node 클래스를 상속하고 있는데, <code>Node</code> 클래스의 <code>setData()</code> 메소드와 <code>MyNode</code> 클래스의 <code>setData()</code> 메소드의 시그니처가 다릅니다. 하나는 Object를, 하나는 Integer를 파라미터로 받고 있는데요. 이렇게 될 경우 <code>setData</code> 메소드는 override가 아닌 <strong>overload</strong> 가 되겠죠. 코드가 여기까지만 변환되었다면, <code>n</code> 변수가 호출하는 <code>setData</code> 메소드는 <code>mn</code> 변수가 호출하는 <code>setData</code>는 다른 메소드이니 문제가 발생하게 됩니다. 즉, 다형성을 유지할 수 없어지게 되는데요. 이러한 문제를 해결하기 위해, 컴파일러는 다음과 같은 메소드를 클래스 내에 삽입합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setData</span><span style=color:#f92672>(</span>Object data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    setData<span style=color:#f92672>((</span>Integer<span style=color:#f92672>)</span> data<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>이러한 메소드를 브릿지 메소드라 부르고, 해당 메소드내에 있는 <code>(Integer)</code> 캐스팅으로 인해 <code>ClassCastException</code>이 발생하게 됩니다.</p><h1 id=3-so->3. So &mldr;<a hidden class=anchor aria-hidden=true href=#3-so->#</a></h1><p>본격적으로 왜 Object[] array를 만들수 없는지에 대해 알아보겠습니다. 타입 파라미터 형태의 배열을 만들 수 없는 이유를 말하는데 뭐 이리 잡설이 기냐 라고 얘기할 수도 있겠습니다만, 이러한 요소들을 이해하고 있지 않으면, 그 이유를 이해하기가 어렵기 때문입니다.</p><p>앞서, 자바의 배열은 공변이라고 말씀드렸습니다. 따라서, 다음과 같은 코드는 문제가 없습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#f92672>[]</span> array <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>10<span style=color:#f92672>];</span>
</span></span></code></pre></div><p>하지만, 반공변은 아니기 때문에, 다음과 같은 코드는 당연히 실행할 수 없겠죠.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#f92672>[]</span> array <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>10<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>Integer<span style=color:#f92672>[]</span> iarray <span style=color:#f92672>=</span> array<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>그렇다면 지난 시간의 MyList 코드를 가져와서, 타입 파라미터의 배열을 만들 수 있다고 가정해보겠습니다. 그리고, 해당 배열을 가져오는 함수도 하나 만들어보죠.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyList</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> capacity <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> T<span style=color:#f92672>[]</span> array<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyList</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>array</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> T<span style=color:#f92672>[</span>capacity<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>T o<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        array<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> o<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> index<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>T<span style=color:#f92672>)</span> array<span style=color:#f92672>[</span>index<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 새로 추가한 코드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> T<span style=color:#f92672>[]</span> <span style=color:#a6e22e>getArray</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> array<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>그리고, 다음과 같이 사용해보겠습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MyList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> myList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>String<span style=color:#f92672>[]</span> array <span style=color:#f92672>=</span> myList<span style=color:#f92672>.</span><span style=color:#a6e22e>getArray</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><p>겉보기에는 멀쩡해보이는데요. myList에서 얻어온 getArray() 는 타입 파라미터로 넣어준 String[]의 배열이고, 이를 <code>String[] array</code> 에서 받아내고 있으니까요.</p><p>그런데, 앞서 이야기 했던 Type Erasure에 대해 다시 생각해보겠습니다. Type Erasure는 <strong>Unbounded인 경우 타입 파라미터를 모두 Object로 교체한다</strong>고 했었는데요. 그렇다면 실제 컴파일 이후 MyList의 생성자 부분 코드는 <code>this.array = new Object[capacity];</code> 이겠네요. 역시 마찬가지로, getArray() 함수 또한 <code>Object[]</code> 배열을 돌려줄 것이구요. 그런데 이를 <code>String[]</code> 배열에서 받아내고 있습니다. 이는 금방 보았던 공변성에 어긋나게 되고, 문제가 발생하게 됩니다.</p><h1 id=4-plus>4. Plus<a hidden class=anchor aria-hidden=true href=#4-plus>#</a></h1><h2 id=4-1-casting-to-type-parameters-array>4-1. Casting to Type Parameter&rsquo;s array<a hidden class=anchor aria-hidden=true href=#4-1-casting-to-type-parameters-array>#</a></h2><p>타입 파라미터의 배열 생성이 불가능하다면, Object의 배열을 생성한 뒤, 타입 파라미터로 캐스팅하는 것은 어떨까요? 즉 다음과 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>T<span style=color:#f92672>[]</span> array <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>T<span style=color:#f92672>[])</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>10<span style=color:#f92672>];</span>
</span></span></code></pre></div><p>이 또한 괜찮은 선택지인 것 처럼 보이지만, 실제로는 잘못된 다운캐스팅(Downcasting) 으로 인해 실패하게 됩니다. 생성하는 객체가 Object 객체의 배열이기 때문에, 이를 다른 타입의 객체 배열로 캐스팅하는 것은 성립이 되지 않습니다. 다운캐스팅은 다음과 같이 실제로 생성하는 객체가 해당 타입이거나, 혹은 그 상위일때에만 가능합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#f92672>[]</span> array <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>10<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>String<span style=color:#f92672>[]</span> sArray <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>String<span style=color:#f92672>[])</span> array<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>여기서 <code>new String[10];</code> 을 <code>new Object[10];</code> 으로 바꾸게 되면 <code>ClassCastException</code>이 발생합니다.</p><h2 id=4-2-array-of-generic-class>4-2. Array of Generic Class<a hidden class=anchor aria-hidden=true href=#4-2-array-of-generic-class>#</a></h2><p>다음으로 살펴볼 예시는, 제네릭 클래스의 배열입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;[]</span> arrOfList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;[</span>10<span style=color:#f92672>];</span>
</span></span></code></pre></div><p>이와 같은 코드는 실제로 컴파일 되지 않지만, 가능하다고 가정해봅니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#f92672>[]</span> objarr <span style=color:#f92672>=</span> arrOfList<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>objarr<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;();</span>
</span></span></code></pre></div><p>이 때, 위와 같이 코드를 작성하면, 문제가 발생하지 않습니다. Type Erasure로 인해 런타임 당시에는 결국 <code>List&lt;String>[]</code> 이 아닌 <code>List[]</code> 니까요. 위에서는 List만 받기로 했는데, List를 할당하고 있으니 예외가 발생해야 하는데, 그렇지 않죠. 애초에 제네릭의 탄생 목적이 사용하는 타입의 안정성을 보장하기 위한 것인데(즉, 제한된 종류의 타입만 한정지어서 사용하도록 하고, 이에 관련된 문제는 컴파일 도중에 잡아낼 수 있도록이죠), String을 넣기로 약속한 곳에 Integer를 넣을 수 있다면 제네릭의 안정성이 전혀 보장될 수 없습니다. 그렇기 때문에 애초에 <code>Generic Array Creation</code> 이라는 경고 문구가 등장합니다.</p><p>예외가 발생한다고 해서, 다음과 같은 코드를 작성해서도 안됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;[]</span> listOfArr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>[</span>10<span style=color:#f92672>];</span>
</span></span></code></pre></div><p>아예 제네릭을 빼버리는건데요. 그러면 다음과 같이 흐름이 이어질 경우 역시 타입 캐스팅 도중에 <code>ClassCastException</code>이 발생하게 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#f92672>[]</span> objarr <span style=color:#f92672>=</span> listOfArr<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> iList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>iList<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>123<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>objarr<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> ilist<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>strlistarr<span style=color:#f92672>[</span>0<span style=color:#f92672>].</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>0<span style=color:#f92672>));</span> <span style=color:#75715e>// exception occurs here
</span></span></span></code></pre></div><p>억지를 부려서 <code>List&lt;String></code>만 받기로 약속한 <code>listOfArr</code> 에 <code>List&lt;Integer></code>를 넣어줬는데요. 꺼낼때에는 <code>listOfArr</code>은 &ldquo;당연히 내 안에 들어있는 녀석들은 String이겠군&rdquo; 하고 캐스팅을 하려다 문제가 발생하게 됩니다. 지난 편에 제네릭을 소개할 때 보여드렸던, 실수할 수 있는 케이스와 결국 같은 맥락입니다.</p><p>지금까지 제네릭 속에 들어있는 프로그래밍 이론에 관해서 다뤄보고, 이에 기인한 제네릭의 주의점에 대해서 알아보았습니다. 꽤나 복잡하고 많은 양을 다루었다고 생각했는데, 아직도 갈 길이 멉니다. 다음 시간에는 타입 경계, 그리고 와일드카드에 대해서 이야기해보고자 합니다. 감사합니다.</p><h2 id=5-reference>5. Reference<a hidden class=anchor aria-hidden=true href=#5-reference>#</a></h2><p><a href=https://edykim.com/ko/post/what-is-coercion-and-anticommunism/>공변성과 반공변성은 무엇인가? | edykim</a>
<a href=https://stackoverflow.com/questions/18581002/how-to-create-a-generic-array>java - How to create a generic array? - Stack Overflow</a>
<a href=https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29>Covariance and contravariance (computer science) - Wikipedia</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/post/language/python/2021-09-16-journey-to-property/><span class=title>« Prev Page</span><br><span># (Python) @Property까지 가는 길</span></a>
<a class=next href=http://cjlee38.github.io/post/language/java/2021-08-10-java-generics-1-copy/><span class=title>Next Page »</span><br><span># 제네릭 톺아보기 1</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 제네릭 톺아보기 2 on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%ec%a0%9c%eb%84%a4%eb%a6%ad%20%ed%86%ba%ec%95%84%eb%b3%b4%ea%b8%b0%202&url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2021-08-29-java-generics-2%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 제네릭 톺아보기 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2021-08-29-java-generics-2%2f&title=%23%20%ec%a0%9c%eb%84%a4%eb%a6%ad%20%ed%86%ba%ec%95%84%eb%b3%b4%ea%b8%b0%202&summary=%23%20%ec%a0%9c%eb%84%a4%eb%a6%ad%20%ed%86%ba%ec%95%84%eb%b3%b4%ea%b8%b0%202&source=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2021-08-29-java-generics-2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 제네릭 톺아보기 2 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2021-08-29-java-generics-2%2f&title=%23%20%ec%a0%9c%eb%84%a4%eb%a6%ad%20%ed%86%ba%ec%95%84%eb%b3%b4%ea%b8%b0%202"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 제네릭 톺아보기 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2021-08-29-java-generics-2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 제네릭 톺아보기 2 on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%ec%a0%9c%eb%84%a4%eb%a6%ad%20%ed%86%ba%ec%95%84%eb%b3%b4%ea%b8%b0%202%20-%20http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2021-08-29-java-generics-2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 제네릭 톺아보기 2 on telegram" href="https://telegram.me/share/url?text=%23%20%ec%a0%9c%eb%84%a4%eb%a6%ad%20%ed%86%ba%ec%95%84%eb%b3%b4%ea%b8%b0%202&url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2021-08-29-java-generics-2%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>