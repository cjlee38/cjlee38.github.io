<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># Java의 static 메소드는 왜 overriding이 안되나요? | cjlee38</title><meta name=keywords content="java,jvm"><meta name=description content="얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.
 Java의 static method는 왜 overriding이 안되나요 ?
 static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.
이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.
예제 아래 코드를 한번 살펴보겠습니다."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/post/language/java/2022-12-03-override-static-method/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-174927148-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="# Java의 static 메소드는 왜 overriding이 안되나요?"><meta property="og:description" content="얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.
 Java의 static method는 왜 overriding이 안되나요 ?
 static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.
이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.
예제 아래 코드를 한번 살펴보겠습니다."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/post/language/java/2022-12-03-override-static-method/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-03T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-03T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# Java의 static 메소드는 왜 overriding이 안되나요?"><meta name=twitter:description content="얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.
 Java의 static method는 왜 overriding이 안되나요 ?
 static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.
이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.
예제 아래 코드를 한번 살펴보겠습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# Java의 static 메소드는 왜 overriding이 안되나요?","item":"http://cjlee38.github.io/post/language/java/2022-12-03-override-static-method/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# Java의 static 메소드는 왜 overriding이 안되나요?","name":"# Java의 static 메소드는 왜 overriding이 안되나요?","description":"얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.\n Java의 static method는 왜 overriding이 안되나요 ?\n static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.\n이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.\n예제 아래 코드를 한번 살펴보겠습니다.","keywords":["java","jvm"],"articleBody":"얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.\n Java의 static method는 왜 overriding이 안되나요 ?\n static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.\n이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.\n예제 아래 코드를 한번 살펴보겠습니다.(해당 코드는 반복해서 사용할 예정이니 구조를 눈여겨보시기 바랍니다.)\npublic class StaticMethodOverride {  public static void main(String[] args) {  Parent whoAreU = new Child();  whoAreU.myInstantMethod();  whoAreU.myStaticMethod();  } }  class Parent {  public static void myStaticMethod() {  System.out.println(\"Parent.myStaticMethod\");  }   public void myInstantMethod() {  System.out.println(\"Parent.myInstantMethod\");  } }  class Child extends Parent {   public static void myStaticMethod() {  System.out.println(\"Child.myStaticMethod\");  }   @Override  public void myInstantMethod() {  System.out.println(\"Child.myInstantMethod\");  } } Parent와 Parent를 상속받는 Chid라는 두 개의 클래스를 만들었습니다. 그리고 Child 클래스를 구현체로 갖는 Parent 객체를 생성한 뒤, 각각 static method와 instance method를 호출했습니다. 그리고 그 결과는 예상했던대로, 아래와 같이 출력되었습니다.\nChild.myInstantMethod Parent.myStaticMethod 왜 instance method는 구현체에 따라 호출되었고, static method는 타입에 따라 호출되었을까요? 그 이유는 java bytecode와 JVM이 메소드를 invoke 하는 방식을 살펴보면 알 수 있습니다.\n바이트코드 자바 컴파일러가 .java 확장자를 가진 자바파일을 읽어들이면서, 작성된 자바코드를 자바 bytecode로 변환합니다. 그리고, javap 명령어를 통해 컴파일된 .class 파일, 즉 bytecode를 역어셈블할 수 있습니다.\n사용한 명령어는 아래와 같습니다.\njavac StaticMethodOverride.java \u0026\u0026 javap -c -verbose StaticMethodOverride.class 실행 결과를 살펴보면 꽤 복잡한 내용의 코드가 출력됩니다. 그 중, 가장 먼저 살펴볼 부분은 바로 bytecode 명령어가 담긴 부분입니다.\n알아보기가 힘들지만, 중간 즈음에 위치한 public static void main(java.lang.String[]); 부분이 우리의 main method가 호출되는 지점임을 확인할 수 있습니다.\nCode: 부분으로 넘어가서 살펴보죠. 객체를 생성하는 부분을 제외하고, 메소드를 호출하는 부분만 살펴보면 9번, 14번에 위치한 invokevirtual과 invokestatic이 각각 호출했던 instant method와 static method에 대응합니다. 즉, 바꿔말하면 “호출하려는 메소드가 static metho인지, instance method인지\"에 대해서는 컴파일타임에 알 수 있다는 점입니다.\n 각각의 명령어가 invokevirtual, invokestatic 이었다는 사실을 기억해주세요.\n 그런데 또 자세히 살펴보면, #4 와 #5 라는 숫자가 써있네요. 이 부분은 constant pool 이라고 하는 곳의 index를 나타냅니다. constant pool을 확인해보겠습니다.\n각각의 #4, #5 번은 MethodRef 라는 의미를 내포하면서, 각각 #18.#19, #18.20 에 대한 index를 다시 나타내고 있습니다. 해당 인덱스를 따라가보면, #18은 Class를, #19는 다시 NameAndType을 가리킵니다. 최종적으로 쭉 따라가다보면, 결국 Utf8 이라는 타입으로 귀결됩니다.\nstatic 위와 같은 과정을 통해, 우리는 java의 클래스나 메소드가 위와같이 재귀참조를 통해 시그니쳐를 나타낸다는 것까지 확인했습니다. 그리고, 호출하는 메소드의 클래스는 슈퍼클래스인 Parent 라는 것까지 확인했죠. 그렇다면 여기서 우리는 메소드의 호출은 “타입을 따라간다” 라고 추론할 수 있습니다. 이를 증명하기 위해, 서브클래스인 Child를 타입으로 객체를 생성하여 static method를 호출해보겠습니다.\nChild.myStaticMethod(); /* 결과 17: invokestatic #6 // Method study/java/staticmethod/Child.myStaticMethod:()V */ 위와같이 자식 타입에 대한 static method를 호출하고, 바이트코드를 살펴보면 아까와는 다르게 Child에 대한 메소드를 호출함을 볼 수 있습니다. 즉, 슈퍼클래스와 서브클래스의 static method signature는 일치할 수 있으며, 우리는 이를 overriding이 아닌 hiding 이라고 부릅니다.\ninvokevirtual, invokestatic 그런데 이상한점이 있습니다. invokestatic이야 Parent 클래스를 가리키는 것은 그렇다 쳐도, invokevirtual 또한 constant pool을 따라가다보면 Parent 클래스를 가리킨다는 점입니다. 그런데 어떻게 Child 메소드가 호출될 수 있을까요? 이 때 JVM이 메소드를 호출하는 방식, 즉 dynamic dispatch(혹은 dynamic binding)이 동작하는 시점입니다.\nJVM Specification에서는 다음과 같이 설명합니다.\n invokevirtual invokes an instance method of an object, dispatching on the (virtual) type of the object. This is the normal method dispatch in the Java programming language.\n 즉, invokevirtual 은 “객체\"의 타입을 보고 메소드를 호출한다는 것입니다. 그런데 이것만으로도 설명은 부족합니다. “객체\"의 타입을 어떻게 보고, 어떻게 메소드를 호출한다는 것일까요 ?\n 여기서 virtual 이라는 키워드는 C++ 의 virtual과 연관이 깊습니다. 이와 관련된 내용은 본 포스팅에서 다루지 않습니다. 단, java의 모든 메소드는 final 이나 static 키워드를 붙이지 않았다면 기본적으로 virtual 메소드라는 점만 짚고 넘어가겠습니다.\n 객체에 대한 reference인 whoAreU 변수 그 자체는 사실 내부적으로 두 개의 포인터를 갖고 있습니다. 하나는 우리가 일반적으로 알고 있는, 힙 영역에 존재하는 객체 데이터에 대한 포인터이고, 다른 하나는 객체의 타입과 메소드 테이블을 가지고 있는 포인터입니다.\n그리고 후자에 해당하는 포인터를 따라, 간접적으로 메소드를 호출할 수 있게 되는것입니다. invokevirtual이 동작하는 방식 또한 역시 JVM specification에 명시되어 있습니다.\n Let C be the class of objectref.\nThe actual method to be invoked is selected by the following lookup procedure: If C contains a declaration for an instance method m that overrides (§5.4.5) the resolved method, then m is the method to be invoked, and the lookup procedure terminates.\nOtherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the method to be invoked is the result of the recursive invocation of this lookup procedure.\nOtherwise, an AbstractMethodError is raised.\n 즉, 어떠한 메소드를 호출할 때 자기 자신이 호출되어야할 메소드를 갖고있는지 확인하고, 그렇지 않다면 슈퍼 클래스로 이동해서 확인하게 됩니다. 하지만 이는 명세일뿐, 실제 JVM이 구현하는 방식은 다릅니다. 아무래도 매번 이러한 호출과정을 거치게 되면 속도가 느려지겠죠. 따라서 C++에서 차용한 개념인 method table 을 이용해 위 과정을 최적화했습니다.\n각 JVM의 밴더사마다 method table의 구현 방식은 다르지만, 대략 아래와 같이 구현되어있을 것이라고 기대할 수 있습니다.\n Object class\n   Name Address Description     Object.getClass() 0x01 Object.getClass()   Object.toString() 0x02 Object.toString()   (기타 다른 메소드는 생략)       ClassLoader(아마 Boostrap)에 의해 Object 클래스가 로딩되고 나면, Object 클래스가 갖고 있는 여러 메소드들에 대한 method table이 초기화됩니다. 그리고, 기타 사용자(개발자)가 정의한 클래스가 런타임중에 로딩되는 순간, 각각의 메소드테이블이 초기화됩니다.\nParent 클래스가 ClassLoader(아마 Application)에 의해 로딩되면, Object 클래스로부터 method table을 복사한뒤, 자기 자신이 갖고있는 signature에 따라 method table을 업데이트합니다. 따라서, Parent의 method table은 아래와 같이 구성될 것입니다.\n Parent class\n   Name Address Description     Object.getClass() 0x01 Object.getClass()   Object.toString() 0x02 Object.toString()   Parent.myInstantMethod() 0x03 Parent.myInstantMethod()   (기타 다른 메소드는 생략)       Child 클래스 역시 마찬가지로, 자신의 슈퍼클래스인 Parent 클래스로부터 method table을 복사한뒤 업데이트 과정을 거칩니다. 그런데 이 때, Child 클래스는 myInstantMethod()를 overriding 합니다. 따라서, method table은 아래와 같이 업데이트됩니다.\n Child class\n   Name Address Description     Object.getClass() 0x01 Object.getClass()   Object.toString() 0x02 Object.toString()   Parent.myInstantMethod() 0x03 Child.myInstantMethod()   (기타 다른 메소드는 생략)       자, 이제 정리해보겠습니다. JVM이 명령어를 실행하던 도중, invokevirtual을 마주하고 target이 되는 object와 arguments 들을 operand stack 에서 꺼냅니다. 그리고, 해당 object의 method table을 뒤져보고, 호출할 대상이 되는 메소드를 찾아냅니다. 그리고, object와 arguments로 새로운 스택 프레임을 구성하면서 메소드 호출이 이뤄지게 됩니다.\n나가며 method table 이란 것에 대해서 막연하게만 알고 있었는데, 이번 기회를 통해 좀 깊게 파볼 수 있었던 경험이 된 것 같습니다. 이 글을 읽으시는 여러분들도 JVM이 어떻게 메소드를 호출하는지에 대해 원리를 이해하는데 조금이나마 도움이 되셨으면 좋겠습니다.\n참고했던 자료들이 조금 오래된 자료들이라, 현재(Java 8, 11, 17 …)와는 조금 다를수도 있습니다. 틀린 내용이 있으면 언제든 지적 바랍니다. 감사합니다.\n reference  https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokevirtual https://www.artima.com/insidejvm/ed2/jvmP.html https://en.wikipedia.org/wiki/Virtual_method_table https://www.programmingmitra.com/2017/05/how-does-jvm-handle-method-overriding-internally.html  ","wordCount":"1023","inLanguage":"en","datePublished":"2022-12-03T00:00:00Z","dateModified":"2022-12-03T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/post/language/java/2022-12-03-override-static-method/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># Java의 static 메소드는 왜 overriding이 안되나요?</h1><div class=post-meta><span title="2022-12-03 00:00:00 +0000 UTC">December 3, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Language/Java/2022-12-03-override-static-method.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%98%88%ec%a0%9c aria-label=예제>예제</a></li><li><a href=#%eb%b0%94%ec%9d%b4%ed%8a%b8%ec%bd%94%eb%93%9c aria-label=바이트코드>바이트코드</a></li><li><a href=#static aria-label=static>static</a></li><li><a href=#invokevirtual-invokestatic aria-label="invokevirtual, invokestatic">invokevirtual, invokestatic</a></li><li><a href=#%eb%82%98%ea%b0%80%eb%a9%b0 aria-label=나가며>나가며</a></li><li><a href=#reference aria-label=reference>reference</a></li></ul></div></details></div><div class=post-content><p>얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.</p><blockquote><p>Java의 static method는 왜 overriding이 안되나요 ?</p></blockquote><p>static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.</p><p>이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.</p><h3 id=예제>예제<a hidden class=anchor aria-hidden=true href=#예제>#</a></h3><p>아래 코드를 한번 살펴보겠습니다.(해당 코드는 반복해서 사용할 예정이니 구조를 눈여겨보시기 바랍니다.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StaticMethodOverride</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Parent whoAreU <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Child<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        whoAreU<span style=color:#f92672>.</span><span style=color:#a6e22e>myInstantMethod</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        whoAreU<span style=color:#f92672>.</span><span style=color:#a6e22e>myStaticMethod</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parent</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myStaticMethod</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Parent.myStaticMethod&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myInstantMethod</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Parent.myInstantMethod&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Child</span> <span style=color:#66d9ef>extends</span> Parent <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myStaticMethod</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Child.myStaticMethod&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myInstantMethod</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Child.myInstantMethod&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Parent와 Parent를 상속받는 Chid라는 두 개의 클래스를 만들었습니다. 그리고 <code>Child</code> 클래스를 구현체로 갖는 <code>Parent</code> 객체를 생성한 뒤, 각각 static method와 instance method를 호출했습니다. 그리고 그 결과는 예상했던대로, 아래와 같이 출력되었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Child.myInstantMethod
</span></span><span style=display:flex><span>Parent.myStaticMethod
</span></span></code></pre></div><p>왜 instance method는 구현체에 따라 호출되었고, static method는 타입에 따라 호출되었을까요? 그 이유는 java bytecode와 JVM이 메소드를 invoke 하는 방식을 살펴보면 알 수 있습니다.</p><h3 id=바이트코드>바이트코드<a hidden class=anchor aria-hidden=true href=#바이트코드>#</a></h3><p>자바 컴파일러가 <code>.java</code> 확장자를 가진 자바파일을 읽어들이면서, 작성된 자바코드를 자바 bytecode로 변환합니다. 그리고, <code>javap</code> 명령어를 통해 컴파일된 <code>.class</code> 파일, 즉 bytecode를 역어셈블할 수 있습니다.</p><p>사용한 명령어는 아래와 같습니다.</p><pre tabindex=0><code>javac StaticMethodOverride.java &amp;&amp; javap -c -verbose StaticMethodOverride.class
</code></pre><p>실행 결과를 살펴보면 꽤 복잡한 내용의 코드가 출력됩니다. 그 중, 가장 먼저 살펴볼 부분은 바로 bytecode 명령어가 담긴 부분입니다.</p><p><img loading=lazy src=/assets/images/2022-11-13-override-static-method/2022-12-04-20-19-41.png alt></p><p>알아보기가 힘들지만, 중간 즈음에 위치한 <code>public static void main(java.lang.String[]);</code> 부분이 우리의 main method가 호출되는 지점임을 확인할 수 있습니다.</p><p><code>Code:</code> 부분으로 넘어가서 살펴보죠. 객체를 생성하는 부분을 제외하고, 메소드를 호출하는 부분만 살펴보면 <code>9번</code>, <code>14번</code>에 위치한 <code>invokevirtual</code>과 <code>invokestatic</code>이 각각 호출했던 <code>instant method</code>와 <code>static method</code>에 대응합니다. 즉, 바꿔말하면 &ldquo;호출하려는 메소드가 static metho인지, instance method인지"에 대해서는 컴파일타임에 알 수 있다는 점입니다.</p><blockquote><p>각각의 명령어가 <code>invokevirtual</code>, <code>invokestatic</code> 이었다는 사실을 기억해주세요.</p></blockquote><p>그런데 또 자세히 살펴보면, <code>#4</code> 와 <code>#5</code> 라는 숫자가 써있네요. 이 부분은 <code>constant pool</code> 이라고 하는 곳의 index를 나타냅니다. <code>constant pool</code>을 확인해보겠습니다.</p><p><img loading=lazy src=/assets/images/2022-11-13-override-static-method/2022-12-04-20-30-09.png alt></p><p>각각의 <code>#4</code>, <code>#5</code> 번은 <code>MethodRef</code> 라는 의미를 내포하면서, 각각 <code>#18.#19</code>, <code>#18.20</code> 에 대한 index를 다시 나타내고 있습니다. 해당 인덱스를 따라가보면, <code>#18</code>은 <code>Class</code>를, <code>#19</code>는 다시 <code>NameAndType</code>을 가리킵니다. 최종적으로 쭉 따라가다보면, 결국 <code>Utf8</code> 이라는 타입으로 귀결됩니다.</p><h3 id=static>static<a hidden class=anchor aria-hidden=true href=#static>#</a></h3><p>위와 같은 과정을 통해, 우리는 java의 클래스나 메소드가 위와같이 재귀참조를 통해 시그니쳐를 나타낸다는 것까지 확인했습니다. 그리고, 호출하는 메소드의 클래스는 슈퍼클래스인 <code>Parent</code> 라는 것까지 확인했죠. 그렇다면 여기서 우리는 메소드의 호출은 &ldquo;타입을 따라간다&rdquo; 라고 추론할 수 있습니다. 이를 증명하기 위해, 서브클래스인 <code>Child</code>를 타입으로 객체를 생성하여 static method를 호출해보겠습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Child<span style=color:#f92672>.</span><span style=color:#a6e22e>myStaticMethod</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 결과
</span></span></span><span style=display:flex><span><span style=color:#75715e>17: invokestatic  #6  // Method study/java/staticmethod/Child.myStaticMethod:()V
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>위와같이 자식 타입에 대한 static method를 호출하고, 바이트코드를 살펴보면 아까와는 다르게 <code>Child</code>에 대한 메소드를 호출함을 볼 수 있습니다. 즉, 슈퍼클래스와 서브클래스의 static method signature는 일치할 수 있으며, 우리는 이를 <code>overriding</code>이 아닌 <code>hiding</code> 이라고 부릅니다.</p><h3 id=invokevirtual-invokestatic>invokevirtual, invokestatic<a hidden class=anchor aria-hidden=true href=#invokevirtual-invokestatic>#</a></h3><p>그런데 이상한점이 있습니다. <code>invokestatic</code>이야 Parent 클래스를 가리키는 것은 그렇다 쳐도, <code>invokevirtual</code> 또한 constant pool을 따라가다보면 Parent 클래스를 가리킨다는 점입니다. 그런데 어떻게 <code>Child</code> 메소드가 호출될 수 있을까요? 이 때 JVM이 메소드를 호출하는 방식, 즉 <code>dynamic dispatch(혹은 dynamic binding)</code>이 동작하는 시점입니다.</p><p>JVM Specification에서는 다음과 같이 설명합니다.</p><blockquote><p>invokevirtual invokes an instance method of an object, dispatching on the (virtual) type of the object. This is the normal method dispatch in the Java programming language.</p></blockquote><p>즉, <code>invokevirtual</code> 은 &ldquo;객체"의 타입을 보고 메소드를 호출한다는 것입니다. 그런데 이것만으로도 설명은 부족합니다. &ldquo;객체"의 타입을 어떻게 보고, 어떻게 메소드를 호출한다는 것일까요 ?</p><blockquote><p>여기서 <code>virtual</code> 이라는 키워드는 <code>C++</code> 의 <code>virtual</code>과 연관이 깊습니다. 이와 관련된 내용은 본 포스팅에서 다루지 않습니다. 단, <code>java</code>의 모든 메소드는 <code>final</code> 이나 <code>static</code> 키워드를 붙이지 않았다면 기본적으로 <code>virtual</code> 메소드라는 점만 짚고 넘어가겠습니다.</p></blockquote><p>객체에 대한 reference인 <code>whoAreU</code> 변수 그 자체는 사실 내부적으로 두 개의 포인터를 갖고 있습니다. 하나는 우리가 일반적으로 알고 있는, 힙 영역에 존재하는 객체 데이터에 대한 포인터이고, 다른 하나는 <strong>객체의 타입과 메소드 테이블을 가지고 있는 포인터</strong>입니다.</p><p>그리고 후자에 해당하는 포인터를 따라, 간접적으로 메소드를 호출할 수 있게 되는것입니다. <code>invokevirtual</code>이 동작하는 방식 또한 역시 JVM specification에 명시되어 있습니다.</p><blockquote><p>Let C be the class of objectref.</p><p>The actual method to be invoked is selected by the following lookup procedure:
If C contains a declaration for an instance method m that overrides (§5.4.5) the resolved method, then m is the method to be invoked, and the lookup procedure terminates.</p><p>Otherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the method to be invoked is the result of the recursive invocation of this lookup procedure.</p><p>Otherwise, an AbstractMethodError is raised.</p></blockquote><p>즉, 어떠한 메소드를 호출할 때 자기 자신이 호출되어야할 메소드를 갖고있는지 확인하고, 그렇지 않다면 슈퍼 클래스로 이동해서 확인하게 됩니다. 하지만 이는 명세일뿐, 실제 JVM이 구현하는 방식은 다릅니다. 아무래도 매번 이러한 호출과정을 거치게 되면 속도가 느려지겠죠. 따라서 <code>C++</code>에서 차용한 개념인 <code>method table</code> 을 이용해 위 과정을 최적화했습니다.</p><p>각 JVM의 밴더사마다 <code>method table</code>의 구현 방식은 다르지만, 대략 아래와 같이 구현되어있을 것이라고 기대할 수 있습니다.</p><blockquote><p><strong>Object class</strong></p><table><thead><tr><th style=text-align:center>Name</th><th style=text-align:center>Address</th><th style=text-align:center>Description</th></tr></thead><tbody><tr><td style=text-align:center>Object.getClass()</td><td style=text-align:center>0x01</td><td style=text-align:center>Object.getClass()</td></tr><tr><td style=text-align:center>Object.toString()</td><td style=text-align:center>0x02</td><td style=text-align:center>Object.toString()</td></tr><tr><td style=text-align:center>(기타 다른 메소드는 생략)</td><td></td><td></td></tr></tbody></table></blockquote><p>ClassLoader(아마 Boostrap)에 의해 <code>Object</code> 클래스가 로딩되고 나면, <code>Object</code> 클래스가 갖고 있는 여러 메소드들에 대한 <code>method table</code>이 초기화됩니다. 그리고, 기타 사용자(개발자)가 정의한 클래스가 런타임중에 로딩되는 순간, 각각의 메소드테이블이 초기화됩니다.</p><p><code>Parent</code> 클래스가 ClassLoader(아마 Application)에 의해 로딩되면, <code>Object</code> 클래스로부터 <code>method table</code>을 복사한뒤, 자기 자신이 갖고있는 <code>signature</code>에 따라 <code>method table</code>을 업데이트합니다. 따라서, <code>Parent</code>의 <code>method table</code>은 아래와 같이 구성될 것입니다.</p><blockquote><p><strong>Parent class</strong></p><table><thead><tr><th style=text-align:center>Name</th><th style=text-align:center>Address</th><th style=text-align:center>Description</th></tr></thead><tbody><tr><td style=text-align:center>Object.getClass()</td><td style=text-align:center>0x01</td><td style=text-align:center>Object.getClass()</td></tr><tr><td style=text-align:center>Object.toString()</td><td style=text-align:center>0x02</td><td style=text-align:center>Object.toString()</td></tr><tr><td style=text-align:center><strong>Parent.myInstantMethod()</strong></td><td style=text-align:center><strong>0x03</strong></td><td style=text-align:center><strong>Parent.myInstantMethod()</strong></td></tr><tr><td style=text-align:center>(기타 다른 메소드는 생략)</td><td></td><td></td></tr></tbody></table></blockquote><p><code>Child</code> 클래스 역시 마찬가지로, 자신의 슈퍼클래스인 <code>Parent</code> 클래스로부터 <code>method table</code>을 복사한뒤 업데이트 과정을 거칩니다. 그런데 이 때, <code>Child</code> 클래스는 <code>myInstantMethod()</code>를 overriding 합니다. 따라서, <code>method table</code>은 아래와 같이 업데이트됩니다.</p><blockquote><p><strong>Child class</strong></p><table><thead><tr><th style=text-align:center>Name</th><th style=text-align:center>Address</th><th style=text-align:center>Description</th></tr></thead><tbody><tr><td style=text-align:center>Object.getClass()</td><td style=text-align:center>0x01</td><td style=text-align:center>Object.getClass()</td></tr><tr><td style=text-align:center>Object.toString()</td><td style=text-align:center>0x02</td><td style=text-align:center>Object.toString()</td></tr><tr><td style=text-align:center>Parent.myInstantMethod()</td><td style=text-align:center>0x03</td><td style=text-align:center><strong>Child.myInstantMethod()</strong></td></tr><tr><td style=text-align:center>(기타 다른 메소드는 생략)</td><td></td><td></td></tr></tbody></table></blockquote><p>자, 이제 정리해보겠습니다. JVM이 명령어를 실행하던 도중, <code>invokevirtual</code>을 마주하고 target이 되는 <code>object</code>와 <code>arguments</code> 들을 <code>operand stack</code> 에서 꺼냅니다. 그리고, 해당 object의 <code>method table</code>을 뒤져보고, 호출할 대상이 되는 메소드를 찾아냅니다. 그리고, <code>object</code>와 <code>arguments</code>로 새로운 스택 프레임을 구성하면서 메소드 호출이 이뤄지게 됩니다.</p><h3 id=나가며>나가며<a hidden class=anchor aria-hidden=true href=#나가며>#</a></h3><p>method table 이란 것에 대해서 막연하게만 알고 있었는데, 이번 기회를 통해 좀 깊게 파볼 수 있었던 경험이 된 것 같습니다. 이 글을 읽으시는 여러분들도 JVM이 어떻게 메소드를 호출하는지에 대해 원리를 이해하는데 조금이나마 도움이 되셨으면 좋겠습니다.</p><p>참고했던 자료들이 조금 오래된 자료들이라, 현재(Java 8, 11, 17 &mldr;)와는 조금 다를수도 있습니다. 틀린 내용이 있으면 언제든 지적 바랍니다. 감사합니다.</p><hr><h3 id=reference>reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h3><ul><li><a href=https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokevirtual>https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokevirtual</a></li><li><a href=https://www.artima.com/insidejvm/ed2/jvmP.html>https://www.artima.com/insidejvm/ed2/jvmP.html</a></li><li><a href=https://en.wikipedia.org/wiki/Virtual_method_table>https://en.wikipedia.org/wiki/Virtual_method_table</a></li><li><a href=https://www.programmingmitra.com/2017/05/how-does-jvm-handle-method-overriding-internally.html>https://www.programmingmitra.com/2017/05/how-does-jvm-handle-method-overriding-internally.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/java/>java</a></li><li><a href=http://cjlee38.github.io/tags/jvm/>jvm</a></li></ul><nav class=paginav><a class=next href=http://cjlee38.github.io/post/tech/architecture/2022-10-19-domain-layered-architecture/><span class=title>Next Page »</span><br><span># 개인적인, 도메인과 레이어드 아키텍처</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # Java의 static 메소드는 왜 overriding이 안되나요? on twitter" href="https://twitter.com/intent/tweet/?text=%23%20Java%ec%9d%98%20static%20%eb%a9%94%ec%86%8c%eb%93%9c%eb%8a%94%20%ec%99%9c%20overriding%ec%9d%b4%20%ec%95%88%eb%90%98%eb%82%98%ec%9a%94%3f&url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2022-12-03-override-static-method%2f&hashtags=java%2cjvm"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # Java의 static 메소드는 왜 overriding이 안되나요? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2022-12-03-override-static-method%2f&title=%23%20Java%ec%9d%98%20static%20%eb%a9%94%ec%86%8c%eb%93%9c%eb%8a%94%20%ec%99%9c%20overriding%ec%9d%b4%20%ec%95%88%eb%90%98%eb%82%98%ec%9a%94%3f&summary=%23%20Java%ec%9d%98%20static%20%eb%a9%94%ec%86%8c%eb%93%9c%eb%8a%94%20%ec%99%9c%20overriding%ec%9d%b4%20%ec%95%88%eb%90%98%eb%82%98%ec%9a%94%3f&source=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2022-12-03-override-static-method%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # Java의 static 메소드는 왜 overriding이 안되나요? on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2022-12-03-override-static-method%2f&title=%23%20Java%ec%9d%98%20static%20%eb%a9%94%ec%86%8c%eb%93%9c%eb%8a%94%20%ec%99%9c%20overriding%ec%9d%b4%20%ec%95%88%eb%90%98%eb%82%98%ec%9a%94%3f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # Java의 static 메소드는 왜 overriding이 안되나요? on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2022-12-03-override-static-method%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # Java의 static 메소드는 왜 overriding이 안되나요? on whatsapp" href="https://api.whatsapp.com/send?text=%23%20Java%ec%9d%98%20static%20%eb%a9%94%ec%86%8c%eb%93%9c%eb%8a%94%20%ec%99%9c%20overriding%ec%9d%b4%20%ec%95%88%eb%90%98%eb%82%98%ec%9a%94%3f%20-%20http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2022-12-03-override-static-method%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # Java의 static 메소드는 왜 overriding이 안되나요? on telegram" href="https://telegram.me/share/url?text=%23%20Java%ec%9d%98%20static%20%eb%a9%94%ec%86%8c%eb%93%9c%eb%8a%94%20%ec%99%9c%20overriding%ec%9d%b4%20%ec%95%88%eb%90%98%eb%82%98%ec%9a%94%3f&url=http%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2022-12-03-override-static-method%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>