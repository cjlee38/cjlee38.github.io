<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># (Java) HashMap 으로의 여행 | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. 들어가며 : 나는 프로그래밍에서 Naming이 정말 Critical한 중요성을 갖는다고 생각한다.
새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,
왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.
Python에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는
데이터를 저장하는 가장 대표적인 클래스다.
Python의 dictionary 라는 이름을 보면,
&ldquo;음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!&rdquo;
이라고 유추해 볼 수 있지만,
Java의 HashMap을 보면 잘 이해가 되지 않는다."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/language/java/2020-09-10-journey_to_java_hashmap/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-174927148-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="# (Java) HashMap 으로의 여행"><meta property="og:description" content="0. 들어가며 : 나는 프로그래밍에서 Naming이 정말 Critical한 중요성을 갖는다고 생각한다.
새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,
왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.
Python에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는
데이터를 저장하는 가장 대표적인 클래스다.
Python의 dictionary 라는 이름을 보면,
&ldquo;음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!&rdquo;
이라고 유추해 볼 수 있지만,
Java의 HashMap을 보면 잘 이해가 되지 않는다."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/language/java/2020-09-10-journey_to_java_hashmap/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-09-10T14:54:36+00:00"><meta property="article:modified_time" content="2020-09-10T14:54:36+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# (Java) HashMap 으로의 여행"><meta name=twitter:description content="0. 들어가며 : 나는 프로그래밍에서 Naming이 정말 Critical한 중요성을 갖는다고 생각한다.
새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,
왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.
Python에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는
데이터를 저장하는 가장 대표적인 클래스다.
Python의 dictionary 라는 이름을 보면,
&ldquo;음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!&rdquo;
이라고 유추해 볼 수 있지만,
Java의 HashMap을 보면 잘 이해가 되지 않는다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# (Java) HashMap 으로의 여행","item":"https://cjlee38.github.io/post/language/java/2020-09-10-journey_to_java_hashmap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# (Java) HashMap 으로의 여행","name":"# (Java) HashMap 으로의 여행","description":"0. 들어가며 : 나는 프로그래밍에서 Naming이 정말 Critical한 중요성을 갖는다고 생각한다.\n새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,\n왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.\nPython에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는\n데이터를 저장하는 가장 대표적인 클래스다.\nPython의 dictionary 라는 이름을 보면,\n\u0026ldquo;음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!\u0026rdquo;\n이라고 유추해 볼 수 있지만,\nJava의 HashMap을 보면 잘 이해가 되지 않는다.","keywords":["null"],"articleBody":"0. 들어가며 : 나는 프로그래밍에서 Naming이 정말 Critical한 중요성을 갖는다고 생각한다.\n새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,\n왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.\nPython에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는\n데이터를 저장하는 가장 대표적인 클래스다.\nPython의 dictionary 라는 이름을 보면,\n“음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!”\n이라고 유추해 볼 수 있지만,\nJava의 HashMap을 보면 잘 이해가 되지 않는다.\nMap이야 Key랑 Value를 Mapping한다는 의미로 쓰인것 같은데,\n“Hash? 내가 아는 그 Hash의 의미로 쓴게 맞나? 왜 Hash라는 이름을 쓴거지?”\n라는 의구심이 든다.\n또한, 흔히 “Key-Value의 시간복잡도는 O(1) 이다” 라고 한다. 왜일까?\nKey라고 하는 것은 결국, Index나 Memory의 위치가 아니라, Object일텐데,\n어떻게 O(1)이 나올 수 있을까?\n궁금증을 해결하기 위해,\n세계 모든 지식을 총망라하신 구선생님께 여쭤보았다.\n(공부하면서 작성한 것이니, 틀린 부분이 있다면 말씀해주세요.)\n1. Hash : Hash 자체에 대한 내용은 이 포스팅에서 다루지 않는다.\nHash에 대한 이해가 없으면, 이 글을 읽기가 조금 어려울 수 있다.\n(2020.09.25 수정)\nHash 맛보기\nHash에 관해서 포스팅했습니다.\n2. HashMap의 구조 : HashMap에 왜 Hash라는 이름이 붙었는지 이해하기 위해선,\n먼저 그 구조를 파악하는 것이 우선이다.\n{: .alignCenter}\n사진 출처\n먼저, bucket 이라는 Array가 있고,\n그 Array 내부에는 Node로 구성된 “LinkedList” 가 존재한다.\n즉, 이렇게 생긴 것을 “Hash table” 이라고 하고, Hash table을 통해 Key-Value를 관리하게 된다.\n기수정렬(Radix Sort) 할 때의 모습을 상상해보면 된다.\n3. HashMap의 동작 (이론편) : 대충 어떻게 생겨 먹었는지는 알겠으니, 어떻게 동작하는지에 대해서 한번 간략하게 익혀보자.\n데이터를 집어 넣는 과정을 이해하면, 꺼내는 것을 이해하는 것은 당연하게 여겨진다.\nHashMap에 put() 함수를 사용해서, 데이터를 넣고자 하면, 다음과 같은 과정이 일어난다.\n Key로 들어온 Object를 Hash화를 한다 Hash화한 값을 “배열의 인덱스” 로 지정한다. 해당 배열에 값이 존재하지 않으면, 그 위치에 Node라는 클래스로 Key-Value Object를 저장한다. 해당 배열에 값이 존재하면, 그 다음 위치에 새로운 Node를 연결하고 Key-Value Object를 저장한다.(즉, LinkedList로 관리한다.) List가 너무 길게 이어진다면, Tree로 변환한다. Hash충돌(Collision)이 너무 많이 발생한다면, Bucket. 즉 배열의 크기를 늘린다.  이해력이 좋은 사람이라면, 여기까지만 봐도 아하 할 수 있다.\n나같은 멍청이는 뭔소리야? 싶어서 결국 코드를 뜯어보고야 만다.\n4. HashMap의 동작 (코드편) : HashMap 에 데이터를 넣고자 하는, put() 함수로 이동해보자.\npublic V put(K key, V value) {  return putVal(hash(key), key, value, false, true); } 보는 바와 같이,\n hash()라는 함수를 실행한 key 원래 key value 뭔지 모를 false 뭔지 모를 true  가 있다.\nhash() 함수로 슬쩍 발 하나 담궈보자.\nstatic final int hash(Object key) {  int h;  return (key == null) ? 0 : (h = key.hashCode()) ^ (h  16); } key가 null이라면 0을, null이 아니라면 key의 hashCode() 라는 함수를 실행한 값과, key의 Hash코드를 unsigned로 쉬프트 연산한 값을 XOR 연산한 것을 확인할 수 있다.\n이렇게 하면 어떤 값이 나온다는 것을 예측할 수 있다.\n이번 포스팅에서의 목적은 Hash가 어떻게 구현되는지가 아니므로,\n뭐 대충 어떤 숫자가 나왔다고 이해하고 넘어가자.\n다시 돌아와서, 이제 putVal() 이라는 곳으로 구경 가보자.\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,  boolean evict) {  NodeK,V[] tab; NodeK,V p; int n, i;  if ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length;  if ((p = tab[i = (n - 1) \u0026 hash]) == null)  tab[i] = newNode(hash, key, value, null);  else {  NodeK,V e; K k;  if (p.hash == hash \u0026\u0026  ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k))))  e = p;  else if (p instanceof TreeNode)  e = ((TreeNodeK,V)p).putTreeVal(this, tab, hash, key, value);  else {  for (int binCount = 0; ; ++binCount) {  if ((e = p.next) == null) {  p.next = newNode(hash, key, value, null);  if (binCount = TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash);  break;  }  if (e.hash == hash \u0026\u0026  ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  break;  p = e;  }  }  if (e != null) { // existing mapping for key  V oldValue = e.value;  if (!onlyIfAbsent || oldValue == null)  e.value = value;  afterNodeAccess(e);  return oldValue;  }  }  ++modCount;  if (++size  threshold)  resize();  afterNodeInsertion(evict);  return null; } 꽤 길다. 그리고 복잡하다. 코드를 머릿속으로 Deserialize 하는데 좀 시간이 걸렸다.\nSection을 조금 나눠서 살펴보자.\nif ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length; 첫 if문에서 table, 즉 Hash테이블이 null 인지를 물어본다. 즉, “데이터를 처음 넣는거냐?” 라고 물어보는 것이다.\n참이라면, resize() 함수를 실행하고, 그 결과를 tab에, 그리고 그 길이를 n에 넣는다.\nif ((p = tab[i = (n - 1) \u0026 hash]) == null)  tab[i] = newNode(hash, key, value, null); 다음으로, table의 ((n-1) \u0026 hash) 위치. 즉 배열의 특정 index에 위치한 값이 null 이라면,\n다시 말해, 자리가 비어있다면, 해당 위치에는 새로운 Node를 만들어서 집어넣는다.\nelse {  NodeK,V e; K k;  if (p.hash == hash \u0026\u0026  ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k))))  e = p; 아니라면, 즉 해당 위치에 무언가가(Node) 이미 존재한다면, else문으로 진입하게 된다.\n그 이후 등장하는 첫번째 if문은 “hash만 같은게 아니라, key 자체도 같은거야?’ 라고 물어본다.\n맞다면, 해당 key를 교체하게 된다.\nelse if (p instanceof TreeNode)  e = ((TreeNodeK,V)p).putTreeVal(this, tab, hash, key, value); 그게 아니라면, 우선 해당 LinkedList가 Tree인지를 물어본다.\nTree라면, Tree에 맞게 값을 추가한다.\nelse {  for (int binCount = 0; ; ++binCount) {  if ((e = p.next) == null) {  p.next = newNode(hash, key, value, null);  if (binCount = TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash);  break;  }  if (e.hash == hash \u0026\u0026  ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  break;  p = e;  } } 트리가 아니라면, LinkedList란 뜻이다. 그렇다면 해당 LinkedList를 돌면서,\n“Key까지 같으면, replace” 해주고, 처음 들어오는 놈이라면, 맨 끝에 이어붙이게 된다.\n그 과정속에서, bin. 즉 LinkedList의 길이가 너무 길다면, 이를 Tree로 바꿔준다.\nif (e != null) { // existing mapping for key  V oldValue = e.value;  if (!onlyIfAbsent || oldValue == null)  e.value = value;  afterNodeAccess(e);  return oldValue; } 여기서 e는 우리가 새로이 추가하고자 하는 Node를 가리킨다.\nelse문으로 분기한 이후, 우리가 지금까지 한 것은, Node를 추가할 위치를 찾는 것이었다.\n이제 값을 넣어야 한다. 해당 코드가 Key 안에 Value를 넣는것이다.\nonltIfAbsent는 “키가 이미 있으면, 안넣겠다\"를 의미한다. 즉, 우리는 false를 넣어줬고, ! 가 붙었으므로 true이므로, 참이 되니 값을 교체할 수 있다.\n++modCount; if (++size  threshold)  resize(); afterNodeInsertion(evict); return null; 마지막으로, 수정된 횟수를 ++시키고,\nHashTable의 길이 또한 ++ 시킨 뒤, 일정 수준을 넘어서면 resize() 하게 된다.\nafterNodeAccess와 afterNodeInsertion은 LinkedHashMap에서 Override 되는 내용이므로 Pass한다.\nresize() 코드 또한 꽤 복잡하므로, 주석만 따왔다. 여기서는 다음과 같이 설명한다.\n Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.\n 즉, bucket을 초기화 하던지, 충돌이 너무 많이 일어나면 두배로 늘리겠다는 얘기다.\n이렇게 흐름을 읽고 나면, 왜 HashMap이 O(1)에 가까운 접근속도를 보이는지 알 수 있다.\n기본적으로, 데이터의 구조가 배열이므로 O(1)의 접근속도를 가지고, “해쉬\"라는 것은 결국 일정 길이의 숫자를 return 하므로,\n“해쉬값을 통해 index 접근\"을 진행하면, 어떤 Object 이던 O(1)으로 접근할 수 있다.\n그런데, 충돌이 아예 안일어난다면 좋겠지만, 이를 위해 배열의 길이를 너무 길게 만들면 공간의 낭비고, 그렇다고 적게 만들자니, 충돌이 일어날 때 문제가 생긴다. 따라서 충돌이 일어나면 LinkedList로 연결지어준다.\n이 LinkedList는 특정 길이를 넘어서면 Tree 형태를 갖게 되고,\n또한 충돌 자체도 많이 일어나면 배열을 늘리므로,\n이 LinkedList 혹은 Tree는 제한된 크기를 갖게 된다.\n5. 마치며 : 기존에 가졌던 궁금증이 모두 해소되었다.\nHash를 왜 사용했는지, 그리고 왜 시간복잡도가 이렇게 빠른 것인지 알 수 있었다.\n그런데, 또 한가지 궁금증이 발생한다.\nPython은 3.7 이후 Dictionary는 Ordered, 즉 순서를 갖는 Dictionary를 Default로 사용한다고 한다.\n얘는 또 어떻게 구현되었을지에 대해 알아보고 싶지만, 일단 여기에서 멈추자.\nReference\n Java HashMap은 어떻게 동작하는가? Hash Table은 프로그래머의 기본기 Java HashMap동작 원리  ","wordCount":"1239","inLanguage":"en","datePublished":"2020-09-10T14:54:36Z","dateModified":"2020-09-10T14:54:36Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/language/java/2020-09-10-journey_to_java_hashmap/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># (Java) HashMap 으로의 여행</h1><div class=post-meta><span title="2020-09-10 14:54:36 +0000 UTC">September 10, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Language/Java/2020-09-10-journey_to_java_hashmap.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label="0. 들어가며">0. 들어가며</a></li><li><a href=#1-hash aria-label="1. Hash">1. Hash</a></li><li><a href=#2-hashmap%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="2. HashMap의 구조">2. HashMap의 구조</a></li><li><a href=#3-hashmap%ec%9d%98-%eb%8f%99%ec%9e%91-%ec%9d%b4%eb%a1%a0%ed%8e%b8 aria-label="3. HashMap의 동작 (이론편)">3. HashMap의 동작 (이론편)</a></li><li><a href=#4-hashmap%ec%9d%98-%eb%8f%99%ec%9e%91-%ec%bd%94%eb%93%9c%ed%8e%b8 aria-label="4. HashMap의 동작 (코드편)">4. HashMap의 동작 (코드편)</a></li><li><a href=#5-%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label="5. 마치며">5. 마치며</a></li></ul></div></details></div><div class=post-content><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>: 나는 프로그래밍에서 Naming이 정말 <strong>Critical한 중요성</strong>을 갖는다고 생각한다.<br>새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,<br>왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.</p><p>Python에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는<br>데이터를 저장하는 가장 대표적인 클래스다.</p><p>Python의 dictionary 라는 이름을 보면,<br>&ldquo;음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!&rdquo;<br>이라고 유추해 볼 수 있지만,</p><p>Java의 HashMap을 보면 잘 이해가 되지 않는다.<br>Map이야 Key랑 Value를 Mapping한다는 의미로 쓰인것 같은데,<br>&ldquo;Hash? 내가 아는 그 Hash의 의미로 쓴게 맞나? 왜 Hash라는 이름을 쓴거지?&rdquo;<br>라는 의구심이 든다.</p><p>또한, 흔히 &ldquo;Key-Value의 시간복잡도는 O(1) 이다&rdquo; 라고 한다. 왜일까?<br>Key라고 하는 것은 결국, Index나 Memory의 위치가 아니라, Object일텐데,<br>어떻게 O(1)이 나올 수 있을까?</p><p>궁금증을 해결하기 위해,<br>세계 모든 지식을 총망라하신 구선생님께 여쭤보았다.<br>(공부하면서 작성한 것이니, 틀린 부분이 있다면 말씀해주세요.)</p><h1 id=1-hash>1. Hash<a hidden class=anchor aria-hidden=true href=#1-hash>#</a></h1><p>: Hash 자체에 대한 내용은 이 포스팅에서 다루지 않는다.<br>Hash에 대한 이해가 없으면, 이 글을 읽기가 조금 어려울 수 있다.</p><p>(2020.09.25 수정)<br><a href=https://cjlee38.github.io/btb/what_is_hash>Hash 맛보기</a><br>Hash에 관해서 포스팅했습니다.</p><h1 id=2-hashmap의-구조>2. HashMap의 구조<a hidden class=anchor aria-hidden=true href=#2-hashmap의-구조>#</a></h1><p>: HashMap에 왜 Hash라는 이름이 붙었는지 이해하기 위해선,<br>먼저 그 구조를 파악하는 것이 우선이다.</p><p><img loading=lazy src=/assets/images/2020-09-10-15-07-31_journey_to_java_hashmap.md.png alt="Structure of Hashmap">
{: .alignCenter}</p><p><a href=https://www.javatpoint.com/working-of-hashmap-in-java>사진 출처</a></p><p>먼저, bucket 이라는 <strong>Array</strong>가 있고,<br>그 Array 내부에는 <strong>Node로 구성된 &ldquo;LinkedList&rdquo;</strong> 가 존재한다.</p><p>즉, 이렇게 생긴 것을 <strong>&ldquo;Hash table&rdquo;</strong> 이라고 하고, Hash table을 통해 Key-Value를 관리하게 된다.<br><em>기수정렬(Radix Sort) 할 때의 모습을 상상해보면 된다.</em></p><h1 id=3-hashmap의-동작-이론편>3. HashMap의 동작 (이론편)<a hidden class=anchor aria-hidden=true href=#3-hashmap의-동작-이론편>#</a></h1><p>: 대충 어떻게 생겨 먹었는지는 알겠으니, 어떻게 동작하는지에 대해서 한번 간략하게 익혀보자.</p><p>데이터를 집어 넣는 과정을 이해하면, 꺼내는 것을 이해하는 것은 당연하게 여겨진다.<br>HashMap에 put() 함수를 사용해서, 데이터를 넣고자 하면, 다음과 같은 과정이 일어난다.</p><ol><li>Key로 들어온 Object를 Hash화를 한다</li><li>Hash화한 값을 <strong>&ldquo;배열의 인덱스&rdquo;</strong> 로 지정한다.</li><li>해당 배열에 값이 존재하지 않으면, 그 위치에 Node라는 클래스로 Key-Value Object를 저장한다.</li><li>해당 배열에 값이 존재하면, 그 <strong>다음</strong> 위치에 새로운 Node를 연결하고 Key-Value Object를 저장한다.(즉, LinkedList로 관리한다.)</li><li>List가 너무 길게 이어진다면, Tree로 변환한다.</li><li>Hash충돌(Collision)이 너무 많이 발생한다면, Bucket. 즉 배열의 크기를 늘린다.</li></ol><p>이해력이 좋은 사람이라면, 여기까지만 봐도 아하 할 수 있다.<br>나같은 멍청이는 뭔소리야? 싶어서 결국 코드를 뜯어보고야 만다.</p><h1 id=4-hashmap의-동작-코드편>4. HashMap의 동작 (코드편)<a hidden class=anchor aria-hidden=true href=#4-hashmap의-동작-코드편>#</a></h1><p>: HashMap 에 데이터를 넣고자 하는, put() 함수로 이동해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>K key<span style=color:#f92672>,</span> V value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> putVal<span style=color:#f92672>(</span>hash<span style=color:#f92672>(</span>key<span style=color:#f92672>),</span> key<span style=color:#f92672>,</span> value<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>보는 바와 같이,</p><ol><li>hash()라는 함수를 실행한 key</li><li>원래 key</li><li>value</li><li>뭔지 모를 false</li><li>뭔지 모를 true</li></ol><p>가 있다.</p><p>hash() 함수로 슬쩍 발 하나 담궈보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hash</span><span style=color:#f92672>(</span>Object key<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> h<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>key <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>?</span> 0 <span style=color:#f92672>:</span> <span style=color:#f92672>(</span>h <span style=color:#f92672>=</span> key<span style=color:#f92672>.</span><span style=color:#a6e22e>hashCode</span><span style=color:#f92672>())</span> <span style=color:#f92672>^</span> <span style=color:#f92672>(</span>h <span style=color:#f92672>&gt;&gt;&gt;</span> 16<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>key가 null이라면 0을,
null이 아니라면 <strong>key의 hashCode() 라는 함수를 실행한 값</strong>과,
<strong>key의 Hash코드를 unsigned로 쉬프트 연산한 값</strong>을 <strong>XOR 연산</strong>한 것을 확인할 수 있다.</p><p>이렇게 하면 어떤 값이 나온다는 것을 예측할 수 있다.<br>이번 포스팅에서의 목적은 Hash가 어떻게 구현되는지가 아니므로,<br>뭐 대충 어떤 숫자가 나왔다고 이해하고 넘어가자.</p><p>다시 돌아와서, 이제 putVal() 이라는 곳으로 구경 가보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>putVal</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> hash<span style=color:#f92672>,</span> K key<span style=color:#f92672>,</span> V value<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> onlyIfAbsent<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>boolean</span> evict<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;[]</span> tab<span style=color:#f92672>;</span> Node<span style=color:#f92672>&lt;</span>K<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> p<span style=color:#f92672>;</span> <span style=color:#66d9ef>int</span> n<span style=color:#f92672>,</span> i<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>tab <span style=color:#f92672>=</span> table<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>=</span> tab<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>tab <span style=color:#f92672>=</span> resize<span style=color:#f92672>()).</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>p <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;</span> hash<span style=color:#f92672>])</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> newNode<span style=color:#f92672>(</span>hash<span style=color:#f92672>,</span> key<span style=color:#f92672>,</span> value<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> e<span style=color:#f92672>;</span> K k<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p<span style=color:#f92672>.</span><span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>((</span>k <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>key</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>k<span style=color:#f92672>))))</span>
</span></span><span style=display:flex><span>            e <span style=color:#f92672>=</span> p<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p <span style=color:#66d9ef>instanceof</span> TreeNode<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            e <span style=color:#f92672>=</span> <span style=color:#f92672>((</span>TreeNode<span style=color:#f92672>&lt;</span>K<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;)</span>p<span style=color:#f92672>).</span><span style=color:#a6e22e>putTreeVal</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> tab<span style=color:#f92672>,</span> hash<span style=color:#f92672>,</span> key<span style=color:#f92672>,</span> value<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> binCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> <span style=color:#f92672>;</span> <span style=color:#f92672>++</span>binCount<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>e <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode<span style=color:#f92672>(</span>hash<span style=color:#f92672>,</span> key<span style=color:#f92672>,</span> value<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>binCount <span style=color:#f92672>&gt;=</span> TREEIFY_THRESHOLD <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#75715e>// -1 for 1st
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        treeifyBin<span style=color:#f92672>(</span>tab<span style=color:#f92672>,</span> hash<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e<span style=color:#f92672>.</span><span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>((</span>k <span style=color:#f92672>=</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>key</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>k<span style=color:#f92672>))))</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                p <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// existing mapping for key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            V oldValue <span style=color:#f92672>=</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>value</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>onlyIfAbsent <span style=color:#f92672>||</span> oldValue <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            afterNodeAccess<span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> oldValue<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>++</span>modCount<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(++</span>size <span style=color:#f92672>&gt;</span> threshold<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        resize<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    afterNodeInsertion<span style=color:#f92672>(</span>evict<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>꽤 길다. 그리고 복잡하다. 코드를 머릿속으로 Deserialize 하는데 좀 시간이 걸렸다.<br>Section을 조금 나눠서 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>tab <span style=color:#f92672>=</span> table<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>=</span> tab<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>tab <span style=color:#f92672>=</span> resize<span style=color:#f92672>()).</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span>    
</span></span></code></pre></div><p>첫 if문에서 table, 즉 Hash테이블이 null 인지를 물어본다.
즉, <strong>&ldquo;데이터를 처음 넣는거냐?&rdquo;</strong> 라고 물어보는 것이다.<br>참이라면, resize() 함수를 실행하고, 그 결과를 tab에, 그리고 그 길이를 n에 넣는다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>p <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;</span> hash<span style=color:#f92672>])</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> newNode<span style=color:#f92672>(</span>hash<span style=color:#f92672>,</span> key<span style=color:#f92672>,</span> value<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>다음으로, table의 ((n-1) & hash) 위치.
즉 배열의 특정 index에 위치한 값이 null 이라면,<br>다시 말해, 자리가 비어있다면,<br>해당 위치에는 새로운 Node를 만들어서 집어넣는다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> e<span style=color:#f92672>;</span> K k<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p<span style=color:#f92672>.</span><span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>((</span>k <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>key</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>k<span style=color:#f92672>))))</span>
</span></span><span style=display:flex><span>        e <span style=color:#f92672>=</span> p<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>아니라면, 즉 해당 위치에 무언가가(Node) 이미 존재한다면, else문으로 진입하게 된다.</p><p>그 이후 등장하는 첫번째 if문은 &ldquo;hash만 같은게 아니라, key 자체도 같은거야?&rsquo; 라고 물어본다.<br>맞다면, 해당 key를 교체하게 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p <span style=color:#66d9ef>instanceof</span> TreeNode<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    e <span style=color:#f92672>=</span> <span style=color:#f92672>((</span>TreeNode<span style=color:#f92672>&lt;</span>K<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;)</span>p<span style=color:#f92672>).</span><span style=color:#a6e22e>putTreeVal</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> tab<span style=color:#f92672>,</span> hash<span style=color:#f92672>,</span> key<span style=color:#f92672>,</span> value<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>그게 아니라면, 우선 해당 LinkedList가 Tree인지를 물어본다.<br>Tree라면, Tree에 맞게 값을 추가한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> binCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> <span style=color:#f92672>;</span> <span style=color:#f92672>++</span>binCount<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>e <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            p<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode<span style=color:#f92672>(</span>hash<span style=color:#f92672>,</span> key<span style=color:#f92672>,</span> value<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>binCount <span style=color:#f92672>&gt;=</span> TREEIFY_THRESHOLD <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#75715e>// -1 for 1st
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                treeifyBin<span style=color:#f92672>(</span>tab<span style=color:#f92672>,</span> hash<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e<span style=color:#f92672>.</span><span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>((</span>k <span style=color:#f92672>=</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>key</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>k<span style=color:#f92672>))))</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>트리가 아니라면, LinkedList란 뜻이다. 그렇다면 해당 LinkedList를 돌면서,<br>&ldquo;Key까지 같으면, replace&rdquo; 해주고, 처음 들어오는 놈이라면, 맨 끝에 이어붙이게 된다.</p><p>그 과정속에서, bin. 즉 LinkedList의 길이가 너무 길다면, 이를 Tree로 바꿔준다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// existing mapping for key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    V oldValue <span style=color:#f92672>=</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>value</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>onlyIfAbsent <span style=color:#f92672>||</span> oldValue <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        e<span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    afterNodeAccess<span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> oldValue<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>여기서 e는 우리가 새로이 추가하고자 하는 Node를 가리킨다.<br>else문으로 분기한 이후, 우리가 지금까지 한 것은, Node를 추가할 위치를 찾는 것이었다.<br>이제 값을 넣어야 한다. 해당 코드가 Key 안에 Value를 넣는것이다.</p><p>onltIfAbsent는 &ldquo;키가 이미 있으면, 안넣겠다"를 의미한다.
즉, 우리는 false를 넣어줬고, ! 가 붙었으므로 true이므로, 참이 되니 값을 교체할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>++</span>modCount<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(++</span>size <span style=color:#f92672>&gt;</span> threshold<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    resize<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>afterNodeInsertion<span style=color:#f92672>(</span>evict<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>마지막으로, 수정된 횟수를 ++시키고,<br>HashTable의 길이 또한 ++ 시킨 뒤, 일정 수준을 넘어서면 resize() 하게 된다.</p><p>afterNodeAccess와 afterNodeInsertion은 LinkedHashMap에서 Override 되는 내용이므로 Pass한다.</p><p>resize() 코드 또한 꽤 복잡하므로, 주석만 따왔다. 여기서는 다음과 같이 설명한다.</p><blockquote><p>Initializes or doubles table size. If null, allocates in
accord with initial capacity target held in field threshold.
Otherwise, because we are using power-of-two expansion, the
elements from each bin must either stay at same index, or move
with a power of two offset in the new table.</p></blockquote><p>즉, bucket을 초기화 하던지, 충돌이 너무 많이 일어나면 두배로 늘리겠다는 얘기다.</p><p>이렇게 흐름을 읽고 나면, 왜 HashMap이 O(1)에 가까운 접근속도를 보이는지 알 수 있다.</p><p>기본적으로, 데이터의 구조가 배열이므로 O(1)의 접근속도를 가지고, &ldquo;해쉬"라는 것은 결국 일정 길이의 숫자를 return 하므로,<br>&ldquo;해쉬값을 통해 index 접근"을 진행하면, 어떤 Object 이던 O(1)으로 접근할 수 있다.</p><p>그런데, 충돌이 아예 안일어난다면 좋겠지만, 이를 위해 배열의 길이를 너무 길게 만들면 공간의 낭비고,
그렇다고 적게 만들자니, 충돌이 일어날 때 문제가 생긴다. 따라서 충돌이 일어나면 LinkedList로 연결지어준다.</p><p>이 LinkedList는 특정 길이를 넘어서면 Tree 형태를 갖게 되고,<br>또한 충돌 자체도 많이 일어나면 배열을 늘리므로,<br>이 LinkedList 혹은 Tree는 제한된 크기를 갖게 된다.</p><h1 id=5-마치며>5. 마치며<a hidden class=anchor aria-hidden=true href=#5-마치며>#</a></h1><p>: 기존에 가졌던 궁금증이 모두 해소되었다.<br>Hash를 왜 사용했는지, 그리고 왜 시간복잡도가 이렇게 빠른 것인지 알 수 있었다.<br>그런데, 또 한가지 궁금증이 발생한다.<br>Python은 3.7 이후 Dictionary는 Ordered, 즉 순서를 갖는 Dictionary를 Default로 사용한다고 한다.</p><p>얘는 또 어떻게 구현되었을지에 대해 알아보고 싶지만, 일단 여기에서 멈추자.</p><p><strong>Reference</strong></p><ul><li><a href=https://d2.naver.com/helloworld/831311>Java HashMap은 어떻게 동작하는가?</a></li><li><a href="https://www.youtube.com/watch?v=S7vni1hdsZE&t=297s&ab_channel=%ED%8F%AC%ED%94%84TV">Hash Table은 프로그래머의 기본기</a></li><li><a href=https://backdoosaan.tistory.com/13>Java HashMap동작 원리</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/tech/jsp/2020-09-11-jsp_project_with_intellij/><span class=title>« Prev Page</span><br><span># 0. JSP 학습기록 - Intellij JSP 프로젝트 생성</span></a>
<a class=next href=https://cjlee38.github.io/post/algorithm/data_structure/2020-09-10-what_is_linked_list/><span class=title>Next Page »</span><br><span># 마음으로 이해하는 자료구조 : LinkedList ( feat. C )</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) HashMap 으로의 여행 on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%28Java%29%20HashMap%20%ec%9c%bc%eb%a1%9c%ec%9d%98%20%ec%97%ac%ed%96%89&url=https%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2020-09-10-journey_to_java_hashmap%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) HashMap 으로의 여행 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2020-09-10-journey_to_java_hashmap%2f&title=%23%20%28Java%29%20HashMap%20%ec%9c%bc%eb%a1%9c%ec%9d%98%20%ec%97%ac%ed%96%89&summary=%23%20%28Java%29%20HashMap%20%ec%9c%bc%eb%a1%9c%ec%9d%98%20%ec%97%ac%ed%96%89&source=https%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2020-09-10-journey_to_java_hashmap%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) HashMap 으로의 여행 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2020-09-10-journey_to_java_hashmap%2f&title=%23%20%28Java%29%20HashMap%20%ec%9c%bc%eb%a1%9c%ec%9d%98%20%ec%97%ac%ed%96%89"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) HashMap 으로의 여행 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2020-09-10-journey_to_java_hashmap%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) HashMap 으로의 여행 on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%28Java%29%20HashMap%20%ec%9c%bc%eb%a1%9c%ec%9d%98%20%ec%97%ac%ed%96%89%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2020-09-10-journey_to_java_hashmap%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) HashMap 으로의 여행 on telegram" href="https://telegram.me/share/url?text=%23%20%28Java%29%20HashMap%20%ec%9c%bc%eb%a1%9c%ec%9d%98%20%ec%97%ac%ed%96%89&url=https%3a%2f%2fcjlee38.github.io%2fpost%2flanguage%2fjava%2f2020-09-10-journey_to_java_hashmap%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>