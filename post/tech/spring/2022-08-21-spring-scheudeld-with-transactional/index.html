<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 스프링 @Scheduled 와 @Transactional에 얽힌 이야기 | cjlee38</title><meta name=keywords content="spring,transctional,scheduled"><meta name=description content="0. 서론 팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.
코드는 대략 다음과 같이 구성되어 있었습니다.
@Service @Transactional public class PollService {  	@Scheduled(cron = &#34;0 0/1 * * * ?&#34;) 	void notifyClosedByScheduled() { 	List<Poll> pollsToBeClosed = pollRepository.findAllToBeClosed(LocalDateTime.now()); 	for (Poll poll : pollsToBeClosed) { 	poll."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/tech/spring/2022-08-21-spring-scheudeld-with-transactional/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK",{anonymize_ip:!1})}</script><meta property="og:title" content="# 스프링 @Scheduled 와 @Transactional에 얽힌 이야기"><meta property="og:description" content="0. 서론 팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.
코드는 대략 다음과 같이 구성되어 있었습니다.
@Service @Transactional public class PollService {  	@Scheduled(cron = &#34;0 0/1 * * * ?&#34;) 	void notifyClosedByScheduled() { 	List<Poll> pollsToBeClosed = pollRepository.findAllToBeClosed(LocalDateTime.now()); 	for (Poll poll : pollsToBeClosed) { 	poll."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/tech/spring/2022-08-21-spring-scheudeld-with-transactional/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-08-21T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-21T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 스프링 @Scheduled 와 @Transactional에 얽힌 이야기"><meta name=twitter:description content="0. 서론 팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.
코드는 대략 다음과 같이 구성되어 있었습니다.
@Service @Transactional public class PollService {  	@Scheduled(cron = &#34;0 0/1 * * * ?&#34;) 	void notifyClosedByScheduled() { 	List<Poll> pollsToBeClosed = pollRepository.findAllToBeClosed(LocalDateTime.now()); 	for (Poll poll : pollsToBeClosed) { 	poll."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 스프링 @Scheduled 와 @Transactional에 얽힌 이야기","item":"https://cjlee38.github.io/post/tech/spring/2022-08-21-spring-scheudeld-with-transactional/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 스프링 @Scheduled 와 @Transactional에 얽힌 이야기","name":"# 스프링 @Scheduled 와 @Transactional에 얽힌 이야기","description":"0. 서론 팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.\n코드는 대략 다음과 같이 구성되어 있었습니다.\n@Service @Transactional public class PollService {  \t@Scheduled(cron = \u0026#34;0 0/1 * * * ?\u0026#34;) \tvoid notifyClosedByScheduled() { \tList\u0026lt;Poll\u0026gt; pollsToBeClosed = pollRepository.findAllToBeClosed(LocalDateTime.now()); \tfor (Poll poll : pollsToBeClosed) { \tpoll.","keywords":["spring","transctional","scheduled"],"articleBody":"0. 서론 팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.\n코드는 대략 다음과 같이 구성되어 있었습니다.\n@Service @Transactional public class PollService {  \t@Scheduled(cron = \"0 0/1 * * * ?\") \tvoid notifyClosedByScheduled() { \tListPoll pollsToBeClosed = pollRepository.findAllToBeClosed(LocalDateTime.now()); \tfor (Poll poll : pollsToBeClosed) { \tpoll.close(poll.getHost()); \tnotificationService.notifyMenuStatus( \tpoll.getTeam(), MessageFormatter.formatClosed(FormattableData.from(poll)) \t); \t} \t} } 대략 위와 같이 서비스가 구성되어 있었고, poll entity 내부에서는 member(host) 객체를 lazy loading 하고 있는 상황이었습니다. 이번 포스팅에서는 위와 같은 상황에서 겪었던 Transactional이 동작하지 않는 문제와, 이를 해결하면서 알게된 (기초적인) 사실들을 이야기해보고자 합니다.\n1. 발단  could not initialize proxy - no session\n 가장 첫 번째로 당면한 문제는 프록시 초기화 문제였습니다. 위와 같은 상황에서, poll 객체의 상태를 close하기 위해서 주어진 member가 host인지 확인합니다. host를 직접 꺼내다 다시 넣어주었으니, 로직상 문제는 없었죠. 하지만 같은 객체인지 비교하기 위해 equals 메소드가 호출되는 순간, 위와 같은 문제가 발생했습니다.\n가장 첫 번째로 의심한 부분은 Transaction 여부였습니다. JPA의 객체는 기본적으로 Transaction 하위에 있는 영속성 컨텍스트 내부에서 활동하고, 영속성 컨텍스트가 끊어지면, 즉 Transaction이 끊어지면 위와 같은 문제가 발생하기 때문입니다.\n테스트 코드에서는 잘 동작하던 코드였기에, 어느 부분이 문제인지 확인이 되지 않았습니다. 따라서 application.yml 에 다음과 같은 설정을 추가하고 스케줄링 동작시 로그를 확인해보았습니다.\nlogging:  level:  org:  springframework:  transaction.interceptor: TRACE 위 설정은 트랜잭션이 언제 동작하는지 확인할 수 있는 설정입니다.(참고)\n[2022-08-22 21:50:19:3733][scheduled-task-pool-1] TRACE o.s.t.i.TransactionInterceptor - No need to create transaction for [org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAllToBeClosed]: This method is not transactional. Hibernate: {쿼리문} 제가 class level에 분명히 @Transactional 어노테이션을 붙였음에도 불구하고, 메소드를 호출할 때에는 Transaction 을 생성하는 로그가 찍히지 않았습니다. 대신, 위와 같이 조회 쿼리일때에는 “트랜잭션이 필요없다” 라는 로그만 뱉어주고 있었죠. 게다가 더욱 아이러니한 점은, save 메소드를 호출할 때에는 트랜잭션을 잠깐 얻고, 쿼리를 날린 후 곧바로 종료시켜버리고 있었습니다.\n2. 의문 하나. 문제를 해결하기에 앞서, 가장 먼저 의문이 들었던 부분은 ?왜 save를 할 때는 transaction이 동작하고, findAllTobeClosed 와 같은 조회 쿼리는 동작하지 않았을까?\" 였습니다.\n그 원인은, JPA가 조회하는 로직일때는 transaction이 필요하지 않기 때문입니다. 다음은 한 스택오버플로우 글에서 인용한 JTA spec의 일부입니다.\n The persist, merge, remove, and refresh methods must be invoked within a transaction context when an entity manager with a transaction-scoped persistence context is used. If there is no transaction context, the javax.persistence.TransactionRequiredException is thrown.\n  The find method (provided it is invoked without a lock or invoked with LockModeType.NONE) and the getReference method are not required to be invoked within a transaction context. If an entity manager with transaction-scoped persistence context is in use, the resulting entities will be detached; if an entity manager with an extended persistence context is used, they will be managed. See section 3.3 for entity manager use outside a transaction.\n 즉, 조회로직은 transaction context 내에서 일어날 필요가 없다는 뜻입니다. 그렇다면 save는 어떨까요? 이는 SimpleJpaRepository를 살펴보면 알 수 있습니다.\nSimpleJpaRepository는 Repository 인터페이스의 최상위 구현체이자, CrudRepository의 default 구현체입니다. 우리가 Repository 혹은 JpaRepository를 상속한 인터페이스를 만들면, JpaRepositoryFactoryBean가 SimpleJpaRepository 를 상속하여 만든 프록시 객체로 우리가 만든 인터페이스의 구현체를 생성합니다.\n그리고 이 SimpleJpaRepository 에는 save 메소드가 기본으로 구현되어있으며, 여기에는 @Transactional 어노테이션이 붙어있습니다.\n3. 의문 둘. 두 번째로 들었던 의문은 “왜 service method 레벨에서 transaction이 걸리지 않았을까 ?” 입니다. 처음에 구글링을 통해 얻었던 정보는 “스케줄러와 서비스를 분리해라” 였습니다. 말인즉슨, @Scheduled 가 먼저 처리되고 나서 @Transactional 이 처리되기 때문에, 등록된 @Scheduled 는 @Transactional 과 상관이 없다는 것입니다.\n또 다른 정보로는, PlatformTransactionManager 의 default 구현체가 DataSourceTransactionManager 인 경우, JPA 스펙 구현체인 Hibernate의 AbstractTransactionImpl 안에 있는 begin 메소드를 호출하지 않는다는 것이고, 따라서 커스텀하게 TransactionManager를 설정해주어야 한다는 정보였습니다.\n하지만 결론부터 말씀드리자면 제 경우에는 둘 다 해당하지 않았습니다. @Scheduled 와 @Transactional 어노테이션이 처리되는 순서에 대해서 살펴보았을 때에도 문제가 없었고, 제가 사용하고 있던 트랜잭션 매니저는 JpaTransactionManager 였습니다.\n 제가 현재 사용하고 있는 스프링부트 버전은 2.6.6 이고, hibernate 버전은 5.6.7 입니다.\n 눈치채셨을지도 모르겠지만 해결법은 의외로 기초적이고 간단한 내용이었는데, 바로 서비스 메소드의 접근제어자를 public으로 선언하는 것이었습니다. 외부 패키지(e.g. controller) 에서 사용할 수 없도록 접근제어자를 package-private으로 두었는데, 이것이 화근이었습니다.\n이는 공식문서에서도 잘 나와있는 내용이었습니다.\n When you use transactional proxies with Spring’s standard configuration, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private, or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings.\n 그렇다면 또 다시 드는 의문은 왜 꼭 “public이어야 하는가?” 입니다. 이 또한 Spring Core 공식문서 중 AOP 내용을 뒤져보면 간략하게나마 알 수 있습니다.\n Due to the proxy-based nature of Spring’s AOP framework, calls within the target object are, by definition, not intercepted. For JDK proxies, only public interface method calls on the proxy can be intercepted. With CGLIB, public and protected method calls on the proxy are intercepted (and even package-visible methods, if necessary). However, common interactions through proxies should always be designed through public signatures.\n 즉, JDK 프록시는 public 메소드만 intercept 할 수 있고, CGLIB은 package-private 까지 가져올수 있지만, 일반적으로 public 시그니쳐를 통해 동작하도록 되어있다는 내용입니다.\n참고로, 이와 같은 사실을 통해, 다음과 같은 설정으로 @Transactional이 protected나 package-private 에서도 동작하게 만들 수는 있습니다. 자세한 내용은 이곳을 참고하세요\n/** * Register a custom AnnotationTransactionAttributeSource with the * publicMethodsOnly flag set to false to enable support for * protected and package-private @Transactional methods in * class-based proxies. * * @see ProxyTransactionManagementConfiguration#transactionAttributeSource() */ // @EnableTransactionManagement 이 등록되어 있어야 합니다. @Bean TransactionAttributeSource transactionAttributeSource() {  return new AnnotationTransactionAttributeSource(false); } 4. 부록. 스케줄링이 어떻게 동작하는지 한번 코드로 살펴보았습니다.\n스프링에는 의존관계를 주입하며 bean을 생성하는 AutowireCapableBeanFactory가 있습니다. 아래 위 코드는 해당 인터페이스의 추상 클래스인 AbstractAutowireCapableBeanFactory 중 일부입니다 (line 450)\n위 코드에서 알 수 있다시피, bean을 등록하고 난 뒤, post-processor에 의해 후처리 작업을 진행합니다. 후처리 작업은 post-processor에 의해 처리된 결과가 null이 아니라면 계속해서 바꿔치기를 진행합니다.\n여기서 getBeanPostProcessor()를 확인해보면, 15개의 post-processor가 등록되어있는 것을 확인할 수 있습니다. 이 중, 5번째에 해당하는 AnnotationAwareAspectJAutoProxyCreator 가 @Transactional 어노테이션을 처리하는 녀석입니다. 그리고, 14번째에 있는 ScheduledAnnotationBeanPostProcessor 가 바로 @Scheduled 어노테이션을 처리하는 녀석이구요.\n그리고 Transactional을 위해 AnnotationAwareAspectJAutoProxyCreator 에 의해, 처리 되기 전(result)에는 일반 객체였지만, 처리된 녀석(current)이 프록시 객체임을 확인할 수 있습니다.\n그렇다면 스케줄링은 어떻게 등록되고, 실행될까요 ? ScheduledAnnotationBeanPostProcessor 로 이동해보겠습니다.\n앞서 보았던 postProcessAfterInitialization() 메소드 내부를 살펴보면,\n아래와 같이 @Scheduled 어노테이션이 붙어있는 메소드들에 대해서, processScheduled() 메소드 를 호출하고 있음을 확인할 수 있습니다. 해당 메소드로 다시 넘어가보겠습니다.\n위 코드는 fixedDelay, cron 등 @Scheduled 어노테이션에 달았던 여러 설정값을 처리하고, 이를 task로 만드는 작업을 진행합니다. (코드가 너무 길어, cron 부분만 떼왔습니다.) 그리고 나서, registrar 에 CronTask를 등록합니다.\n당장은 빨간 박스로 친 부분만 실행된다는 점에 유의해서 살펴보시면 됩니다. 새로 등록된 Task이므로, CronTask 리스트에 등록하면서, 동시에 unresolvedTask에 등록합니다.\n여기까지 진행한 다음, 빈 초기화가 모두 끝난 이후를 확인해보겠습니다. 애플리케이션이 실행되고나면, SimpleApplicationEventMultiCaster 의 multicast 를 호출해 ApplicationListener 에게 invoke 할 것을 명령합니다.\n이 Listener 중 하나가 방금 보았던 ScheduledAnnotationBeanPostProcessor 입니다. 그리고 invoke()는 onApplicationEvent()를, onApplicationEvent()는 finishRegistration()을 순차적으로 호출합니다. 이 때, 우리가 등록한 SchedulingConfigurer Configuration이 있다면 이를 등록합니다.\n즉, 위의 List configures 에 아래 코드와 같이 우리가 정의한 configuration이 들어갑니다.\n그리고 finishRegistration()은 최종적으로 this.registrar.afterPropertiesSet(); 을, 그리고 이는 registrar 내부의 scheduleTasks()를 호출합니다.\n그러면 앞서 익숙한 메소드명이 보입니다. 바로 scheduleCronTask() 입니다.\ntaskScheduler가 null이 아니기때문에(앞서 커스텀 정의한 configuration에서 ThreadPoolTaskScheduler을 넣어줬으니까요.), future에 ScheduledFuture 를 넣어줍니다.\n넣어준 ScheduledFuture 의 구현체는 ReschedulingRunnable로, 자기 자신이 실행해야할 시각을 설정합니다. 그리고 java에 의해 설정된 시각에 동작합니다.\n자, 이제 마무리입니다. java에 의해 run 메소드가 호출되면, 해야 할 일을 수행하고, triggerContext에 의해 다음 실행 시각을 다시 계산한뒤 schedule 을 다시 호출합니다.\n5. 마무리. 사실 처음 작성했던 코드가 의도한대로 동작하지 않았던 문제의 해결방법은 그리 어렵지 않았습니다. 단순히 public 접근제어자를 붙이기만 해주면 되니까요. 하지만 그 이면에서 왜 이런 문제가 발생했는지, @Scheduled가 어떻게 동작하는지 등의 궁금증을 해결할 수 있는 계기가 되었습니다.\n트러블슈팅과 관련해서 레퍼런스도 많이 발견하지 못했는데, 혹여라도 난항을 겪는 분들께 도움이 되었길 바라겠습니다. 감사합니다.\n","wordCount":"1217","inLanguage":"en","datePublished":"2022-08-21T00:00:00Z","dateModified":"2022-08-21T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/tech/spring/2022-08-21-spring-scheudeld-with-transactional/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 스프링 @Scheduled 와 @Transactional에 얽힌 이야기</h1><div class=post-meta><span title="2022-08-21 00:00:00 +0000 UTC">August 21, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Tech/Spring/2022-08-21-spring-scheudeld-with-transactional.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%ec%84%9c%eb%a1%a0 aria-label="0. 서론">0. 서론</a></li><li><a href=#1-%eb%b0%9c%eb%8b%a8 aria-label="1. 발단">1. 발단</a></li><li><a href=#2-%ec%9d%98%eb%ac%b8-%ed%95%98%eb%82%98 aria-label="2. 의문 하나.">2. 의문 하나.</a></li><li><a href=#3-%ec%9d%98%eb%ac%b8-%eb%91%98 aria-label="3. 의문 둘.">3. 의문 둘.</a></li><li><a href=#4-%eb%b6%80%eb%a1%9d aria-label="4. 부록.">4. 부록.</a></li><li><a href=#5-%eb%a7%88%eb%ac%b4%eb%a6%ac aria-label="5. 마무리.">5. 마무리.</a></li></ul></div></details></div><div class=post-content><h1 id=0-서론>0. 서론<a hidden class=anchor aria-hidden=true href=#0-서론>#</a></h1><p>팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.</p><p>코드는 대략 다음과 같이 구성되어 있었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PollService</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Scheduled</span><span style=color:#f92672>(</span>cron <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0 0/1 * * * ?&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notifyClosedByScheduled</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>		List<span style=color:#f92672>&lt;</span>Poll<span style=color:#f92672>&gt;</span> pollsToBeClosed <span style=color:#f92672>=</span> pollRepository<span style=color:#f92672>.</span><span style=color:#a6e22e>findAllToBeClosed</span><span style=color:#f92672>(</span>LocalDateTime<span style=color:#f92672>.</span><span style=color:#a6e22e>now</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Poll poll <span style=color:#f92672>:</span> pollsToBeClosed<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>			poll<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>poll<span style=color:#f92672>.</span><span style=color:#a6e22e>getHost</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>			notificationService<span style=color:#f92672>.</span><span style=color:#a6e22e>notifyMenuStatus</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>					poll<span style=color:#f92672>.</span><span style=color:#a6e22e>getTeam</span><span style=color:#f92672>(),</span> MessageFormatter<span style=color:#f92672>.</span><span style=color:#a6e22e>formatClosed</span><span style=color:#f92672>(</span>FormattableData<span style=color:#f92672>.</span><span style=color:#a6e22e>from</span><span style=color:#f92672>(</span>poll<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>대략 위와 같이 서비스가 구성되어 있었고, <code>poll</code> entity 내부에서는 <code>member(host)</code> 객체를 <code>lazy loading</code> 하고 있는 상황이었습니다. 이번 포스팅에서는 위와 같은 상황에서 겪었던 <code>Transactional</code>이 동작하지 않는 문제와, 이를 해결하면서 알게된 (기초적인) 사실들을 이야기해보고자 합니다.</p><h1 id=1-발단>1. 발단<a hidden class=anchor aria-hidden=true href=#1-발단>#</a></h1><blockquote><p>could not initialize proxy - no session</p></blockquote><p>가장 첫 번째로 당면한 문제는 프록시 초기화 문제였습니다. 위와 같은 상황에서, poll 객체의 상태를 close하기 위해서 주어진 member가 host인지 확인합니다. host를 직접 꺼내다 다시 넣어주었으니, 로직상 문제는 없었죠. 하지만 같은 객체인지 비교하기 위해 <code>equals</code> 메소드가 호출되는 순간, 위와 같은 문제가 발생했습니다.</p><p>가장 첫 번째로 의심한 부분은 <code>Transaction</code> 여부였습니다. JPA의 객체는 기본적으로 <code>Transaction</code> 하위에 있는 영속성 컨텍스트 내부에서 활동하고, 영속성 컨텍스트가 끊어지면, 즉 <code>Transaction</code>이 끊어지면 위와 같은 문제가 발생하기 때문입니다.</p><p>테스트 코드에서는 잘 동작하던 코드였기에, 어느 부분이 문제인지 확인이 되지 않았습니다. 따라서 <code>application.yml</code> 에 다음과 같은 설정을 추가하고 스케줄링 동작시 로그를 확인해보았습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>logging</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>level</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>org</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>springframework</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>transaction.interceptor</span>: <span style=color:#ae81ff>TRACE</span>
</span></span></code></pre></div><p>위 설정은 트랜잭션이 언제 동작하는지 확인할 수 있는 설정입니다.(<a href=https://www.baeldung.com/spring-transaction-active#using-spring-transaction-logging>참고</a>)</p><pre tabindex=0><code class=language-log data-lang=log>[2022-08-22 21:50:19:3733][scheduled-task-pool-1] TRACE o.s.t.i.TransactionInterceptor - No need to create transaction for [org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAllToBeClosed]: This method is not transactional.
Hibernate: 
    {쿼리문}
</code></pre><p>제가 class level에 분명히 <code>@Transactional</code> 어노테이션을 붙였음에도 불구하고, 메소드를 호출할 때에는 <code>Transaction</code> 을 생성하는 로그가 찍히지 않았습니다. 대신, 위와 같이 조회 쿼리일때에는 &ldquo;트랜잭션이 필요없다&rdquo; 라는 로그만 뱉어주고 있었죠. 게다가 더욱 아이러니한 점은, <code>save</code> 메소드를 호출할 때에는 트랜잭션을 잠깐 얻고, 쿼리를 날린 후 곧바로 종료시켜버리고 있었습니다.</p><h1 id=2-의문-하나>2. 의문 하나.<a hidden class=anchor aria-hidden=true href=#2-의문-하나>#</a></h1><p>문제를 해결하기에 앞서, 가장 먼저 의문이 들었던 부분은 ?왜 <code>save</code>를 할 때는 <code>transaction</code>이 동작하고, <code>findAllTobeClosed</code> 와 같은 조회 쿼리는 동작하지 않았을까?" 였습니다.</p><p>그 원인은, JPA가 조회하는 로직일때는 <code>transaction</code>이 필요하지 않기 때문입니다. 다음은 <a href=https://stackoverflow.com/questions/21672454/application-managed-jpa-when-is-transaction-needed>한 스택오버플로우 글</a>에서 인용한 JTA spec의 일부입니다.</p><blockquote><p>The persist, merge, remove, and refresh methods must be invoked within a transaction context when an entity manager with a transaction-scoped persistence context is used. If there is no transaction context, the javax.persistence.TransactionRequiredException is thrown.</p></blockquote><blockquote><p>The find method (provided it is invoked without a lock or invoked with LockModeType.NONE) and the getReference method are not required to be invoked within a transaction context. If an entity manager with transaction-scoped persistence context is in use, the resulting entities will be detached; if an entity manager with an extended persistence context is used, they will be managed. See section 3.3 for entity manager use outside a transaction.</p></blockquote><p>즉, 조회로직은 transaction context 내에서 일어날 필요가 없다는 뜻입니다. 그렇다면 <code>save</code>는 어떨까요? 이는 <code>SimpleJpaRepository</code>를 살펴보면 알 수 있습니다.</p><p>SimpleJpaRepository는 Repository 인터페이스의 최상위 구현체이자, CrudRepository의 default 구현체입니다. 우리가 Repository 혹은 JpaRepository를 상속한 인터페이스를 만들면, <code>JpaRepositoryFactoryBean</code>가 <code>SimpleJpaRepository</code> 를 상속하여 만든 프록시 객체로 우리가 만든 인터페이스의 구현체를 생성합니다.</p><p><img loading=lazy src=/assets/images/2022-08-24-13-20-01.png alt></p><p>그리고 이 <code>SimpleJpaRepository</code> 에는 <code>save</code> 메소드가 기본으로 구현되어있으며, 여기에는 <code>@Transactional</code> 어노테이션이 붙어있습니다.</p><p><img loading=lazy src=/assets/images/2022-08-24-13-40-57.png alt></p><h1 id=3-의문-둘>3. 의문 둘.<a hidden class=anchor aria-hidden=true href=#3-의문-둘>#</a></h1><p>두 번째로 들었던 의문은 &ldquo;왜 service method 레벨에서 transaction이 걸리지 않았을까 ?&rdquo; 입니다. 처음에 구글링을 통해 얻었던 정보는 &ldquo;스케줄러와 서비스를 분리해라&rdquo; 였습니다. 말인즉슨, <code>@Scheduled</code> 가 먼저 처리되고 나서 <code>@Transactional</code> 이 처리되기 때문에, 등록된 <code>@Scheduled</code> 는 <code>@Transactional</code> 과 상관이 없다는 것입니다.</p><p>또 다른 정보로는, <code>PlatformTransactionManager</code> 의 default 구현체가 <code>DataSourceTransactionManager</code> 인 경우, JPA 스펙 구현체인 <code>Hibernate</code>의 <code>AbstractTransactionImpl</code> 안에 있는 <code>begin</code> 메소드를 호출하지 않는다는 것이고, 따라서 커스텀하게 TransactionManager를 설정해주어야 한다는 정보였습니다.</p><p>하지만 결론부터 말씀드리자면 제 경우에는 둘 다 해당하지 않았습니다. <code>@Scheduled</code> 와 <code>@Transactional</code> 어노테이션이 처리되는 순서에 대해서 살펴보았을 때에도 문제가 없었고, 제가 사용하고 있던 트랜잭션 매니저는 <code>JpaTransactionManager</code> 였습니다.</p><blockquote><p>제가 현재 사용하고 있는 스프링부트 버전은 2.6.6 이고, hibernate 버전은 5.6.7 입니다.</p></blockquote><p>눈치채셨을지도 모르겠지만 해결법은 의외로 기초적이고 간단한 내용이었는데, 바로 <strong>서비스 메소드의 접근제어자를 public으로 선언하는 것</strong>이었습니다. 외부 패키지(e.g. controller) 에서 사용할 수 없도록 접근제어자를 package-private으로 두었는데, 이것이 화근이었습니다.</p><p>이는 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations-method-visibility>공식문서</a>에서도 잘 나와있는 내용이었습니다.</p><blockquote><p>When you use transactional proxies with Spring’s standard configuration, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private, or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings.</p></blockquote><p>그렇다면 또 다시 드는 의문은 왜 꼭 &ldquo;public이어야 하는가?&rdquo; 입니다. 이 또한 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators>Spring Core 공식문서 중 AOP</a> 내용을 뒤져보면 간략하게나마 알 수 있습니다.</p><blockquote><p>Due to the proxy-based nature of Spring’s AOP framework, calls within the target object are, by definition, not intercepted. For JDK proxies, only public interface method calls on the proxy can be intercepted. With CGLIB, public and protected method calls on the proxy are intercepted (and even package-visible methods, if necessary). However, common interactions through proxies should always be designed through public signatures.</p></blockquote><p>즉, JDK 프록시는 <code>public</code> 메소드만 intercept 할 수 있고, CGLIB은 <code>package-private</code> 까지 가져올수 있지만, 일반적으로 <code>public</code> 시그니쳐를 통해 동작하도록 되어있다는 내용입니다.</p><p>참고로, 이와 같은 사실을 통해, 다음과 같은 설정으로 <code>@Transactional</code>이 <code>protected</code>나 <code>package-private</code> 에서도 동작하게 만들 수는 있습니다. 자세한 내용은 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations-method-visibility>이곳</a>을 참고하세요</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Register a custom AnnotationTransactionAttributeSource with the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * publicMethodsOnly flag set to false to enable support for
</span></span></span><span style=display:flex><span><span style=color:#75715e> * protected and package-private @Transactional methods in
</span></span></span><span style=display:flex><span><span style=color:#75715e> * class-based proxies.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// @EnableTransactionManagement 이 등록되어 있어야 합니다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>TransactionAttributeSource <span style=color:#a6e22e>transactionAttributeSource</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AnnotationTransactionAttributeSource<span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h1 id=4-부록>4. 부록.<a hidden class=anchor aria-hidden=true href=#4-부록>#</a></h1><p>스케줄링이 어떻게 동작하는지 한번 코드로 살펴보았습니다.</p><p>스프링에는 의존관계를 주입하며 bean을 생성하는 <code>AutowireCapableBeanFactory</code>가 있습니다. 아래 위 코드는 해당 인터페이스의 추상 클래스인 <code>AbstractAutowireCapableBeanFactory</code> 중 일부입니다 (line 450)</p><p><img loading=lazy src=/assets/images/2022-08-22-23-26-19.png alt></p><p>위 코드에서 알 수 있다시피, bean을 등록하고 난 뒤, <code>post-processor</code>에 의해 후처리 작업을 진행합니다. 후처리 작업은 post-processor에 의해 처리된 결과가 <code>null</code>이 아니라면 계속해서 바꿔치기를 진행합니다.</p><p><img loading=lazy src=/assets/images/2022-08-22-23-32-30.png alt></p><p>여기서 <code>getBeanPostProcessor()</code>를 확인해보면, 15개의 <code>post-processor</code>가 등록되어있는 것을 확인할 수 있습니다. 이 중, 5번째에 해당하는 <code>AnnotationAwareAspectJAutoProxyCreator</code> 가 <code>@Transactional</code> 어노테이션을 처리하는 녀석입니다. 그리고, 14번째에 있는 <code>ScheduledAnnotationBeanPostProcessor</code> 가 바로 <code>@Scheduled</code> 어노테이션을 처리하는 녀석이구요.</p><p><img loading=lazy src=/assets/images/2022-08-22-23-37-13.png alt></p><p>그리고 Transactional을 위해 <code>AnnotationAwareAspectJAutoProxyCreator</code> 에 의해, 처리 되기 전(result)에는 일반 객체였지만, 처리된 녀석(current)이 프록시 객체임을 확인할 수 있습니다.</p><p>그렇다면 스케줄링은 어떻게 등록되고, 실행될까요 ?
<code>ScheduledAnnotationBeanPostProcessor</code> 로 이동해보겠습니다.</p><p>앞서 보았던 <code>postProcessAfterInitialization()</code> 메소드 내부를 살펴보면,</p><p><img loading=lazy src=/assets/images/2022-08-22-23-49-22.png alt></p><p>아래와 같이 <code>@Scheduled</code> 어노테이션이 붙어있는 메소드들에 대해서, <code>processScheduled()</code> 메소드 를 호출하고 있음을 확인할 수 있습니다. 해당 메소드로 다시 넘어가보겠습니다.</p><p><img loading=lazy src=/assets/images/2022-08-23-00-21-19.png alt></p><p>위 코드는 <code>fixedDelay</code>, <code>cron</code> 등 <code>@Scheduled</code> 어노테이션에 달았던 여러 설정값을 처리하고, 이를 task로 만드는 작업을 진행합니다. (코드가 너무 길어, <code>cron</code> 부분만 떼왔습니다.) 그리고 나서, <code>registrar</code> 에 <code>CronTask</code>를 등록합니다.</p><p><img loading=lazy src=/assets/images/2022-08-23-00-24-09.png alt></p><p>당장은 빨간 박스로 친 부분만 실행된다는 점에 유의해서 살펴보시면 됩니다. 새로 등록된 Task이므로, <code>CronTask</code> 리스트에 등록하면서, 동시에 <code>unresolvedTask</code>에 등록합니다.</p><p>여기까지 진행한 다음, 빈 초기화가 모두 끝난 이후를 확인해보겠습니다. 애플리케이션이 실행되고나면, <code>SimpleApplicationEventMultiCaster</code> 의 <code>multicast</code> 를 호출해 <code>ApplicationListener</code> 에게 <code>invoke</code> 할 것을 명령합니다.</p><p><img loading=lazy src=/assets/images/2022-08-23-00-13-43.png alt></p><p>이 <code>Listener</code> 중 하나가 방금 보았던 <code>ScheduledAnnotationBeanPostProcessor</code> 입니다. 그리고 <code>invoke()</code>는 <code>onApplicationEvent()</code>를, <code>onApplicationEvent()</code>는 <code>finishRegistration()</code>을 순차적으로 호출합니다. 이 때, 우리가 등록한 <code>SchedulingConfigurer</code> Configuration이 있다면 이를 등록합니다.</p><p><img loading=lazy src=/assets/images/2022-08-25-00-33-22.png alt></p><p>즉, 위의 <code>List&lt;SchedulingConfigurer> configures</code> 에 아래 코드와 같이 우리가 정의한 configuration이 들어갑니다.</p><p><img loading=lazy src=/assets/images/2022-08-25-00-44-35.png alt></p><p>그리고 <code>finishRegistration()</code>은 최종적으로 <code>this.registrar.afterPropertiesSet();</code> 을, 그리고 이는 <code>registrar</code> 내부의 <code>scheduleTasks()</code>를 호출합니다.</p><p><img loading=lazy src=/assets/images/2022-08-23-00-29-39.png alt></p><p>그러면 앞서 익숙한 메소드명이 보입니다. 바로 <code>scheduleCronTask()</code> 입니다.</p><p><img loading=lazy src=/assets/images/2022-08-23-00-31-08.png alt></p><p><code>taskScheduler</code>가 null이 아니기때문에(앞서 커스텀 정의한 configuration에서 <code>ThreadPoolTaskScheduler</code>을 넣어줬으니까요.), future에 <code>ScheduledFuture</code> 를 넣어줍니다.</p><p><img loading=lazy src=/assets/images/2022-08-25-01-01-21.png alt></p><p>넣어준 <code>ScheduledFuture</code> 의 구현체는 <code>ReschedulingRunnable</code>로, 자기 자신이 실행해야할 시각을 설정합니다. 그리고 java에 의해 설정된 시각에 동작합니다.</p><p><img loading=lazy src=/assets/images/2022-08-25-01-03-59.png alt></p><p>자, 이제 마무리입니다. java에 의해 <code>run</code> 메소드가 호출되면, 해야 할 일을 수행하고, triggerContext에 의해 다음 실행 시각을 다시 계산한뒤 <code>schedule</code> 을 다시 호출합니다.</p><p><img loading=lazy src=/assets/images/2022-08-25-01-01-21.png alt></p><h1 id=5-마무리>5. 마무리.<a hidden class=anchor aria-hidden=true href=#5-마무리>#</a></h1><p>사실 처음 작성했던 코드가 의도한대로 동작하지 않았던 문제의 해결방법은 그리 어렵지 않았습니다. 단순히 <code>public</code> 접근제어자를 붙이기만 해주면 되니까요. 하지만 그 이면에서 왜 이런 문제가 발생했는지, <code>@Scheduled</code>가 어떻게 동작하는지 등의 궁금증을 해결할 수 있는 계기가 되었습니다.</p><p>트러블슈팅과 관련해서 레퍼런스도 많이 발견하지 못했는데, 혹여라도 난항을 겪는 분들께 도움이 되었길 바라겠습니다. 감사합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/spring/>spring</a></li><li><a href=https://cjlee38.github.io/tags/transctional/>transctional</a></li><li><a href=https://cjlee38.github.io/tags/scheduled/>scheduled</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/tech/jpa/2022-09-25-query-enhancement/><span class=title>« Prev</span><br><span># 모락 쿼리 성능 개선기</span></a>
<a class=next href=https://cjlee38.github.io/post/tech/spring/2022-08-13-spring-environment-seperation/><span class=title>Next »</span><br><span># 스프링에서 환경을 분리하는 방법</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 스프링 @Scheduled 와 @Transactional에 얽힌 이야기 on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%ec%8a%a4%ed%94%84%eb%a7%81%20%40Scheduled%20%ec%99%80%20%40Transactional%ec%97%90%20%ec%96%bd%ed%9e%8c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2022-08-21-spring-scheudeld-with-transactional%2f&hashtags=spring%2ctransctional%2cscheduled"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 스프링 @Scheduled 와 @Transactional에 얽힌 이야기 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2022-08-21-spring-scheudeld-with-transactional%2f&title=%23%20%ec%8a%a4%ed%94%84%eb%a7%81%20%40Scheduled%20%ec%99%80%20%40Transactional%ec%97%90%20%ec%96%bd%ed%9e%8c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&summary=%23%20%ec%8a%a4%ed%94%84%eb%a7%81%20%40Scheduled%20%ec%99%80%20%40Transactional%ec%97%90%20%ec%96%bd%ed%9e%8c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&source=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2022-08-21-spring-scheudeld-with-transactional%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 스프링 @Scheduled 와 @Transactional에 얽힌 이야기 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2022-08-21-spring-scheudeld-with-transactional%2f&title=%23%20%ec%8a%a4%ed%94%84%eb%a7%81%20%40Scheduled%20%ec%99%80%20%40Transactional%ec%97%90%20%ec%96%bd%ed%9e%8c%20%ec%9d%b4%ec%95%bc%ea%b8%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 스프링 @Scheduled 와 @Transactional에 얽힌 이야기 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2022-08-21-spring-scheudeld-with-transactional%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 스프링 @Scheduled 와 @Transactional에 얽힌 이야기 on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%ec%8a%a4%ed%94%84%eb%a7%81%20%40Scheduled%20%ec%99%80%20%40Transactional%ec%97%90%20%ec%96%bd%ed%9e%8c%20%ec%9d%b4%ec%95%bc%ea%b8%b0%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2022-08-21-spring-scheudeld-with-transactional%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 스프링 @Scheduled 와 @Transactional에 얽힌 이야기 on telegram" href="https://telegram.me/share/url?text=%23%20%ec%8a%a4%ed%94%84%eb%a7%81%20%40Scheduled%20%ec%99%80%20%40Transactional%ec%97%90%20%ec%96%bd%ed%9e%8c%20%ec%9d%b4%ec%95%bc%ea%b8%b0&url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2022-08-21-spring-scheudeld-with-transactional%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>