<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># [Spring 학습 정리] Dependency Injection 의 필요성 | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. Dependency Injection 이란? : Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,
객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다. 이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.
이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.
자세한 내용은 이전의 포스팅 혹은 다른 참고자료를 이용해 공부하자.
          SRP Single Responsibility Principle 클래스는 하나의 책임만을 가져야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/post/tech/spring/2020-12-29-dependency_injection/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-174927148-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="# [Spring 학습 정리] Dependency Injection 의 필요성"><meta property="og:description" content="0. Dependency Injection 이란? : Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,
객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다. 이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.
이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.
자세한 내용은 이전의 포스팅 혹은 다른 참고자료를 이용해 공부하자.
          SRP Single Responsibility Principle 클래스는 하나의 책임만을 가져야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/post/tech/spring/2020-12-29-dependency_injection/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-12-29T09:58:00+00:00"><meta property="article:modified_time" content="2020-12-29T09:58:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# [Spring 학습 정리] Dependency Injection 의 필요성"><meta name=twitter:description content="0. Dependency Injection 이란? : Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,
객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다. 이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.
이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.
자세한 내용은 이전의 포스팅 혹은 다른 참고자료를 이용해 공부하자.
          SRP Single Responsibility Principle 클래스는 하나의 책임만을 가져야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# [Spring 학습 정리] Dependency Injection 의 필요성","item":"http://cjlee38.github.io/post/tech/spring/2020-12-29-dependency_injection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# [Spring 학습 정리] Dependency Injection 의 필요성","name":"# [Spring 학습 정리] Dependency Injection 의 필요성","description":"0. Dependency Injection 이란? : Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,\n객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다. 이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.\n이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.\n자세한 내용은 이전의 포스팅 혹은 다른 참고자료를 이용해 공부하자.\n          SRP Single Responsibility Principle 클래스는 하나의 책임만을 가져야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.","keywords":["null"],"articleBody":"0. Dependency Injection 이란? : Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,\n객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다. 이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.\n이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.\n자세한 내용은 이전의 포스팅 혹은 다른 참고자료를 이용해 공부하자.\n          SRP Single Responsibility Principle 클래스는 하나의 책임만을 가져야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.   LSP Liskov Substitution Principle 상위 클래스는 하위 클래스로 대체할 수 있어야 한다.   ISP Interface Segregation Principle 클라이언트별로 세분화된 인터페이스를 만들어라.   DIP Dependeny Inversion Principle 구체 클래스가 아닌 추상 클래스에 의존해라.     그런데 아직 공부가 부족해서 그런지, 의존성이 뭐냐? 라고 물어보면 한마디로 “이거다” 라고 짚어내기는 어려운 것 같다. 역시 예시를 보자.\nclass Computer {  private CableMouse mouse;   public Computer() {  this.mouse = new CableMouse();  }   public void moveMouse() {  mouse.move();  } } Computer 클래스에서 CableMouse 라는 객체를 가지고 있다. 뭐 컴퓨터가 마우스를 갖고 있는거야 당연해보이지만, 당연하지 않다. 왜일까? Computer 객체가 생성 될 때 반드시 CableMouse가 생기기 때문이다. 이게 정상적인 상황일까? 절대 그렇지 않다. 컴퓨터는, 조금 불편하겠지만 마우스가 없더라도 컴퓨터로서의 기능을 여전히 할 수 있기 때문이다.\n이를 코드 관점으로 바라보면, Computer 객체가 CableMouse에 의존하고 있다. 라고 표현한다. 혹은, Computer 와 CableMouse 사이엔 강한 결합이 존재한다고 말할 수 있다.\n1. Dependency Injection 이 필요한 이유? : 그렇다면 DI 를 이용해서, SOLID 원칙을 지킬 수 있다는 뜻일까? 대답은 그렇다. 이긴 한데, 어떻게 그게 가능한 것인지, 위 Computer 예시를 조금씩 수정해나가면서 알아가보자.\nExample.1 : 우선 위 예제를 그대로 갖고 오자. 그리고, CableMouse와 WirelessMouse 또한 만들어보자.\nclass Computer {  private CableMouse mouse;   public Computer() {  this.mouse = new CableMouse();  }   public void moveMouse() {  mouse.move();  } }  class CableMouse {  public void move() {  System.out.println(\"CableMouse moved\");  } }  class WirelessMouse {  public void move() {  System.out.println(\"WirelessMouse moved\");  } } 아까 위 예시에서 봤듯이, 현재 Computer 클래스는 CableMouse에 대한 의존성을 갖고 있다. 여기서, 컴퓨터가 사용하는 유선마우스를 무선마우스로 바꾼다면 어떻게 해야할까?\nclass Computer {  WirelessMouse mouse; // 변경된 부분   public Computer() {  this.mouse = new WirelessMouse(); // 변경된 부분  }   public void moveMouse() {  mouse.move();  } } 위와 같이, CableMouse를 쓰는 부분을 모두 WirelessMouse로 고쳐야 한다. SOLID 원칙에 입각해서 보면, 다음과 같다.\n   SOLID Compliance Reason     Single Responsibility Principle X Computer 클래스는, 하나의 역할만 하고 있지 않다. 마우스 객체를 생성하고, 사용하는 역할까지 하고 있다.   Open Closed Principle X 유선 마우스를 무선 마우스로 변경하기 위해서, Computer 클래스를 수정해야 했다.   Liskov Substitution Principle X 아직 유선 마우스와 무선 마우스는 서로 독립적인 클래스이므로, 아직 super/sub의 개념이 없다.   Interface Segregation Principle X 마찬가지로 아직 Interface가 존재하지 않는다.   Dependency Inversion Principle X “무선\"마우스, “유선” 마우스 라는 구체적인 클래스에 의존하고 있다.    아무래도 보아하니, 우선 interface 를 만드는 것이 급선무인 것 처럼 보인다. 우선 Mouse interface를 만들어보자. 그리고, CableMouse와 WirelessMouse가 이를 구현할 수 있도록 해보자.\nExample.2 interface Mouse {  void move(); }  class CableMouse implements Mouse {  @Override  public void move() {  System.out.println(\"CableMouse moved\");  } }  class WirelessMouse implements Mouse {  @Override  public void move() {  System.out.println(\"WirelessMouse moved\");  } } 마지막으로, Mouse 객체의 변경이 용이하도록(즉, 다형성을 이용하도록), Data type을 CableMouse인 구체 클래스가 아닌, Mouse 라는 interface를 사용하도록 하자.\nclass Computer {  private Mouse mouse;   public Computer() {  this.mouse = new CableMouse(); // 여기는..?  }   public void moveMouse() {  mouse.move();  } } 그런데 이렇게 interface 를 만든다고 해서 모두 해결된 것이 아니다. 여전히, 생성자에서 new CableMouse() 라는 구체 클래스를 사용하고 있고, WirelessMouse로 바꾸기 위해서는 코드를 수정해야 하기 때문이다.\nSOLID 5원칙을 기준으로 다시 하나씩 점검해보자.\n   SOLID Compliance Reason     Single Responsibility Principle X 여전히, 마우스 객체를 클래스에서 생성하고 있다.   Open Closed Principle X 여전히, 유선 마우스를 무선 마우스로 변경하기 위해서, Computer 클래스가 수정되어야 한다.   Liskov Substitution Principle O 마우스 interface가 기대한 대로 유/무선 마우스 클래스가 동작하고 있으므로, LSP를 지키고 있다.   Interface Segregation Principle O 인터페이스가 작은(응집된) 역할만 하고 있으므로, ISP를 준수하고 있다.   Dependency Inversion Principle X 다형성을 이용했음에도 불구하고, CableMouse 라는 여전히 구체 클래스에 의존하고 있다.    결국 문제가 되는 부분은, Computer 클래스에서 Mouse를 직접 만든다는 것이다. Mouse 객체를 외부에서 받을 수 있도록, 즉 의존성을 주입받을 수 있도록 수정해보자.\nExample.3 class Computer {  private Mouse mouse;   public Computer(Mouse mouse) {  this.mouse = mouse;  }   public void moveMouse() {  mouse.move();  } }    SOLID Compliance Reason     Single Responsibility Principle O Computer 클래스에서 마우스를 직접 생성하지 않고, 외부에서 입력받는다.   Open Closed Principle O 유선 마우스에서 무선 마우스로 바꾸더라도, Computer 클래스는 변하지 않는다.   Liskov Substitution Principle O 마우스 interface가 기대한 대로 유/무선 마우스 클래스가 동작하고 있으므로, LSP를 지키고 있다.   Interface Segregation Principle O 인터페이스가 작은(응집된) 역할만 하고 있으므로, ISP를 준수하고 있다.   Dependency Inversion Principle O Computer 클래스는 CableMouse, WirelessMouse 라는 구체 클래스에 전혀 의존하지 않는다.    드디어 SOLID 원칙을 모두 준수하는(우리가 당연스럽게 작성해왔던) 설계의 코드를 만들 수 있었다. 이제 행복하게 사용하기만 하면 될…까? Computer 객체를 사용하는 Person 이라는 객체가 있으면 어떨까?\nclass Person {  public static void main(String[] args) {  Mouse mouse = new CableMouse(); // 여기  Computer computer = new Computer(mouse);  computer.moveMouse();  } } 역시 또 CableMouse를 WirelessMouse로 바꾸기 위해 주석으로 달아놓은 코드를 수정해야 하는 문제가 생긴다. 결국 이렇게 보면 반쪽짜리 SOLID 가 되는 것이다. 그런데 여기까지 오면, 이런 의문이 생긴다.\n맞는 말이다. 결국 어딘가에서는 내가 사용하고자하는 마우스가 유선인지, 무선인지에 대한 지정은 해줘야한다. 그러나 여기서 잠깐 짚고 넘어갈 것이 있다.\n1) SOLID 원칙을 준수함으로써 얻는 이득 우리가 SOLID 원칙을 지킴으로써 얻고자 하는것은 한 쪽의 코드를 변경했을 때, 다른 쪽의 코드를 변경하는 상황을 막는 것. 즉, 약한 결합력(light coupling) 이다. 이를 통해, 코드 설계를 이해하기에, 유지보수하기에, 확장하기에 쉽도록 만들 수 있다. 우리가 Computer 클래스를 사용하는 Person 클래스의 코드를 변경하더라도, Computer 클래스의 코드는 전혀 변화하지 않는다.\n2) 역할과 구현 : 가령, 어떤 흥행하는 뮤지컬이 있다고 해보자. 주연 A의 역할을 배우 a가 맡았고, 주연 B의 역할을 배우 b가 맡았다. 그런데 b가 갑자기 아파서, c 라는 사람이 b의 역할을 대신해야 한다. 이게 문제가 될까? 문제가 되지 않는다. 왜냐하면, B 라는 역할을 수행하던 b가 하던대로(즉, 각본대로), c 또한 잘 해내면 되기 때문이다.\n위 예시로 바꿔서 생각해보자. Computer는 뮤지컬이고, Mouse는 주연이다. Mouse 의 역할을 기존 CableMouse 라는 배우가 담당했는데, 사정이 생겨서 WirelessMouse 가 대체해야 한다. 문제가 될까? 그렇지 않다. 똑같이 마우스를 움직이고, 클릭하는 기능만 제대로 수행할 수 있으면 되기 때문이다. 잘 생각해보면, 결국 1번과 비슷한 이야기다.\n즉, 위 두 이야기를 고려했을 때, Computer 클래스에는 전혀 문제가 없다는 이야기다. 그렇다면 문제가 됐던 Person 클래스의 코드를 수정해야 하는데, 관건은 도대체 어디서 실제 객체를 생성할 것이냐? 가 문제가 되는 것이다.\n뮤지컬 주연은 배우를 선택하지 않는다. 배우를 선택하는 건 뮤지컬 감독이 한다. 마찬가지다. Mouse 라는 주연, 즉 인터페이스는 CableMouse 라는 배우, 즉 객체를 선택하지 않는다. 우리는 뮤지컬 감독의 역할이 필요하다. 즉, 감독의 역할을 맡는 config 설정파일을 생성할 수도 있고, 혹은 Config 라는 클래스를 만들어서 사용할 수도 있다. 그리고 이렇게 Config 에서 실 객체를 넣어주는 작업을 바로 Dependency Injection이라 한다.\nclass Config {  public static Mouse getMouse() {  return new CableMouse();  } }  class Person {  public static void main(String[] args) {  Mouse mouse = Config.getMouse();  Computer computer = new Computer(mouse);  computer.moveMouse();  } } 이렇게 하면, 유선 마우스를 무선 마우스로 바꾼다면, Config 라는 클래스의 new CableMouse() 를 new WirelessMouse() 로 수정하기만 하면 된다.\n2. 아직 끝이 아니다. : 그런데, 마우스와 같은 간단한 경우가 아니라, 사용자가 많은 주문 서비스라면 어떨까? 가령, 사용자가 초당 100 명이라고 한다면, 매 초마다 100개의 객체가 생성되었다가, 삭제되었다가를 반복할 것이다.\n객체들이 특정한 상태가 요구되지 않는다면, 싱글톤 패턴을 이용하는 것이 해결책이 될 수 있다.\nclass Computer {  private static final Computer instance = new Computer();   private Computer() {}   public static Computer getInstance() {  return instance;  } }   Note. 위 Computer 클래스는 간단하게 싱글톤 패턴의 예시를 보여줄 뿐, 위에서 했던 내용과는 연관이 없다.\n  싱글톤 패턴은, 클래스의 instance가 1개만 생성되는 것을 보장하는 디자인 패턴을 의미한다. 따라서, instance가 여러 개 생성되는 것을 막기 위해서, private constructor를 사용했다.\n그리고 이 instance를 얻기 위해서는, 반드시 미리 생성된 getInstance() 메소드를 호출해야 한다.\n그러나, 싱글톤 패턴을 이용할 경우, 다음과 같은 문제점들이 있다.\n 싱글톤 패턴을 구현하는 코드 자체가 많아진다.(e.g. multi-thread 환경의 동기화) 구체 클래스의 instance를 가져오는 메소드를 호출하므로, 구체 클래스에 의존하게 된다.\n따라서, DIP를 위반하게 된다. 테스트가 어렵다. private 생성자를 사용하므로, 자식 클래스를 만들기 어렵다. 즉, 유연성이 떨어진다.  이렇게 되면 골치가 아프다. 우리는 Singleton 패턴의 단점을 최소화하면서, 동시에 Dependency injection 을 사용하고 싶다. 그리고 여기서, 드디어 Spring이 등장한다.\nSpring 은 이 두마리 토끼를 다 잡을 수 있도록 지원해준다. 그것이 어떻게 가능한 것인지, 그 동작 방식은 무엇인지에 대해 다루기는 양이 꽤 되므로 다음 포스팅에서 다루기로 하고, 마틴 파울러의 저서, ‘리팩토링’ 에서 남긴 말로 포스팅을 마무리한다.\n 컴퓨터가 이해할 수 있는 코드는 어느 바보나 다 짤 수 있다.\n좋은 프로그래머는 사람이 이해할 수 있는 코드를 짠다. - Martin Fowler\n Reference  Spring프레임워크를 사용하여 DI(Dependency Injection) 해보기 인프런, 김영한 님 스프링 강좌 유튜브, 뉴렉처 님 스프링 강좌  ","wordCount":"1375","inLanguage":"en","datePublished":"2020-12-29T09:58:00Z","dateModified":"2020-12-29T09:58:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/post/tech/spring/2020-12-29-dependency_injection/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># [Spring 학습 정리] Dependency Injection 의 필요성</h1><div class=post-meta><span title="2020-12-29 09:58:00 +0000 UTC">December 29, 2020</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Tech/Spring/2020-12-29-Dependency_injection.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-dependency-injection-%ec%9d%b4%eb%9e%80 aria-label="0. Dependency Injection 이란?">0. Dependency Injection 이란?</a></li><li><a href=#1-dependency-injection-%ec%9d%b4-%ed%95%84%ec%9a%94%ed%95%9c-%ec%9d%b4%ec%9c%a0 aria-label="1. Dependency Injection 이 필요한 이유?">1. Dependency Injection 이 필요한 이유?</a><ul><li><a href=#example1 aria-label=Example.1>Example.1</a></li><li><a href=#example2 aria-label=Example.2>Example.2</a></li><li><a href=#example3 aria-label=Example.3>Example.3</a><ul><li><a href=#1-solid-%ec%9b%90%ec%b9%99%ec%9d%84-%ec%a4%80%ec%88%98%ed%95%a8%ec%9c%bc%eb%a1%9c%ec%8d%a8-%ec%96%bb%eb%8a%94-%ec%9d%b4%eb%93%9d aria-label="1) SOLID 원칙을 준수함으로써 얻는 이득">1) SOLID 원칙을 준수함으로써 얻는 이득</a></li><li><a href=#2-%ec%97%ad%ed%95%a0%ea%b3%bc-%ea%b5%ac%ed%98%84 aria-label="2) 역할과 구현">2) 역할과 구현</a></li></ul></li></ul></li><li><a href=#2-%ec%95%84%ec%a7%81-%eb%81%9d%ec%9d%b4-%ec%95%84%eb%8b%88%eb%8b%a4 aria-label="2. 아직 끝이 아니다.">2. 아직 끝이 아니다.</a><ul><li><a href=#reference aria-label=Reference>Reference</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=0-dependency-injection-이란>0. Dependency Injection 이란?<a hidden class=anchor aria-hidden=true href=#0-dependency-injection-이란>#</a></h1><p>: Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,<br>객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다.
이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.</p><p>이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.<br>자세한 내용은 <a href=https://cjlee38.github.io/btb/solid_principles>이전의 포스팅</a> 혹은 다른 참고자료를 이용해 공부하자.</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center></th><th></th></tr></thead><tbody><tr><td style=text-align:center>SRP</td><td style=text-align:center>Single Responsibility Principle</td><td style=text-align:center>클래스는 하나의 책임만을 가져야 한다.</td></tr><tr><td style=text-align:center>OCP</td><td style=text-align:center>Open-Closed Principle</td><td style=text-align:center>클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.</td></tr><tr><td style=text-align:center>LSP</td><td style=text-align:center>Liskov Substitution Principle</td><td style=text-align:center>상위 클래스는 하위 클래스로 대체할 수 있어야 한다.</td></tr><tr><td style=text-align:center>ISP</td><td style=text-align:center>Interface Segregation Principle</td><td style=text-align:center>클라이언트별로 세분화된 인터페이스를 만들어라.</td></tr><tr><td style=text-align:center>DIP</td><td style=text-align:center>Dependeny Inversion Principle</td><td style=text-align:center>구체 클래스가 아닌 추상 클래스에 의존해라.</td></tr></tbody></table><hr><p>그런데 아직 공부가 부족해서 그런지, 의존성이 뭐냐? 라고 물어보면 한마디로 &ldquo;이거다&rdquo; 라고 짚어내기는 어려운 것 같다. 역시 예시를 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Computer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> CableMouse mouse<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Computer</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>mouse</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CableMouse<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>moveMouse</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        mouse<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Computer 클래스에서 CableMouse 라는 객체를 가지고 있다. 뭐 컴퓨터가 마우스를 갖고 있는거야 당연해보이지만, 당연하지 않다. 왜일까? <strong>Computer 객체가 생성 될 때 반드시 CableMouse가 생기기 때문이다.</strong> 이게 정상적인 상황일까? 절대 그렇지 않다. 컴퓨터는, 조금 불편하겠지만 마우스가 없더라도 컴퓨터로서의 기능을 여전히 할 수 있기 때문이다.</p><p>이를 코드 관점으로 바라보면, <strong>Computer 객체가 CableMouse에 의존하고 있다.</strong> 라고 표현한다. 혹은, Computer 와 CableMouse 사이엔 <strong>강한 결합</strong>이 존재한다고 말할 수 있다.</p><h1 id=1-dependency-injection-이-필요한-이유>1. Dependency Injection 이 필요한 이유?<a hidden class=anchor aria-hidden=true href=#1-dependency-injection-이-필요한-이유>#</a></h1><p>: 그렇다면 DI 를 이용해서, SOLID 원칙을 지킬 수 있다는 뜻일까? 대답은 <strong>그렇다.</strong> 이긴 한데, 어떻게 그게 가능한 것인지, 위 Computer 예시를 조금씩 수정해나가면서 알아가보자.</p><h2 id=example1>Example.1<a hidden class=anchor aria-hidden=true href=#example1>#</a></h2><p>: 우선 위 예제를 그대로 갖고 오자. 그리고, CableMouse와 WirelessMouse 또한 만들어보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Computer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> CableMouse mouse<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Computer</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>mouse</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CableMouse<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>moveMouse</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        mouse<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CableMouse</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>move</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;CableMouse moved&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WirelessMouse</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>move</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;WirelessMouse moved&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>아까 위 예시에서 봤듯이, 현재 Computer 클래스는 CableMouse에 대한 의존성을 갖고 있다. 여기서, 컴퓨터가 사용하는 유선마우스를 무선마우스로 바꾼다면 어떻게 해야할까?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Computer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    WirelessMouse mouse<span style=color:#f92672>;</span> <span style=color:#75715e>// 변경된 부분
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Computer</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>mouse</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WirelessMouse<span style=color:#f92672>();</span> <span style=color:#75715e>// 변경된 부분
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>moveMouse</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        mouse<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>위와 같이, CableMouse를 쓰는 부분을 모두 WirelessMouse로 고쳐야 한다. SOLID 원칙에 입각해서 보면, 다음과 같다.</p><table><thead><tr><th style=text-align:center>SOLID</th><th style=text-align:center>Compliance</th><th style=text-align:center>Reason</th></tr></thead><tbody><tr><td style=text-align:center>Single Responsibility Principle</td><td style=text-align:center>X</td><td style=text-align:center>Computer 클래스는, 하나의 역할만 하고 있지 않다. 마우스 객체를 생성하고, 사용하는 역할까지 하고 있다.</td></tr><tr><td style=text-align:center>Open Closed Principle</td><td style=text-align:center>X</td><td style=text-align:center>유선 마우스를 무선 마우스로 변경하기 위해서, Computer 클래스를 수정해야 했다.</td></tr><tr><td style=text-align:center>Liskov Substitution Principle</td><td style=text-align:center>X</td><td style=text-align:center>아직 유선 마우스와 무선 마우스는 서로 독립적인 클래스이므로, 아직 super/sub의 개념이 없다.</td></tr><tr><td style=text-align:center>Interface Segregation Principle</td><td style=text-align:center>X</td><td style=text-align:center>마찬가지로 아직 Interface가 존재하지 않는다.</td></tr><tr><td style=text-align:center>Dependency Inversion Principle</td><td style=text-align:center>X</td><td style=text-align:center>&ldquo;무선"마우스, &ldquo;유선&rdquo; 마우스 라는 구체적인 클래스에 의존하고 있다.</td></tr></tbody></table><p>아무래도 보아하니, 우선 interface 를 만드는 것이 급선무인 것 처럼 보인다. 우선 Mouse interface를 만들어보자. 그리고, CableMouse와 WirelessMouse가 이를 구현할 수 있도록 해보자.</p><h2 id=example2>Example.2<a hidden class=anchor aria-hidden=true href=#example2>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Mouse</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>move</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CableMouse</span> <span style=color:#66d9ef>implements</span> Mouse <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>move</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;CableMouse moved&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WirelessMouse</span> <span style=color:#66d9ef>implements</span> Mouse <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>move</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;WirelessMouse moved&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>마지막으로, Mouse 객체의 변경이 용이하도록(즉, 다형성을 이용하도록), Data type을 CableMouse인 구체 클래스가 아닌, Mouse 라는 interface를 사용하도록 하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Computer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Mouse mouse<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Computer</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>mouse</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CableMouse<span style=color:#f92672>();</span> <span style=color:#75715e>// 여기는..?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>moveMouse</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        mouse<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>그런데 이렇게 interface 를 만든다고 해서 모두 해결된 것이 아니다. 여전히, 생성자에서 <code>new CableMouse()</code> 라는 구체 클래스를 사용하고 있고, WirelessMouse로 바꾸기 위해서는 코드를 수정해야 하기 때문이다.</p><p>SOLID 5원칙을 기준으로 다시 하나씩 점검해보자.</p><table><thead><tr><th style=text-align:center>SOLID</th><th style=text-align:center>Compliance</th><th style=text-align:center>Reason</th></tr></thead><tbody><tr><td style=text-align:center>Single Responsibility Principle</td><td style=text-align:center>X</td><td style=text-align:center>여전히, 마우스 객체를 클래스에서 생성하고 있다.</td></tr><tr><td style=text-align:center>Open Closed Principle</td><td style=text-align:center>X</td><td style=text-align:center>여전히, 유선 마우스를 무선 마우스로 변경하기 위해서, Computer 클래스가 수정되어야 한다.</td></tr><tr><td style=text-align:center>Liskov Substitution Principle</td><td style=text-align:center>O</td><td style=text-align:center>마우스 interface가 기대한 대로 유/무선 마우스 클래스가 동작하고 있으므로, LSP를 지키고 있다.</td></tr><tr><td style=text-align:center>Interface Segregation Principle</td><td style=text-align:center>O</td><td style=text-align:center>인터페이스가 작은(응집된) 역할만 하고 있으므로, ISP를 준수하고 있다.</td></tr><tr><td style=text-align:center>Dependency Inversion Principle</td><td style=text-align:center>X</td><td style=text-align:center>다형성을 이용했음에도 불구하고, <code>CableMouse</code> 라는 여전히 구체 클래스에 의존하고 있다.</td></tr></tbody></table><p>결국 문제가 되는 부분은, Computer 클래스에서 Mouse를 직접 만든다는 것이다. Mouse 객체를 <strong>외부에서 받을 수 있도록</strong>, 즉 의존성을 주입받을 수 있도록 수정해보자.</p><h2 id=example3>Example.3<a hidden class=anchor aria-hidden=true href=#example3>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Computer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Mouse mouse<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Computer</span><span style=color:#f92672>(</span>Mouse mouse<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>mouse</span> <span style=color:#f92672>=</span> mouse<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>moveMouse</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        mouse<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><table><thead><tr><th style=text-align:center>SOLID</th><th style=text-align:center>Compliance</th><th style=text-align:center>Reason</th></tr></thead><tbody><tr><td style=text-align:center>Single Responsibility Principle</td><td style=text-align:center>O</td><td style=text-align:center>Computer 클래스에서 마우스를 직접 생성하지 않고, 외부에서 입력받는다.</td></tr><tr><td style=text-align:center>Open Closed Principle</td><td style=text-align:center>O</td><td style=text-align:center>유선 마우스에서 무선 마우스로 바꾸더라도, Computer 클래스는 변하지 않는다.</td></tr><tr><td style=text-align:center>Liskov Substitution Principle</td><td style=text-align:center>O</td><td style=text-align:center>마우스 interface가 기대한 대로 유/무선 마우스 클래스가 동작하고 있으므로, LSP를 지키고 있다.</td></tr><tr><td style=text-align:center>Interface Segregation Principle</td><td style=text-align:center>O</td><td style=text-align:center>인터페이스가 작은(응집된) 역할만 하고 있으므로, ISP를 준수하고 있다.</td></tr><tr><td style=text-align:center>Dependency Inversion Principle</td><td style=text-align:center>O</td><td style=text-align:center>Computer 클래스는 CableMouse, WirelessMouse 라는 구체 클래스에 전혀 의존하지 않는다.</td></tr></tbody></table><p>드디어 SOLID 원칙을 모두 준수하는(우리가 당연스럽게 작성해왔던) 설계의 코드를 만들 수 있었다. 이제 행복하게 사용하기만 하면 될&mldr;까? Computer 객체를 사용하는 Person 이라는 객체가 있으면 어떨까?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Mouse mouse <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CableMouse<span style=color:#f92672>();</span> <span style=color:#75715e>// 여기
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Computer computer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Computer<span style=color:#f92672>(</span>mouse<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        computer<span style=color:#f92672>.</span><span style=color:#a6e22e>moveMouse</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>역시 또 CableMouse를 WirelessMouse로 바꾸기 위해 주석으로 달아놓은 코드를 수정해야 하는 문제가 생긴다. 결국 이렇게 보면 반쪽짜리 SOLID 가 되는 것이다. 그런데 여기까지 오면, 이런 의문이 생긴다.</p><p>맞는 말이다. 결국 어딘가에서는 내가 사용하고자하는 마우스가 유선인지, 무선인지에 대한 지정은 해줘야한다. 그러나 여기서 잠깐 짚고 넘어갈 것이 있다.</p><h3 id=1-solid-원칙을-준수함으로써-얻는-이득>1) SOLID 원칙을 준수함으로써 얻는 이득<a hidden class=anchor aria-hidden=true href=#1-solid-원칙을-준수함으로써-얻는-이득>#</a></h3><p>우리가 SOLID 원칙을 지킴으로써 얻고자 하는것은 한 쪽의 코드를 변경했을 때, 다른 쪽의 코드를 변경하는 상황을 막는 것. 즉, 약한 결합력(light coupling) 이다. 이를 통해, 코드 설계를 이해하기에, 유지보수하기에, 확장하기에 쉽도록 만들 수 있다. 우리가 Computer 클래스를 사용하는 Person 클래스의 코드를 변경하더라도, Computer 클래스의 코드는 전혀 변화하지 않는다.</p><h3 id=2-역할과-구현>2) 역할과 구현<a hidden class=anchor aria-hidden=true href=#2-역할과-구현>#</a></h3><p>: 가령, 어떤 흥행하는 뮤지컬이 있다고 해보자. 주연 A의 역할을 배우 a가 맡았고, 주연 B의 역할을 배우 b가 맡았다. 그런데 b가 갑자기 아파서, c 라는 사람이 b의 역할을 대신해야 한다. 이게 문제가 될까? 문제가 되지 않는다. 왜냐하면, B 라는 역할을 수행하던 b가 하던대로(즉, <strong>각본대로</strong>), c 또한 잘 해내면 되기 때문이다.</p><p>위 예시로 바꿔서 생각해보자. Computer는 뮤지컬이고, Mouse는 주연이다. Mouse 의 역할을 기존 CableMouse 라는 배우가 담당했는데, 사정이 생겨서 WirelessMouse 가 대체해야 한다. 문제가 될까? 그렇지 않다. 똑같이 마우스를 움직이고, 클릭하는 기능만 제대로 수행할 수 있으면 되기 때문이다. 잘 생각해보면, 결국 1번과 비슷한 이야기다.</p><p>즉, 위 두 이야기를 고려했을 때, Computer 클래스에는 전혀 문제가 없다는 이야기다. 그렇다면 문제가 됐던 Person 클래스의 코드를 수정해야 하는데, 관건은 <strong>도대체 어디서 실제 객체를 생성할 것이냐?</strong> 가 문제가 되는 것이다.</p><p>뮤지컬 주연은 배우를 선택하지 않는다. 배우를 선택하는 건 뮤지컬 감독이 한다. 마찬가지다. Mouse 라는 주연, 즉 인터페이스는 CableMouse 라는 배우, 즉 객체를 선택하지 않는다. <strong>우리는 뮤지컬 감독의 역할이 필요하다.</strong> 즉, 감독의 역할을 맡는 config 설정파일을 생성할 수도 있고, 혹은 Config 라는 클래스를 만들어서 사용할 수도 있다. 그리고 이렇게 Config 에서 실 객체를 넣어주는 작업을 바로 Dependency Injection이라 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Config</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Mouse <span style=color:#a6e22e>getMouse</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> CableMouse<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Mouse mouse <span style=color:#f92672>=</span> Config<span style=color:#f92672>.</span><span style=color:#a6e22e>getMouse</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        Computer computer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Computer<span style=color:#f92672>(</span>mouse<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        computer<span style=color:#f92672>.</span><span style=color:#a6e22e>moveMouse</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>이렇게 하면, 유선 마우스를 무선 마우스로 바꾼다면, Config 라는 클래스의 <code>new CableMouse()</code> 를 <code>new WirelessMouse()</code> 로 수정하기만 하면 된다.</p><h1 id=2-아직-끝이-아니다>2. 아직 끝이 아니다.<a hidden class=anchor aria-hidden=true href=#2-아직-끝이-아니다>#</a></h1><p>: 그런데, 마우스와 같은 간단한 경우가 아니라, 사용자가 많은 주문 서비스라면 어떨까? 가령, 사용자가 초당 100 명이라고 한다면, 매 초마다 100개의 객체가 생성되었다가, 삭제되었다가를 반복할 것이다.</p><p>객체들이 <strong>특정한 상태</strong>가 요구되지 않는다면, 싱글톤 패턴을 이용하는 것이 해결책이 될 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Computer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Computer instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Computer<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Computer</span><span style=color:#f92672>()</span> <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Computer <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><hr><blockquote><p>Note. 위 Computer 클래스는 간단하게 싱글톤 패턴의 예시를 보여줄 뿐, 위에서 했던 내용과는 연관이 없다.</p></blockquote><hr><p>싱글톤 패턴은, 클래스의 instance가 1개만 생성되는 것을 보장하는 디자인 패턴을 의미한다. 따라서, instance가 여러 개 생성되는 것을 막기 위해서, private constructor를 사용했다.<br>그리고 이 instance를 얻기 위해서는, 반드시 미리 생성된 <code>getInstance()</code> 메소드를 호출해야 한다.</p><p>그러나, 싱글톤 패턴을 이용할 경우, 다음과 같은 문제점들이 있다.</p><ul><li>싱글톤 패턴을 구현하는 코드 자체가 많아진다.(e.g. multi-thread 환경의 동기화)</li><li>구체 클래스의 instance를 가져오는 메소드를 호출하므로, 구체 클래스에 의존하게 된다.<br>따라서, DIP를 위반하게 된다.</li><li>테스트가 어렵다.</li><li>private 생성자를 사용하므로, 자식 클래스를 만들기 어렵다.</li><li>즉, 유연성이 떨어진다.</li></ul><p>이렇게 되면 골치가 아프다. 우리는 Singleton 패턴의 단점을 최소화하면서, 동시에 Dependency injection 을 사용하고 싶다. 그리고 여기서, 드디어 <strong>Spring이 등장한다.</strong></p><p>Spring 은 이 두마리 토끼를 다 잡을 수 있도록 지원해준다. 그것이 어떻게 가능한 것인지, 그 동작 방식은 무엇인지에 대해 다루기는 양이 꽤 되므로 다음 포스팅에서 다루기로 하고, 마틴 파울러의 저서, &lsquo;리팩토링&rsquo; 에서 남긴 말로 포스팅을 마무리한다.</p><blockquote><p>컴퓨터가 이해할 수 있는 코드는 어느 바보나 다 짤 수 있다.<br>좋은 프로그래머는 사람이 이해할 수 있는 코드를 짠다. - Martin Fowler</p></blockquote><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://taesan94.tistory.com/87>Spring프레임워크를 사용하여 DI(Dependency Injection) 해보기</a></li><li>인프런, 김영한 님 스프링 강좌</li><li>유튜브, 뉴렉처 님 스프링 강좌</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/post/algorithm/problem_solving/2021-01-02-problem_solving_22/><span class=title>« Prev Page</span><br><span># 백준[No.1676] - 팩토리얼 0의 개수 ( Java )</span></a>
<a class=next href=http://cjlee38.github.io/post/language/java/2020-12-21-java8-behavior-parameterization/><span class=title>Next Page »</span><br><span># (Java8) 동작(≒메소드) 파라미터화</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # [Spring 학습 정리] Dependency Injection 의 필요성 on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%5bSpring%20%ed%95%99%ec%8a%b5%20%ec%a0%95%eb%a6%ac%5d%20Dependency%20Injection%20%ec%9d%98%20%ed%95%84%ec%9a%94%ec%84%b1&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2020-12-29-dependency_injection%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # [Spring 학습 정리] Dependency Injection 의 필요성 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2020-12-29-dependency_injection%2f&title=%23%20%5bSpring%20%ed%95%99%ec%8a%b5%20%ec%a0%95%eb%a6%ac%5d%20Dependency%20Injection%20%ec%9d%98%20%ed%95%84%ec%9a%94%ec%84%b1&summary=%23%20%5bSpring%20%ed%95%99%ec%8a%b5%20%ec%a0%95%eb%a6%ac%5d%20Dependency%20Injection%20%ec%9d%98%20%ed%95%84%ec%9a%94%ec%84%b1&source=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2020-12-29-dependency_injection%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # [Spring 학습 정리] Dependency Injection 의 필요성 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2020-12-29-dependency_injection%2f&title=%23%20%5bSpring%20%ed%95%99%ec%8a%b5%20%ec%a0%95%eb%a6%ac%5d%20Dependency%20Injection%20%ec%9d%98%20%ed%95%84%ec%9a%94%ec%84%b1"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # [Spring 학습 정리] Dependency Injection 의 필요성 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2020-12-29-dependency_injection%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # [Spring 학습 정리] Dependency Injection 의 필요성 on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%5bSpring%20%ed%95%99%ec%8a%b5%20%ec%a0%95%eb%a6%ac%5d%20Dependency%20Injection%20%ec%9d%98%20%ed%95%84%ec%9a%94%ec%84%b1%20-%20http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2020-12-29-dependency_injection%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # [Spring 학습 정리] Dependency Injection 의 필요성 on telegram" href="https://telegram.me/share/url?text=%23%20%5bSpring%20%ed%95%99%ec%8a%b5%20%ec%a0%95%eb%a6%ac%5d%20Dependency%20Injection%20%ec%9d%98%20%ed%95%84%ec%9a%94%ec%84%b1&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fspring%2f2020-12-29-dependency_injection%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>