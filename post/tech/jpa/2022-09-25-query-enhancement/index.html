<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 모락 쿼리 성능 개선기 | cjlee38</title><meta name=keywords content="jpa,query'"><meta name=description content="0. 서론 우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.
 서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정 서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유 인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유  레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/tech/jpa/2022-09-25-query-enhancement/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK",{anonymize_ip:!1})}</script><meta property="og:title" content="# 모락 쿼리 성능 개선기"><meta property="og:description" content="0. 서론 우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.
 서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정 서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유 인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유  레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/tech/jpa/2022-09-25-query-enhancement/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-09-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-25T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 모락 쿼리 성능 개선기"><meta name=twitter:description content="0. 서론 우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.
 서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정 서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유 인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유  레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 모락 쿼리 성능 개선기","item":"https://cjlee38.github.io/post/tech/jpa/2022-09-25-query-enhancement/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 모락 쿼리 성능 개선기","name":"# 모락 쿼리 성능 개선기","description":"0. 서론 우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.\n 서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정 서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유 인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유  레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다.","keywords":["jpa","query'"],"articleBody":"0. 서론 우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.\n 서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정 서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유 인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유  레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다.\n    Mean Min Max     요청 처리 시간 307.872 16.496 3234.609   쿼리 시간 236.812 1.437 3133.169   쿼리 개수 43.6 2 1002    평균 처리 시간이 짧은지 느린지는 확언할 수 없지만, 최대 처리 시간이 약 3초 남짓, 쿼리 개수가 1002개가 나가는 모습은 분명 문제가 있다고 이야기할 수 있습니다. 각각의 API 에서 요청이 어떻게 처리되는지 확인한 뒤, 하나씩 해결해본 경험을 말씀드리겠습니다.\n1. ID 기반 조회 저희 서비스에서 각 entity 는 서로 직접 참조를 맺고 있었습니다. 가령 Poll 이라는 entity 안에 Team 이라는 필드를 직접 가지고 있는 형태였죠. 그리고 repository 에서는 다음과 같은 메소드를 쓰고 있었습니다.\n// PollRepository#findAllByTeamId ListPoll findAllByTeamId(Long teamId); 위 메소드는 얼핏 보면 아무런 문제가 없어보입니다. ID 값을 기반으로 조회해오겠다는 뜻이니까요. 하지만 실제로 나가는 쿼리는 다음과 같았습니다.\nselect \tpoll0_.id as id1_3_, \tpoll0_.created_at as created_2_3_, \tpoll0_.updated_at as updated_3_3_, \t... from \tpoll poll0_ left outer join \tteam team1_ \ton poll0_.team_id=team1_.id where \tteam1_.id=? 분명 poll 이라는 테이블안에는 team_id 라는 외래키가 존재함에도 불구하고 left outer join 이 불필요하게 나가는 모습을 확인할 수 있습니다. 종종 JPQL과 SQL을 헷갈리고 이런 식으로 작성하는 경우가 많은데요. poll 이라는 entity가 갖고있는 객체는 team_id가 아닌 team이고, 따라서 team이 갖고 있는 다시 갖고 있는 id 를 기반으로 조회하고자 위와 같은 쿼리가 나가게 되는 것입니다.\n개선 방법은 간단하게, entity를 기반으로 조회하도록 변경하는 것입니다.\nselect \tpoll0_.id as id1_3_, \tpoll0_.created_at as created_2_3_, \tpoll0_.updated_at as updated_3_3_, \t... from \tpoll poll0_ where \tpoll0_.team_id=? 따라서 불필요한 join 쿼리 없이 곧바로 where 절로 접근할 수 있게 되었습니다.\n2. 단건 처리 (1) 사용하던 메소드 시그니쳐는 아래와 같습니다.\nAvailableTimeRepository#deleteAllByAppointment void deleteAllByAppointment(Appointment appointment) 이에 대응하는 쿼리는 delete from appointment_available_time where appointment_id = ? 으로, 즉 appointment를 where 절에 걸어서 delete 쿼리가 나가길 기대했지만, 실제 실행 결과는 아래와 같았습니다.\n위와 같이 appointment_id 가 아닌 id 를 기반으로 available_time을 삭제하고 있었습니다. 그 이유는 구현체인 SimpleJpaRepository 를 보면 유추할 수 있습니다.\ndeleteAll 메소드 자체는 단순히 entity의 목록을 반복하면서 삭제하기를 반복하고만 있었습니다. 이를 해결하기 위해서 직접 JPQL을 작성해주었습니다.\n@Modifying @Query(\"DELETE FROM AvailableTime at WHERE at.appointment = :appointment\") void deleteAllByAppointment(@Param(\"appointment\") Appointment appointment); 직접 작성한 JPQL 의 결과로 날아가는 쿼리는 아래와 같습니다.\ndelete from \tappointment_available_time where \tappointment_id=?  deleteAll 메소드 바로 밑에 deleteAllInbatch 라는 메소드가 있지만, deleteAllInBatchByAppointment와 같이 활용할 수 없는 것으로 파악했습니다. 공식 문서에서도 @Query 를 이용해서 처리하고 있다는 것을 확인할 수 있었습니다. 혹시 InBatch clause 를 이용할 수 있는 방법이 있다면 댓글 부탁드립니다.\n 3. 단건 처리 (2) 여러 이유로 영속성 컨텍스트에 엔티티를 담을수 없어, 직접 update 메소드를 repository 를 통해 직접 처리하고 있는 경우가 있었습니다. 대략 다음과 같이 구성되어 있었습니다.\n// PollRepository#closedById 시그니쳐 @Query(\"update Appointment a set a.status = 'CLOSED' where a.id = :id\") void closeById(@Param(\"id\") Long id);  // 사용할 때 for (Poll poll: polls) { \tpollRepository.closed(poll.getId())) } 앞서 2번과 비슷하게도, 이 부분 또한 반복문을 통해 처리되기 때문에 단건으로 처리됩니다. 어차피 업데이트할 엔티티는 이미 정해져있기 떄문에 굳이 번거롭게 매번 쿼리를 날려 불필요한 딜레이 시간을 가질 필요가 없습니다. 따라서 다음과 같이 수정하였습니다.\n@Modifying @Query(\"update Appointment a set a.status = 'CLOSED' where a in :appointments\") void closeAll(@Param(\"appointments\") IterableAppointment appointments); JPQL 에서는 위와 같이 in 절도 처리할 수 있습니다.1\n4. N+1 문제 N+1 문제는 JPA를 사용하면서 가장 흔하게 발생하고 또 신경써줘야 하는 문제입니다. 모든 N+1 문제를 해결하면서 동시에 ORM의 장점을 취하는 silver bullet은 존재하지 않고, 본인이 사용하는 로직이 N+1 문제가 어떻게 발생하느냐에 따라 적절한 해결책을 선택해야 합니다. N+1 문제를 해결하기 위한 근본적인 해결책은 entity 간의 직접적인 참조를 하지 않는 것이지만, ORM 이라는 기술이 제공해주는 다양한 장점을 불가피하게 버릴 수밖에 없습니다.\n모락의 도메인에서 Team 은 여러 Member 를 가질 수 있고, Member 또한 여러 Team 을 가질 수 있습니다. 이러한 다대다 관계를 풀어내기 위해 TeamMember라는 중간 엔티티(테이블)를 두었습니다. 그리고, Member가 속해있는 Team의 목록을 조회하기 위해서는 아래와 같은 로직을 사용했습니다.\n// TeamMemberRepository#findAllByMember ListTeamMember findAllByMember(Member member);  // 사용할 때 ListTeamMember teamMembers = teamMemberRepository.findAllByMember(member); ListTeam teams = teamMembers.stream() \t.map(teamMember - teamMember.getTeam()) \t.collect(Collectors.toList()); TeamMember를 조회하는 것 까지는 좋았으나, 여러 TeamMember에 대해서 각각의 team을 구해온다면 N+1 문제가 발생합니다. 가령, 1명의 멤버가 10개의 팀에 속해있다고 가정해봅시다. 그렇다면 전체 쿼리는 다음과 같이 구성됩니다.\n Member 조회 (1번) select * from member where id = ? Member가 속해 있는 TeamMember 목록을 조회 (1번) select * from team_member where member_id = ? TeamMember 목록에서 각각의 Team을 조회 select * from team where id = ? * 10  따라서 총 12 번의 쿼리가 날아갑니다. 만약 소속된 Team이 1000개 였다면 총 1002번의 쿼리가 날아갔겠죠. 다행히 아직까지는 저희 도메인 정책상 페이지네이션과 같은 로직은 존재하지 않기 때문에, fetch join을 이용하여 비교적 간단하게 해결할 수 있었습니다.\n@Query(\"SELECT tm FROM TeamMember tm JOIN FETCH tm.team WHERE tm.member = :member\") ListTeamMember findAllByMember(@Param(\"member\") Member member); 위와 같은 JPQL 을 작성한다면 teamMember entity를 조회하는 과정에서 team entity를 join해서 가져오게 됩니다. 따라서 1000 개의 team이 있다 하더라도 쿼리 개수 자체는 3번에서 끝나게 됩니다.\n @EntityGraph 를 사용해도 N+1 문제는 해결할 수 있지만, 이에 대한 쿼리를 살펴보면 left outer join 을 사용합니다.  하지만 직접 fetch join을 사용하게 되면 inner join 을 사용합니다.   5. 최종 결과 개선 과정을 거친 뒤, 최종 성능 측정 결과 표는 아래와 같습니다.\n    Mean Min Max     요청 처리 시간 37.478 9.44 219.352   쿼리 시간 1.698 0.307 7.87   쿼리 개수 5.6 2 13    평균을 기준으로, 각각 약 8, 140, 7 배 가량 개선하였습니다.\n  DBA와 개발자가 모두 행복해지는 Hibernate의 in_clause_parameter_padding 옵션 ↩︎\n   ","wordCount":"889","inLanguage":"en","datePublished":"2022-09-25T00:00:00Z","dateModified":"2022-09-25T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/tech/jpa/2022-09-25-query-enhancement/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 모락 쿼리 성능 개선기</h1><div class=post-meta><span title="2022-09-25 00:00:00 +0000 UTC">September 25, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Tech/Jpa/2022-09-25-query-enhancement.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%ec%84%9c%eb%a1%a0 aria-label="0. 서론">0. 서론</a></li><li><a href=#1-id-%ea%b8%b0%eb%b0%98-%ec%a1%b0%ed%9a%8c aria-label="1. ID 기반 조회">1. ID 기반 조회</a></li><li><a href=#2-%eb%8b%a8%ea%b1%b4-%ec%b2%98%eb%a6%ac-1 aria-label="2. 단건 처리 (1)">2. 단건 처리 (1)</a></li><li><a href=#3-%eb%8b%a8%ea%b1%b4-%ec%b2%98%eb%a6%ac-2 aria-label="3. 단건 처리 (2)">3. 단건 처리 (2)</a></li><li><a href=#4-n1-%eb%ac%b8%ec%a0%9c aria-label="4. N+1 문제">4. N+1 문제</a></li><li><a href=#5-%ec%b5%9c%ec%a2%85-%ea%b2%b0%ea%b3%bc aria-label="5. 최종 결과">5. 최종 결과</a></li></ul></div></details></div><div class=post-content><h1 id=0-서론>0. 서론<a hidden class=anchor aria-hidden=true href=#0-서론>#</a></h1><p>우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.</p><ul><li>서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정</li><li>서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유</li><li>인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유</li></ul><p>레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다.</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>Mean</th><th style=text-align:center>Min</th><th style=text-align:center>Max</th></tr></thead><tbody><tr><td style=text-align:center>요청 처리 시간</td><td style=text-align:center>307.872</td><td style=text-align:center>16.496</td><td style=text-align:center>3234.609</td></tr><tr><td style=text-align:center>쿼리 시간</td><td style=text-align:center>236.812</td><td style=text-align:center>1.437</td><td style=text-align:center>3133.169</td></tr><tr><td style=text-align:center>쿼리 개수</td><td style=text-align:center>43.6</td><td style=text-align:center>2</td><td style=text-align:center>1002</td></tr></tbody></table><p>평균 처리 시간이 짧은지 느린지는 확언할 수 없지만, 최대 처리 시간이 약 3초 남짓, 쿼리 개수가 1002개가 나가는 모습은 분명 문제가 있다고 이야기할 수 있습니다. 각각의 API 에서 요청이 어떻게 처리되는지 확인한 뒤, 하나씩 해결해본 경험을 말씀드리겠습니다.</p><h1 id=1-id-기반-조회>1. ID 기반 조회<a hidden class=anchor aria-hidden=true href=#1-id-기반-조회>#</a></h1><p>저희 서비스에서 각 entity 는 서로 직접 참조를 맺고 있었습니다. 가령 <code>Poll</code> 이라는 entity 안에 <code>Team</code> 이라는 필드를 직접 가지고 있는 형태였죠. 그리고 repository 에서는 다음과 같은 메소드를 쓰고 있었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// PollRepository#findAllByTeamId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>List<span style=color:#f92672>&lt;</span>Poll<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findAllByTeamId</span><span style=color:#f92672>(</span>Long teamId<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>위 메소드는 얼핏 보면 아무런 문제가 없어보입니다. ID 값을 기반으로 조회해오겠다는 뜻이니까요. 하지만 실제로 나가는 쿼리는 다음과 같았습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>	poll0_.id <span style=color:#66d9ef>as</span> id1_3_,
</span></span><span style=display:flex><span>	poll0_.created_at <span style=color:#66d9ef>as</span> created_2_3_,
</span></span><span style=display:flex><span>	poll0_.updated_at <span style=color:#66d9ef>as</span> updated_3_3_,
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span>
</span></span><span style=display:flex><span>	poll poll0_ 
</span></span><span style=display:flex><span><span style=color:#66d9ef>left</span> <span style=color:#66d9ef>outer</span> <span style=color:#66d9ef>join</span>
</span></span><span style=display:flex><span>	team team1_ 
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>on</span> poll0_.team_id<span style=color:#f92672>=</span>team1_.id 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>	team1_.id<span style=color:#f92672>=?</span>
</span></span></code></pre></div><p>분명 <code>poll</code> 이라는 테이블안에는 <code>team_id</code> 라는 외래키가 존재함에도 불구하고 <code>left outer join</code> 이 불필요하게 나가는 모습을 확인할 수 있습니다. 종종 <code>JPQL</code>과 <code>SQL</code>을 헷갈리고 이런 식으로 작성하는 경우가 많은데요. <code>poll</code> 이라는 entity가 갖고있는 객체는 <code>team_id</code>가 아닌 <code>team</code>이고, 따라서 team이 갖고 있는 다시 갖고 있는 id 를 기반으로 조회하고자 위와 같은 쿼리가 나가게 되는 것입니다.</p><p>개선 방법은 간단하게, entity를 기반으로 조회하도록 변경하는 것입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>	poll0_.id <span style=color:#66d9ef>as</span> id1_3_,
</span></span><span style=display:flex><span>	poll0_.created_at <span style=color:#66d9ef>as</span> created_2_3_,
</span></span><span style=display:flex><span>	poll0_.updated_at <span style=color:#66d9ef>as</span> updated_3_3_,
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span>
</span></span><span style=display:flex><span>	poll poll0_ 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>	poll0_.team_id<span style=color:#f92672>=?</span>
</span></span></code></pre></div><p>따라서 불필요한 join 쿼리 없이 곧바로 where 절로 접근할 수 있게 되었습니다.</p><h1 id=2-단건-처리-1>2. 단건 처리 (1)<a hidden class=anchor aria-hidden=true href=#2-단건-처리-1>#</a></h1><p>사용하던 메소드 시그니쳐는 아래와 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>AvailableTimeRepository<span style=color:#f92672>#</span>deleteAllByAppointment
</span></span><span style=display:flex><span>void deleteAllByAppointment(Appointment appointment)
</span></span></code></pre></div><p>이에 대응하는 쿼리는 <code>delete from appointment_available_time where appointment_id = ?</code> 으로, 즉 appointment를 where 절에 걸어서 delete 쿼리가 나가길 기대했지만, 실제 실행 결과는 아래와 같았습니다.</p><p><img loading=lazy src=/assets/images/2022-09-25-query-enhancement/2022-10-05-11-05-29.png alt></p><p>위와 같이 <code>appointment_id</code> 가 아닌 <code>id</code> 를 기반으로 <code>available_time</code>을 삭제하고 있었습니다. 그 이유는 구현체인 <code>SimpleJpaRepository</code> 를 보면 유추할 수 있습니다.</p><p><img loading=lazy src=/assets/images/2022-09-25-query-enhancement/2022-10-05-11-34-19.png alt></p><p>deleteAll 메소드 자체는 단순히 entity의 목록을 반복하면서 삭제하기를 반복하고만 있었습니다. 이를 해결하기 위해서 직접 JPQL을 작성해주었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Modifying</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Query</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;DELETE FROM AvailableTime at WHERE at.appointment = :appointment&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deleteAllByAppointment</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@Param</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;appointment&#34;</span><span style=color:#f92672>)</span> Appointment appointment<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>직접 작성한 <code>JPQL</code> 의 결과로 날아가는 쿼리는 아래와 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>delete</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span>
</span></span><span style=display:flex><span>	appointment_available_time 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>	appointment_id<span style=color:#f92672>=?</span>
</span></span></code></pre></div><blockquote><p><code>deleteAll</code> 메소드 바로 밑에 <code>deleteAllInbatch</code> 라는 메소드가 있지만, <code>deleteAllInBatchByAppointment</code>와 같이 활용할 수 없는 것으로 파악했습니다.
<img loading=lazy src=/assets/images/2022-09-25-query-enhancement/2022-10-05-11-40-51.png alt>
<a href=https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.modifying-queries.derived-delete>공식 문서에서도 <code>@Query</code> 를 이용해서 처리하고 있다는 것</a>을 확인할 수 있었습니다. 혹시 <code>InBatch</code> clause 를 이용할 수 있는 방법이 있다면 댓글 부탁드립니다.</p></blockquote><h1 id=3-단건-처리-2>3. 단건 처리 (2)<a hidden class=anchor aria-hidden=true href=#3-단건-처리-2>#</a></h1><p>여러 이유로 영속성 컨텍스트에 엔티티를 담을수 없어, 직접 <code>update</code> 메소드를 repository 를 통해 직접 처리하고 있는 경우가 있었습니다. 대략 다음과 같이 구성되어 있었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// PollRepository#closedById 시그니쳐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Query</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;update Appointment a set a.status = &#39;CLOSED&#39; where a.id = :id&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closeById</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@Param</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;id&#34;</span><span style=color:#f92672>)</span> Long id<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 사용할 때
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Poll poll<span style=color:#f92672>:</span> polls<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	pollRepository<span style=color:#f92672>.</span><span style=color:#a6e22e>closed</span><span style=color:#f92672>(</span>poll<span style=color:#f92672>.</span><span style=color:#a6e22e>getId</span><span style=color:#f92672>()))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>앞서 2번과 비슷하게도, 이 부분 또한 반복문을 통해 처리되기 때문에 단건으로 처리됩니다. 어차피 업데이트할 엔티티는 이미 정해져있기 떄문에 굳이 번거롭게 매번 쿼리를 날려 불필요한 딜레이 시간을 가질 필요가 없습니다. 따라서 다음과 같이 수정하였습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Modifying</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Query</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;update Appointment a set a.status = &#39;CLOSED&#39; where a in :appointments&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closeAll</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@Param</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;appointments&#34;</span><span style=color:#f92672>)</span> Iterable<span style=color:#f92672>&lt;</span>Appointment<span style=color:#f92672>&gt;</span> appointments<span style=color:#f92672>);</span>
</span></span></code></pre></div><p><code>JPQL</code> 에서는 위와 같이 <code>in</code> 절도 처리할 수 있습니다.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><h1 id=4-n1-문제>4. N+1 문제<a hidden class=anchor aria-hidden=true href=#4-n1-문제>#</a></h1><p><code>N+1 문제</code>는 JPA를 사용하면서 가장 흔하게 발생하고 또 신경써줘야 하는 문제입니다. 모든 N+1 문제를 해결하면서 동시에 ORM의 장점을 취하는 silver bullet은 존재하지 않고, 본인이 사용하는 로직이 N+1 문제가 어떻게 발생하느냐에 따라 적절한 해결책을 선택해야 합니다. N+1 문제를 해결하기 위한 근본적인 해결책은 entity 간의 직접적인 참조를 하지 않는 것이지만, <code>ORM</code> 이라는 기술이 제공해주는 다양한 장점을 불가피하게 버릴 수밖에 없습니다.</p><p>모락의 도메인에서 <code>Team</code> 은 여러 <code>Member</code> 를 가질 수 있고, <code>Member</code> 또한 여러 <code>Team</code> 을 가질 수 있습니다. 이러한 다대다 관계를 풀어내기 위해 <code>TeamMember</code>라는 중간 엔티티(테이블)를 두었습니다. 그리고, <code>Member</code>가 속해있는 <code>Team</code>의 목록을 조회하기 위해서는 아래와 같은 로직을 사용했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// TeamMemberRepository#findAllByMember
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>List<span style=color:#f92672>&lt;</span>TeamMember<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findAllByMember</span><span style=color:#f92672>(</span>Member member<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 사용할 때
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>List<span style=color:#f92672>&lt;</span>TeamMember<span style=color:#f92672>&gt;</span> teamMembers <span style=color:#f92672>=</span> teamMemberRepository<span style=color:#f92672>.</span><span style=color:#a6e22e>findAllByMember</span><span style=color:#f92672>(</span>member<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Team<span style=color:#f92672>&gt;</span> teams <span style=color:#f92672>=</span> teamMembers<span style=color:#f92672>.</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>teamMember <span style=color:#f92672>-&gt;</span> teamMember<span style=color:#f92672>.</span><span style=color:#a6e22e>getTeam</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>Collectors<span style=color:#f92672>.</span><span style=color:#a6e22e>toList</span><span style=color:#f92672>());</span>
</span></span></code></pre></div><p><code>TeamMember</code>를 조회하는 것 까지는 좋았으나, 여러 <code>TeamMember</code>에 대해서 각각의 <code>team</code>을 구해온다면 N+1 문제가 발생합니다. 가령, 1명의 멤버가 10개의 팀에 속해있다고 가정해봅시다. 그렇다면 전체 쿼리는 다음과 같이 구성됩니다.</p><ol><li>Member 조회 (1번)
<code>select * from member where id = ?</code></li><li>Member가 속해 있는 TeamMember 목록을 조회 (1번)
<code>select * from team_member where member_id = ?</code></li><li>TeamMember 목록에서 각각의 Team을 조회
<code>select * from team where id = ?</code> * 10</li></ol><p>따라서 총 12 번의 쿼리가 날아갑니다. 만약 소속된 Team이 1000개 였다면 총 1002번의 쿼리가 날아갔겠죠. 다행히 아직까지는 저희 도메인 정책상 페이지네이션과 같은 로직은 존재하지 않기 때문에, <code>fetch join</code>을 이용하여 비교적 간단하게 해결할 수 있었습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Query</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;SELECT tm FROM TeamMember tm JOIN FETCH tm.team WHERE tm.member = :member&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>TeamMember<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findAllByMember</span><span style=color:#f92672>(</span><span style=color:#a6e22e>@Param</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;member&#34;</span><span style=color:#f92672>)</span> Member member<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>위와 같은 <code>JPQL</code> 을 작성한다면 <code>teamMember</code> entity를 조회하는 과정에서 <code>team</code> entity를 join해서 가져오게 됩니다. 따라서 1000 개의 <code>team</code>이 있다 하더라도 쿼리 개수 자체는 3번에서 끝나게 됩니다.</p><blockquote><p><code>@EntityGraph</code> 를 사용해도 <code>N+1 문제</code>는 해결할 수 있지만, 이에 대한 쿼리를 살펴보면 <code>left outer join</code> 을 사용합니다.<figure class=align-center><img loading=lazy src=/assets/images/2022-09-25-query-enhancement/2022-10-07-09-21-45.png#center width=400px></figure>하지만 직접 <code>fetch join</code>을 사용하게 되면 <code>inner join</code> 을 사용합니다.<figure class=align-center><img loading=lazy src=/assets/images/2022-09-25-query-enhancement/2022-10-07-09-23-12.png#center width=400px></figure></p></blockquote><h1 id=5-최종-결과>5. 최종 결과<a hidden class=anchor aria-hidden=true href=#5-최종-결과>#</a></h1><p>개선 과정을 거친 뒤, 최종 성능 측정 결과 표는 아래와 같습니다.</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>Mean</th><th style=text-align:center>Min</th><th style=text-align:center>Max</th></tr></thead><tbody><tr><td style=text-align:center>요청 처리 시간</td><td style=text-align:center>37.478</td><td style=text-align:center>9.44</td><td style=text-align:center>219.352</td></tr><tr><td style=text-align:center>쿼리 시간</td><td style=text-align:center>1.698</td><td style=text-align:center>0.307</td><td style=text-align:center>7.87</td></tr><tr><td style=text-align:center>쿼리 개수</td><td style=text-align:center>5.6</td><td style=text-align:center>2</td><td style=text-align:center>13</td></tr></tbody></table><p>평균을 기준으로, 각각 약 8, 140, 7 배 가량 개선하였습니다.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://meetup.toast.com/posts/211>DBA와 개발자가 모두 행복해지는 Hibernate의 in_clause_parameter_padding 옵션</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/jpa/>jpa</a></li><li><a href=https://cjlee38.github.io/tags/query/>query'</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/tech/btb/2022-10-03-encoding-with-mysql/><span class=title>« Prev</span><br><span># 문자 인코딩과 MySQL varchar</span></a>
<a class=next href=https://cjlee38.github.io/post/tech/spring/2022-08-21-spring-scheudeld-with-transactional/><span class=title>Next »</span><br><span># 스프링 @Scheduled 와 @Transactional에 얽힌 이야기</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 모락 쿼리 성능 개선기 on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%eb%aa%a8%eb%9d%bd%20%ec%bf%bc%eb%a6%ac%20%ec%84%b1%eb%8a%a5%20%ea%b0%9c%ec%84%a0%ea%b8%b0&url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fjpa%2f2022-09-25-query-enhancement%2f&hashtags=jpa%2cquery%27"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 모락 쿼리 성능 개선기 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fjpa%2f2022-09-25-query-enhancement%2f&title=%23%20%eb%aa%a8%eb%9d%bd%20%ec%bf%bc%eb%a6%ac%20%ec%84%b1%eb%8a%a5%20%ea%b0%9c%ec%84%a0%ea%b8%b0&summary=%23%20%eb%aa%a8%eb%9d%bd%20%ec%bf%bc%eb%a6%ac%20%ec%84%b1%eb%8a%a5%20%ea%b0%9c%ec%84%a0%ea%b8%b0&source=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fjpa%2f2022-09-25-query-enhancement%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 모락 쿼리 성능 개선기 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fjpa%2f2022-09-25-query-enhancement%2f&title=%23%20%eb%aa%a8%eb%9d%bd%20%ec%bf%bc%eb%a6%ac%20%ec%84%b1%eb%8a%a5%20%ea%b0%9c%ec%84%a0%ea%b8%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 모락 쿼리 성능 개선기 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fjpa%2f2022-09-25-query-enhancement%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 모락 쿼리 성능 개선기 on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%eb%aa%a8%eb%9d%bd%20%ec%bf%bc%eb%a6%ac%20%ec%84%b1%eb%8a%a5%20%ea%b0%9c%ec%84%a0%ea%b8%b0%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fjpa%2f2022-09-25-query-enhancement%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 모락 쿼리 성능 개선기 on telegram" href="https://telegram.me/share/url?text=%23%20%eb%aa%a8%eb%9d%bd%20%ec%bf%bc%eb%a6%ac%20%ec%84%b1%eb%8a%a5%20%ea%b0%9c%ec%84%a0%ea%b8%b0&url=https%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fjpa%2f2022-09-25-query-enhancement%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>