<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 객체지향 설계원칙 - SOLID(번역) | cjlee38</title><meta name=keywords content="null"><meta name=description content="SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,
짧은 영어 실력으로 번역 및 정리해보았다.
수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,
영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,
이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.
사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면
차라리 영어 원문을 보는것을 추천한다.
원문
SOLID 원칙이란 무엇입니까?  Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/post/tech/btb/2020-10-08-solid_principles/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-174927148-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="# 객체지향 설계원칙 - SOLID(번역)"><meta property="og:description" content="SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,
짧은 영어 실력으로 번역 및 정리해보았다.
수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,
영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,
이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.
사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면
차라리 영어 원문을 보는것을 추천한다.
원문
SOLID 원칙이란 무엇입니까?  Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/post/tech/btb/2020-10-08-solid_principles/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-10-08T12:35:00+00:00"><meta property="article:modified_time" content="2020-10-08T12:35:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 객체지향 설계원칙 - SOLID(번역)"><meta name=twitter:description content="SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,
짧은 영어 실력으로 번역 및 정리해보았다.
수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,
영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,
이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.
사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면
차라리 영어 원문을 보는것을 추천한다.
원문
SOLID 원칙이란 무엇입니까?  Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 객체지향 설계원칙 - SOLID(번역)","item":"http://cjlee38.github.io/post/tech/btb/2020-10-08-solid_principles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 객체지향 설계원칙 - SOLID(번역)","name":"# 객체지향 설계원칙 - SOLID(번역)","description":"SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,\n짧은 영어 실력으로 번역 및 정리해보았다.\n수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,\n영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,\n이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.\n사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면\n차라리 영어 원문을 보는것을 추천한다.\n원문\nSOLID 원칙이란 무엇입니까?  Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다.","keywords":["null"],"articleBody":"SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,\n짧은 영어 실력으로 번역 및 정리해보았다.\n수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,\n영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,\n이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.\n사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면\n차라리 영어 원문을 보는것을 추천한다.\n원문\nSOLID 원칙이란 무엇입니까?  Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다.\n  SRP : Single Responsibility Principle. 단일 책임 원칙 OCP : Open-Closed Principle. 개방 폐쇄 원칙 LSP : Liskov Substitution Principle. 리스코프 치환(교체) 원칙 ISP : Interface Segregation Principle. 인터페이스 분리 원칙 DIP : Dependeny Inversion Principle. 의존관계 역전 원칙  SOLID 원칙은 다양한 테스트 제품군과 함께, 코드가 부패(…) 하는것을 방지하는데 도움을 주는 클래스 레벨의 객체지향 설계 컨셉입니다. 자바에서, SOLID 원칙은 소프트웨어의 주요 가치를 높게 유지하는데 도움을 줍니다.\n왜 SOLID 설계 원칙을 사용해야 합니까? 개발자들이 SOLID와 같은 구조화된 설계 원칙 없이 설계를 하면, 그들은 이 프로젝트를 진행할 미래의 개발자들에게 오랫동안 지속될 문제를 만들 수 있고, 그들이 개발하는 어플리케이션의 잠재적인 성공을 제한할 수 있습니다. 이러한 이슈는 흔히 “코드 부패” 라고 부릅니다.\n  그렇다면, 어떻게 미래의 코드 부패를 알아낼 수 있을까요? 아래와 같은 신호(징후)는 코드가 부패한다는 것을 암시합니다.\n Rigidity(경직성) : 작은 변화가 전체 시스템의 rebuild를 야기하는 것 Fragility(취약성) : 한 모듈의 변화가 다른 관련 없는 모듈이 오작동하도록 야기하는 것.\n(e.g. 라디오 주파수 변경이 창문에 영향을 미치는 자동차 시스템) Immobility(부동성) : 모듈의 내부 구성요소가 새로운 환경에서 재사용 될 수 없는 것 (e.g. 한 어플리케이션의 로그인 모듈이 다른 모듈들 간의 coupling과 의존성으로 인해 완전히 다른 시스템에서 재사용 될 수 없는 경우, 부동적이다.) Viscosity(점성) : 빌드와 테스트가 어렵고 실행하는 데 오래 걸리는 경우. 사소한 변화도 비용이 많이 들고, 여러 위치/수준 에서 변경이 필요한 경우.  사용자들은 사용하는 소프트웨어에서 어떠한 가치를 얻을 것이라고 기대합니다.\n어플리케이션의 가치는, 생산성, 시간, 돈 등을 증대시키고 낭비를 절약함으로써, 사용자들이 무언가를 하는데에 도움을 주는지의 여부에 따라 결정됩니다.\n사람들은 높은 가치를 가친 소프트웨어에 돈을 지불합니다.\n하지만, 사용자들이 훌륭한 소프트웨어로부터 얻는 2차 가치가 있는데, 나는 그 가치에 대해서 먼저 이야기하려고 합니다. 왜냐하면, 사람들이 소프트웨어의 가치에 대해 이야기 할 때 이것을 가장 먼저 생각하기 때문입니다 : Behaviour(행동)\n어플리케이션에서 2차 가치를 만드는 것 : 만약 소프트웨어가 버그, 충돌, 딜레이 없이 사용자가 필요로 하는 것을 수행한다면, 소프트웨어의 2차 가치는 높습니다. 2차 가치는 소프트웨어가 사용자의 현재 요구를 만족시킬 때 달성됩니다. 하지만 사용자의 변화는 자주 변합니다; 소프트웨어가 제공하는 행동(behaviour)와, 사용자가 필요로 하는 것은 불일치하기 쉽고, 이는 가치를 낮추게 됩니다. 당신의 소프트웨어는 사용자의 변화하는 요구에 따라갈 수 있어야 합니다. 그래야 우리는 지속적인 변화를 용인하고, 촉진할 수 있는 소프트웨어의 주요 가치에 도달하게 됩니다.\n현재 소프트웨어가 사용자의 요구를 만족시키지만, 수정하기에 아주 어렵고 비싸다고 상상해보세요. 여기서, 앱의 inflexibility(경직성)으로 인해, 사용자들은 좋아하지 않고, 수익률도 떨어질 것입니다.\n처음에는 2차 가치가 낮지만, 수정하기에 싸고 간단한 소프트웨어가 있다고 상상해보세요. 수익성은 올라가고, 사용자들은 점점 더 좋아할 것입니다.\nSOLID 5원칙에는 무엇이 있습니까? : 위에서 얘기했듯이, SOLID 원칙은 5가지 객체지향 설계 원칙으로 구성되어 있습니다; 단일책임 원칙, 개방폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존관계 역전 원칙. 이 원칙들은 개발자들이 “코드 부패\"에서 벗어나, 고객들에게 지속적인 가치와 이 프로젝트에 참여할 미래의 개발자들에게 건전성을 제공하는 어플리케이션을 만들 수 있도록 하는 가치있는 기준을 제공해줍니다.\n          SRP Single Responsibility Principle 클래스를 변경하는 이유는 오직 하나여야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.   LSP Liskov Substitution Principle 상위 클래스는 하위 클래스로 대체할 수 있어야 한다.   ISP Interface Segregation Principle 클라이언트별로 세분화된 인터페이스를 만들어라.   DIP Dependeny Inversion Principle 구체 클래스가 아닌 추상 클래스에 의존해라.    1.Single Responsibility Principle(SRP) 단일 책임 원칙은 클래스가 변경되어야 하는 이유가 하나보다 많으면 안된다고 명시하고 있습니다. 즉, 코드의 모든 클래스(혹은 유사한 구조)는 하나의 작업만 수행해야 합니다.\n클래스의 모든 것은 하나의 목적과 관련이 있어야 합니다.(즉, 응집되어야 합니다.) 이것은 클래스가 하나의 메소드나 속성만을 가져야 한다는 것을 의미하지는 않습니다.\n단일책임에 관련되는 한, 많은 구성원이 있을 수 있습니다. 한 가지 변경의 이유가 생길 경우, 클래스의 여러 개의 멤버가 변경되어야 할 수 있기 때문입니다. 또는 많은 클래스에 업데이트가 필요할 수 있습니다.\n다음의 코드는 얼마나 많은 책임을 갖고 있을까요?\nclass Employee {  public Pay calculatePay() {...}  public void save() {...}  public String describeEmployee() {...} } 정답은 세 개 입니다.\n하나의 클래스 안에 1) 계산하는 로직, 2) 데이터베이스 로직, 3) 보고 로직이 섞여 있습니다. 만약 당신이 여러개의 책임을 하나의 클래스로 합친다면, 다른 것들을 깨뜨리지 않으면서 하나를 바꾸는 것은 어려울 것입니다. 책임을 섞는것은 또한, 이해하기도, 테스트하기에도 어렵게 만들면서, 응집도를 낮춥니다. 이를 해결하는 가장 간단한 방법은 클래스를 세 개의 서로 다른 클래스로 나누고, 각각이 하나의 책임을 갖도록 하는 것입니다 : 데이터베이스 접근, 계산, 보고\n2. Open-Closed Principle(OCP) 개방폐쇄원칙은 클래스가 확장에는 개방되어 있으나, 변경에는 닫혀있어야 함을 말합니다.“확장에 개방되어 있다\"는 것은, 새로운 요구사항이 생겼을 때 새로운 기능을 쉽게 추가할 수 있도록 클래스를 작성해야 함을 의미합니다. “변경에 닫혀 있어야 한다\"는 것은, 한번 만들어진 클래스는 버그를 잡는 것이 아니라면 변경해서는 안된다는 것을 의미합니다.\n이 원칙의 두가지 부분은 모순되는 것 처럼 보입니다. 하지만, 올바르게 클래스와 의존성을 구조화 하면, 기존의 코드를 변경하지 않고 기능을 추가할 수 있습니다.\n일반적으로 concrete(구체) class가 아닌, interface나 abstract class와 같은 추상적인 것들에 의존적이게 참조함으로써 이를 달성할 수 있습니다. 인터페이스를 구현하는 새로운 클래스를 만들어서, 기능을 추가할 수 있습니다.\nOCP를 당신의 프로젝트에 적용하는 것은 소스코드가 한번 작성되고, 테스트되고, 디버깅 되었다면, 변경할 필요를 제한합니다. 이는 기존의 코드에 새로운 버그를 발생시킬 위험을 줄임으로써, 더욱 robust(강력한) 한 소프트웨어로 이어집니다.\n Open-Closed Principle Example 의존성을 위해 인터페이스를 사용하는 것의 side-effect는 결합력을 낮추고, 기능성을 증가시키는 것 입니다.  void checkOut(Receipt receipt) {  Money total = Money.zero;  for (item : items) {  total += item.getPrice();  receipt.addItem(item);  }  Payment p = acceptCash(total);  receipt.addPayment(p); } 신용카드 결제를 어떻게 추가할 수 있을까요? 아래와 같이 if-문을 추가할 수 있지만, 이는 OCP의 위반입니다.\nPayment p; if (credit)  p = acceptCredit(total); else  p = acceptCash(total); receipt.addPayment(p); 다음의 방식이 더 낫습니다.\npublic interface PaymentMethod {void acceptPayment(Money total);}  void checkOut(Receipt receipt, PaymentMethod pm) {  Money total = Money.zero;  for (item : items) {  total += item.getPrice();  receipt.addItem(item);  }  Payment p = pm.acceptPayment(total);  receipt.addPayment(p); } 그리고, 여기 더러운(?) 작은 비밀이 하나 있습니다 : OCP는 발생할 것이라고 예측 가능한 경우에만 도움을 줍니다. 따라서, 비슷한 변화가 이미 일어난 경우에만 적용해야 합니다. 따라서, 가장 간단한 것을 먼저 하고, 어떤 변화가 요구되는지 확인해야, 미래의 변화를 좀 더 정확하게 예측할 수 있습니다.\n이는 고객이 변화를 만들고 나서야, (미래의 비슷한 변화로부터 당신을 보호하기 위해) 추상적인 것을 개발하는 것을 의미합니다.\n3. Liskov Substitution Principle (LSP) LSP는 상속 계층에 적용되며, 클라이언트가 알지 못하게 클라이언트 종속성이 하위 클래스로 대체될 수 있도록 설계해야 함을 말합니다.\n따라서, 모든 하위클래스는 상위클래스와 같은 방식으로 동작해야 합니다. 하위 클래스의 특정 기능은 다를 수 있지만, 상위 클래스의 기대되는 동작에 부합해야 합니다. 진정한 행동적 subtype 이 되기 위해서, 하위클래스는 상위 클래스의 메소드와 속성을 구현할 뿐만 아니라, 암시적 행동 또한 부합해야 합니다.\n일반적으로, supertype의 subtype이 supertype의 클라이언트가 기대하지 않은 행동을 한다면, 이는 LSP의 위반입니다. 상위 클래스가 던지지 않는 예외를 던지는 하위클래스를 상상해보세요. 기본적으로, 하위클래스의 기능은 상위클래스보다 적어서는 안됩니다.\nLSP를 위반하는 전형적인 예로는, 직사각형 클래스에서 파생되는 정사각형 클래스 입니다. 정사각형 클래스는 언제나 높이와 너비가 같습니다. 만약 직사각형이 기대되는 곳에서 정사각형 객체가 사용된다면, 정사각형의 치수는 독립적으로 변할 수 없기 때문에, 예기치 않은 동작이 발생할 수 있습니다.\n Liskov Substitution Principle Example 이 문제는 쉽게 해결할 수 없습니다 : 정사각형이 불변(즉, 치수가 같도록 유지)하기 위해서 정사각형의 setter 메소드를 수정할 수 있다면, 이 method는 직사각형 setter의 치수가 독립적으로 수정될 수 있다는 직사각형의 사후 조건을 위반합니다.  public class Rectangle {  private double height;  private double width;   public double area();   public void setHeight(double height);  public void setWidth(double width); } 위 코드는 LSP를 위반합니다.\npublic class Square extends Rectangle {  public void setHeight(double height) {  super.setHeight(height);  super.setWidth(height);  }   public void setWidth(double width) {  setHeight(width);  } } LSP 위반은 정의되지 않은 행동을 야기합니다. 정의되지 않은 행동이란, 개발과정에서는 잘 동작하지만, 생산 단계에서 blows up(터지거나), 하루에 한번 일어날 수 있는 것을 디버깅 하는데 몇주를 쓰거나, 무엇이 잘못되었는지 알아내기 위해 몇백 MB의 로그파일을 뒤져봐야 하는 것을 의미합니다.\n4. Interface Segregation Principle (ISP) ISP는 고객이 사용하지 않는 인터페이스에 의존하도록 강요하지 않아야 하는 것을 의미합니다. 우리가 응집되지 않은 인터페이스를 가지고 있을 때, ISP는 더 작고, 다양하고, 응집된 인터페이스를 만들도록 안내합니다.\nISP를 적용하면, 클래스와 클래스의 의존성은 타이트하게 초점을 맞춘 인터페이스를 이용해 통신함으로써, 사용되지 않는 멤버에 대한 의존성을 최소화하고, 이에 따라 결합력도 낮춥니다. 작아진 인터페이스는 구현하기 쉽고, 유연성과 재사용성을 높여줍니다. 더 적은 클래스가 이러한 인터페이스를 공유함에 따라, 인터페이스 변경에 따라 필요한 변화의 수가 적어지고, robustness(건전성)을 향상시킵니다.\n기본적으로, 여기서의 교훈은 “필요하지 않은 것에 의존하지 말라” 입니다. 예를 들자면 다음과 같습니다.\n다른 메시지를 표시하고자 하는 화면이 있는 ATM기기를 상상해보세요. 다른 메시지를 표시하는 문제를 어떻게 해결할 수 있을까요? SRP, OCP, LSP를 적용해서 해결책을 제시하지만, 여전히 시스템은 유지보수하기 어렵습니다. 왜일까요?\nATM의 주인이 인출기능만을 위해 나타나는 메시지를 추가하고 싶다고 상상해보세요. 즉, “이 ATM은 인출 시 약간의 수수료를 부과합니다, 동의하십니까?” 라는 메시지를 표현하려고 합니다. 어떻게 해결할까요?\n아마, 메신저 인터페이스에 메소드를 추가함으로써 해결할 수 있을 것입니다. 하지만 이로 인해, 인터페이스의 모든 사용자가 다시 컴파일하고, 거의 모든 시스템이 재배포되더야 하는데, 이는 OCP를 직접적으로 위반하고, 코드를 부패시키는 것입니다.\n여기서, 인출 기능의 변경이 다른 관련없는 기능들에 변화를 만들었고, 이는 우리가 원하는 것이 아닙니다. 왜 이런 일이 일어났을까요?\nInterface Segregation Principle Example\n사실, 각각의 기능들이 필요로 하지는 않지만, 다른 기능에 의해 필요한 메소드에 의존하는, 거꾸로된 의존성이 있습니다. 이는 우리가 피하고 싶은 것입니다.\npublic interface Messenger {  askForCard();  tellInvalidCard();  askForPin();  tellInvalidPin();  tellCardWasSiezed();  askForAccount();  tellNotEnoughMoneyInAccount();  tellAmountDeposited();  tellBalance(); } 대신, 메신저 인터페이스를 나눔으로써, 다른 ATM 기능들이 분리된 메신저에 의존하도록 해야 합니다.\npublic interface LoginMessenger {  askForCard();  tellInvalidCard();  askForPin();  tellInvalidPin();\t}  public interface WithdrawalMessenger {  tellNotEnoughMoneyInAccount();  askForFeeConfirmation(); }  public class EnglishMessenger implements LoginMessenger, WithdrawalMessenger {  ...\t} 5. Dependency Inversion Principle (DIP) DIP는, 높은 수준의 모듈은 낮은 수준의 모듈이 아닌 추상화에 의존해야 하는 것을 의미합니다. 둘 째로, 추상화는 세부적인 것에 의존하지 않아야 하고, 세부적인 것들은 추상화에 의존해야 합니다. 핵심은 클래스를 추상화에 의해 형성된 경계선 뒤에 클래스를 고립시키는 것입니다. 추상화 뒤에 있는 모든 세부사항들이 변경되더라도, 클래스는 여전히 안전합니다. 이는 결합력을 낮추고, 설계를 쉽게 바꿀 수 있도록 해줍니다. DIP는 things(아마 코드를 의미하는듯) 독립적으로 테스트할 수 있도록 해줍니다.\nDependency Inversion Principle Example\n예시는 다음과 같습니다 : 프로그램은 추상화인 Reader와 Writer 인터페이스에 의존하고, 키보드와 프린터는 이 인터페이스를 구현하는, 추상화에 의존하는 세부사항 입니다. 다음의 예에서, CharCopier는 Reader와 Writer의 세부적인 구현을 알지 못하므로, Reader와 Writer 인터페이스를 구현한다면 어느 Device든 넘길 수 있습니다.\npublic interface Reader { char getchar(); } public interface Writer { void putchar(char c)}  class CharCopier {   void copy(Reader reader, Writer writer) {  int c;  while ((c = reader.getchar()) != EOF) {  writer.putchar();  }  } }  public Keyboard implements Reader {...} public Printer implements Writer {…} ","wordCount":"1652","inLanguage":"en","datePublished":"2020-10-08T12:35:00Z","dateModified":"2020-10-08T12:35:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/post/tech/btb/2020-10-08-solid_principles/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 객체지향 설계원칙 - SOLID(번역)</h1><div class=post-meta><span title="2020-10-08 12:35:00 +0000 UTC">October 8, 2020</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Tech/BTB/2020-10-08-solid_principles.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#solid-%ec%9b%90%ec%b9%99%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9e%85%eb%8b%88%ea%b9%8c aria-label="SOLID 원칙이란 무엇입니까?">SOLID 원칙이란 무엇입니까?</a></li><li><a href=#%ec%99%9c-solid-%ec%84%a4%ea%b3%84-%ec%9b%90%ec%b9%99%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%b4%ec%95%bc-%ed%95%a9%eb%8b%88%ea%b9%8c aria-label="왜 SOLID 설계 원칙을 사용해야 합니까?">왜 SOLID 설계 원칙을 사용해야 합니까?</a><ul><ul><li><a href=#%ec%96%b4%ed%94%8c%eb%a6%ac%ec%bc%80%ec%9d%b4%ec%85%98%ec%97%90%ec%84%9c-2%ec%b0%a8-%ea%b0%80%ec%b9%98%eb%a5%bc-%eb%a7%8c%eb%93%9c%eb%8a%94-%ea%b2%83 aria-label="어플리케이션에서 2차 가치를 만드는 것">어플리케이션에서 2차 가치를 만드는 것</a></li></ul><li><a href=#solid-5%ec%9b%90%ec%b9%99%ec%97%90%eb%8a%94-%eb%ac%b4%ec%97%87%ec%9d%b4-%ec%9e%88%ec%8a%b5%eb%8b%88%ea%b9%8c aria-label="SOLID 5원칙에는 무엇이 있습니까?">SOLID 5원칙에는 무엇이 있습니까?</a></li><li><a href=#1single-responsibility-principlesrp aria-label="1.Single Responsibility Principle(SRP)">1.Single Responsibility Principle(SRP)</a></li><li><a href=#2-open-closed-principleocp aria-label="2. Open-Closed Principle(OCP)">2. Open-Closed Principle(OCP)</a></li><li><a href=#3-liskov-substitution-principle-lsp aria-label="3. Liskov Substitution Principle (LSP)">3. Liskov Substitution Principle (LSP)</a></li><li><a href=#4-interface-segregation-principle-isp aria-label="4. Interface Segregation Principle (ISP)">4. Interface Segregation Principle (ISP)</a></li><li><a href=#5-dependency-inversion-principle-dip aria-label="5. Dependency Inversion Principle (DIP)">5. Dependency Inversion Principle (DIP)</a></li></ul></li></ul></div></details></div><div class=post-content><p>SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,<br>짧은 영어 실력으로 번역 및 정리해보았다.</p><p>수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,<br>영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,<br>이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.</p><p>사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면<br>차라리 영어 원문을 보는것을 추천한다.</p><p><a href=https://www.jrebel.com/blog/solid-principles-in-java>원문</a></p><h1 id=solid-원칙이란-무엇입니까>SOLID 원칙이란 무엇입니까?<a hidden class=anchor aria-hidden=true href=#solid-원칙이란-무엇입니까>#</a></h1><blockquote><p>Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다.</p></blockquote><ul><li>SRP : Single Responsibility Principle. 단일 책임 원칙</li><li>OCP : Open-Closed Principle. 개방 폐쇄 원칙</li><li>LSP : Liskov Substitution Principle. 리스코프 치환(교체) 원칙</li><li>ISP : Interface Segregation Principle. 인터페이스 분리 원칙</li><li>DIP : Dependeny Inversion Principle. 의존관계 역전 원칙</li></ul><p>SOLID 원칙은 다양한 테스트 제품군과 함께, 코드가 부패(&mldr;) 하는것을 방지하는데 도움을 주는 클래스 레벨의 객체지향 설계 컨셉입니다. 자바에서, SOLID 원칙은 소프트웨어의 주요 가치를 높게 유지하는데 도움을 줍니다.</p><h1 id=왜-solid-설계-원칙을-사용해야-합니까>왜 SOLID 설계 원칙을 사용해야 합니까?<a hidden class=anchor aria-hidden=true href=#왜-solid-설계-원칙을-사용해야-합니까>#</a></h1><p><img loading=lazy src=/assets/images/2020-10-21-12-57-44_2020-10-08-solid_principles.md.png alt></p><p>개발자들이 SOLID와 같은 구조화된 설계 원칙 없이 설계를 하면, 그들은 이 프로젝트를 진행할 미래의 개발자들에게 오랫동안 지속될 문제를 만들 수 있고, 그들이 개발하는 어플리케이션의 잠재적인 성공을 제한할 수 있습니다. 이러한 이슈는 흔히 <strong>&ldquo;코드 부패&rdquo;</strong> 라고 부릅니다.</p><hr><hr><p>그렇다면, 어떻게 미래의 코드 부패를 알아낼 수 있을까요? 아래와 같은 신호(징후)는 코드가 부패한다는 것을 암시합니다.</p><ul><li><strong>Rigidity(경직성)</strong> : 작은 변화가 전체 시스템의 rebuild를 야기하는 것</li><li><strong>Fragility(취약성)</strong> : 한 모듈의 변화가 다른 관련 없는 모듈이 오작동하도록 야기하는 것.<br>(e.g. 라디오 주파수 변경이 창문에 영향을 미치는 자동차 시스템)</li><li><strong>Immobility(부동성)</strong> : 모듈의 내부 구성요소가 새로운 환경에서 재사용 될 수 없는 것
(e.g. 한 어플리케이션의 로그인 모듈이 다른 모듈들 간의 coupling과 의존성으로 인해 완전히 다른 시스템에서 재사용 될 수 없는 경우, 부동적이다.)</li><li><strong>Viscosity(점성)</strong> : 빌드와 테스트가 어렵고 실행하는 데 오래 걸리는 경우. 사소한 변화도 비용이 많이 들고, 여러 위치/수준 에서 변경이 필요한 경우.</li></ul><p>사용자들은 사용하는 소프트웨어에서 어떠한 가치를 얻을 것이라고 기대합니다.<br>어플리케이션의 가치는, 생산성, 시간, 돈 등을 증대시키고 낭비를 절약함으로써, 사용자들이 무언가를 하는데에 도움을 주는지의 여부에 따라 결정됩니다.<br>사람들은 높은 가치를 가친 소프트웨어에 돈을 지불합니다.</p><p>하지만, 사용자들이 훌륭한 소프트웨어로부터 얻는 2차 가치가 있는데, 나는 그 가치에 대해서 먼저 이야기하려고 합니다. 왜냐하면, 사람들이 소프트웨어의 가치에 대해 이야기 할 때 이것을 가장 먼저 생각하기 때문입니다 : <strong>Behaviour(행동)</strong></p><h3 id=어플리케이션에서-2차-가치를-만드는-것>어플리케이션에서 2차 가치를 만드는 것<a hidden class=anchor aria-hidden=true href=#어플리케이션에서-2차-가치를-만드는-것>#</a></h3><p>: 만약 소프트웨어가 버그, 충돌, 딜레이 없이 사용자가 필요로 하는 것을 수행한다면, 소프트웨어의 2차 가치는 높습니다. 2차 가치는 소프트웨어가 사용자의 현재 요구를 만족시킬 때 달성됩니다. 하지만 사용자의 변화는 자주 변합니다; 소프트웨어가 제공하는 행동(behaviour)와, 사용자가 필요로 하는 것은 불일치하기 쉽고, 이는 가치를 낮추게 됩니다. 당신의 소프트웨어는 사용자의 변화하는 요구에 따라갈 수 있어야 합니다. 그래야 우리는 지속적인 변화를 용인하고, 촉진할 수 있는 소프트웨어의 주요 가치에 도달하게 됩니다.</p><p>현재 소프트웨어가 사용자의 요구를 만족시키지만, 수정하기에 아주 어렵고 비싸다고 상상해보세요. 여기서, 앱의 inflexibility(경직성)으로 인해, 사용자들은 좋아하지 않고, 수익률도 떨어질 것입니다.</p><p>처음에는 2차 가치가 낮지만, 수정하기에 싸고 간단한 소프트웨어가 있다고 상상해보세요. 수익성은 올라가고, 사용자들은 점점 더 좋아할 것입니다.</p><h2 id=solid-5원칙에는-무엇이-있습니까>SOLID 5원칙에는 무엇이 있습니까?<a hidden class=anchor aria-hidden=true href=#solid-5원칙에는-무엇이-있습니까>#</a></h2><p>: 위에서 얘기했듯이, SOLID 원칙은 5가지 객체지향 설계 원칙으로 구성되어 있습니다; 단일책임 원칙, 개방폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존관계 역전 원칙. 이 원칙들은 개발자들이 &ldquo;코드 부패"에서 벗어나, 고객들에게 지속적인 가치와 이 프로젝트에 참여할 미래의 개발자들에게 건전성을 제공하는 어플리케이션을 만들 수 있도록 하는 가치있는 기준을 제공해줍니다.</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center></th><th></th></tr></thead><tbody><tr><td style=text-align:center>SRP</td><td style=text-align:center>Single Responsibility Principle</td><td style=text-align:center>클래스를 변경하는 이유는 오직 하나여야 한다.</td></tr><tr><td style=text-align:center>OCP</td><td style=text-align:center>Open-Closed Principle</td><td style=text-align:center>클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.</td></tr><tr><td style=text-align:center>LSP</td><td style=text-align:center>Liskov Substitution Principle</td><td style=text-align:center>상위 클래스는 하위 클래스로 대체할 수 있어야 한다.</td></tr><tr><td style=text-align:center>ISP</td><td style=text-align:center>Interface Segregation Principle</td><td style=text-align:center>클라이언트별로 세분화된 인터페이스를 만들어라.</td></tr><tr><td style=text-align:center>DIP</td><td style=text-align:center>Dependeny Inversion Principle</td><td style=text-align:center>구체 클래스가 아닌 추상 클래스에 의존해라.</td></tr></tbody></table><h2 id=1single-responsibility-principlesrp>1.Single Responsibility Principle(SRP)<a hidden class=anchor aria-hidden=true href=#1single-responsibility-principlesrp>#</a></h2><p><img loading=lazy src=/assets/images/2020-10-21-13-31-19_2020-10-08-solid_principles.md.png alt></p><p>단일 책임 원칙은 클래스가 변경되어야 하는 이유가 하나보다 많으면 안된다고 명시하고 있습니다. 즉, 코드의 모든 클래스(혹은 유사한 구조)는 하나의 작업만 수행해야 합니다.</p><p>클래스의 모든 것은 하나의 목적과 관련이 있어야 합니다.(즉, 응집되어야 합니다.) 이것은 클래스가 하나의 메소드나 속성만을 가져야 한다는 것을 의미하지는 않습니다.</p><p>단일책임에 관련되는 한, 많은 구성원이 있을 수 있습니다. 한 가지 변경의 이유가 생길 경우, 클래스의 여러 개의 멤버가 변경되어야 할 수 있기 때문입니다. 또는 많은 클래스에 업데이트가 필요할 수 있습니다.</p><p>다음의 코드는 얼마나 많은 책임을 갖고 있을까요?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Employee</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> Pay <span style=color:#a6e22e>calculatePay</span><span style=color:#f92672>()</span> <span style=color:#f92672>{...}</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save</span><span style=color:#f92672>()</span> <span style=color:#f92672>{...}</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>describeEmployee</span><span style=color:#f92672>()</span> <span style=color:#f92672>{...}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>정답은 세 개 입니다.</p><p>하나의 클래스 안에 1) 계산하는 로직, 2) 데이터베이스 로직, 3) 보고 로직이 섞여 있습니다. 만약 당신이 여러개의 책임을 하나의 클래스로 합친다면, 다른 것들을 깨뜨리지 않으면서 하나를 바꾸는 것은 어려울 것입니다. 책임을 섞는것은 또한, 이해하기도, 테스트하기에도 어렵게 만들면서, 응집도를 낮춥니다. 이를 해결하는 가장 간단한 방법은 클래스를 세 개의 서로 다른 클래스로 나누고, 각각이 하나의 책임을 갖도록 하는 것입니다 : 데이터베이스 접근, 계산, 보고</p><h2 id=2-open-closed-principleocp>2. Open-Closed Principle(OCP)<a hidden class=anchor aria-hidden=true href=#2-open-closed-principleocp>#</a></h2><p><img loading=lazy src=/assets/images/2020-10-21-13-38-48_2020-10-08-solid_principles.md.png alt></p><p>개방폐쇄원칙은 클래스가 확장에는 개방되어 있으나, 변경에는 닫혀있어야 함을 말합니다.&ldquo;확장에 개방되어 있다"는 것은, 새로운 요구사항이 생겼을 때 새로운 기능을 쉽게 추가할 수 있도록 클래스를 작성해야 함을 의미합니다. &ldquo;변경에 닫혀 있어야 한다"는 것은, 한번 만들어진 클래스는 버그를 잡는 것이 아니라면 변경해서는 안된다는 것을 의미합니다.</p><p>이 원칙의 두가지 부분은 모순되는 것 처럼 보입니다. 하지만, 올바르게 클래스와 의존성을 구조화 하면, 기존의 코드를 변경하지 않고 기능을 추가할 수 있습니다.</p><p>일반적으로 concrete(구체) class가 아닌, interface나 abstract class와 같은 추상적인 것들에 의존적이게 참조함으로써 이를 달성할 수 있습니다. 인터페이스를 구현하는 새로운 클래스를 만들어서, 기능을 추가할 수 있습니다.</p><p>OCP를 당신의 프로젝트에 적용하는 것은 소스코드가 한번 작성되고, 테스트되고, 디버깅 되었다면, 변경할 필요를 제한합니다. 이는 기존의 코드에 새로운 버그를 발생시킬 위험을 줄임으로써, 더욱 robust(강력한) 한 소프트웨어로 이어집니다.</p><dl><dt><strong>Open-Closed Principle Example</strong></dt><dd>의존성을 위해 인터페이스를 사용하는 것의 side-effect는 결합력을 낮추고, 기능성을 증가시키는 것 입니다.</dd></dl><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkOut</span><span style=color:#f92672>(</span>Receipt receipt<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  Money total <span style=color:#f92672>=</span> Money<span style=color:#f92672>.</span><span style=color:#a6e22e>zero</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>item <span style=color:#f92672>:</span> items<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    total <span style=color:#f92672>+=</span> item<span style=color:#f92672>.</span><span style=color:#a6e22e>getPrice</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    receipt<span style=color:#f92672>.</span><span style=color:#a6e22e>addItem</span><span style=color:#f92672>(</span>item<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  Payment p <span style=color:#f92672>=</span> acceptCash<span style=color:#f92672>(</span>total<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  receipt<span style=color:#f92672>.</span><span style=color:#a6e22e>addPayment</span><span style=color:#f92672>(</span>p<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>신용카드 결제를 어떻게 추가할 수 있을까요? 아래와 같이 if-문을 추가할 수 있지만, 이는 OCP의 위반입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Payment p<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>credit<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  p <span style=color:#f92672>=</span> acceptCredit<span style=color:#f92672>(</span>total<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  p <span style=color:#f92672>=</span> acceptCash<span style=color:#f92672>(</span>total<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>receipt<span style=color:#f92672>.</span><span style=color:#a6e22e>addPayment</span><span style=color:#f92672>(</span>p<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>다음의 방식이 더 낫습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>PaymentMethod</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>acceptPayment</span><span style=color:#f92672>(</span>Money total<span style=color:#f92672>);}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkOut</span><span style=color:#f92672>(</span>Receipt receipt<span style=color:#f92672>,</span> PaymentMethod pm<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  Money total <span style=color:#f92672>=</span> Money<span style=color:#f92672>.</span><span style=color:#a6e22e>zero</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>item <span style=color:#f92672>:</span> items<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    total <span style=color:#f92672>+=</span> item<span style=color:#f92672>.</span><span style=color:#a6e22e>getPrice</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    receipt<span style=color:#f92672>.</span><span style=color:#a6e22e>addItem</span><span style=color:#f92672>(</span>item<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  Payment p <span style=color:#f92672>=</span> pm<span style=color:#f92672>.</span><span style=color:#a6e22e>acceptPayment</span><span style=color:#f92672>(</span>total<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  receipt<span style=color:#f92672>.</span><span style=color:#a6e22e>addPayment</span><span style=color:#f92672>(</span>p<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>그리고, 여기 더러운(?) 작은 비밀이 하나 있습니다 : OCP는 발생할 것이라고 예측 가능한 경우에만 도움을 줍니다. 따라서, 비슷한 변화가 이미 일어난 경우에만 적용해야 합니다. 따라서, 가장 간단한 것을 먼저 하고, 어떤 변화가 요구되는지 확인해야, 미래의 변화를 좀 더 정확하게 예측할 수 있습니다.</p><p>이는 고객이 변화를 만들고 나서야, (미래의 비슷한 변화로부터 당신을 보호하기 위해) 추상적인 것을 개발하는 것을 의미합니다.</p><h2 id=3-liskov-substitution-principle-lsp>3. Liskov Substitution Principle (LSP)<a hidden class=anchor aria-hidden=true href=#3-liskov-substitution-principle-lsp>#</a></h2><p><img loading=lazy src=/assets/images/2020-10-21-13-54-05_2020-10-08-solid_principles.md.png alt></p><p>LSP는 상속 계층에 적용되며, 클라이언트가 알지 못하게 클라이언트 종속성이 하위 클래스로 대체될 수 있도록 설계해야 함을 말합니다.</p><p>따라서, 모든 하위클래스는 상위클래스와 같은 방식으로 동작해야 합니다. 하위 클래스의 특정 기능은 다를 수 있지만, 상위 클래스의 기대되는 동작에 부합해야 합니다. 진정한 행동적 subtype 이 되기 위해서, 하위클래스는 상위 클래스의 메소드와 속성을 구현할 뿐만 아니라, 암시적 행동 또한 부합해야 합니다.</p><p>일반적으로, supertype의 subtype이 supertype의 클라이언트가 기대하지 않은 행동을 한다면, 이는 LSP의 위반입니다. 상위 클래스가 던지지 않는 예외를 던지는 하위클래스를 상상해보세요. 기본적으로, 하위클래스의 기능은 상위클래스보다 적어서는 안됩니다.</p><p>LSP를 위반하는 전형적인 예로는, 직사각형 클래스에서 파생되는 정사각형 클래스 입니다. 정사각형 클래스는 언제나 높이와 너비가 같습니다. 만약 직사각형이 기대되는 곳에서 정사각형 객체가 사용된다면, 정사각형의 치수는 독립적으로 변할 수 없기 때문에, 예기치 않은 동작이 발생할 수 있습니다.</p><dl><dt><strong>Liskov Substitution Principle Example</strong></dt><dd>이 문제는 쉽게 해결할 수 없습니다 : 정사각형이 불변(즉, 치수가 같도록 유지)하기 위해서 정사각형의 setter 메소드를 수정할 수 있다면, 이 method는 직사각형 setter의 치수가 독립적으로 수정될 수 있다는 직사각형의 사후 조건을 위반합니다.</dd></dl><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Rectangle</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span> height<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span> width<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>area</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setHeight</span><span style=color:#f92672>(</span><span style=color:#66d9ef>double</span> height<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setWidth</span><span style=color:#f92672>(</span><span style=color:#66d9ef>double</span> width<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>위 코드는 LSP를 위반합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Square</span> <span style=color:#66d9ef>extends</span> Rectangle <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setHeight</span><span style=color:#f92672>(</span><span style=color:#66d9ef>double</span> height<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>setHeight</span><span style=color:#f92672>(</span>height<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>setWidth</span><span style=color:#f92672>(</span>height<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setWidth</span><span style=color:#f92672>(</span><span style=color:#66d9ef>double</span> width<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    setHeight<span style=color:#f92672>(</span>width<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>LSP 위반은 정의되지 않은 행동을 야기합니다. 정의되지 않은 행동이란, 개발과정에서는 잘 동작하지만, 생산 단계에서 blows up(터지거나), 하루에 한번 일어날 수 있는 것을 디버깅 하는데 몇주를 쓰거나, 무엇이 잘못되었는지 알아내기 위해 몇백 MB의 로그파일을 뒤져봐야 하는 것을 의미합니다.</p><h2 id=4-interface-segregation-principle-isp>4. Interface Segregation Principle (ISP)<a hidden class=anchor aria-hidden=true href=#4-interface-segregation-principle-isp>#</a></h2><p><img loading=lazy src=/assets/images/2020-10-21-14-06-43_2020-10-08-solid_principles.md.png alt></p><p>ISP는 고객이 사용하지 않는 인터페이스에 의존하도록 강요하지 않아야 하는 것을 의미합니다. 우리가 응집되지 않은 인터페이스를 가지고 있을 때, ISP는 더 작고, 다양하고, 응집된 인터페이스를 만들도록 안내합니다.</p><p>ISP를 적용하면, 클래스와 클래스의 의존성은 타이트하게 초점을 맞춘 인터페이스를 이용해 통신함으로써, 사용되지 않는 멤버에 대한 의존성을 최소화하고, 이에 따라 결합력도 낮춥니다. 작아진 인터페이스는 구현하기 쉽고, 유연성과 재사용성을 높여줍니다. 더 적은 클래스가 이러한 인터페이스를 공유함에 따라, 인터페이스 변경에 따라 필요한 변화의 수가 적어지고, robustness(건전성)을 향상시킵니다.</p><p>기본적으로, 여기서의 교훈은 &ldquo;필요하지 않은 것에 의존하지 말라&rdquo; 입니다. 예를 들자면 다음과 같습니다.</p><p>다른 메시지를 표시하고자 하는 화면이 있는 ATM기기를 상상해보세요. 다른 메시지를 표시하는 문제를 어떻게 해결할 수 있을까요? SRP, OCP, LSP를 적용해서 해결책을 제시하지만, 여전히 시스템은 유지보수하기 어렵습니다. 왜일까요?</p><p>ATM의 주인이 인출기능만을 위해 나타나는 메시지를 추가하고 싶다고 상상해보세요. 즉, &ldquo;이 ATM은 인출 시 약간의 수수료를 부과합니다, 동의하십니까?&rdquo; 라는 메시지를 표현하려고 합니다. 어떻게 해결할까요?</p><p>아마, 메신저 인터페이스에 메소드를 추가함으로써 해결할 수 있을 것입니다. 하지만 이로 인해, 인터페이스의 모든 사용자가 다시 컴파일하고, 거의 모든 시스템이 재배포되더야 하는데, 이는 OCP를 직접적으로 위반하고, 코드를 부패시키는 것입니다.</p><p>여기서, 인출 기능의 변경이 다른 관련없는 기능들에 변화를 만들었고, 이는 우리가 원하는 것이 아닙니다. 왜 이런 일이 일어났을까요?</p><p><strong>Interface Segregation Principle Example</strong></p><p>사실, 각각의 기능들이 필요로 하지는 않지만, 다른 기능에 의해 필요한 메소드에 의존하는, 거꾸로된 의존성이 있습니다. 이는 우리가 피하고 싶은 것입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Messenger</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  askForCard<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellInvalidCard<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  askForPin<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellInvalidPin<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellCardWasSiezed<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  askForAccount<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellNotEnoughMoneyInAccount<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellAmountDeposited<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellBalance<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>대신, 메신저 인터페이스를 나눔으로써, 다른 ATM 기능들이 분리된 메신저에 의존하도록 해야 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>LoginMessenger</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  askForCard<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellInvalidCard<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  askForPin<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  tellInvalidPin<span style=color:#f92672>();</span>	
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>WithdrawalMessenger</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  tellNotEnoughMoneyInAccount<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  askForFeeConfirmation<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EnglishMessenger</span> <span style=color:#66d9ef>implements</span> LoginMessenger<span style=color:#f92672>,</span> WithdrawalMessenger <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>	
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=5-dependency-inversion-principle-dip>5. Dependency Inversion Principle (DIP)<a hidden class=anchor aria-hidden=true href=#5-dependency-inversion-principle-dip>#</a></h2><p><img loading=lazy src=/assets/images/2020-10-21-14-22-09_2020-10-08-solid_principles.md.png alt></p><p>DIP는, 높은 수준의 모듈은 낮은 수준의 모듈이 아닌 추상화에 의존해야 하는 것을 의미합니다. 둘 째로, 추상화는 세부적인 것에 의존하지 않아야 하고, 세부적인 것들은 추상화에 의존해야 합니다. 핵심은 클래스를 추상화에 의해 형성된 경계선 뒤에 클래스를 고립시키는 것입니다. 추상화 뒤에 있는 모든 세부사항들이 변경되더라도, 클래스는 여전히 안전합니다. 이는 결합력을 낮추고, 설계를 쉽게 바꿀 수 있도록 해줍니다. DIP는 things(아마 코드를 의미하는듯) 독립적으로 테스트할 수 있도록 해줍니다.</p><p><strong>Dependency Inversion Principle Example</strong></p><p>예시는 다음과 같습니다 : 프로그램은 추상화인 Reader와 Writer 인터페이스에 의존하고, 키보드와 프린터는 이 인터페이스를 구현하는, 추상화에 의존하는 세부사항 입니다. 다음의 예에서, CharCopier는 Reader와 Writer의 세부적인 구현을 알지 못하므로, Reader와 Writer 인터페이스를 구현한다면 어느 Device든 넘길 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Reader</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>char</span> <span style=color:#a6e22e>getchar</span><span style=color:#f92672>();</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Writer</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>putchar</span><span style=color:#f92672>(</span><span style=color:#66d9ef>char</span> c<span style=color:#f92672>)}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CharCopier</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>copy</span><span style=color:#f92672>(</span>Reader reader<span style=color:#f92672>,</span> Writer writer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>((</span>c <span style=color:#f92672>=</span> reader<span style=color:#f92672>.</span><span style=color:#a6e22e>getchar</span><span style=color:#f92672>())</span> <span style=color:#f92672>!=</span> EOF<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      writer<span style=color:#f92672>.</span><span style=color:#a6e22e>putchar</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Keyboard <span style=color:#66d9ef>implements</span> Reader <span style=color:#f92672>{...}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Printer <span style=color:#66d9ef>implements</span> Writer <span style=color:#f92672>{</span><span style=color:#960050;background-color:#1e0010>…</span><span style=color:#f92672>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/post/language/java/2020-10-09-java_enum/><span class=title>« Prev Page</span><br><span># (Java) [짧] Enum 뜯어보기</span></a>
<a class=next href=http://cjlee38.github.io/post/language/java/2020-10-07-java_stream/><span class=title>Next Page »</span><br><span># (Java) Stream API 첫걸음</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 객체지향 설계원칙 - SOLID(번역) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%9b%90%ec%b9%99%20-%20SOLID%28%eb%b2%88%ec%97%ad%29&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-08-solid_principles%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 객체지향 설계원칙 - SOLID(번역) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-08-solid_principles%2f&title=%23%20%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%9b%90%ec%b9%99%20-%20SOLID%28%eb%b2%88%ec%97%ad%29&summary=%23%20%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%9b%90%ec%b9%99%20-%20SOLID%28%eb%b2%88%ec%97%ad%29&source=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-08-solid_principles%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 객체지향 설계원칙 - SOLID(번역) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-08-solid_principles%2f&title=%23%20%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%9b%90%ec%b9%99%20-%20SOLID%28%eb%b2%88%ec%97%ad%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 객체지향 설계원칙 - SOLID(번역) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-08-solid_principles%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 객체지향 설계원칙 - SOLID(번역) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%9b%90%ec%b9%99%20-%20SOLID%28%eb%b2%88%ec%97%ad%29%20-%20http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-08-solid_principles%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 객체지향 설계원칙 - SOLID(번역) on telegram" href="https://telegram.me/share/url?text=%23%20%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%9b%90%ec%b9%99%20-%20SOLID%28%eb%b2%88%ec%97%ad%29&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-08-solid_principles%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=cjlee38/hugo-blog issue-term=pathname label=✨💬✨ theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>