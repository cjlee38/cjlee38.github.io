<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 재귀함수 주무르기 with 피보나치 수열 ( feat. Java ) | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. 들어가며 : 나는 재귀함수를 좋아하지 않는다.
재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.
그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.
이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,
재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.
1. 재귀함수의 사전적 정의 : 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.
이를 프로그래밍에 적용하면, 함수가 자기 자신으로 되돌아옴 정도로 표현할 수 있겠다.
다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/post/tech/btb/2020-10-16-recursive_function/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="# 재귀함수 주무르기 with 피보나치 수열 ( feat. Java )"><meta property="og:description" content="0. 들어가며 : 나는 재귀함수를 좋아하지 않는다.
재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.
그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.
이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,
재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.
1. 재귀함수의 사전적 정의 : 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.
이를 프로그래밍에 적용하면, 함수가 자기 자신으로 되돌아옴 정도로 표현할 수 있겠다.
다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/post/tech/btb/2020-10-16-recursive_function/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-10-16T05:44:00+00:00"><meta property="article:modified_time" content="2020-10-16T05:44:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 재귀함수 주무르기 with 피보나치 수열 ( feat. Java )"><meta name=twitter:description content="0. 들어가며 : 나는 재귀함수를 좋아하지 않는다.
재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.
그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.
이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,
재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.
1. 재귀함수의 사전적 정의 : 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.
이를 프로그래밍에 적용하면, 함수가 자기 자신으로 되돌아옴 정도로 표현할 수 있겠다.
다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"# 재귀함수 주무르기 with 피보나치 수열 ( feat. Java )","item":"http://cjlee38.github.io/post/tech/btb/2020-10-16-recursive_function/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 재귀함수 주무르기 with 피보나치 수열 ( feat. Java )","name":"# 재귀함수 주무르기 with 피보나치 수열 ( feat. Java )","description":"0. 들어가며 : 나는 재귀함수를 좋아하지 않는다.\n재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.\n그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.\n이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,\n재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.\n1. 재귀함수의 사전적 정의 : 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.\n이를 프로그래밍에 적용하면, 함수가 자기 자신으로 되돌아옴 정도로 표현할 수 있겠다.\n다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다.","keywords":["null"],"articleBody":"0. 들어가며 : 나는 재귀함수를 좋아하지 않는다.\n재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.\n그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.\n이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,\n재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.\n1. 재귀함수의 사전적 정의 : 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.\n이를 프로그래밍에 적용하면, 함수가 자기 자신으로 되돌아옴 정도로 표현할 수 있겠다.\n다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다.\n2. 해결할 문제. 이러한 재귀함수를 활용하는 가장 대표적인 문제는, 역시 피보나치 수열이다.\n잡다한 이야기는 쫙 빼고, 피보나치 수열이 무엇인가 하면,\nN번째 항의 값은, 그 전항(N-1) 과, 그 전전항(N-2)의 값의 합이다.\n라는 것으로 정의되는 수열이다.\n즉, 만약 N이 3이라면, 다시 말해 fibonacci(3)을 구하고자 한다면,\n전항인 fibonacci(2)와, fibonacci(1)의 값을 더해서 구할 수 있다.(이하 F() 로 통일)\n그렇다면 F(0)과 F(1)을 구하기 위해 F(-1)과 같은 음수로 가느냐?\n그렇지는 않고, 0과 1의 값은 각각 0과 1로 정의되어 있다.\n간단하게, F(4)를 구해보자. 이를 구하기 위해서는, F(3)과 F(2)를 알아야 한다.\nF(3)과 F(2)를 구하기 위해서는, F(2)와 F(1)을, 그리고 F(1)과 F(0)을 구해야 한다.\nF(1)과 F(0)은 1과 0으로 정의되어 있으니, 다시 거꾸로 타고 올라가면 된다.\nF(2) = F(1) + F(0) = 1 + 0 = 1\nF(3) = F(2) + F(1) = 1 + 1 = 2\nF(4) = F(3) + F(2) = 2 + 1 = 3\n답이 나왔다. F(4)의 답은 3 이다.\n3. 해결법 : 여러 가지 해결 방법이 있지만, 반복문과 오늘의 핵심인 재귀함수 두가지 방법을 이용해보자.\n1) 반복문 : 반복문을 이용하는 방법은 간단하다.\n배열을 만들어놓고, 전항의 값, 그리고 전전항의 값을 더해서 넣으면 된다.\npublic static int fibonacci(int n) {  int[] fibo = new int[n+1];  fibo[0] = 0;  fibo[1] = 1;   for (int i = 2; i  fibo.length; i++) {  fibo[i] = fibo[i-1] + fibo[i-2];  }   return fibo[n]; } 보는 바와 같이, 0번째 항과 1번째 항은 0과 1로 값을 미리 채워두고,\n반복문을 통해 더해가면서 구할 수 있다.\n2) 재귀함수 : 그렇다면, 재귀함수는 어떨까?\npublic static int fibonacci(int n) {  if (n == 0) return 0;  else if (n == 1) return 1;   return fibonacci(n-1) + fibonacci(n-2); } 삼항연산자로도 풀어낼 수 있지만,\n가장 기본에 충실하게 작성하면 위와 같이 작성할 수 있다.\nn에 3이 들어오는 경우, fibonacci(2)와 fibonacci(1) 이 각각 호출되고,\nfibonacci(2)는 fibonacci(1)과 fibonacci(0)을 호출한다.\nfibonacci(1)은 1을, fibonacci(0)은 0을 return하므로, 이 둘을 더해 fibonacci(2)는 1이 된다.\n따라서, fibonacci(2) + fibonacci(1)은 1+1이 되어,\n최종적으로 2가 return된다.\n여기까지 모두가 행복하게 잘 살았습니다의 해피엔딩으로 끝나면 좋겠지만,\n문제가 남아있다.\n4. 문제점 : 만약, 피보나치에 100을 요구하면 어떻게 될까?\n결과가 나타나지 않는다. 너무 오래 걸리는 탓이다.\n반토막을 내서 50을 넣어봐도, 약 65초가 걸렸다.\n(여담으로 값은 약 120억으로, int형의 최대값인 21억을 훨씬 넘어선다.)\n왜 이렇게 오래 걸릴까?\n그 이유는, 재귀함수를 돌면서, Call Stack이 쌓이기 때문이다.\n위 코드를 다시 보자.\nfibonacci(n)을 구하기 위해, fibonacci(n-1), fibonacci(n-2)를 수행해야 한다.\n당연하게 보이지만, fibonacci(n-1)과 fibonacci(n-2)를 구하기 전까지는,\nfibonacci(n)은 대기하고 있는 상태이다.\n즉, n이 0 또는 1이 되기 전까지는 계속해서 대기, 대기, 대기 하는 함수들이 쌓이고,\n0 또는 1이 되어서야 다시 돌아와서 값을 구하고, 더해야 하기 때문이다.\n5. 해결 방법 : 이는 다음의 두 가지 방법으로 해결할 수 있다.\n1) Tail Recursion : 먼저 활용할 수 있는 방법은 꼬리재귀를 이용하는 방법이다.\n꼬리재귀는, 재귀함수의 탈을 쓴 while문과 같다.\n앞서, 위와 같이 계속해서 Stack이 쌓였던 이유는,\nfibonacci(n-1)과 fibonacci(n-2)를 구하고 나서,\n이를 더하는 연산이 필요했기 때문이다.\n즉, 아직 할 일이 남아있었다.\n그런데, 할 일이 없다면 어떨까?\n그냥 곧바로, 가장 최초로 함수를 실행한 지점으로 return을 쏴버리면 안될까?\n안될 것 없다.\n코드를 다음과 같이 수정해보자.\npublic static int fibonacci(int n) {  return fibonacciTail(n, 0, 1); }  public static int fibonacciTail(int n, int prev, int next) {  if (n == 0) return prev;  return fibonacciTail(n-1, next, prev+next); } 앞서 코드는, fibonacci(n)을 구하기 위해서\n계산을 최대한 뒤로 미루는 듯한 느낌을 받았는데,\n새로운 코드는 계산을 한다음에 그 값을 넘겨준다.\n그리고, 직접 디버깅으로 하나하나 실행해보면 알겠지만,\nn이 되는 순간 곧바로 fibonacciTail()이 아닌 fibonacci() 로 쏴버린다.\n반복 횟수는 어떨까?\nFibonacci(10)을 기준으로,\n기존의 방식은 177번,\n새로운 방식은 11번 반복했다.\nN이 늘어나면 늘어날수록, 이 차이는 더더욱 극명하게 드러날 것이다.\n Note. 좀 더 자세히 찾아보았는데, 진정한 꼬리재귀는 Stack Frame 자체를 쌓지 않는다. 즉, 꼬리재귀함수를 지원하지 않는다는 Python 에서도, 위와 같은 코드는 구현할 수 있고, 실제로 잘 동작하기도 한다. 그러나, 꼬리재귀함수를 지원하는 컴파일러인 경우, 애초에 Stack Frame을 쌓지 않도록 이를 while문으로 애초에 “바꾸어버린다” 는 것이다. 따라서, 다음과 같이 정리할 수 있겠다.\n  꼬리재귀를 지원하는 경우 : 애초에 while문으로 바뀌기 때문에, Stack Frame 자체가 쌓이지 않음. 즉, StackOverflow 의 에러가 절대 발생하지 않는다. - Tail Call Optimization\n꼬리재귀를 지원하지 않는 경우 : 위와 같은 로직으로 최적화는 되더라도, Stack은 쌓이기 때문에, StackOverflow가 발생할 수 있다.\n 2) 동적계획법(cache)을 이용 : 문제가 발생했던 코드의 경우, 같은 연산을 반복하는 코드가 존재한다.\n즉, F(4)를 구하기 위해서, F(3)과 F(2)를 구해야 했는데,\nF(3)을 구하기 위해서, 또 다시 F(2) 에 대한 연산을 해야하는 것이다.\n그러므로, 재귀함수를 반복하면서,\n구하고자 하는 값이, 처음 구하는 경우에는 직접 연산,\n한번 구한적 있는 값이라면, 꺼내오기\n를 이용하면, 좀 더 똑똑하게 가져올 수 있다.\n다음과 같이 코드를 작성해보자.\nstatic int[] fibo;  public static void main(String[] args) {  int n = 10;  fibo = new int[n+1];  int result = fibonacci(n);  System.out.println(result); }  public static int fibonacci(int n) {  if (fibo[n] != 0) return fibo[n];  if (n == 0) return 0;  else if (n == 1) return 1;   fibo[n] = fibonacci(n-1) + fibonacci(n-2);  return fibo[n]; } int[] 배열 fibo를 선언한 뒤, main method에서 n+1 만큼의 길이로 정의해주었다.\n다음으로, fibonacci() 함수가 실행될 때마다,\n값이 있는지 확인하고,\n없는 경우에는 기존의 로직을, 있는 경우에는 그 값을 곧바로 return하도록 만들었다.\n그리고 최종적으로, 원하는 fibonacci 값인 fibo[n]을 return했다.\n반복 횟수는, 10을 기준으로 19번을 반복했다.\n6. 마치며 : 하나의 문제를 푸는데에 여러 가지 방법을 아는 것은 큰 도움이 된다.\n모든것을 한방에 해결해주는 만능 알고리즘은 없으니,\n상황에 맞게 적절하게 사용하는 것이 중요한데,\n이 때 내가 어떤 무기, Tool을 갖고 있느냐에 따라\n선택의 폭도 달라지고, 생각의 틀도 격변하기 때문인 것 같다.\n위 피보나치를 구하는 방법에도,\n일반항을 이용하는 방법이나, 행렬을 이용하는 방법이 있다고 하는데,\n본 포스팅의 목적은 피보나치가 아닌 재귀함수 이므로 이에 대해서 따로 찾아보지는 않았다.\n궁금한 사람은 이하의 Reference를 참고하면 좋겠다.\n이상으로 포스팅을 마칩니다.\nReference  피보나치 수열 알고리즘을 해결하는 5가지 방법 Tail Recursion in Python StackOverflow - What is tail-recursion elimination? Wikipedia - Tail call  ","wordCount":"986","inLanguage":"en","datePublished":"2020-10-16T05:44:00Z","dateModified":"2020-10-16T05:44:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/post/tech/btb/2020-10-16-recursive_function/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/post/>Posts</a></div><h1 class=post-title># 재귀함수 주무르기 with 피보나치 수열 ( feat. Java )</h1><div class=post-meta><span title="2020-10-16 05:44:00 +0000 UTC">October 16, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/Tech/BTB/2020-10-16-recursive_function.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label="0. 들어가며">0. 들어가며</a></li><li><a href=#1-%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98%ec%9d%98-%ec%82%ac%ec%a0%84%ec%a0%81-%ec%a0%95%ec%9d%98 aria-label="1. 재귀함수의 사전적 정의">1. 재귀함수의 사전적 정의</a></li><li><a href=#2-%ed%95%b4%ea%b2%b0%ed%95%a0-%eb%ac%b8%ec%a0%9c aria-label="2. 해결할 문제.">2. 해결할 문제.</a></li><li><a href=#3-%ed%95%b4%ea%b2%b0%eb%b2%95 aria-label="3. 해결법">3. 해결법</a><ul><li><a href=#1-%eb%b0%98%eb%b3%b5%eb%ac%b8 aria-label="1) 반복문">1) 반복문</a></li><li><a href=#2-%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98 aria-label="2) 재귀함수">2) 재귀함수</a></li></ul></li><li><a href=#4-%eb%ac%b8%ec%a0%9c%ec%a0%90 aria-label="4. 문제점">4. 문제점</a></li><li><a href=#5-%ed%95%b4%ea%b2%b0-%eb%b0%a9%eb%b2%95 aria-label="5. 해결 방법">5. 해결 방법</a><ul><li><a href=#1-tail-recursion aria-label="1) Tail Recursion">1) Tail Recursion</a></li><li><a href=#2-%eb%8f%99%ec%a0%81%ea%b3%84%ed%9a%8d%eb%b2%95cache%ec%9d%84-%ec%9d%b4%ec%9a%a9 aria-label="2) 동적계획법(cache)을 이용">2) 동적계획법(cache)을 이용</a></li></ul></li><li><a href=#6-%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label="6. 마치며">6. 마치며</a><ul><li><a href=#reference aria-label=Reference>Reference</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>: 나는 재귀함수를 좋아하지 않는다.<br>재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.<br>그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.</p><p>이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,<br>재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.</p><h1 id=1-재귀함수의-사전적-정의>1. 재귀함수의 사전적 정의<a hidden class=anchor aria-hidden=true href=#1-재귀함수의-사전적-정의>#</a></h1><p>: 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.</p><p>이를 프로그래밍에 적용하면, <strong>함수가 자기 자신으로 되돌아옴</strong> 정도로 표현할 수 있겠다.<br>다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다.</p><h1 id=2-해결할-문제>2. 해결할 문제.<a hidden class=anchor aria-hidden=true href=#2-해결할-문제>#</a></h1><p>이러한 재귀함수를 활용하는 가장 대표적인 문제는, 역시 피보나치 수열이다.<br>잡다한 이야기는 쫙 빼고, 피보나치 수열이 무엇인가 하면,<br><strong>N번째 항의 값은, 그 전항(N-1) 과, 그 전전항(N-2)의 값의 합이다.</strong><br>라는 것으로 정의되는 수열이다.</p><p>즉, 만약 N이 3이라면, 다시 말해 <code>fibonacci(3)</code>을 구하고자 한다면,<br>전항인 <code>fibonacci(2)</code>와, <code>fibonacci(1)</code>의 값을 더해서 구할 수 있다.<em>(이하 F() 로 통일)</em></p><p>그렇다면 F(0)과 F(1)을 구하기 위해 F(-1)과 같은 음수로 가느냐?<br>그렇지는 않고, 0과 1의 값은 각각 0과 1로 정의되어 있다.</p><p><img loading=lazy src=/assets/images/2020-10-25-06-03-21_2020-10-16-recursive_function.md.png alt></p><p>간단하게, <code>F(4)</code>를 구해보자.
이를 구하기 위해서는, <code>F(3)</code>과 <code>F(2)</code>를 알아야 한다.<br><code>F(3)</code>과 <code>F(2)</code>를 구하기 위해서는, <code>F(2)</code>와 <code>F(1)</code>을, 그리고 <code>F(1)</code>과<code> F(0)</code>을 구해야 한다.</p><p><code>F(1)</code>과 <code>F(0)</code>은 1과 0으로 정의되어 있으니, 다시 거꾸로 타고 올라가면 된다.</p><p><strong>F(2) = F(1) + F(0) = 1 + 0 = 1</strong><br><strong>F(3) = F(2) + F(1) = 1 + 1 = 2</strong><br><strong>F(4) = F(3) + F(2) = 2 + 1 = 3</strong></p><p>답이 나왔다. F(4)의 답은 <strong>3</strong> 이다.</p><h1 id=3-해결법>3. 해결법<a hidden class=anchor aria-hidden=true href=#3-해결법>#</a></h1><p>: 여러 가지 해결 방법이 있지만, 반복문과 오늘의 핵심인 재귀함수 두가지 방법을 이용해보자.</p><h2 id=1-반복문>1) 반복문<a hidden class=anchor aria-hidden=true href=#1-반복문>#</a></h2><p>: 반복문을 이용하는 방법은 간단하다.<br>배열을 만들어놓고, 전항의 값, 그리고 전전항의 값을 더해서 넣으면 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fibonacci</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> fibo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>+</span>1<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    fibo<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    fibo<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 2<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> fibo<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        fibo<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> fibo<span style=color:#f92672>[</span>i<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> fibo<span style=color:#f92672>[</span>i<span style=color:#f92672>-</span>2<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fibo<span style=color:#f92672>[</span>n<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>보는 바와 같이, 0번째 항과 1번째 항은 0과 1로 값을 미리 채워두고,<br>반복문을 통해 더해가면서 구할 수 있다.</p><h2 id=2-재귀함수>2) 재귀함수<a hidden class=anchor aria-hidden=true href=#2-재귀함수>#</a></h2><p>: 그렇다면, 재귀함수는 어떨까?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fibonacci</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>==</span> 1<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fibonacci<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span>1<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> fibonacci<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span>2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>삼항연산자로도 풀어낼 수 있지만,<br>가장 기본에 충실하게 작성하면 위와 같이 작성할 수 있다.</p><p>n에 3이 들어오는 경우,
<code>fibonacci(2)</code>와 <code>fibonacci(1)</code> 이 각각 호출되고,<br><code>fibonacci(2)</code>는 <code>fibonacci(1)</code>과 <code>fibonacci(0)</code>을 호출한다.</p><p><code>fibonacci(1)</code>은 1을, <code>fibonacci(0)</code>은 0을 return하므로,<br>이 둘을 더해 <code>fibonacci(2)</code>는 1이 된다.</p><p>따라서, <code>fibonacci(2) + fibonacci(1)</code>은 <code>1+1</code>이 되어,<br>최종적으로 2가 return된다.</p><p>여기까지 모두가 행복하게 잘 살았습니다의 해피엔딩으로 끝나면 좋겠지만,<br><strong>문제가 남아있다.</strong></p><h1 id=4-문제점>4. 문제점<a hidden class=anchor aria-hidden=true href=#4-문제점>#</a></h1><p>: 만약, 피보나치에 100을 요구하면 어떻게 될까?<br>결과가 나타나지 않는다. 너무 오래 걸리는 탓이다.<br>반토막을 내서 50을 넣어봐도, 약 65초가 걸렸다.<br>(여담으로 값은 약 120억으로, int형의 최대값인 21억을 훨씬 넘어선다.)</p><p>왜 이렇게 오래 걸릴까?<br>그 이유는, 재귀함수를 돌면서, Call Stack이 쌓이기 때문이다.</p><p>위 코드를 다시 보자.<br><code>fibonacci(n)</code>을 구하기 위해, <code>fibonacci(n-1)</code>, <code>fibonacci(n-2)</code>를 수행해야 한다.<br>당연하게 보이지만, <code>fibonacci(n-1)</code>과 <code>fibonacci(n-2)</code>를 구하기 전까지는,<br><code>fibonacci(n)</code>은 대기하고 있는 상태이다.</p><p>즉, n이 0 또는 1이 되기 전까지는 계속해서 대기, 대기, 대기 하는 함수들이 쌓이고,<br>0 또는 1이 되어서야 다시 돌아와서 값을 구하고, 더해야 하기 때문이다.</p><p><img loading=lazy src=/assets/images/2020-10-25-06-44-21_2020-10-16-recursive_function.md.png alt></p><h1 id=5-해결-방법>5. 해결 방법<a hidden class=anchor aria-hidden=true href=#5-해결-방법>#</a></h1><p>: 이는 다음의 두 가지 방법으로 해결할 수 있다.</p><h2 id=1-tail-recursion>1) Tail Recursion<a hidden class=anchor aria-hidden=true href=#1-tail-recursion>#</a></h2><p>: 먼저 활용할 수 있는 방법은 꼬리재귀를 이용하는 방법이다.<br>꼬리재귀는, 재귀함수의 탈을 쓴 while문과 같다.</p><p>앞서, 위와 같이 계속해서 Stack이 쌓였던 이유는,<br><code>fibonacci(n-1)</code>과 <code>fibonacci(n-2)</code>를 구하고 나서,<br>이를 더하는 연산이 필요했기 때문이다.</p><p>즉, <strong>아직 할 일이 남아있었다.</strong></p><p>그런데, 할 일이 없다면 어떨까?<br>그냥 곧바로, 가장 최초로 함수를 실행한 지점으로 return을 쏴버리면 안될까?<br>안될 것 없다.</p><p>코드를 다음과 같이 수정해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fibonacci</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fibonacciTail<span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fibonacciTail</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> prev<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> next<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> prev<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fibonacciTail<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span>1<span style=color:#f92672>,</span> next<span style=color:#f92672>,</span> prev<span style=color:#f92672>+</span>next<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>앞서 코드는, fibonacci(n)을 구하기 위해서<br>계산을 최대한 뒤로 미루는 듯한 느낌을 받았는데,</p><p>새로운 코드는 계산을 한다음에 그 값을 넘겨준다.<br>그리고, 직접 디버깅으로 하나하나 실행해보면 알겠지만,<br>n이 되는 순간 곧바로 <code>fibonacciTail()</code>이 아닌 <code>fibonacci()</code> 로 쏴버린다.</p><p>반복 횟수는 어떨까?<br>Fibonacci(10)을 기준으로,<br>기존의 방식은 <strong>177번</strong>,<br>새로운 방식은 <strong>11번</strong> 반복했다.</p><p>N이 늘어나면 늘어날수록, 이 차이는 더더욱 극명하게 드러날 것이다.</p><blockquote><p>Note. 좀 더 자세히 찾아보았는데, <strong>진정한</strong> 꼬리재귀는 Stack Frame 자체를 쌓지 않는다. 즉, <strong>꼬리재귀함수를 지원하지 않는다는 Python</strong> 에서도, 위와 같은 코드는 구현할 수 있고, 실제로 잘 동작하기도 한다. 그러나, <strong>꼬리재귀함수를 지원하는</strong> 컴파일러인 경우, 애초에 Stack Frame을 쌓지 않도록 이를 while문으로 애초에 <strong>&ldquo;바꾸어버린다&rdquo;</strong> 는 것이다. 따라서, 다음과 같이 정리할 수 있겠다.</p></blockquote><blockquote><p>꼬리재귀를 지원하는 경우 : 애초에 while문으로 바뀌기 때문에, Stack Frame 자체가 쌓이지 않음. 즉, StackOverflow 의 에러가 절대 발생하지 않는다. -> Tail Call Optimization<br>꼬리재귀를 지원하지 않는 경우 : 위와 같은 로직으로 최적화는 되더라도, Stack은 쌓이기 때문에, StackOverflow가 발생할 수 있다.</p></blockquote><h2 id=2-동적계획법cache을-이용>2) 동적계획법(cache)을 이용<a hidden class=anchor aria-hidden=true href=#2-동적계획법cache을-이용>#</a></h2><p>: 문제가 발생했던 코드의 경우, <strong>같은 연산을 반복하는</strong> 코드가 존재한다.</p><p>즉, <code>F(4)</code>를 구하기 위해서, <code>F(3)</code>과 <code>F(2)</code>를 구해야 했는데,<br><code>F(3)</code>을 구하기 위해서, <strong>또 다시</strong> <code>F(2)</code> 에 대한 연산을 해야하는 것이다.</p><p>그러므로, 재귀함수를 반복하면서,<br><strong>구하고자 하는 값이, 처음 구하는 경우에는 직접 연산</strong>,<br><strong>한번 구한적 있는 값이라면, 꺼내오기</strong><br>를 이용하면, 좀 더 똑똑하게 가져올 수 있다.</p><p>다음과 같이 코드를 작성해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> fibo<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    fibo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>+</span>1<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> fibonacci<span style=color:#f92672>(</span>n<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fibonacci</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>fibo<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> fibo<span style=color:#f92672>[</span>n<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>==</span> 1<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fibo<span style=color:#f92672>[</span>n<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> fibonacci<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span>1<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> fibonacci<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span>2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fibo<span style=color:#f92672>[</span>n<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>int[] 배열 fibo를 선언한 뒤, main method에서 n+1 만큼의 길이로 정의해주었다.</p><p>다음으로, <code>fibonacci()</code> 함수가 실행될 때마다,<br>값이 있는지 확인하고,<br><strong>없는 경우에는 기존의 로직을</strong>,<br><strong>있는 경우에는 그 값을 곧바로 return하도록</strong> 만들었다.</p><p>그리고 최종적으로, 원하는 fibonacci 값인 <code>fibo[n]</code>을 return했다.<br>반복 횟수는, 10을 기준으로 19번을 반복했다.</p><h1 id=6-마치며>6. 마치며<a hidden class=anchor aria-hidden=true href=#6-마치며>#</a></h1><p>: 하나의 문제를 푸는데에 여러 가지 방법을 아는 것은 큰 도움이 된다.<br>모든것을 한방에 해결해주는 만능 알고리즘은 없으니,<br>상황에 맞게 적절하게 사용하는 것이 중요한데,<br>이 때 내가 <strong>어떤 무기, Tool</strong>을 갖고 있느냐에 따라<br>선택의 폭도 달라지고, 생각의 틀도 격변하기 때문인 것 같다.</p><p>위 피보나치를 구하는 방법에도,<br>일반항을 이용하는 방법이나, 행렬을 이용하는 방법이 있다고 하는데,<br>본 포스팅의 목적은 피보나치가 아닌 재귀함수 이므로 이에 대해서 따로 찾아보지는 않았다.<br>궁금한 사람은 이하의 Reference를 참고하면 좋겠다.</p><p>이상으로 포스팅을 마칩니다.</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://shoark7.github.io/programming/algorithm/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-5%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95.html>피보나치 수열 알고리즘을 해결하는 5가지 방법</a></li><li><a href=http://philosophical.one/posts/tail-recursion-in-python/>Tail Recursion in Python</a></li><li><a href=https://stackoverflow.com/questions/1240539/what-is-tail-recursion-elimination>StackOverflow - What is tail-recursion elimination?</a></li><li><a href=https://en.wikipedia.org/wiki/Tail_call>Wikipedia - Tail call</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/null/>null</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 재귀함수 주무르기 with 피보나치 수열 ( feat. Java ) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98%20%ec%a3%bc%eb%ac%b4%eb%a5%b4%ea%b8%b0%20with%20%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98%20%ec%88%98%ec%97%b4%20%28%20feat.%20Java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-16-recursive_function%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 재귀함수 주무르기 with 피보나치 수열 ( feat. Java ) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-16-recursive_function%2f&title=%23%20%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98%20%ec%a3%bc%eb%ac%b4%eb%a5%b4%ea%b8%b0%20with%20%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98%20%ec%88%98%ec%97%b4%20%28%20feat.%20Java%20%29&summary=%23%20%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98%20%ec%a3%bc%eb%ac%b4%eb%a5%b4%ea%b8%b0%20with%20%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98%20%ec%88%98%ec%97%b4%20%28%20feat.%20Java%20%29&source=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-16-recursive_function%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 재귀함수 주무르기 with 피보나치 수열 ( feat. Java ) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-16-recursive_function%2f&title=%23%20%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98%20%ec%a3%bc%eb%ac%b4%eb%a5%b4%ea%b8%b0%20with%20%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98%20%ec%88%98%ec%97%b4%20%28%20feat.%20Java%20%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 재귀함수 주무르기 with 피보나치 수열 ( feat. Java ) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-16-recursive_function%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 재귀함수 주무르기 with 피보나치 수열 ( feat. Java ) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98%20%ec%a3%bc%eb%ac%b4%eb%a5%b4%ea%b8%b0%20with%20%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98%20%ec%88%98%ec%97%b4%20%28%20feat.%20Java%20%29%20-%20http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-16-recursive_function%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 재귀함수 주무르기 with 피보나치 수열 ( feat. Java ) on telegram" href="https://telegram.me/share/url?text=%23%20%ec%9e%ac%ea%b7%80%ed%95%a8%ec%88%98%20%ec%a3%bc%eb%ac%b4%eb%a5%b4%ea%b8%b0%20with%20%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98%20%ec%88%98%ec%97%b4%20%28%20feat.%20Java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fpost%2ftech%2fbtb%2f2020-10-16-recursive_function%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>