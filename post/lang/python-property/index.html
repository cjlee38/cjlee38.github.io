<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>python property | cjlee38</title>
<meta name=keywords content="null"><meta name=description content="흔히 &ldquo;객체지향&rdquo; 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용한다. Java 에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.
class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/lang/python-property/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cjlee38.github.io/post/lang/python-property/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta property="og:title" content="python property"><meta property="og:description" content="흔히 &ldquo;객체지향&rdquo; 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용한다. Java 에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.
class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/lang/python-property/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-09-16T22:05:00+00:00"><meta property="article:modified_time" content="2021-09-16T22:05:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="python property"><meta name=twitter:description content="흔히 &ldquo;객체지향&rdquo; 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용한다. Java 에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.
class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"python property","item":"https://cjlee38.github.io/post/lang/python-property/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"python property","name":"python property","description":"흔히 \u0026ldquo;객체지향\u0026rdquo; 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용한다. Java 에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.","keywords":["null"],"articleBody":"흔히 “객체지향” 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용한다. Java 에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } public void setAge(int age) { if (age \u003c= 0) throw new IllegalArgumentException(\"나이는 0 이하가 될 수 없다.\"); this.age = age; } } public class Main { public static void main(String[] args) { Person person = new Person(\"Mr.Kim\", 26); System.out.println(person.getName()); // \"Mr.Kim\"; person.setAge(-62); // IllegalArgumentException(\"나이는 0 이하가 될 수 없다.\") } } 그러나 python 에서는 programming language 수준에서 접근 권한을 제어할 수 없다. _(언더스코어) 를 활용하는 방법을 제공하기는 하지만, 결국 _{클래스명}__{변수명} 으로 접근이 가능합니다.(이후 뒤에서 설명할 property도 결국 직접 접근하는 방법은 있다.)\n따라서 python 에서는 기본적으로 모두 public 이라고 생각하면 된다. 하지만 그렇다고 해서 getter/setter를 쓸 필요가 없다는 것은 아니다. 당장 위와 같은 예시만 보더라도, setAge() 메소드를 호출할 때, 나이가 음수인지 아닌지 검증하는 로직이 필요하기 때문이다. 위 코드를 python 으로는 다음과 같이 쓸 수 있다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age # 다른 메소드는 편의상 생략 def set_age(self, new_age) : if new_age \u003c= 0 : raise Exception(\"나이는 0 이하가 될 수 없다.\") self._age = new_age if __name__ == '__main__' : person = Person(\"Mr.Kim\", 26) person.set_age(-62) # Exception('나이는 0 이하가 될 수 없다.') 여기까지는 Java와 똑같다. 하지만, 이런 식의 코드 사용은 explicit 하지 못하다는 단점이 있다. 만약 기존 나이에서 1살을 더해줘야 한다면, 다음과 같이 작성해야 한다.\nperson.set_age(person.get_age() + 1) 뿐만 아니라, person._age = -62 와 같은 코드는 방어할 수가 없어진다는 문제도 여전히 남아있다. 그러나 @property 를 활용하면 다음과 같은 코드가 가능하다.\nperson.age += 1 person.age = -62 # Exception('나이는 0 이하가 될 수 없다.') ??? 어떻게 된 일일까? 겉으로 보기에는 변수에 값을 직접 대입하는 것 같은데, 로직에 따른 Exception을 던지고 있다. 어떻게 이것이 가능한지는 차차 알아보기로 하고, 일단 생김새부터 살펴보자. 위 Person 클래스에 @Property를 적용하면 다음과 같이 작성할 수 있다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age @property def age(self) : return self._age @age.setter def age(self, new_age) : if new_age \u003c= 0 : raise Exception(\"나이는 0 이하가 될 수 없다.\") self._age = new_age 대충 살펴 봤을때, 눈에 띄는 차이점은 다음과 같다.\n함수의 이름이 get_age 혹은 set_age 가 아니라, 그냥 age 자체로 변경되었다. 계속 언급했던 @property 가 age 메소드 위에 붙었다. 또한, @age.setter 라는 녀석도 두 번째 age 메소드 위에 붙어있다. 이러한 변화가 어떻게 앞서 언급했던 동작에 영향을 미쳤는지 하나씩 알아보자.\n@property를 이해하기 위한 배경지식들은 다음과 같다.\nEverything is Object Decorator Descriptor Object 1. Everything is Object Python에서 다루는 모든 값은 객체이다. Java에서는 일반적으로 값을 Primitive Type, Reference Type 으로 구분한다. 반면 Python에서는 int, bool과 같은 값들도 모두 객체로 다뤄진다.\na = 1 print(id(a)) # 4341049696 id 함수는 Built-in 함수로, 객체가 가지고 있는 주소값을 나타낸다. 따라서 id(a)라는 코드는 1 이라는 값이 할당된 메모리 주소를 반환한다. Java에서는 Integer 와 비슷하다고 생각할 수 있다.\n이에 더해, Python 에서는 함수마저도 객체이다.\ndef my_func() : return \"hello world\" print(my_func.__str__()) # '' 위 예시에서 보시다시피, my_func 이라는 이름의 함수를 만든 뒤, 해당 함수가 갖고 있는 __str__ 이라는 메소드를 호출할 수 있다. 즉, my_func 자체는 Function 이라는 클래스를 상속하는 클래스다.\n간단하게 생각하면, def my_func() 라는 키워드는 my_func = {함수 바디} 와 같이 변수로 정의되는 것을 상상해볼 수 있다.\nNote. 함수가 객체라는 이야기를 할 때, 1급 시민 이라는 키워드가 자주 등장한다. 1급 시민이란, 변수에 할당할 수 있어야 하고, argument로 전달될 수 있으며, return 으로 반환될 수 있는 값들을 말합니다. Java에서 메소드는 일급 객체가 아니지만, 인터페이스를 활용해 1급 시민의 흉내를 낼 수 있다.\n2. Decorator 데코레이터를 이야기하려면 Python 함수가 갖는 또 다른 특징을 알아야 한다.\n1) 함수는 중첩이 가능하다. python은 다음과 같이 함수를 중첩해서 정의할 수 있다.\ndef outer() : def inner() : print('inner called') print('outer called') inner() return inner var = outer() # outer called \\n inner called (1) var() # inner called (2) outer 함수 안에 inner 함수를 정의한 뒤, inner 함수를 호출했다. 따라서 var = outer() 를 통해 outer함수를 호출할 때, 내부에 있는 inner 함수 (1)도 실행된다.\n다음으로 return inner를 통해 inner 함수 그 자체를 돌려주고, 해당 함수 객체는 var 라는 변수에 저장된다. 따라서 var() 를 통해 함수를 실행하는 것은 결국 inner 함수를 실행하는 것과 같다.\n2) Enclosed Function Locals python의 함수가 갖는 두 번째 특징은, 이러한 중첩 함수로 인해 조금 특별한 변수 scope가 생긴다는 것이다. C를 처음 배웠을 무렵, 지역변수 전역변수와 같은 개념에 대해서 배우고, “내가 허용된 범위의 바깥 변수는 알 수 없다”, “가까운 scope부터 찾아 나간다” 정도의 개념으로 정리하고 넘어갔다. python에서는 후자, 즉 “가까운 scope부터 찾아 나간다\"는 맞는 말이지만, 전자인 “내가 허용된 범위 바깥 변수는 알 수 없다” 는 조금 다르다. 한마디로, “내가 허용된 범위 바깥 변수에 접근할 수는 있지만, 수정할 수는 없다.”.\nx = 1 def outer() : y = 2 def inner() : z = 3 print(z, y, x) inner() return inner a = outer() # 3 2 1 a() # 3 2 1 아까 예시를 들었던 outer/inner 함수를 약간 변형해보았다. outer 함수가 실행되던 와중에 inner가 호출되든, 함수 객체를 return 받은 a가 호출되든 상관없이, 모두 3 2 1을 출력한다.\nNote. python에서는 가까운 곳부터 찾아나가는 접근법을 LEGB 규칙 이라고 명명한다. 순서대로 Local, Enclosed function locals, Global, Built-in 의 약자이며, z, y, x 변수가 이에 해당한다. 마지막 Built-in 변수는 __name__과 같이 “내가 정의하지도 않았는데 기존에 정의되어 있던 값들\"을 말한다.\n하지만 다음의 예시는 쓰기에 대해서는 조금 다른 결과임을 보여준다.\nx = 1 def outer() : y = 2 def inner() : z = 3 y += 1 # UnboundLocalError: local variable 'y' referenced before assignment x += 1 # UnboundLocalError: local variable 'x' referenced before assignment print(z, y, x) inner() return inner a = outer() a() inner 내부에서 y와 x에 대해서 값을 1씩 더하려고 하자 할당되기 전에 참조되었다는 에러를 발생시킨다. 즉, 자기 자신의 scope 바깥에 있는 변수에 대해서는 “쓰기” 연산에 대해, 즉 “변경\"에 대해 제한되어 있다.\nNote. 만약 해당 값을 수정하고 싶다면 nonlocal 혹은 global 키워드를 통해 “내가 외부의 값을 수정하고자 한다” 라는 의도를 드러내야 한다.\n3) Closure Closure는 위키피디아에서 다음과 같이 설명하고 있다.\n컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 이러한 설명은 처음 Closure를 접한 사람들에게 전혀 도움이 되지 않다. 심지어 Closure라는 네이밍 그 자체에서도 어떠한 힌트를 얻기는 어렵다. 예시를 살펴보면서 이해해보자.\ndef outer(val) : def inner() : print('inner called') print(val) print('outer called') return inner a = outer(10) # ??? a() # ??? 첫 번째로 실행한 a = outer(10), 두 번째로 실행한 a() 코드가 각각 어떻게 돌아갈지 한번 상상해보자.\na = outer(10)에 의해 outer 함수를 호출했고, argument로 10을 넘겨주고, 이를 val 이라는 이름으로 받아냈다. 그 내부에서 inner 함수를 정의했고, outer called 를 출력한 뒤, inner 함수 객체를 돌려준다.\n두 번째로 a() 를 통해, a 변수가 갖고 있는 inner 함수 객체를 호출한다. inner called를 출력한 뒤, val을 출력하려고 하는데, 여기서 의문점이 하나 생긴다. 해당 함수는 자신 바깥에 있는, 즉 val 변수를 참조하고 있다. 앞서 이야기한 LEGB 규칙에 따르면, L 에서 E를 참조하는 셈이다.\n여기서 val은 살아 있을까? 바꿔말하면, val 변수를 참조해서 아까 넣어준 10 이라는 값을 얻어낼 수 있을까? 정답은 “그렇다” 입니다.\n이렇게 보니 마치 outer 라는 클래스가 val 이라는 멤버변수를 가지고 있는 것처럼 느껴진다. 여기까지 읽고 나서, 다시 위키피디아의 정의를 살펴보자.\n컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 이렇게 보니 100% 이해하지는 못하더라도, 어떤 느낌으로 설명하고 있는지는 알 수 있다. Closure라는 이름 또한 직역 시 “폐쇄” 라는 뜻을 갖고 있는데, 조금 과장해서 “나만의 구역\"과 같은 느낌이 연상되기도 한다.\nNote. 어떠한 함수 A 가 Closure이기 위해서는 다음의 세 가지 조건이 만족되어야 한다.\nA 함수는 다른 함수 B 안에 정의된 함수, 즉 중첩된 함수여야 한다. 자신을 둘러싼 함수 B scope 의 값을 참조해야 한다. B 함수는 A 함수를 반환해야 한다. 여기서 한 단계 더 나아가보자.\ndef outer(func) : def inner() : print('inner called') func() print('outer called') return inner def my_func() : print('my_func called') a = outer(my_func) # outer called a() # inner called \\n my_func called 앞서는 val 이라는 숫자 값을 넣어줬지만, 이번에는 my_func 이라는 함수를 넣어주고 있다. 거듭 반복해서 확인할 수 있듯이, 함수 또한 객체이기 떄문에(a.k.a 1급 시민) 다른 함수의 argument로 전달될 수 있다.\n여기서는 outer 라는 함수의 argument로 my_func을 전달하고 있고, 좀 전과 마찬가지로 my_func는 outer 함수의 호출이 끝나더라도 inner에 의해 참조되고 있다.\n4) Decorator 정리 Decorator를 알기 위한 사전 지식은 준비되었으니, 이제 본격적으로 알아보자.\n바로 위의 예시에서는 a = outer(my_func) 라는 함수를 통해 closure를 만들고, a() 를 통해 inner 함수, 즉 closure 를 호출했다. Decorator를 활용하면 이를 보다 손쉽게 정의할 수 있다.\n즉, 다음의 두 코드는 같다.\n기존\ndef outer(func) : ... def my_func() : ... a = outer(my_func) # outer called a() # inner called \\n my_func called 데코레이터\ndef outer(func) : ... @outer # outer called def my_func() : ... a = my_func() # inner called \\n my_func called 여기서 한 가지 주의할 점은, 데코레이터 버전에서 outer called 는 @outer를 붙여서 my_func를 정의하는 시점에 호출된다는 점이다. 이렇게 보면 Decorator 라는 이름이 왜 Decorator 인지 알 수 있다.\n3. Descriptor Object Descriptor 는 객체 A가 갖고있는 속성인 객체 B를 다룰 때 조회, 저장 및 삭제를 사용자 정의할 수 있는 객체 B를 디스크립터라고 이야기한다. 이 Descriptor라는 녀석은 객체 A의 클래스 변수로서 정의되어야 한다. (the descriptor must be in either the owner’s class dictionary or in the class dictionary for one of its parents)\n역시, 예시를 보면서 진행하겠다.\nclass Age : def __init__(self, age) : self._age = age def __get__(self, obj, objtype) : print(\"__get__ method called\") return self._age def __set__(self, obj, val) : print(\"__set__ method called\") self._age = val def __delete__(self, obj) : print(\"__delete__ method called\") self._age = -1 class Person : age = Age(26) p = Person() print(p.age) # __get__ method called \\n 26 p.age = 20 # __set__ method called del p.age # __delete__ method called print(p.age) # __get__method called \\n -1 Age 라는 클래스를 만들고, __get__, __set__, __delete__ 메소드를 정의했다. 이 세개의 메소드는 스페셜 메소드 라고 불리우며, 객체가 갖는 특성을 지정할 수 있다. 가장 대표적으로 __init__ 메소드는 인스턴스 생성시에 동작하는 행위에 대해서 정의할 수 있다.\n어떠한 객체에 위에서 언급한 세 개의 __get__, __set__, __delete__ 메소드가 정의되었을 경우, 해당 객체를 “디스크립터” 라고 부르게 된다.\nNote. __get__ 메소드만 정의된 경우에는 Non-data Descriptor, __set__ 메소드 혹은 __delete__ 메소드가 정의된 경우에는 Data Descriptor 라고 부른다. 이 둘의 차이는 우선순위에 있다만, 여기서는 다룰 내용이 아닌지라 넘어가겠다.\n이렇게 Descriptor를 정의할 경우, 해당 객체로 접근할 때 우리가 생각했던 것처럼 값에 직접 접근하는 것이 아니라, 메소드 호출을 통해 접근하게 된다. 그림으로 보면 다음과 같이 상상해 볼 수 있다.\nDescriptor 라는 특별한 개념이 없다면, 코드 상으로는 객체가 위 그림과 비슷한 형태로 구성될 것이라고 예측할 수 있다. Person 안에 Age 객체가, 그리고 Age 객체 안에 _age 라는 멤버변수, __getter__, __setter__ 라는 메소드를 가질 뿐이다. 따라서 p.age 로 접근하게 되면 Age() 객체로 접근할 것처럼 보인다. 하지만 실질적으로는 다음 그림과 같다.\np.age를 호출하게 되는 순간, Person 객체 내에 있는 Age() 객체를 가져오려 하는데, __get__ 메소드가 오버라이드 되어 실질적으로는 Age() 객체가 아닌 그 내부의 self._age를 돌려주게 된다.\n이러한 동작 방식을 보고나면, 왜 Data Descriptor 라는 이름을 갖게 되었는지 알 수 있다. Data Descriptor로 정의된 객체는, 일반적으로 생각하는 것처럼 값을 갖고 메소드라는 행위를 갖지 않고, 대신 내가 원하는 Data(여기서는 _age라는 int 변수)에 대한 톨게이트와 같은 역할을 하게 된다.\n4. Property 장황한 이야기를 끝내고, 드디어 Property에 대한 이야기를 해보자. 앞서 보여드렸던 Property 사용 예시는 다음과 같다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age @property def age(self) : return self._age @age.setter def age(self, new_age) : if new_age \u003c= 0 : raise Exception(\"나이는 0 이하가 될 수 없다.\") self._age = new_age Decorator에 대해서 이해하고 왔으니, @property 라는 코드를 통해, property 라는 함수(함수는 다시 객체이니 정확히는 property라는 객체)로 age 라는 메소드를 전달한다는 사실을 알 수 있다.\n따라서, 아래와 같은 코드는\n@property def age( ... ) : ... 실질적으로는 다음과 같다고 볼 수 있다.\nage = property(age) 아까전에 def my_func() 라는 코드는 my_func = {함수바디}와 같이 변수로 정의되는 것을 상상해볼 수 있다고 이야기 했다. 여기서도 같은 맥락임을 확인할 수 있는데, 왜냐하면, @property 데코레이터를 사용해 age = property(age)로, 즉 클래스 변수로 만들었기 때문이다. (Descriptor는 반드시 클래스 변수에 있어야 한다는 사실을 상기하자.)\n파이썬 공식 문서에 있는 property의 생김새는 다음과 같다.\nclass Property: \"Emulate PyProperty_Type() in Objects/descrobject.c\" def __init__(self, fget=None, fset=None, fdel=None, doc=None): self.fget = fget self.fset = fset self.fdel = fdel if doc is None and fget is not None: doc = fget.__doc__ self.__doc__ = doc def __get__(self, obj, objtype=None): if obj is None: return self if self.fget is None: raise AttributeError(\"unreadable attribute\") return self.fget(obj) def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set attribute\") self.fset(obj, value) def __delete__(self, obj): if self.fdel is None: raise AttributeError(\"can't delete attribute\") self.fdel(obj) def getter(self, fget): return type(self)(fget, self.fset, self.fdel, self.__doc__) def setter(self, fset): return type(self)(self.fget, fset, self.fdel, self.__doc__) def deleter(self, fdel): return type(self)(self.fget, self.fset, fdel, self.__doc__) 자, 이제 어떻게 코드가 동작하는지에 대해서 이해할 준비가 되었으니, 한 줄씩 따라가보며 총 정리해보자.\n@property def age( ... ) : ... 위 코드를 통해 age = property(age) 가 실행된다고 언급했다. property의 생성자 인자로 age라는 메소드를 넘겨줬으니, 이 age는 __init__ 메소드 내부에서 fget 이라는 변수에 할당됨을 확인할 수 있다. 그리고 @property를 적용한 Person 클래스의 현재 생김새는 다음과 같다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age def age(self) : return self._age age = property(age) @age.setter def age(self, new_age) : if new_age \u003c= 0 : raise Exception(\"나이는 0 이하가 될 수 없다.\") self._age = new_age 다음으로 @age.setter 부분을 살펴보자. 현재 age는 property 객체인 상태다. 그러면 @age.setter는 다음과 같이 해석된다. age가 계속 나와 헷갈리니 주석을 참고하자.\nage = property(age) # age(1번) = property(age(2번)) # age 라는 이름의 변수(1번)에 'age 메소드'(2번)를 인자로 넘긴 property 객체를 저장. age = age.setter(age) # age(3) = age(1).setter(age(4)) # age라는 이름의 변수(3번)에, property 객체를 갖고 있는 age 변수(1번)의 setter 메소드에 새로운 age 메소드(4)를 넘겨준다. 그리고 setter 메소드를 살펴보면,\ndef setter(self, fset): return type(self)(self.fget, fset, self.fdel, self.__doc__) type(self) 부분은 자기 자신에 대한 type을 구하고 있다. self는 property 이니 다음과 같이 해석된다.\ndef setter(self, fset): return property(self.fget, fset, self.fdel, self.__doc__) 자기 자신에 대해서 생성자를 호출하고 있다. 꼭 마치 자바에서 생성자에 this()와 비슷해 보인다. 또한, 나머지는 self 키워드를 붙여서 자기 자신이 갖고 있던 녀석들을 넘겨주고, fset 위치에만 age(self, new_age) 라는 메소드를 넘겨주고 있다.\n이제 Person 객체에서 age를 접근할 때 무슨일이 일어날까? p.age 로 꺼낸 age는 property 객체라는 사실은 이 쯤 되면 잘 알 것이다. property 객체는 연이어 __get__ 메소드를 호출할 것이다.\ndef __get__(self, obj, objtype=None): if obj is None: return self if self.fget is None: raise AttributeError(\"unreadable attribute\") return self.fget(obj) __get__ 메소드의 인자 obj는 자기 자신을 실행한 인스턴스, objtype은 해당 클래스를 의미한다. p.age로 인스턴스를 통해 실행했으니 obj는 p일 것이고, objtype 은 Person 이다.\nobj가 None이 아니고, fget 또한 아까 할당되었으니, return self.fget(obj)가 실행된다.\n즉, fget(obj) 의 fget은 앞서 정의한 def age(self) 이니, 아까 내가 정의한 getter 메소드, 즉 다음 메소드가 실행된다.\ndef age(self) : return self._age 다음으로 __set__ 메소드를 살펴보자. p.age = -10 이라고 작성했다면, 역시 p.age 변수가 갖고 있는 객체는 property 객체이고, 해당 객체의 __set__ 메소드가 호출된다.\ndef __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set attribute\") self.fset(obj, value) 마찬가지로 obj는 자기 자신을 실행한 인스턴스, 즉 p 이고, value는 -10 입니다. fset 변수는 앞서 할당한 def age(self, new_age) 함수 객체이고, None이 아니니 self.fset(obj, value)를 실행한다. 즉, 다음 메소드가 실행된다.\ndef age(self, new_age) : if new_age \u003c= 0 : raise Exception(\"나이는 0 이하가 될 수 없다.\") self._age = new_age Reference Python의 Closure에 대해 알아보자 Wikidocs 레벨업 파이썬 - 클로저 Python 공식문서 - Descriptor Hardcore in Programming - Descriptor [Python 지식]- Descriptor 우선순위 ","wordCount":"2554","inLanguage":"en","datePublished":"2021-09-16T22:05:00Z","dateModified":"2021-09-16T22:05:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/lang/python-property/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">python property</h1><div class=post-meta><span title='2021-09-16 22:05:00 +0000 UTC'>September 16, 2021</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/lang/python-property.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-everything-is-object aria-label="1. Everything is Object">1. Everything is Object</a></li><li><a href=#2-decorator aria-label="2. Decorator">2. Decorator</a><ul><li><a href=#1-%ed%95%a8%ec%88%98%eb%8a%94-%ec%a4%91%ec%b2%a9%ec%9d%b4-%ea%b0%80%eb%8a%a5%ed%95%98%eb%8b%a4 aria-label="1) 함수는 중첩이 가능하다.">1) 함수는 중첩이 가능하다.</a></li><li><a href=#2-enclosed-function-locals aria-label="2) Enclosed Function Locals">2) Enclosed Function Locals</a></li><li><a href=#3-closure aria-label="3) Closure">3) Closure</a></li><li><a href=#4-decorator-%ec%a0%95%eb%a6%ac aria-label="4) Decorator 정리">4) Decorator 정리</a></li></ul></li><li><a href=#3-descriptor-object aria-label="3. Descriptor Object">3. Descriptor Object</a></li><li><a href=#4-property aria-label="4. Property">4. Property</a><ul><li><a href=#reference aria-label=Reference>Reference</a></li></ul></li></ul></div></details></div><div class=post-content><p>흔히 &ldquo;객체지향&rdquo; 에서는, 객체가 갖고 있는 <code>Field</code> 를 적절하게 외부로 노출시키거나 숨기기 위해, <code>getter/setter</code>를 사용한다. Java 에서는 <code>private</code> 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 <code>getter</code> 메소드를, 외부에 의해 변경되어도 되는 변수는 <code>setter</code> 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (age <span style=color:#f92672>&lt;=</span> 0) 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;나이는 0 이하가 될 수 없다.&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person person <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Mr.Kim&#34;</span>, 26);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(person.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Mr.Kim&#34;;</span>
</span></span><span style=display:flex><span>        person.<span style=color:#a6e22e>setAge</span>(<span style=color:#f92672>-</span>62); <span style=color:#75715e>// IllegalArgumentException(&#34;나이는 0 이하가 될 수 없다.&#34;)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>그러나 python 에서는 programming language 수준에서 접근 권한을 제어할 수 없다. _(언더스코어) 를 활용하는 방법을 제공하기는 하지만, 결국 <code>_{클래스명}__{변수명}</code> 으로 접근이 가능합니다.(이후 뒤에서 설명할 property도 결국 직접 접근하는 방법은 있다.)</p><p>따라서 python 에서는 기본적으로 모두 <code>public</code> 이라고 생각하면 된다. 하지만 그렇다고 해서 <code>getter/setter</code>를 쓸 필요가 없다는 것은 아니다. 당장 위와 같은 예시만 보더라도, <code>setAge()</code> 메소드를 호출할 때, 나이가 음수인지 아닌지 검증하는 로직이 필요하기 때문이다. 위 코드를 python 으로는 다음과 같이 쓸 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, age) :
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 다른 메소드는 편의상 생략</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_age</span>(self, new_age) :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> new_age <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> :
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;나이는 0 이하가 될 수 없다.&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> new_age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span> :
</span></span><span style=display:flex><span>    person <span style=color:#f92672>=</span> Person(<span style=color:#e6db74>&#34;Mr.Kim&#34;</span>, <span style=color:#ae81ff>26</span>)
</span></span><span style=display:flex><span>    person<span style=color:#f92672>.</span>set_age(<span style=color:#f92672>-</span><span style=color:#ae81ff>62</span>) <span style=color:#75715e># Exception(&#39;나이는 0 이하가 될 수 없다.&#39;)</span>
</span></span></code></pre></div><p>여기까지는 Java와 똑같다. 하지만, 이런 식의 코드 사용은 <code>explicit</code> 하지 못하다는 단점이 있다. 만약 기존 나이에서 1살을 더해줘야 한다면, 다음과 같이 작성해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>person<span style=color:#f92672>.</span>set_age(person<span style=color:#f92672>.</span>get_age() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>뿐만 아니라, <code>person._age = -62</code> 와 같은 코드는 방어할 수가 없어진다는 문제도 여전히 남아있다. 그러나 <code>@property</code> 를 활용하면 다음과 같은 코드가 가능하다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>person<span style=color:#f92672>.</span>age <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>person<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>62</span> <span style=color:#75715e># Exception(&#39;나이는 0 이하가 될 수 없다.&#39;)</span>
</span></span></code></pre></div><p>??? 어떻게 된 일일까? 겉으로 보기에는 변수에 값을 직접 대입하는 것 같은데, 로직에 따른 Exception을 던지고 있다. 어떻게 이것이 가능한지는 차차 알아보기로 하고, 일단 생김새부터 살펴보자. 위 <code>Person</code> 클래스에 <code>@Property</code>를 적용하면 다음과 같이 작성할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, age) :
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self) :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@age.setter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self, new_age) :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> new_age <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> :
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;나이는 0 이하가 될 수 없다.&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> new_age
</span></span></code></pre></div><p>대충 살펴 봤을때, 눈에 띄는 차이점은 다음과 같다.</p><ol><li>함수의 이름이 <code>get_age</code> 혹은 <code>set_age</code> 가 아니라, 그냥 <code>age</code> 자체로 변경되었다.</li><li>계속 언급했던 <code>@property</code> 가 <code>age</code> 메소드 위에 붙었다. 또한, <code>@age.setter</code> 라는 녀석도 두 번째 <code>age</code> 메소드 위에 붙어있다.</li></ol><p>이러한 변화가 어떻게 앞서 언급했던 동작에 영향을 미쳤는지 하나씩 알아보자.</p><p><code>@property</code>를 이해하기 위한 배경지식들은 다음과 같다.</p><ol><li>Everything is Object</li><li>Decorator</li><li>Descriptor Object</li></ol><h1 id=1-everything-is-object>1. Everything is Object<a hidden class=anchor aria-hidden=true href=#1-everything-is-object>#</a></h1><p>Python에서 다루는 모든 값은 객체이다. Java에서는 일반적으로 값을 <code>Primitive Type</code>, <code>Reference Type</code> 으로 구분한다. 반면 Python에서는 <code>int</code>, <code>bool</code>과 같은 값들도 모두 객체로 다뤄진다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>print(id(a)) <span style=color:#75715e># 4341049696</span>
</span></span></code></pre></div><p><code>id</code> 함수는 Built-in 함수로, 객체가 가지고 있는 주소값을 나타낸다. 따라서 <code>id(a)</code>라는 코드는 1 이라는 값이 할당된 메모리 주소를 반환한다. Java에서는 <code>Integer</code> 와 비슷하다고 생각할 수 있다.</p><p>이에 더해, Python 에서는 <strong>함수마저도</strong> 객체이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_func</span>() :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;hello world&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(my_func<span style=color:#f92672>.</span>__str__()) <span style=color:#75715e># &#39;&lt;function my_func at 0x7ffd70cf1f70&gt;&#39;</span>
</span></span></code></pre></div><p>위 예시에서 보시다시피, <code>my_func</code> 이라는 이름의 함수를 만든 뒤, 해당 함수가 갖고 있는 <code>__str__</code> 이라는 메소드를 호출할 수 있다. 즉, <code>my_func</code> 자체는 <code>Function</code> 이라는 클래스를 상속하는 클래스다.</p><p>간단하게 생각하면, <code>def my_func()</code> 라는 키워드는 <code>my_func = {함수 바디}</code> 와 같이 변수로 정의되는 것을 상상해볼 수 있다.</p><blockquote><p>Note. 함수가 객체라는 이야기를 할 때, <code>1급 시민</code> 이라는 키워드가 자주 등장한다. 1급 시민이란, 변수에 할당할 수 있어야 하고, argument로 전달될 수 있으며, return 으로 반환될 수 있는 값들을 말합니다. Java에서 메소드는 일급 객체가 아니지만, 인터페이스를 활용해 1급 시민의 흉내를 낼 수 있다.</p></blockquote><h1 id=2-decorator>2. Decorator<a hidden class=anchor aria-hidden=true href=#2-decorator>#</a></h1><p>데코레이터를 이야기하려면 Python 함수가 갖는 또 다른 특징을 알아야 한다.</p><h2 id=1-함수는-중첩이-가능하다>1) 함수는 중첩이 가능하다.<a hidden class=anchor aria-hidden=true href=#1-함수는-중첩이-가능하다>#</a></h2><p>python은 다음과 같이 함수를 중첩해서 정의할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>outer</span>() :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>inner</span>() :
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;inner called&#39;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;outer called&#39;</span>)
</span></span><span style=display:flex><span>    inner()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> inner
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var <span style=color:#f92672>=</span> outer() <span style=color:#75715e># outer called \n inner called (1)</span>
</span></span><span style=display:flex><span>var() <span style=color:#75715e># inner called (2)</span>
</span></span></code></pre></div><p><code>outer</code> 함수 안에 <code>inner</code> 함수를 정의한 뒤, <code>inner</code> 함수를 호출했다. 따라서 <code>var = outer()</code> 를 통해 <code>outer</code>함수를 호출할 때, 내부에 있는 <code>inner</code> 함수 (1)도 실행된다.</p><p>다음으로 <code>return inner</code>를 통해 <code>inner</code> 함수 그 자체를 돌려주고, 해당 <code>함수 객체</code>는 <code>var</code> 라는 변수에 저장된다. 따라서 <code>var()</code> 를 통해 함수를 실행하는 것은 결국 <code>inner</code> 함수를 실행하는 것과 같다.</p><h2 id=2-enclosed-function-locals>2) Enclosed Function Locals<a hidden class=anchor aria-hidden=true href=#2-enclosed-function-locals>#</a></h2><p>python의 함수가 갖는 두 번째 특징은, 이러한 중첩 함수로 인해 조금 특별한 변수 scope가 생긴다는 것이다. C를 처음 배웠을 무렵, 지역변수 전역변수와 같은 개념에 대해서 배우고, &ldquo;내가 허용된 범위의 바깥 변수는 알 수 없다&rdquo;, &ldquo;가까운 scope부터 찾아 나간다&rdquo; 정도의 개념으로 정리하고 넘어갔다. python에서는 후자, 즉 &ldquo;가까운 scope부터 찾아 나간다"는 맞는 말이지만, 전자인 &ldquo;내가 허용된 범위 바깥 변수는 알 수 없다&rdquo; 는 조금 다르다. 한마디로, &ldquo;내가 허용된 범위 바깥 변수에 접근할 수는 있지만, 수정할 수는 없다.&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>outer</span>() :
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>inner</span>() :
</span></span><span style=display:flex><span>        z <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>        print(z, y, x)
</span></span><span style=display:flex><span>    inner()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> inner
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> outer() <span style=color:#75715e># 3 2 1</span>
</span></span><span style=display:flex><span>a() <span style=color:#75715e># 3 2 1</span>
</span></span></code></pre></div><p>아까 예시를 들었던 <code>outer/inner</code> 함수를 약간 변형해보았다. <code>outer</code> 함수가 실행되던 와중에 <code>inner</code>가 호출되든, 함수 객체를 return 받은 <code>a</code>가 호출되든 상관없이, 모두 3 2 1을 출력한다.</p><blockquote><p>Note. python에서는 가까운 곳부터 찾아나가는 접근법을 <strong>LEGB 규칙</strong> 이라고 명명한다. 순서대로 Local, Enclosed function locals, Global, Built-in 의 약자이며, <code>z</code>, <code>y</code>, <code>x</code> 변수가 이에 해당한다. 마지막 Built-in 변수는 __name__과 같이 &ldquo;내가 정의하지도 않았는데 기존에 정의되어 있던 값들"을 말한다.</p></blockquote><p>하지만 다음의 예시는 쓰기에 대해서는 조금 다른 결과임을 보여준다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>outer</span>() :
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>inner</span>() :
</span></span><span style=display:flex><span>        z <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>        y <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># UnboundLocalError: local variable &#39;y&#39; referenced before assignment</span>
</span></span><span style=display:flex><span>        x <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># UnboundLocalError: local variable &#39;x&#39; referenced before assignment</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        print(z, y, x)
</span></span><span style=display:flex><span>    inner()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> inner
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> outer()
</span></span><span style=display:flex><span>a()
</span></span></code></pre></div><p><code>inner</code> 내부에서 <code>y</code>와 <code>x</code>에 대해서 값을 1씩 더하려고 하자 할당되기 전에 참조되었다는 에러를 발생시킨다. 즉, 자기 자신의 scope 바깥에 있는 변수에 대해서는 &ldquo;쓰기&rdquo; 연산에 대해, 즉 &ldquo;변경"에 대해 제한되어 있다.</p><blockquote><p>Note. 만약 해당 값을 수정하고 싶다면 <code>nonlocal</code> 혹은 <code>global</code> 키워드를 통해 &ldquo;내가 외부의 값을 수정하고자 한다&rdquo; 라는 의도를 드러내야 한다.</p></blockquote><h2 id=3-closure>3) Closure<a hidden class=anchor aria-hidden=true href=#3-closure>#</a></h2><p>Closure는 위키피디아에서 다음과 같이 설명하고 있다.</p><pre tabindex=0><code>컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.
</code></pre><p>이러한 설명은 처음 Closure를 접한 사람들에게 전혀 도움이 되지 않다. 심지어 <code>Closure</code>라는 네이밍 그 자체에서도 어떠한 힌트를 얻기는 어렵다. 예시를 살펴보면서 이해해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>outer</span>(val) :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>inner</span>() :
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;inner called&#39;</span>)
</span></span><span style=display:flex><span>        print(val)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;outer called&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> inner
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> outer(<span style=color:#ae81ff>10</span>) <span style=color:#75715e># ???</span>
</span></span><span style=display:flex><span>a() <span style=color:#75715e># ???</span>
</span></span></code></pre></div><p>첫 번째로 실행한 <code>a = outer(10)</code>, 두 번째로 실행한 <code>a()</code> 코드가 각각 어떻게 돌아갈지 한번 상상해보자.</p><p><code>a = outer(10)</code>에 의해 <code>outer</code> 함수를 호출했고, argument로 <code>10</code>을 넘겨주고, 이를 val 이라는 이름으로 받아냈다. 그 내부에서 <code>inner</code> 함수를 정의했고, <code>outer called</code> 를 출력한 뒤, <code>inner</code> 함수 객체를 돌려준다.</p><p>두 번째로 <code>a()</code> 를 통해, <code>a</code> 변수가 갖고 있는 <code>inner</code> 함수 객체를 호출한다. <code>inner called</code>를 출력한 뒤, <code>val</code>을 출력하려고 하는데, <strong>여기서 의문점이 하나 생긴다.</strong> 해당 함수는 자신 바깥에 있는, 즉 <code>val</code> 변수를 참조하고 있다. 앞서 이야기한 <code>LEGB 규칙</code>에 따르면, <code>L</code> 에서 <code>E</code>를 참조하는 셈이다.</p><p>여기서 <code>val</code>은 살아 있을까? 바꿔말하면, <code>val</code> 변수를 참조해서 아까 넣어준 <code>10</code> 이라는 값을 얻어낼 수 있을까? 정답은 <strong>&ldquo;그렇다&rdquo;</strong> 입니다.</p><p>이렇게 보니 마치 <code>outer</code> 라는 클래스가 <code>val</code> 이라는 멤버변수를 가지고 있는 것처럼 느껴진다. 여기까지 읽고 나서, 다시 위키피디아의 정의를 살펴보자.</p><pre tabindex=0><code>컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.
</code></pre><p>이렇게 보니 100% 이해하지는 못하더라도, 어떤 느낌으로 설명하고 있는지는 알 수 있다. <code>Closure</code>라는 이름 또한 직역 시 &ldquo;폐쇄&rdquo; 라는 뜻을 갖고 있는데, 조금 과장해서 &ldquo;나만의 구역"과 같은 느낌이 연상되기도 한다.</p><blockquote><p>Note. 어떠한 함수 A 가 Closure이기 위해서는 다음의 세 가지 조건이 만족되어야 한다.</p><ol><li>A 함수는 다른 함수 B 안에 정의된 함수, 즉 중첩된 함수여야 한다.</li><li>자신을 둘러싼 함수 B scope 의 값을 참조해야 한다.</li><li>B 함수는 A 함수를 반환해야 한다.</li></ol></blockquote><p>여기서 한 단계 더 나아가보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>outer</span>(func) :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>inner</span>() :
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;inner called&#39;</span>)
</span></span><span style=display:flex><span>        func()
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;outer called&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> inner
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_func</span>() :
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;my_func called&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> outer(my_func) <span style=color:#75715e># outer called</span>
</span></span><span style=display:flex><span>a() <span style=color:#75715e># inner called \n my_func called</span>
</span></span></code></pre></div><p>앞서는 <code>val</code> 이라는 숫자 값을 넣어줬지만, 이번에는 <code>my_func</code> 이라는 함수를 넣어주고 있다. 거듭 반복해서 확인할 수 있듯이, 함수 또한 객체이기 떄문에(a.k.a 1급 시민) 다른 함수의 argument로 전달될 수 있다.</p><p>여기서는 <code>outer</code> 라는 함수의 argument로 <code>my_func</code>을 전달하고 있고, 좀 전과 마찬가지로 <code>my_func</code>는 <code>outer</code> 함수의 호출이 끝나더라도 <code>inner</code>에 의해 참조되고 있다.</p><h2 id=4-decorator-정리>4) Decorator 정리<a hidden class=anchor aria-hidden=true href=#4-decorator-정리>#</a></h2><p><code>Decorator</code>를 알기 위한 사전 지식은 준비되었으니, 이제 본격적으로 알아보자.</p><p>바로 위의 예시에서는 <code>a = outer(my_func)</code> 라는 함수를 통해 closure를 만들고, <code>a()</code> 를 통해 <code>inner</code> 함수, 즉 closure 를 호출했다. Decorator를 활용하면 이를 보다 손쉽게 정의할 수 있다.</p><p>즉, 다음의 두 코드는 같다.</p><p>기존</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>outer</span>(func) :
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_func</span>() :
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> outer(my_func) <span style=color:#75715e># outer called</span>
</span></span><span style=display:flex><span>a() <span style=color:#75715e># inner called \n my_func called</span>
</span></span></code></pre></div><p>데코레이터</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>outer</span>(func) :
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@outer</span>  <span style=color:#75715e># outer called</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_func</span>() :
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> my_func() <span style=color:#75715e># inner called \n my_func called </span>
</span></span></code></pre></div><p>여기서 한 가지 주의할 점은, 데코레이터 버전에서 <code>outer called</code> 는 <code>@outer</code>를 붙여서 <code>my_func</code>를 정의하는 시점에 호출된다는 점이다. 이렇게 보면 <code>Decorator</code> 라는 이름이 왜 <code>Decorator</code> 인지 알 수 있다.</p><h1 id=3-descriptor-object>3. Descriptor Object<a hidden class=anchor aria-hidden=true href=#3-descriptor-object>#</a></h1><p>Descriptor 는 객체 A가 갖고있는 속성인 객체 B를 다룰 때 조회, 저장 및 삭제를 사용자 정의할 수 있는 객체 B를 디스크립터라고 이야기한다. 이 Descriptor라는 녀석은 객체 A의 클래스 변수로서 정의되어야 한다. (<em>the descriptor must be in either the owner’s class dictionary or in the class dictionary for one of its parents</em>)</p><p>역시, 예시를 보면서 진행하겠다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Age</span> :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, age) :
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __get__(self, obj, objtype) :
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;__get__ method called&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __set__(self, obj, val) :
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;__set__ method called&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> val
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __delete__(self, obj) :
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;__delete__ method called&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> :
</span></span><span style=display:flex><span>    age <span style=color:#f92672>=</span> Age(<span style=color:#ae81ff>26</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> Person()
</span></span><span style=display:flex><span>print(p<span style=color:#f92672>.</span>age) <span style=color:#75715e># __get__ method called \n 26</span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span> <span style=color:#75715e># __set__ method called</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>del</span> p<span style=color:#f92672>.</span>age <span style=color:#75715e># __delete__ method called</span>
</span></span><span style=display:flex><span>print(p<span style=color:#f92672>.</span>age) <span style=color:#75715e># __get__method called \n -1</span>
</span></span></code></pre></div><p>Age 라는 클래스를 만들고, <code>__get__</code>, <code>__set__</code>, <code>__delete__</code> 메소드를 정의했다. 이 세개의 메소드는 <strong>스페셜 메소드</strong> 라고 불리우며, 객체가 갖는 특성을 지정할 수 있다. 가장 대표적으로 <code>__init__</code> 메소드는 인스턴스 생성시에 동작하는 행위에 대해서 정의할 수 있다.</p><p>어떠한 객체에 위에서 언급한 세 개의 <code>__get__</code>, <code>__set__</code>, <code>__delete__</code> 메소드가 정의되었을 경우, 해당 객체를 &ldquo;디스크립터&rdquo; 라고 부르게 된다.</p><blockquote><p>Note. <code>__get__</code> 메소드만 정의된 경우에는 <code>Non-data Descriptor</code>, <code>__set__</code> 메소드 혹은 <code>__delete__</code> 메소드가 정의된 경우에는 <code>Data Descriptor</code> 라고 부른다. 이 둘의 차이는 우선순위에 있다만, 여기서는 다룰 내용이 아닌지라 넘어가겠다.</p></blockquote><p>이렇게 Descriptor를 정의할 경우, 해당 객체로 접근할 때 우리가 생각했던 것처럼 값에 직접 접근하는 것이 아니라, 메소드 호출을 통해 접근하게 된다. 그림으로 보면 다음과 같이 상상해 볼 수 있다.</p><p><img loading=lazy src=/assets/images/2021-09-18-15-52-24.png alt></p><p>Descriptor 라는 특별한 개념이 없다면, 코드 상으로는 객체가 위 그림과 비슷한 형태로 구성될 것이라고 예측할 수 있다. <code>Person</code> 안에 <code>Age</code> 객체가, 그리고 <code>Age</code> 객체 안에 <code>_age</code> 라는 멤버변수, <code>__getter__</code>, <code>__setter__</code> 라는 메소드를 가질 뿐이다. 따라서 <code>p.age</code> 로 접근하게 되면 <code>Age()</code> 객체로 접근할 것처럼 보인다. 하지만 실질적으로는 다음 그림과 같다.</p><p><img loading=lazy src=/assets/images/2021-09-18-15-56-29.png alt></p><p><code>p.age</code>를 호출하게 되는 순간, <code>Person</code> 객체 내에 있는 <code>Age()</code> 객체를 가져오려 하는데, <code>__get__</code> 메소드가 오버라이드 되어 실질적으로는 <code>Age()</code> 객체가 아닌 그 내부의 <code>self._age</code>를 돌려주게 된다.</p><p>이러한 동작 방식을 보고나면, 왜 <code>Data Descriptor</code> 라는 이름을 갖게 되었는지 알 수 있다. <code>Data Descriptor</code>로 정의된 객체는, 일반적으로 생각하는 것처럼 값을 갖고 메소드라는 행위를 갖지 않고, 대신 내가 원하는 <code>Data</code>(여기서는 _age라는 int 변수)에 대한 톨게이트와 같은 역할을 하게 된다.</p><h1 id=4-property>4. Property<a hidden class=anchor aria-hidden=true href=#4-property>#</a></h1><p>장황한 이야기를 끝내고, 드디어 Property에 대한 이야기를 해보자. 앞서 보여드렸던 Property 사용 예시는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, age) :
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self) :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@age.setter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self, new_age) :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> new_age <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> :
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;나이는 0 이하가 될 수 없다.&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> new_age
</span></span></code></pre></div><p>Decorator에 대해서 이해하고 왔으니, <code>@property</code> 라는 코드를 통해, <code>property</code> 라는 함수(함수는 다시 객체이니 정확히는 <code>property</code>라는 객체)로 <code>age</code> 라는 메소드를 전달한다는 사실을 알 수 있다.</p><p>따라서, 아래와 같은 코드는</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>( <span style=color:#f92672>...</span> ) :
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>실질적으로는 다음과 같다고 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>age <span style=color:#f92672>=</span> property(age)
</span></span></code></pre></div><p>아까전에 <code>def my_func()</code> 라는 코드는 <code>my_func = {함수바디}</code>와 같이 변수로 정의되는 것을 상상해볼 수 있다고 이야기 했다. 여기서도 같은 맥락임을 확인할 수 있는데, 왜냐하면, <code>@property</code> 데코레이터를 사용해 <code>age = property(age)</code>로, 즉 클래스 변수로 만들었기 때문이다. (Descriptor는 반드시 클래스 변수에 있어야 한다는 사실을 상기하자.)</p><p><a href=https://docs.python.org/3/howto/descriptor.html>파이썬 공식 문서</a>에 있는 <code>property</code>의 생김새는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Property</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Emulate PyProperty_Type() in Objects/descrobject.c&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, fget<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, fset<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, fdel<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, doc<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>fget <span style=color:#f92672>=</span> fget
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>fset <span style=color:#f92672>=</span> fset
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>fdel <span style=color:#f92672>=</span> fdel
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> doc <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span> <span style=color:#f92672>and</span> fget <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            doc <span style=color:#f92672>=</span> fget<span style=color:#f92672>.</span>__doc__
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__doc__ <span style=color:#f92672>=</span> doc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __get__(self, obj, objtype<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> obj <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>fget <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>&#34;unreadable attribute&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>fget(obj)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __set__(self, obj, value):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>fset <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>&#34;can&#39;t set attribute&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>fset(obj, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __delete__(self, obj):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>fdel <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>&#34;can&#39;t delete attribute&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>fdel(obj)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getter</span>(self, fget):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> type(self)(fget, self<span style=color:#f92672>.</span>fset, self<span style=color:#f92672>.</span>fdel, self<span style=color:#f92672>.</span>__doc__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setter</span>(self, fset):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> type(self)(self<span style=color:#f92672>.</span>fget, fset, self<span style=color:#f92672>.</span>fdel, self<span style=color:#f92672>.</span>__doc__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>deleter</span>(self, fdel):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> type(self)(self<span style=color:#f92672>.</span>fget, self<span style=color:#f92672>.</span>fset, fdel, self<span style=color:#f92672>.</span>__doc__)
</span></span></code></pre></div><p>자, 이제 어떻게 코드가 동작하는지에 대해서 이해할 준비가 되었으니, 한 줄씩 따라가보며 총 정리해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>( <span style=color:#f92672>...</span> ) :
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>위 코드를 통해 <code>age = property(age)</code> 가 실행된다고 언급했다. <code>property</code>의 생성자 인자로 <code>age</code>라는 메소드를 넘겨줬으니, 이 age는 <code>__init__</code> 메소드 내부에서 <code>fget</code> 이라는 변수에 할당됨을 확인할 수 있다. 그리고 <code>@property</code>를 적용한 <code>Person</code> 클래스의 현재 생김새는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, age) :
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self) :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    age <span style=color:#f92672>=</span> property(age)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@age.setter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self, new_age) :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> new_age <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> :
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;나이는 0 이하가 될 수 없다.&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> new_age
</span></span></code></pre></div><p>다음으로 <code>@age.setter</code> 부분을 살펴보자. 현재 <code>age</code>는 <code>property</code> 객체인 상태다. 그러면 <code>@age.setter</code>는 다음과 같이 해석된다. age가 계속 나와 헷갈리니 주석을 참고하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>age <span style=color:#f92672>=</span> property(age)
</span></span><span style=display:flex><span><span style=color:#75715e># age(1번) = property(age(2번))</span>
</span></span><span style=display:flex><span><span style=color:#75715e># age 라는 이름의 변수(1번)에 &#39;age 메소드&#39;(2번)를 인자로 넘긴 property 객체를 저장.</span>
</span></span><span style=display:flex><span>age <span style=color:#f92672>=</span> age<span style=color:#f92672>.</span>setter(age) 
</span></span><span style=display:flex><span><span style=color:#75715e># age(3) = age(1).setter(age(4))</span>
</span></span><span style=display:flex><span><span style=color:#75715e># age라는 이름의 변수(3번)에, property 객체를 갖고 있는 age 변수(1번)의 setter 메소드에 새로운 age 메소드(4)를 넘겨준다.</span>
</span></span></code></pre></div><p>그리고 <code>setter</code> 메소드를 살펴보면,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setter</span>(self, fset):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> type(self)(self<span style=color:#f92672>.</span>fget, fset, self<span style=color:#f92672>.</span>fdel, self<span style=color:#f92672>.</span>__doc__)
</span></span></code></pre></div><p><code>type(self)</code> 부분은 자기 자신에 대한 <code>type</code>을 구하고 있다. <code>self</code>는 <code>property</code> 이니 다음과 같이 해석된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setter</span>(self, fset):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> property(self<span style=color:#f92672>.</span>fget, fset, self<span style=color:#f92672>.</span>fdel, self<span style=color:#f92672>.</span>__doc__)
</span></span></code></pre></div><p>자기 자신에 대해서 생성자를 호출하고 있다. 꼭 마치 자바에서 생성자에 <code>this()</code>와 비슷해 보인다. 또한, 나머지는 <code>self</code> 키워드를 붙여서 자기 자신이 갖고 있던 녀석들을 넘겨주고, <code>fset</code> 위치에만 <code>age(self, new_age)</code> 라는 메소드를 넘겨주고 있다.</p><p>이제 <code>Person</code> 객체에서 <code>age</code>를 접근할 때 무슨일이 일어날까? <code>p.age</code> 로 꺼낸 <code>age</code>는 <code>property</code> 객체라는 사실은 이 쯤 되면 잘 알 것이다. <code>property</code> 객체는 연이어 <code>__get__</code> 메소드를 호출할 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> __get__(self, obj, objtype<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> obj <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>fget <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>&#34;unreadable attribute&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>fget(obj)
</span></span></code></pre></div><p><code>__get__</code> 메소드의 인자 <code>obj</code>는 자기 자신을 실행한 인스턴스, <code>objtype</code>은 해당 클래스를 의미한다. <code>p.age</code>로 인스턴스를 통해 실행했으니 <code>obj</code>는 p일 것이고, <code>objtype</code> 은 <code>Person</code> 이다.<br><code>obj</code>가 <code>None</code>이 아니고, <code>fget</code> 또한 아까 할당되었으니, <code>return self.fget(obj)</code>가 실행된다.</p><p>즉, <code>fget(obj)</code> 의 fget은 앞서 정의한 <code>def age(self)</code> 이니, 아까 내가 정의한 <code>getter</code> 메소드, 즉 다음 메소드가 실행된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self) :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_age
</span></span></code></pre></div><p>다음으로 <code>__set__</code> 메소드를 살펴보자. <code>p.age = -10</code> 이라고 작성했다면, 역시 <code>p.age</code> 변수가 갖고 있는 객체는 <code>property</code> 객체이고, 해당 객체의 <code>__set__</code> 메소드가 호출된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> __set__(self, obj, value):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>fset <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>&#34;can&#39;t set attribute&#34;</span>)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>fset(obj, value)
</span></span></code></pre></div><p>마찬가지로 obj는 자기 자신을 실행한 인스턴스, 즉 <code>p</code> 이고, <code>value</code>는 <code>-10</code> 입니다. <code>fset</code> 변수는 앞서 할당한 <code>def age(self, new_age)</code> 함수 객체이고, None이 아니니 <code>self.fset(obj, value)</code>를 실행한다. 즉, 다음 메소드가 실행된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self, new_age) :
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> new_age <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> :
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;나이는 0 이하가 될 수 없다.&#34;</span>)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> new_age
</span></span></code></pre></div><hr><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://shoark7.github.io/programming/python/closure-in-python>Python의 Closure에 대해 알아보자</a></li><li><a href=https://wikidocs.net/81226>Wikidocs 레벨업 파이썬 - 클로저</a></li><li><a href=https://docs.python.org/3/howto/descriptor.html>Python 공식문서 - Descriptor</a></li><li><a href=https://kukuta.tistory.com/339>Hardcore in Programming - Descriptor</a></li><li><a href=https://m.blog.naver.com/r00tdr4g0n/222056023801>[Python 지식]- Descriptor 우선순위</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/null/>Null</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/lang/kotlin-property/><span class=title>« Prev</span><br><span>kotlin Property</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share python property on x" href="https://x.com/intent/tweet/?text=python%20property&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f&amp;hashtags=null"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share python property on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f&amp;title=python%20property&amp;summary=python%20property&amp;source=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share python property on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f&title=python%20property"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share python property on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share python property on whatsapp" href="https://api.whatsapp.com/send?text=python%20property%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share python property on telegram" href="https://telegram.me/share/url?text=python%20property&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share python property on ycombinator" href="https://news.ycombinator.com/submitlink?t=python%20property&u=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fpython-property%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://cjlee38.github.io/>cjlee38</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>