<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java Memory Model explained (feat. Effective Java, Item 78) | cjlee38</title>
<meta name=keywords content="java,jmm"><meta name=description content="개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.
public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다."><meta name=author content="cjlee38"><link rel=canonical href=https://cjlee38.github.io/post/lang/java-memory-model-explained/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cjlee38.github.io/post/lang/java-memory-model-explained/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta property="og:title" content="Java Memory Model explained (feat. Effective Java, Item 78)"><meta property="og:description" content="개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.
public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다."><meta property="og:type" content="article"><meta property="og:url" content="https://cjlee38.github.io/post/lang/java-memory-model-explained/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-05T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java Memory Model explained (feat. Effective Java, Item 78)"><meta name=twitter:description content="개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.
public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjlee38.github.io/post/"},{"@type":"ListItem","position":2,"name":"Java Memory Model explained (feat. Effective Java, Item 78)","item":"https://cjlee38.github.io/post/lang/java-memory-model-explained/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java Memory Model explained (feat. Effective Java, Item 78)","name":"Java Memory Model explained (feat. Effective Java, Item 78)","description":"개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.\npublic class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다.","keywords":["java","jmm"],"articleBody":"개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.\npublic class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u003e { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다. 책에서는 이를 OpenJDK의 경우 hoisting에 의한 것일 수 있다고 간단하게만 짚고 넘어간다. 또한, 이와 관련한 많은 자료들을 서치해보면 이는 CPU cache에 의한 문제라고 진단하고 넘어간다. 물론 틀린 말은 아니지만, 그 내부를 들여다보면 이는 간단하지 않은 문제다.\nJIT compiler 위 문제의 원인을 진단하기 위해서는, 우선 JVM 이 java 파일을 실행시키는 과정을 자세히 살펴보아야 한다. 우리가 javac 명령어를 통해 .java 확장자를 가진 파일을 컴파일하게 되면, 이는 곧바로 CPU에서 실행될 수 있는 코드로 변환되지 않는다. 해당 코드는 JVM 이 이해할 수 있는 Java Bytecode 로 변환되고, 이를 java 명령어로 실행할 때가 되어서야 비로소 기계어로 번역되어 실행된다.\n기계어로 번역되는 과정에서 JVM은 Java Bytecode를 CPU가 이해할 수 있는 machine code로 한줄씩 번역하게 된다. 이 과정에서 자주 참조하는 코드가 보이면(이 과정을 warm-up 이라고 표현하기도 한다.) 해당 코드를 통째로 컴파일해 실시간으로 번역하지 않고 컴파일을 진행한다.\nReordering 위와 같은 일련의 과정을 거치면서, JVM은 주어진 Java Bytecode에 대한 최적화를 진행한다. 일례로, 아래의 코드를 살펴보자.\npublic class Reordering { private int a = 0; private int b = 0; public void increase() { a += 1; b += 2; a += 3; } } 위와 같은 코드를 작성하면 우리는 increase 메소드가 호출되었을 때 다음과 같은 순서로 동작하기를 기대한다.\n처음 Reordering 인스턴스를 생성하면, a와 b는 0으로 초기화된다. increase 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다. a에 1을 더한다. b에 2를 더한다. a에 3을 더한다. 이러한 흐름은 사람에게는 자연스럽지만, 조금 더 기계친화적으로 흐름을 살펴보면 아래와 같이 동작한다.\nReordering 인스턴스에 대한 생성을 요청하면 Reordering 인스턴스의 클래스를 분석하고, 해당 인스턴스에 대한 공간을 할당받는다. 공간을 할당받은 뒤, init 메소드(생성자)를 실행하여 변수에 대한 초기화를 진행한다. increase 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다. 변수 a로부터 값을 읽어 CPU register에 올린다. CPU register에 1을 더하는 연산을 수행한다. 1을 더한 연산을 마친 후, a 변수가 위치한 공간에 값을 다시 write 한다. 변수 b 로부터 값을 읽어 CPU register에 올린다. CPU register에 2 를 더하는 연산을 수행한다. 2를 더한 연산을 마친 후, b 변수가 위치한 공간에 값을 다시 write 한다. 변수 a로부터 값을 읽어 CPU register에 올린다. CPU register에 3을 더하는 연산을 수행한다. 3을 더한 연산을 마친 후, a 변수가 위치한 공간에 값을 다시 write 한다. 내용이 조금 길긴 하지만, 자세히 읽어보면 그다지 어려운 내용이 아님을 알 수 있다. 그저, 값을 읽은 뒤 더하기 연산을 한 후, 그 값을 다시 원래 위치에 쓰기 연산을 했을 뿐이다. 하지만 위 과정을 다시 읽어보면, 더 효율적으로 계산할 수 있는 방법이 있다는 것 또한 알 수 있다.\n즉, 2.1 에 해당하는 읽기 연산을 한 후, 2.2에 해당하는 덧셈 연산 직후에 곧바로 2.7 의 덧셈 연산을 연달아 수행하고, 2.8 의 쓰기 연산을 이어나가면 명령어 수행 횟수를 줄일 수 있다. 이를 코드로 표현하면 아래와 같이 변경된다.\npublic class Reordering { private int a = 0; private int b = 0; public void increase() { a += 1; a += 3; b += 2; } } 심지어는 1과 3을 더하는 연산을 묶어서 차라리 4를 더해버리는 연산을 진행할 수도 있다. JVM은 위와 같이 코드의 순서를 변경하는 작업을 수행할 수 있으며, 이를 reordering 이라고 부른다.\n이 reordering 은 JVM이 판단하기에 순서를 바꿔도 영향이 없는 코드에 대해 진행된다. 가령, b += a; 와 같이 a에 대한 덧셈 연산 결과를 바탕으로 b에 대한 연산을 수행하는 경우 해당 코드는 재배치되지 않는다.\nWord Tearing 위에서 소개한 예제 뿐만 아니라, 또 다른 문제도 발생할 수 있다. 아이템 78의 첫 페이지 세 번째 문단을 살펴보면, 아래와 같이 이야기한다.\n언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.(JLS, 174. 17.7)\nlong과 double은 왜 제외되는가 하고 보면, 두 개의 원시타입은 다른 타입들과 다르게 64bit 라는 특성을 가지고 있다. 다음의 코드를 살펴보자.\npublic class WordTearing { long a = 0L; void thread1() { a = 0x0000FFFF; } void thread2() { a = 0xFFFF0000; } } 위 코드를 두 개의 스레드가 동시에 접근하여 수행하면 어떤 결과가 나타날까 ? 일반적으로 생각했을 때에는 0x0000FFFF 혹은 0xFFFF0000 둘 중 하나로 결과가 남을 것으로 기대해볼 수 있을 것이다. 하지만 32bit processor는 CPU register에 최대 32bit 만 올릴 수 있으므로, 총 64 bit 중 앞 쪽 32bit 의 쓰기연산과 뒤 쪽 32 bit의 쓰기 연산의 총 두 개의 연산으로 작업을 수행한다. 따라서 0x0000FFFF, 0xFFFF0000, 0x00000000, 0xFFFFFFFF 의 총 4개의 결과가 가능한 결과 집합이 되고, 이러한 문제를 Word Tearing 이라 부른다.\nJMM 하지만 그렇다고 해서 위 코드들을 실제로 로컬환경에서 수행해봐도 문제가 발견되지 않을 수 있다. 이는 하드웨어 아키텍쳐의 차이로 인해 발생하는 것인데, 가령 64bit processor를 이용하는 경우에는 위와 같은 원자성 문제가 발생하지 않는다.\n위 표는 각 CPU 아키텍쳐 별 optimization 지원 여부를 나타낸다. 가령, intel CPU의 경우 load-load 를 지원하지 않는다. load-load 는 하나의 변수를 읽고 다음 변수를 읽을 때 reordering이 발생하는지 여부를 의미한다. 한편, ARM CPU는 load-load를 지원하며, 이는 곧 두 개의 변수를 읽을 때 순서의 재배치가 발생할 수 있음을 의미한다.\nARM 아키텍쳐의 CPU가 상대적으로 전력을 적게 소모하는 이유 중 하나이다.\nJava Memory Model(이하 JMM) 은 특정 순간에 어떠한 필드를 읽었을 때 우리가 어떠한 값을 관찰할 수 있는지를 설명하는 모델이다. JMM은 약한 메모리 모델을 기반으로 설계되었기 때문에 각각의 CPU core가 바라볼 수 있는 값이 다를 수 있고, 따라서 이를 적절하게 제어하는 규칙에 대한 specification을 제공한다.\n그리고 JMM에서 애플리케이션을 보호하는 개념 중 하나가 바로 오늘 중점적으로 다루게 될 happens-before 관계이다. 여기서 한 가지 반드시 짚고 넘어가야 할 점은 happens-before 관계는 single thread를 기반으로 보장되었다는 점이다. 이를 다시 말하면 multi-thread 환경에서는 사용자가 어느정도는 의식적으로 염두에 두어야 한다는 말이다.\n필드 영역에는 final , volatile, 메소드 영역에는 synchronized, java.util.concurrent.locks.Lock 를 이용해 이를 제어할 수 있으며, 해당 키워드/API 를 사용함으로서 JVM에게 동시성 이슈를 발생시킬 수 있는 최적화를 억제하도록 유도할 수 있다. 하지만 반대로 이야기하면 최적화를 진행하지 않음으로 인해 성능저하를 유발할 수도 있다는 뜻이 된다.\n하나씩 살펴보자.\nvolatile 앞서 맨 처음 보았던 무한루프를 돌았던 코드와 비슷한 코드를 다시 한번 살펴보자.\nclass DataRace { boolean ready = false; int answer = 0; void thread1() { while (!ready); assert answer == 42; } void thread2() { answer = 42; ready = true; } } 두 개의 스레드가 동시에 thread1 메소드와 thread2 메소드를 수행하면 어떻게 될까? assert 부분이 통과할 수 있을까? 앞서 문제점들을 인지했다면, 위 코드는 실패할 가능성이 있다는 것을 알 것이다. 왜냐하면, thread2 의 answer = 42; 코드와 ready = true; 코드의 순서가 바뀌어서 ready가 먼저 true가 되버릴 수 있기 때문이다. 혹은, 앞서 보았던 예시와 마찬가지로 ready 변수가 CPU cache에 저장되어 ready가 true로 변경되었음에도 불구하고 여전히 false로 읽을 수도 있다.\n이 문제를 해결하기 위해서는 아래와 같이 ready 변수에 volatile 키워드를 사용할 수 있다.\nvolatile boolean ready = false;\nJLS 에 나와있듯이, volatile 키워드가 붙은 변수는 모든 스레드가 ‘일관된 값’을 볼 수 있음을 보장해준다.(A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable). 뿐만 아니라, volatile에 대한 쓰기 연산은 읽기연산에 선행(happens-before) 된다.\n한 가지 더 주목할 점은, volatile 키워드를 ready 변수에만 붙여주었다는 점이다.이 또한 JMM이 volatile 변수에 대한 쓰기연산 이전에 선행된 쓰기 연산은, reordering 되지 않음을 보장하기 때문이다. (읽기 연산 또한 마찬가지로, volatile 변수에 대한 읽기가 선행되고 이후에 다른 변수에 대한 읽기가 진행됨이 보장된다.)\n마지막으로, 앞서 보았던 Word Tearing 또한 발생하지 않는다.\n많은 사람들이 volatile 키워드는 메모리에 곧바로 쓸 수 있도록 하는 역할이라고 설명한다. 이것이 틀린 설명은 아니지만, JLS 상에서는 volatile 키워드가 ‘consistence’(일관성)을 유지하도록 보장한다고 설명한다. 즉, ‘명세’ 상으로는 항상 일관된 값을 관찰할 수 있어야 한다는 것이고, 이에 대한 구현(implementation)이 바로 메인 메모리에 대한 flush 라고 볼 수 있다.\n이는 volatile뿐만이 아닌 모든 happens-before 관계를 보장하는 (e.g. synchronized) 키워드에도 해당된다.\nsynchronized synchronized 키워드 또한 happens-before 관계를 성립시키는 도구로 사용될 수 있다. 다음은 역시 마찬가지로 이펙티브 자바 아이템 78 에서 인용한 내용이다.\n많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.\n… 중략\n맞는 설명이지만, 동기화에는 중요한 기능이 하나 더 있다. 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다. 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메소드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.\n즉, synchronized 키워드에는 상호배제(mutual exclusion) 이외에도 스레드 간 통신(앞서 보았던 happens-before) 의 기능을 제공한다는 뜻이다.\n위 DataRace 코드를 synchronized 키워드를 이용해 수정하면 다음과 같다.\nclass DataRace { boolean ready = false; int answer = 0; synchronized void thread1() { // \u003c- 데드락 발생 가능 while (!ready); assert answer == 42; } synchronized void thread2() { answer = 42; ready = true; } } 이 코드를 곧바로 실행하면, 아마 thread1 메소드가 먼저 수행되는 경우에는 데드락이 발생하게 된다. 여기서는 “thread2 코드가 먼저 실행되었다” 라고 가정해보자. 그러면 아래와 같은 흐름으로 진행된다.\n스레드 Thread 1 Thread 2 실행 enter answer = 42; ready = true; exit enter while (!ready); assert answer = 42; exit 이펙티브 자바에서 설명했던 것과 마찬가지로, monitor를 통한 critical section의 진입/탈출 뿐만 아니라 ready 변수와 answer 변수에 대한 순서는 재배치되지 않고 순서대로 (happens-before)수행된다.\nsynchronized 키워드와 관련해서 한 가지 더 짚고 넘어가고 싶은 부분이 있다. 가장 먼저 봤던 StopThread 클래스를 다시 살펴보자.\npublic class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u003e { int i = 0; while (!stopRequested) { i++; System.out.println(\"STOP ?\"); // (*) } }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드에서, 주석으로 별표(*)를 달아놓은 부분을 새로이 추가하였다. 그리고 이 코드를 실행되면 어떻게 될까? 놀랍게도 이번에는 무한 루프를 돌지 않고 약 1초 뒤 종료된다. 출력문 하나를 추가하였을 뿐인데 왜 갑자기 1초뒤에 중단되었을까? 이는 sout 메소드를 살펴보면 알 수 있다.\npublic void println(String x) { synchronized (this) { print(x); newLine(); } } 보는 바와 같이 synchronized 키워드가 존재한다. 그런데 여기서 한 가지 궁금증이 생긴다. synchronized 는 this 에 걸려있고, 이 this는 결국 System.out 인데, 왜 난데없이 전혀 관련 없어보이는 stopRequested 변수가 초기화되었을까 ? 이는 synchronized block에 진입하는 순간, 해당 스레드가 볼 수 있는 모든 변수가 메모리로 flush 되었기 때문이다.\n아래 코드는 이펙티브 자바에서 보인 StopThread 의 synchronized 키워드를 이용한 개선 버전인데, 이 부분도 자세히 보면 처음에는 “왜 synchronized 키워드를 붙인게 효과가 있지?” 라는 생각이 들었다가, 스레드 간 통신을 지원한다는 점을 떠올리면, 곧 고개를 끄덕일 수 있을 것이다.\npublic class StopThreadSynchronized { private static boolean stopRequested; private static synchronized void requestStop() { stopRequested = true; } private static synchronized boolean stopRequested() { return stopRequested; } public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u003e { int i = 0; while (!stopRequested()) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); requestStop(); } } final 자바에서 final은 변수에 대한 재할당을 막는 역할로 널리 알려져 있다. 하지만 final 키워드 또한 happens-before 관계와 연관이 있다. 다음 코드를 보자.\npublic class UnsafePublication { private int a; private UnsafePublication() { a = 42; } static UnsafePublication instance; static void thread1() { instance = new UnsafePublication(); } static void thread2() { if (instance != null) { assert instance.a == 42; } } } 흔히 싱글톤 패턴을 구현할 때 자주 볼 수 있는 코드 형태이다. (물론 동시성 문제를 고려하여 개선버전이 존재한다.) 마찬가지로 thread1 과 thread2 메소드가 동시에 수행되었을 때, 해당 코드는 항상 통과할 수 있을까?\n정답은 ‘그렇지 않다’ 이다. 앞서 Reordering 절에서도 언급했듯이, new 키워드를 이용해 객체를 생성하는 행위는 두 가지로 구분된다.\n객체를 생성하기 위한 공간의 할당 객체 변수의 초기화 따라서 1. 객체를 생성하기 위한 공간의 할당이 먼저 선행되고, thread2 메소드가 수행되는 경우, instance는 null을 가리키지 않으므로 if 절 안으로 진입하게 된다. 하지만, 객체 변수의 초기화 (a = 42;) 는 아직 수행되지 않았으므로(int 변수는 초기화되지 않으면, 0을 갖는다.) 해당 assert 절은 실패하게 된다.\n참고로 파이썬에서는 생성자로 사용되는 __init__ 메소드 이외에도 __new__ 라는 메소드가 있는데, 이는 메모리를 할당받을 때 사용된다. 즉, __init__ 메소드보다 반드시 선행된다.\n이를 해결하기 위한 방법으로 final 을 사용할 수 있다. 위 코드에서 private final int a; 과 같이 final을 붙여주게 되면, 생성자 메소드 init 이 끝난 직후에 freeze 라는 작업을 하게 된다. 생성자 내에서 또한 happens-before 관계가 보장되며, 생성자 체이닝(e.g. 부생성자 → 주생성자)이 발생한다면 최종 생성자가 끝나는 시점에 freeze 작업이 수행된다.\n마무리 JVM의 구현체는 명세보다 더 엄격하게 관리한다. 따라서 구현체를 믿고 프로그램을 작성하다보면, Java 진영에서 이야기하는 Cross-Platform Compatibility, 즉 Write Once, Run Anywhere 이 어려워질 가능성이 높다. 따라서 보수적으로 코드를 작성해야 함에 유의하자.\nReference https://youtu.be/qADk_tj4wY8 https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html https://www.geeksforgeeks.org/happens-before-relationship-in-java/ https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true\u0026blogId=jjoommnn\u0026logNo=130037479493 ","wordCount":"2017","inLanguage":"en","datePublished":"2023-03-05T00:00:00Z","dateModified":"2023-03-05T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cjlee38.github.io/post/lang/java-memory-model-explained/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://cjlee38.github.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cjlee38.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Java Memory Model explained (feat. Effective Java, Item 78)</h1><div class=post-meta><span title='2023-03-05 00:00:00 +0000 UTC'>March 5, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/lang/java-memory-model-explained.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b0%9c%ec%9a%94 aria-label=개요>개요</a></li><li><a href=#jit-compiler aria-label="JIT compiler">JIT compiler</a></li><li><a href=#reordering aria-label=Reordering>Reordering</a></li><li><a href=#word-tearing aria-label="Word Tearing">Word Tearing</a></li><li><a href=#jmm aria-label=JMM>JMM</a></li><li><a href=#volatile aria-label=volatile>volatile</a></li><li><a href=#synchronized aria-label=synchronized>synchronized</a></li><li><a href=#final aria-label=final>final</a></li><li><a href=#%eb%a7%88%eb%ac%b4%eb%a6%ac aria-label=마무리>마무리</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopThread</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread backgroundThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopRequested)
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        backgroundThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드를 읽어보면, <code>stopRequested</code> 가 1초 뒤에 <code>true</code> 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다. 책에서는 이를 OpenJDK의 경우 hoisting에 의한 것일 수 있다고 간단하게만 짚고 넘어간다. 또한, 이와 관련한 많은 자료들을 서치해보면 이는 <code>CPU cache</code>에 의한 문제라고 진단하고 넘어간다. 물론 틀린 말은 아니지만, 그 내부를 들여다보면 이는 간단하지 않은 문제다.</p><h3 id=jit-compiler>JIT compiler<a hidden class=anchor aria-hidden=true href=#jit-compiler>#</a></h3><p>위 문제의 원인을 진단하기 위해서는, 우선 <code>JVM</code> 이 java 파일을 실행시키는 과정을 자세히 살펴보아야 한다. 우리가 <code>javac</code> 명령어를 통해 <code>.java</code> 확장자를 가진 파일을 컴파일하게 되면, 이는 곧바로 CPU에서 실행될 수 있는 코드로 변환되지 않는다. 해당 코드는 <code>JVM</code> 이 이해할 수 있는 <a href=https://en.wikipedia.org/wiki/Java_bytecode>Java Bytecode</a> 로 변환되고, 이를 <code>java</code> 명령어로 실행할 때가 되어서야 비로소 기계어로 번역되어 실행된다.</p><p>기계어로 번역되는 과정에서 <code>JVM</code>은 Java Bytecode를 CPU가 이해할 수 있는 <code>machine code</code>로 한줄씩 번역하게 된다. 이 과정에서 자주 참조하는 코드가 보이면(이 과정을 <code>warm-up</code> 이라고 표현하기도 한다.) 해당 코드를 통째로 컴파일해 실시간으로 번역하지 않고 컴파일을 진행한다.</p><h3 id=reordering>Reordering<a hidden class=anchor aria-hidden=true href=#reordering>#</a></h3><p>위와 같은 일련의 과정을 거치면서, JVM은 주어진 Java Bytecode에 대한 최적화를 진행한다. 일례로, 아래의 코드를 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reordering</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>increase</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 1;
</span></span><span style=display:flex><span>        b <span style=color:#f92672>+=</span> 2;
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 3;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위와 같은 코드를 작성하면 우리는 <code>increase</code> 메소드가 호출되었을 때 다음과 같은 순서로 동작하기를 기대한다.</p><ol><li>처음 <code>Reordering</code> 인스턴스를 생성하면, <code>a</code>와 <code>b</code>는 <code>0</code>으로 초기화된다.</li><li><code>increase</code> 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다.<ol><li><code>a</code>에 <code>1</code>을 더한다.</li><li><code>b</code>에 <code>2</code>를 더한다.</li><li><code>a</code>에 <code>3</code>을 더한다.</li></ol></li></ol><p>이러한 흐름은 사람에게는 자연스럽지만, 조금 더 기계친화적으로 흐름을 살펴보면 아래와 같이 동작한다.</p><ol><li><code>Reordering</code> 인스턴스에 대한 생성을 요청하면<ol><li><code>Reordering</code> 인스턴스의 클래스를 분석하고, 해당 인스턴스에 대한 공간을 할당받는다.</li><li>공간을 할당받은 뒤, <code>init</code> 메소드(생성자)를 실행하여 변수에 대한 초기화를 진행한다.</li></ol></li><li><code>increase</code> 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다.<ol><li>변수 <code>a</code>로부터 값을 읽어 CPU register에 올린다.</li><li>CPU register에 <code>1</code>을 더하는 연산을 수행한다.</li><li><code>1</code>을 더한 연산을 마친 후, <code>a</code> 변수가 위치한 공간에 값을 다시 write 한다.</li><li>변수 <code>b</code> 로부터 값을 읽어 CPU register에 올린다.</li><li>CPU register에 <code>2</code> 를 더하는 연산을 수행한다.</li><li><code>2</code>를 더한 연산을 마친 후, b 변수가 위치한 공간에 값을 다시 write 한다.</li><li>변수 <code>a</code>로부터 값을 읽어 CPU register에 올린다.</li><li>CPU register에 <code>3</code>을 더하는 연산을 수행한다.</li><li><code>3</code>을 더한 연산을 마친 후, <code>a</code> 변수가 위치한 공간에 값을 다시 write 한다.</li></ol></li></ol><p>내용이 조금 길긴 하지만, 자세히 읽어보면 그다지 어려운 내용이 아님을 알 수 있다. 그저, 값을 읽은 뒤 더하기 연산을 한 후, 그 값을 다시 원래 위치에 쓰기 연산을 했을 뿐이다. 하지만 위 과정을 다시 읽어보면, 더 효율적으로 계산할 수 있는 방법이 있다는 것 또한 알 수 있다.</p><p>즉, <code>2.1</code> 에 해당하는 읽기 연산을 한 후, <code>2.2</code>에 해당하는 덧셈 연산 직후에 곧바로 <code>2.7</code> 의 덧셈 연산을 연달아 수행하고, <code>2.8</code> 의 쓰기 연산을 이어나가면 명령어 수행 횟수를 줄일 수 있다. 이를 코드로 표현하면 아래와 같이 변경된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reordering</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>increase</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 1;
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 3;
</span></span><span style=display:flex><span>        b <span style=color:#f92672>+=</span> 2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>심지어는 1과 3을 더하는 연산을 묶어서 차라리 4를 더해버리는 연산을 진행할 수도 있다. JVM은 위와 같이 코드의 순서를 변경하는 작업을 수행할 수 있으며, 이를 <code>reordering</code> 이라고 부른다.</p><p>이 <code>reordering</code> 은 JVM이 판단하기에 순서를 바꿔도 영향이 없는 코드에 대해 진행된다. 가령, <code>b += a;</code> 와 같이 <code>a</code>에 대한 덧셈 연산 결과를 바탕으로 <code>b</code>에 대한 연산을 수행하는 경우 해당 코드는 재배치되지 않는다.</p><h3 id=word-tearing>Word Tearing<a hidden class=anchor aria-hidden=true href=#word-tearing>#</a></h3><p>위에서 소개한 예제 뿐만 아니라, 또 다른 문제도 발생할 수 있다. 아이템 78의 첫 페이지 세 번째 문단을 살펴보면, 아래와 같이 이야기한다.</p><blockquote><p>언어 명세상 <code>long</code>과 <code>double</code> 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.(JLS, 174. 17.7)</p></blockquote><p><code>long</code>과 <code>double</code>은 왜 제외되는가 하고 보면, 두 개의 원시타입은 다른 타입들과 다르게 <code>64bit</code> 라는 특성을 가지고 있다. 다음의 코드를 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WordTearing</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> 0L;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> 0x0000FFFF;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> 0xFFFF0000;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드를 두 개의 스레드가 동시에 접근하여 수행하면 어떤 결과가 나타날까 ? 일반적으로 생각했을 때에는 <code>0x0000FFFF</code> 혹은 <code>0xFFFF0000</code> 둘 중 하나로 결과가 남을 것으로 기대해볼 수 있을 것이다. 하지만 32bit processor는 CPU register에 최대 32bit 만 올릴 수 있으므로, 총 64 bit 중 앞 쪽 32bit 의 쓰기연산과 뒤 쪽 32 bit의 쓰기 연산의 총 두 개의 연산으로 작업을 수행한다. 따라서 <code>0x0000FFFF</code>, <code>0xFFFF0000</code>, <code>0x00000000</code>, <code>0xFFFFFFFF</code> 의 총 4개의 결과가 가능한 결과 집합이 되고, 이러한 문제를 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.6>Word Tearing</a> 이라 부른다.</p><h3 id=jmm>JMM<a hidden class=anchor aria-hidden=true href=#jmm>#</a></h3><p>하지만 그렇다고 해서 위 코드들을 실제로 로컬환경에서 수행해봐도 문제가 발견되지 않을 수 있다. 이는 하드웨어 아키텍쳐의 차이로 인해 발생하는 것인데, 가령 64bit processor를 이용하는 경우에는 위와 같은 원자성 문제가 발생하지 않는다.</p><p><img loading=lazy src=/assets/images/2023-03-06-java-memory-model-explained/2023-03-06-01-25-00.png alt></p><p>위 표는 각 CPU 아키텍쳐 별 optimization 지원 여부를 나타낸다. 가령, intel CPU의 경우 <code>load-load</code> 를 지원하지 않는다. <code>load-load</code> 는 하나의 변수를 읽고 다음 변수를 읽을 때 <code>reordering</code>이 발생하는지 여부를 의미한다. 한편, ARM CPU는 <code>load-load</code>를 지원하며, 이는 곧 두 개의 변수를 읽을 때 순서의 재배치가 발생할 수 있음을 의미한다.</p><blockquote><p>ARM 아키텍쳐의 CPU가 상대적으로 전력을 적게 소모하는 이유 중 하나이다.</p></blockquote><p><code>Java Memory Model</code>(이하 <code>JMM</code>) 은 특정 순간에 어떠한 필드를 읽었을 때 우리가 어떠한 값을 관찰할 수 있는지를 설명하는 모델이다. <code>JMM</code>은 <a href=https://preshing.com/20120930/weak-vs-strong-memory-models/>약한 메모리 모델</a>을 기반으로 설계되었기 때문에 각각의 CPU core가 바라볼 수 있는 값이 다를 수 있고, 따라서 이를 적절하게 제어하는 규칙에 대한 specification을 제공한다.</p><p>그리고 <code>JMM</code>에서 애플리케이션을 보호하는 개념 중 하나가 바로 오늘 중점적으로 다루게 될 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.4.5>happens-before</a> 관계이다. 여기서 한 가지 반드시 짚고 넘어가야 할 점은 <code>happens-before</code> 관계는 single thread를 기반으로 보장되었다는 점이다. 이를 다시 말하면 multi-thread 환경에서는 사용자가 어느정도는 의식적으로 염두에 두어야 한다는 말이다.</p><p>필드 영역에는 <code>final</code> , <code>volatile</code>, 메소드 영역에는 <code>synchronized</code>, <code>java.util.concurrent.locks.Lock</code> 를 이용해 이를 제어할 수 있으며, 해당 키워드/API 를 사용함으로서 JVM에게 동시성 이슈를 발생시킬 수 있는 최적화를 억제하도록 유도할 수 있다. 하지만 반대로 이야기하면 최적화를 진행하지 않음으로 인해 성능저하를 유발할 수도 있다는 뜻이 된다.</p><p>하나씩 살펴보자.</p><h3 id=volatile>volatile<a hidden class=anchor aria-hidden=true href=#volatile>#</a></h3><p>앞서 맨 처음 보았던 무한루프를 돌았던 코드와 비슷한 코드를 다시 한번 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataRace</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>ready);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> answer <span style=color:#f92672>==</span> 42;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        answer <span style=color:#f92672>=</span> 42;
</span></span><span style=display:flex><span>        ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>두 개의 스레드가 동시에 thread1 메소드와 thread2 메소드를 수행하면 어떻게 될까? <code>assert</code> 부분이 통과할 수 있을까? 앞서 문제점들을 인지했다면, 위 코드는 실패할 가능성이 있다는 것을 알 것이다. 왜냐하면, thread2 의 <code>answer = 42;</code> 코드와 <code>ready = true;</code> 코드의 순서가 바뀌어서 <code>ready</code>가 먼저 <code>true</code>가 되버릴 수 있기 때문이다. 혹은, 앞서 보았던 예시와 마찬가지로 <code>ready</code> 변수가 CPU cache에 저장되어 <code>ready</code>가 <code>true</code>로 변경되었음에도 불구하고 여전히 <code>false</code>로 읽을 수도 있다.</p><p>이 문제를 해결하기 위해서는 아래와 같이 <code>ready</code> 변수에 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.3.1.4>volatile</a> 키워드를 사용할 수 있다.</p><p><code>volatile boolean ready = false;</code></p><p>JLS 에 나와있듯이, volatile 키워드가 붙은 변수는 모든 스레드가 ‘일관된 값’을 볼 수 있음을 보장해준다.(A <em>field may be declared <code>volatile</code>, in which case the Java Memory Model ensures that all threads see a consistent value for the variable</em>). 뿐만 아니라, volatile에 대한 쓰기 연산은 읽기연산에 선행(happens-before) 된다.</p><p>한 가지 더 주목할 점은, <code>volatile</code> 키워드를 <code>ready</code> 변수에만 붙여주었다는 점이다.이 또한 JMM이 <code>volatile</code> 변수에 대한 쓰기연산 이전에 선행된 쓰기 연산은, <code>reordering</code> 되지 않음을 보장하기 때문이다. (읽기 연산 또한 마찬가지로, volatile 변수에 대한 읽기가 선행되고 이후에 다른 변수에 대한 읽기가 진행됨이 보장된다.)</p><p>마지막으로, 앞서 보았던 Word Tearing 또한 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.7>발생하지 않는다.</a></p><blockquote><p>많은 사람들이 volatile 키워드는 메모리에 곧바로 쓸 수 있도록 하는 역할이라고 설명한다.
이것이 틀린 설명은 아니지만, JLS 상에서는 volatile 키워드가 ‘consistence’(일관성)을 유지하도록 보장한다고 설명한다. 즉, ‘명세’ 상으로는 항상 일관된 값을 관찰할 수 있어야 한다는 것이고, 이에 대한 구현(implementation)이 바로 메인 메모리에 대한 flush 라고 볼 수 있다.</p><p><strong>이는 <code>volatile</code>뿐만이 아닌 모든 <code>happens-before</code> 관계를 보장하는 (e.g. <code>synchronized</code>) 키워드에도 해당된다.</strong></p></blockquote><h3 id=synchronized>synchronized<a hidden class=anchor aria-hidden=true href=#synchronized>#</a></h3><p><code>synchronized</code> 키워드 또한 <code>happens-before</code> 관계를 성립시키는 도구로 사용될 수 있다. 다음은 역시 마찬가지로 이펙티브 자바 아이템 78 에서 인용한 내용이다.</p><blockquote><p>많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.</p><p>… 중략</p><p>맞는 설명이지만, 동기화에는 중요한 기능이 하나 더 있다. <strong>동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.</strong> 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메소드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.</p></blockquote><p>즉, <code>synchronized</code> 키워드에는 상호배제(mutual exclusion) 이외에도 <strong>스레드 간 통신</strong>(앞서 보았던 <code>happens-before</code>) 의 기능을 제공한다는 뜻이다.</p><p>위 <code>DataRace</code> 코드를 <code>synchronized</code> 키워드를 이용해 수정하면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataRace</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() { <span style=color:#75715e>// &lt;- 데드락 발생 가능</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>ready);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> answer <span style=color:#f92672>==</span> 42;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        answer <span style=color:#f92672>=</span> 42;
</span></span><span style=display:flex><span>        ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 코드를 곧바로 실행하면, 아마 thread1 메소드가 먼저 수행되는 경우에는 데드락이 발생하게 된다. 여기서는 “thread2 코드가 먼저 실행되었다” 라고 가정해보자. 그러면 아래와 같은 흐름으로 진행된다.</p><table><thead><tr><th style=text-align:center>스레드</th><th style=text-align:center>Thread 1</th><th style=text-align:center>Thread 2</th></tr></thead><tbody><tr><td style=text-align:center>실행</td><td style=text-align:center></td><td style=text-align:center>enter</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>answer = 42;</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>ready = true;</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>exit</td></tr><tr><td style=text-align:center></td><td style=text-align:center>enter</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>while (!ready);</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>assert answer = 42;</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>exit</td><td style=text-align:center></td></tr></tbody></table><p>이펙티브 자바에서 설명했던 것과 마찬가지로, <code>monitor</code>를 통한 <code>critical section</code>의 진입/탈출 뿐만 아니라 <code>ready</code> 변수와 <code>answer</code> 변수에 대한 순서는 재배치되지 않고 순서대로 (<code>happens-before</code>)수행된다.</p><p><code>synchronized</code> 키워드와 관련해서 한 가지 더 짚고 넘어가고 싶은 부분이 있다. 가장 먼저 봤던 <code>StopThread</code> 클래스를 다시 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopThread</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread backgroundThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopRequested) {
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;STOP ?&#34;</span>); <span style=color:#75715e>// (*)</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        backgroundThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드에서, 주석으로 별표(*)를 달아놓은 부분을 새로이 추가하였다. 그리고 이 코드를 실행되면 어떻게 될까? 놀랍게도 이번에는 무한 루프를 돌지 않고 약 1초 뒤 종료된다. 출력문 하나를 추가하였을 뿐인데 왜 갑자기 1초뒤에 중단되었을까? 이는 <code>sout</code> 메소드를 살펴보면 알 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>println</span>(String x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>        print(x);
</span></span><span style=display:flex><span>        newLine();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>보는 바와 같이 <code>synchronized</code> 키워드가 존재한다. 그런데 여기서 한 가지 궁금증이 생긴다. <code>synchronized</code> 는 <code>this</code> 에 걸려있고, 이 <code>this</code>는 결국 <code>System.out</code> 인데, 왜 난데없이 전혀 관련 없어보이는 <code>stopRequested</code> 변수가 초기화되었을까 ? <a href=https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html>이는 synchronized block에 진입하는 순간, 해당 스레드가 볼 수 있는 모든 변수가 메모리로 flush 되었기 때문이다.</a></p><p>아래 코드는 이펙티브 자바에서 보인 <code>StopThread</code> 의 <code>synchronized</code> 키워드를 이용한 개선 버전인데, 이 부분도 자세히 보면 처음에는 “왜 <code>synchronized</code> 키워드를 붙인게 효과가 있지?” 라는 생각이 들었다가, 스레드 간 통신을 지원한다는 점을 떠올리면, 곧 고개를 끄덕일 수 있을 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopThreadSynchronized</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>requestStop</span>() {
</span></span><span style=display:flex><span>		stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>stopRequested</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> stopRequested;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread backgroundThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopRequested())
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        backgroundThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        requestStop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=final>final<a hidden class=anchor aria-hidden=true href=#final>#</a></h3><p>자바에서 <code>final</code>은 변수에 대한 재할당을 막는 역할로 널리 알려져 있다. 하지만 final 키워드 또한 <code>happens-before</code> 관계와 연관이 있다. 다음 코드를 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnsafePublication</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>UnsafePublication</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> 42;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> UnsafePublication instance;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() {
</span></span><span style=display:flex><span>        instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UnsafePublication();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (instance <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>assert</span> instance.<span style=color:#a6e22e>a</span> <span style=color:#f92672>==</span> 42;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>흔히 싱글톤 패턴을 구현할 때 자주 볼 수 있는 코드 형태이다. (물론 동시성 문제를 고려하여 개선버전이 존재한다.) 마찬가지로 <code>thread1</code> 과 <code>thread2</code> 메소드가 동시에 수행되었을 때, 해당 코드는 항상 통과할 수 있을까?</p><p>정답은 ‘그렇지 않다’ 이다. 앞서 <code>Reordering</code> 절에서도 언급했듯이, <code>new</code> 키워드를 이용해 객체를 생성하는 행위는 두 가지로 구분된다.</p><ol><li>객체를 생성하기 위한 공간의 할당</li><li>객체 변수의 초기화</li></ol><p>따라서 1. 객체를 생성하기 위한 공간의 할당이 먼저 선행되고, <code>thread2</code> 메소드가 수행되는 경우, instance는 <code>null</code>을 가리키지 않으므로 if 절 안으로 진입하게 된다. 하지만, 객체 변수의 초기화 (<code>a = 42;</code>) 는 아직 수행되지 않았으므로(int 변수는 초기화되지 않으면, <code>0</code>을 갖는다.) 해당 assert 절은 실패하게 된다.</p><blockquote><p>참고로 파이썬에서는 생성자로 사용되는 <code>__init__</code> 메소드 이외에도 <code>__new__</code> 라는 메소드가 있는데, 이는 메모리를 할당받을 때 사용된다. 즉, <code>__init__</code> 메소드보다 반드시 선행된다.</p></blockquote><p>이를 해결하기 위한 방법으로 <code>final</code> 을 사용할 수 있다. 위 코드에서 <code>private final int a;</code> 과 같이 <code>final</code>을 붙여주게 되면, 생성자 메소드 <code>init</code> 이 끝난 직후에 <code>freeze</code> 라는 작업을 하게 된다. 생성자 내에서 또한 <code>happens-before</code> 관계가 보장되며, 생성자 체이닝(e.g. 부생성자 → 주생성자)이 발생한다면 최종 생성자가 끝나는 시점에 <code>freeze</code> 작업이 수행된다.</p><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>JVM의 구현체는 명세보다 더 엄격하게 관리한다. 따라서 구현체를 믿고 프로그램을 작성하다보면, Java 진영에서 이야기하는 <code>Cross-Platform Compatibility</code>, 즉 <code>Write Once, Run Anywhere</code> 이 어려워질 가능성이 높다. 따라서 보수적으로 코드를 작성해야 함에 유의하자.</p><hr><h3 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h3><ul><li><a href=https://youtu.be/qADk_tj4wY8>https://youtu.be/qADk_tj4wY8</a></li><li><a href=https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html>https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html</a></li><li><a href=https://www.geeksforgeeks.org/happens-before-relationship-in-java/>https://www.geeksforgeeks.org/happens-before-relationship-in-java/</a></li><li><a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html>https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html</a></li><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=jjoommnn&amp;logNo=130037479493">https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=jjoommnn&amp;logNo=130037479493</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://cjlee38.github.io/tags/java/>Java</a></li><li><a href=https://cjlee38.github.io/tags/jmm/>Jmm</a></li></ul><nav class=paginav><a class=prev href=https://cjlee38.github.io/post/code/oop-is-psychotic-disorder/><span class=title>« Prev</span><br><span>객체지향은 정신병이다.</span>
</a><a class=next href=https://cjlee38.github.io/post/code/domain-layered-architecture/><span class=title>Next »</span><br><span>도메인과 레이어드 아키텍처</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Memory Model explained (feat. Effective Java, Item 78) on x" href="https://x.com/intent/tweet/?text=Java%20Memory%20Model%20explained%20%28feat.%20Effective%20Java%2c%20Item%2078%29&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f&amp;hashtags=java%2cjmm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Memory Model explained (feat. Effective Java, Item 78) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f&amp;title=Java%20Memory%20Model%20explained%20%28feat.%20Effective%20Java%2c%20Item%2078%29&amp;summary=Java%20Memory%20Model%20explained%20%28feat.%20Effective%20Java%2c%20Item%2078%29&amp;source=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Memory Model explained (feat. Effective Java, Item 78) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f&title=Java%20Memory%20Model%20explained%20%28feat.%20Effective%20Java%2c%20Item%2078%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Memory Model explained (feat. Effective Java, Item 78) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Memory Model explained (feat. Effective Java, Item 78) on whatsapp" href="https://api.whatsapp.com/send?text=Java%20Memory%20Model%20explained%20%28feat.%20Effective%20Java%2c%20Item%2078%29%20-%20https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Memory Model explained (feat. Effective Java, Item 78) on telegram" href="https://telegram.me/share/url?text=Java%20Memory%20Model%20explained%20%28feat.%20Effective%20Java%2c%20Item%2078%29&amp;url=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Memory Model explained (feat. Effective Java, Item 78) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Java%20Memory%20Model%20explained%20%28feat.%20Effective%20Java%2c%20Item%2078%29&u=https%3a%2f%2fcjlee38.github.io%2fpost%2flang%2fjava-memory-model-explained%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://cjlee38.github.io/>cjlee38</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>