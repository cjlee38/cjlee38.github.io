<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># (Java) Wrapper Class는 Call by Value 일까? | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. 들어가며 : Java 는 Call by Value일까, Call by Reference 일까?
지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,
객체를 넘겨줄 때에는 call by reference로 알고 있었다.
그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.
1. Call in Java : Java 에서는 언제나 Call by Value 라고 한다.
약 12년 된 스택오버플로우의 한 질문글에 달린 답변은 다음과 같다.
  자바는 예외 없이, 항상 pass by value 입니다."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/backup/language/java/2020-10-21-java_wrapper_class/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="# (Java) Wrapper Class는 Call by Value 일까?"><meta property="og:description" content="0. 들어가며 : Java 는 Call by Value일까, Call by Reference 일까?
지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,
객체를 넘겨줄 때에는 call by reference로 알고 있었다.
그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.
1. Call in Java : Java 에서는 언제나 Call by Value 라고 한다.
약 12년 된 스택오버플로우의 한 질문글에 달린 답변은 다음과 같다.
  자바는 예외 없이, 항상 pass by value 입니다."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/backup/language/java/2020-10-21-java_wrapper_class/"><meta property="article:section" content="backup"><meta property="article:published_time" content="2020-10-21T20:26:00+00:00"><meta property="article:modified_time" content="2020-10-21T20:26:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# (Java) Wrapper Class는 Call by Value 일까?"><meta name=twitter:description content="0. 들어가며 : Java 는 Call by Value일까, Call by Reference 일까?
지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,
객체를 넘겨줄 때에는 call by reference로 알고 있었다.
그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.
1. Call in Java : Java 에서는 언제나 Call by Value 라고 한다.
약 12년 된 스택오버플로우의 한 질문글에 달린 답변은 다음과 같다.
  자바는 예외 없이, 항상 pass by value 입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Backups","item":"http://cjlee38.github.io/backup/"},{"@type":"ListItem","position":2,"name":"# (Java) Wrapper Class는 Call by Value 일까?","item":"http://cjlee38.github.io/backup/language/java/2020-10-21-java_wrapper_class/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# (Java) Wrapper Class는 Call by Value 일까?","name":"# (Java) Wrapper Class는 Call by Value 일까?","description":"0. 들어가며 : Java 는 Call by Value일까, Call by Reference 일까?\n지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,\n객체를 넘겨줄 때에는 call by reference로 알고 있었다.\n그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.\n1. Call in Java : Java 에서는 언제나 Call by Value 라고 한다.\n약 12년 된 스택오버플로우의 한 질문글에 달린 답변은 다음과 같다.\n  자바는 예외 없이, 항상 pass by value 입니다.","keywords":["null"],"articleBody":"0. 들어가며 : Java 는 Call by Value일까, Call by Reference 일까?\n지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,\n객체를 넘겨줄 때에는 call by reference로 알고 있었다.\n그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.\n1. Call in Java : Java 에서는 언제나 Call by Value 라고 한다.\n약 12년 된 스택오버플로우의 한 질문글에 달린 답변은 다음과 같다.\n  자바는 예외 없이, 항상 pass by value 입니다.\n그렇다면, 왜 사람들이 이것을 혼란스러워 하고, Java는 pass by reference라고 믿고 있을까요? 키 포인트는, Java가 어떠한 상황에서도, 객체의 값에 직접적인 접근을 제공하지 않기 때문입니다. 객체에 접근하는 유일한 방법은 그 객체의 참조를 통하는 것뿐입니다. Java 객체가 직접 접근되지 않고 참조에 의해 접근되기 때문에, 현학적으로 필드, 변수, 그리고 메소드 인자를 객체인 것처럼 이야기 되는데, 이것들은 객체에 대한 참조일 뿐입니다. 이러한 혼란은 (엄밀히 말하면, 틀린) 명명(命名)의 변화에서 기인합니다.\n따라서, 메소드를 호출할 때,\n Primitive인 경우 : pass-by-value 는 primitive의 실제 값의 전달입니다. 객체인 경우 : pass-by-value는 객체에 대한 참조 “값\"의 전달입니다.\n… 하략    또 다른 답변의 경우, 친절하게 예시도 같이 달아주었다.\npublic static void main(String[] args) {  Dog aDog = new Dog(\"Max\");  Dog oldDog = aDog;   // we pass the object to foo  foo(aDog);  // aDog variable is still pointing to the \"Max\" dog when foo(...) returns  aDog.getName().equals(\"Max\"); // true  aDog.getName().equals(\"Fifi\"); // false  aDog == oldDog; // true }  public static void foo(Dog d) {  d.getName().equals(\"Max\"); // true  // change d inside of foo() to point to a new Dog instance \"Fifi\"  d = new Dog(\"Fifi\");  d.getName().equals(\"Fifi\"); // true } 이 예제를 보고 나니, 위 답변이 무슨 말을 하는지 이해할 수 있었다.\n코드를 보면, aDog 라는 변수를 foo() 메소드로 넘겨주었다.\nfoo() 메소드 안에서, getName() 을 찍어보면 \"Max\"로 찍히는 것은 당연하다.\n그러나, 주의깊게 봐야 할 부분은 d = new Dog(\"Fifi\") 다.\n만약 참조에 의한 호출이었다면, d 라는 참조는 본래 aDog가 가리키는 객체를 가리킬 것이다.\n따라서, aDog는 Fifi로 바뀌어야 한다.\n그러나 메소드를 실행하고 나서 다시 aDog의 getName()을 찍어보면,\n여전히 \"Max\"로 남아있다.\n왜냐하면, aDog 라는 참조 를 넘겨준 것이 아니라, 복사본 을 넘겨주었기 때문이다.\n여전히 이해하기 힘들다면, 다음의 그림을 보자.\nDog aDog = new Dog(\"Max\"); Dog oldDog = aDog; 위 코드를 실행하면, 그림과 같이 aDog과 oldDog는 Max라는 녀석을 가리키고 있다.\n여기서, foo() 메소드를 실행하면 어떻게 될까?\n위 그림과 같이, d는 aDog의 복사본(call-by-value)이 된다.\n만약, 참조에 의한 호출이었다면 다음과 같은 모양새였을 것이다.\n그러나, 실제로 d는 복사본이므로, new Dog(\"Fifi\")를 수행하면 다음과 같이 된다.\n따라서, foo() 메소드 안에서 getName() 을 찍어보면 \"Fifi\"로 나오지만,\n메소드가 끝난 이후, 메인 메소드에서 다시 getName()을 찍어보면 \"Max\"로 나오게 된다.\n반면, foo() 메소드 안에서, d.setName(\"Fifi\") 라고 사용한다면,\n다음 그림과 같이 메소드 종료 이후에 aDog의 Name은 \"Fifi\"가 될 것이다.\n결국 Java는 Call-by-value 이지만, 우리가 사용할 때에는 대부분 Call-by-Reference 처럼 인식하게 된다.\nCall-by-value라고 해서, 특별하게 걱정할 내용은 없다는 얘기다.\n2. How about Wrapper classes? : 하지만, Integer 와 같은 Wrapper class는 어떨까?\n다음 코드의 결과를 예상해보자.\npublic class Main {   public static void main(String[] args) {  int intValue = 10;  Integer integerValue = new Integer(10);  MyInteger myIntegerValue = new MyInteger(10);   System.out.println(\"before intValue = \" + intValue);  System.out.println(\"before integerValue = \" + integerValue);  System.out.println(\"before myIntegerValue = \" + myIntegerValue.getValue());   intMethod(10);  integerMethod(integerValue);  myIntegerMethod(myIntegerValue);   System.out.println(\"after intValue = \" + intValue);  System.out.println(\"after integerValue = \" + integerValue);  System.out.println(\"after myIntegerValue = \" + myIntegerValue.getValue());   }   public static void intMethod(int value) {  value = value + 1;  }   public static void integerMethod(Integer value) {  value = value + 1;  }   public static void myIntegerMethod(MyInteger value) {  value.increase();  }  }  class MyInteger {  private int value;   public MyInteger(int value) {  this.value = value;  }   public int getValue() {  return value;  }   public void increase() {  value = value + 1;  } } 결과는 다음과 같다.\nbefore intValue = 10 before integerValue = 10 before myIntegerValue = 10 after intValue = 10 after integerValue = 10 after myIntegerValue = 11 int 값의 경우, 위에서 이야기한 것처럼 call-by-value 이므로,\n10이 그대로 유지되는 것은 당연하다.\nMyInteger의 경우 또한, myIntegerValue 라는 참조값을 복사해서 전달했으므로,\n11로 늘어나는 것 또한 타당하다.\n이는 앞서 이야기한 코드 예시에서, setName(\"Fifi\") 를 실행한 것과 비슷하다.\n주목할 부분은, integerValue 다.\nInteger는 primitive가 아닌 class이고,\n따라서 integerValue 는 new Integer(10) 을 가리키고 있던 것이 아닐까?\n그렇다면, value = value + 1 을 실행하면 11이 나와야 할 것 같은데,\n10으로 그냥 유지되어 버렸다.\n왜 이렇게 되었을까?\n3. Secret in Wrapper class : 그 비밀을 파헤치기 위해, Integer 클래스를 살짝 뜯어보자.\nInteger 클래스의 (int 형을 넘겨주는 경우의) 생성자는 다음과 같이 생겼다.\npublic Integer(int value) {  this.value = value; } 이 this.value 를 찾아가보면, 다음과 같이 final 로 선언된 것을 볼 수 있다.\nprivate final int value; 말인 즉슨, Integer 클래스는 Immutable(불변) 이라는 뜻이 된다.\n그렇다면, 아까 작성했던 value = value + 1 은 어떻게 동작했을까?\nWrapper class에 대해서 배웠다면, autoboxing, unboxing 이라는 용어에 대해서 들어봤을 것이다.\n이 boxing이 어떻게 일어나는지, 바이트 코드를 들여다보자.\npublic static void main(String[] args) {  Integer integerValue = 10; } public static void main(java.lang.String[]); Code: 0: bipush 10 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: return 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n이라는 부분을 보면, valueOf() 라는 static 메소드를 호출하고 있음을 볼 수 있다.\nvalueOf() 메소드는 다음과 같이 생겼다.\npublic static Integer valueOf(int i) {  if (i = IntegerCache.low \u0026\u0026 i  IntegerCache.high)  return IntegerCache.cache[i + (-IntegerCache.low)];  return new Integer(i); } 따라서, autoboxing은 내부적으로 컴파일러가 valueOf() 메소드를 호출했고,\n이에 따라 새로운 Integer 객체를 생성해서, 이를 return 하고 있음을 볼 수 있다.\n그렇다면, 덧셈은 어떻게 동작할까?\npublic static void main(String[] args) {  Integer integerValue = 10;  integerValue = integerValue + 1; }  public static void main(java.lang.String[]); Code: 0: bipush 10 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: aload_1 7: invokevirtual #3 // Method java/lang/Integer.intValue:()I 10: iconst_1 11: iadd 12: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 15: astore_1 16: return 0, 2, 5 번호의 byte code는 위의 내용과 같다.\nvalueOf() 메소드를 실행한 뒤에,\n그 결과인 Integer 객체를 지역변수 Array의 1번에 할당했다.\n6 번에서, 만들었던 이 Integer 객체를 꺼내왔고,\n7 번에서, intValue()라는 메소드를 호출했다. 참고로 intValue()는 다음과 같이 생겼다.\npublic int intValue() {  return value; } 다음으로 10번에서, 1 이라는 상수 값을 가져왔다.\n(iconst_1은 integerValue = interValue + 1 에서, 1을 담당한다.\n만약, 1 대신 3을 더했다면, 바이트 코드는 iconst_3이 된다.)\n이렇게 까지 하면,\n아까 Integer 객체에서 꺼낸 int 값과,\n상수 1이 Stack에 쌓여 있다.\n11번에서 이 두개를 더한다(iadd)\n그리고, 다시 Integer.valueOf() 의 static method를 실행해서,\n다시 Integer 객체로 만들고, 이를 다시 지역변수 Array의 1번에 저장한다.\n와우, 긴 여정이 끝났다. 정리하면 다음과 같다.\n(Integer 덧셈코드)\nInteger integerValue = 10; integerValue = integerValue + 1;  int 값(10)을 boxing(Integer 객체로 만듦)하고, 저장한다. 저장한 Integer 값을 unboxing 한다. unboxing 된 int 값에, 1을 더한다. 더한 결과(11)를 다시 boxing 하고, 저장한다.    Note. 이런 동작방식을 증명하는 또 다른 방법은,\n다음과 같은 코드를 실행해보는 것이다.\nInteger value = 10; System.out.println(\"value.getClass() = \" + value.getClass()); System.out.println(\"(value+1).getClass() = \" + (value+1).getClass()); 당연하게도, (value+1)은 unboxing된 int형이므로,\ngetClass()라는 메소드가 없다는 에러를 뱉는다.\n  이 과정을, 아까 수행한 integerMethod()에 대입해서 생각해보자.\n다시 스크롤해서 올려보기 귀찮을테니, 코드를 여기에 다시 적겠다.\npublic static void integerMethod(Integer value) {  value = value + 1; } 아직 덧셈 연산을 하기 전에는, 다음과 같은 형태를 갖고 있을 것이다.\n그러나, 방금 정리했듯이,\n더한 결과를 다시 Boxing하므로\n다시 말해, 새로운 new Integer() 객체를 생성하므로,\n덧셈을 하고나면, 다음의 그림과 같이 된다.\nvalue 라는 변수는 위와 같이 11 이라는 새로운 객체를 가리키고 있으므로,\nintegerMethod() 를 수행하더라도, 메소드의 종료 이후 결과값은 변하지 않는다.\n4. 마치며 : 길고도 험난한 여정이었다.\nC언어는 포인터라는 개념이 있기에,\n메소드를 호출해서 그 내부의 값을 변경하려면 무조건 이를 이용해야 하는데,\nJava에서는 primitives 와 object 의 동작방식이 다르고,\n이에 더해 Wrapper class는 클래스임에도 불구하고 primitives 처럼 동작해서 자주 헷갈렸다.\n이번 포스팅을 통해 확실하게 개념을 잡을 수 있었던 것 같다.\n이상으로 포스팅을 마칩니다.\nReference  Is Java “pass-by-reference” or “pass-by-value”? Wrapper classes and call by reference in java [duplicate] Java bytecode instruction listings  ","wordCount":"1254","inLanguage":"en","datePublished":"2020-10-21T20:26:00Z","dateModified":"2020-10-21T20:26:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/backup/language/java/2020-10-21-java_wrapper_class/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/backup/>Backups</a></div><h1 class=post-title># (Java) Wrapper Class는 Call by Value 일까?</h1><div class=post-meta><span title="2020-10-21 20:26:00 +0000 UTC">October 21, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/backup/Language/Java/2020-10-21-java_wrapper_class.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label="0. 들어가며">0. 들어가며</a></li><li><a href=#1-call-in-java aria-label="1. Call in Java">1. Call in Java</a></li><li><a href=#2-how-about-wrapper-classes aria-label="2. How about Wrapper classes?">2. How about Wrapper classes?</a></li><li><a href=#3-secret-in-wrapper-class aria-label="3. Secret in Wrapper class">3. Secret in Wrapper class</a></li><li><a href=#4-%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label="4. 마치며">4. 마치며</a><ul><li><a href=#reference aria-label=Reference>Reference</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>: Java 는 Call by Value일까, Call by Reference 일까?</p><p>지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,<br>객체를 넘겨줄 때에는 call by reference로 알고 있었다.</p><p>그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.</p><h1 id=1-call-in-java>1. Call in Java<a hidden class=anchor aria-hidden=true href=#1-call-in-java>#</a></h1><p>: Java 에서는 언제나 Call by Value 라고 한다.<br><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value?page=1&tab=oldest#tab-top">약 12년 된 스택오버플로우의 한 질문글</a>에 달린 답변은 다음과 같다.</p><hr><blockquote><p>자바는 예외 없이, 항상 pass by value 입니다.<br>그렇다면, 왜 사람들이 이것을 혼란스러워 하고, Java는 pass by reference라고 믿고 있을까요? 키 포인트는, Java가 어떠한 상황에서도, 객체의 값에 직접적인 접근을 제공하지 않기 때문입니다. 객체에 접근하는 유일한 방법은 그 객체의 참조를 통하는 것뿐입니다. Java 객체가 직접 접근되지 않고 참조에 의해 접근되기 때문에, 현학적으로 필드, 변수, 그리고 메소드 인자를 객체인 것처럼 이야기 되는데, 이것들은 객체에 대한 참조일 뿐입니다. 이러한 혼란은 (엄밀히 말하면, 틀린) 명명(命名)의 변화에서 기인합니다.<br>따라서, 메소드를 호출할 때,</p><ul><li>Primitive인 경우 : pass-by-value 는 primitive의 실제 값의 전달입니다.</li><li>객체인 경우 : pass-by-value는 객체에 대한 참조 &ldquo;값"의 전달입니다.<br>&mldr; 하략</li></ul></blockquote><hr><p>또 다른 답변의 경우, 친절하게 예시도 같이 달아주었다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Dog aDog <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Dog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Max&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    Dog oldDog <span style=color:#f92672>=</span> aDog<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// we pass the object to foo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    foo<span style=color:#f92672>(</span>aDog<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// aDog variable is still pointing to the &#34;Max&#34; dog when foo(...) returns
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    aDog<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>().</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Max&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    aDog<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>().</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Fifi&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    aDog <span style=color:#f92672>==</span> oldDog<span style=color:#f92672>;</span> <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span><span style=color:#f92672>(</span>Dog d<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    d<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>().</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Max&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// change d inside of foo() to point to a new Dog instance &#34;Fifi&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    d <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Dog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Fifi&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    d<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>().</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Fifi&#34;</span><span style=color:#f92672>);</span> <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>이 예제를 보고 나니, 위 답변이 무슨 말을 하는지 이해할 수 있었다.</p><p>코드를 보면, <code>aDog</code> 라는 변수를 <code>foo()</code> 메소드로 넘겨주었다.<br><code>foo()</code> 메소드 안에서, <code>getName()</code> 을 찍어보면 <code>"Max"</code>로 찍히는 것은 당연하다.<br><strong>그러나, 주의깊게 봐야 할 부분은 <code>d = new Dog("Fifi")</code> 다.</strong></p><p>만약 참조에 의한 호출이었다면, <code>d</code> 라는 참조는 본래 <code>aDog</code>가 가리키는 객체를 가리킬 것이다.<br>따라서, <code>aDog는</code> Fifi로 바뀌어야 한다.</p><p>그러나 메소드를 실행하고 나서 다시 <code>aDog</code>의 <code>getName()</code>을 찍어보면,<br>여전히 <code>"Max"</code>로 남아있다.</p><p>왜냐하면, <code>aDog</code> 라는 <strong>참조</strong> 를 넘겨준 것이 아니라, <strong>복사본</strong> 을 넘겨주었기 때문이다.</p><p>여전히 이해하기 힘들다면, 다음의 그림을 보자.</p><p><img loading=lazy src=/assets/images/2020-10-27-20-59-29_2020-10-21-java_wrapper_class.md.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Dog aDog <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Dog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Max&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>Dog oldDog <span style=color:#f92672>=</span> aDog<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>위 코드를 실행하면, 그림과 같이 <code>aDog과</code> <code>oldDog는</code> Max라는 녀석을 가리키고 있다.<br>여기서, <code>foo()</code> 메소드를 실행하면 어떻게 될까?</p><p><img loading=lazy src=/assets/images/2020-10-27-21-06-02_2020-10-21-java_wrapper_class.md.png alt></p><p>위 그림과 같이, <code>d</code>는 <code>aDog</code>의 복사본(call-by-value)이 된다.<br>만약, 참조에 의한 호출이었다면 다음과 같은 모양새였을 것이다.</p><p><img loading=lazy src=/assets/images/2020-10-27-21-11-08_2020-10-21-java_wrapper_class.md.png alt></p><p>그러나, 실제로 <code>d</code>는 복사본이므로, <code>new Dog("Fifi")</code>를 수행하면 다음과 같이 된다.</p><p><img loading=lazy src=/assets/images/2020-10-27-21-08-22_2020-10-21-java_wrapper_class.md.png alt></p><p>따라서, <code>foo()</code> 메소드 안에서 <code>getName()</code> 을 찍어보면 <code>"Fifi"</code>로 나오지만,<br>메소드가 끝난 이후, 메인 메소드에서 다시 <code>getName()</code>을 찍어보면 <code>"Max"</code>로 나오게 된다.</p><p>반면, <code>foo()</code> 메소드 안에서, <code>d.setName("Fifi")</code> 라고 사용한다면,<br>다음 그림과 같이 메소드 종료 이후에 <code>aDog</code>의 Name은 <code>"Fifi"</code>가 될 것이다.</p><p><img loading=lazy src=/assets/images/2020-10-27-21-15-17_2020-10-21-java_wrapper_class.md.png alt></p><p>결국 Java는 Call-by-value 이지만,
우리가 사용할 때에는 대부분 Call-by-Reference 처럼 인식하게 된다.<br>Call-by-value라고 해서, 특별하게 걱정할 내용은 없다는 얘기다.</p><h1 id=2-how-about-wrapper-classes>2. How about Wrapper classes?<a hidden class=anchor aria-hidden=true href=#2-how-about-wrapper-classes>#</a></h1><p>: 하지만, Integer 와 같은 Wrapper class는 어떨까?<br>다음 코드의 결과를 예상해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> intValue <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        Integer integerValue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Integer<span style=color:#f92672>(</span>10<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        MyInteger myIntegerValue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyInteger<span style=color:#f92672>(</span>10<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;before intValue = &#34;</span> <span style=color:#f92672>+</span> intValue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;before integerValue = &#34;</span> <span style=color:#f92672>+</span> integerValue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;before myIntegerValue = &#34;</span> <span style=color:#f92672>+</span> myIntegerValue<span style=color:#f92672>.</span><span style=color:#a6e22e>getValue</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        intMethod<span style=color:#f92672>(</span>10<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        integerMethod<span style=color:#f92672>(</span>integerValue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        myIntegerMethod<span style=color:#f92672>(</span>myIntegerValue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;after intValue = &#34;</span> <span style=color:#f92672>+</span> intValue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;after integerValue = &#34;</span> <span style=color:#f92672>+</span> integerValue<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;after myIntegerValue = &#34;</span> <span style=color:#f92672>+</span> myIntegerValue<span style=color:#f92672>.</span><span style=color:#a6e22e>getValue</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>intMethod</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> value <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>integerMethod</span><span style=color:#f92672>(</span>Integer value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> value <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>myIntegerMethod</span><span style=color:#f92672>(</span>MyInteger value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        value<span style=color:#f92672>.</span><span style=color:#a6e22e>increase</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyInteger</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> value<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyInteger</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getValue</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>increase</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> value <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>결과는 다음과 같다.</p><pre tabindex=0><code>before intValue = 10
before integerValue = 10
before myIntegerValue = 10
after intValue = 10
after integerValue = 10
after myIntegerValue = 11
</code></pre><p>int 값의 경우, 위에서 이야기한 것처럼 <strong>call-by-value</strong> 이므로,<br>10이 그대로 유지되는 것은 당연하다.</p><p>MyInteger의 경우 또한, <code>myIntegerValue</code> 라는 참조값을 복사해서 전달했으므로,<br>11로 늘어나는 것 또한 타당하다.<br>이는 앞서 이야기한 코드 예시에서, <code>setName("Fifi")</code> 를 실행한 것과 비슷하다.</p><p><strong>주목할 부분은, <code>integerValue</code> 다.</strong><br>Integer는 primitive가 아닌 class이고,<br>따라서 <code>integerValue</code> 는 <code>new Integer(10)</code> 을 가리키고 있던 것이 아닐까?<br>그렇다면, <code>value = value + 1</code> 을 실행하면 11이 나와야 할 것 같은데,<br>10으로 그냥 유지되어 버렸다.</p><p>왜 이렇게 되었을까?</p><h1 id=3-secret-in-wrapper-class>3. Secret in Wrapper class<a hidden class=anchor aria-hidden=true href=#3-secret-in-wrapper-class>#</a></h1><p>: 그 비밀을 파헤치기 위해, Integer 클래스를 살짝 뜯어보자.<br>Integer 클래스의 (int 형을 넘겨주는 경우의) 생성자는 다음과 같이 생겼다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Integer</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>이 this.value 를 찾아가보면, 다음과 같이 final 로 선언된 것을 볼 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> value<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>말인 즉슨, Integer 클래스는 <strong>Immutable(불변)</strong> 이라는 뜻이 된다.<br>그렇다면, 아까 작성했던 <code>value = value + 1</code> 은 어떻게 동작했을까?</p><p>Wrapper class에 대해서 배웠다면, <code>autoboxing</code>, <code>unboxing</code> 이라는 용어에 대해서 들어봤을 것이다.<br>이 <code>boxing</code>이 어떻게 일어나는지, 바이트 코드를 들여다보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Integer integerValue <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><pre tabindex=0><code class=language-properties data-lang=properties>  public static void main(java.lang.String[]);
    Code:
       0: bipush        10
       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
       5: astore_1
       6: return
</code></pre><p><code>2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</code><br>이라는 부분을 보면, valueOf() 라는 static 메소드를 호출하고 있음을 볼 수 있다.</p><p><code>valueOf()</code> 메소드는 다음과 같이 생겼다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Integer <span style=color:#a6e22e>valueOf</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>i <span style=color:#f92672>&gt;=</span> IntegerCache<span style=color:#f92672>.</span><span style=color:#a6e22e>low</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;=</span> IntegerCache<span style=color:#f92672>.</span><span style=color:#a6e22e>high</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> IntegerCache<span style=color:#f92672>.</span><span style=color:#a6e22e>cache</span><span style=color:#f92672>[</span>i <span style=color:#f92672>+</span> <span style=color:#f92672>(-</span>IntegerCache<span style=color:#f92672>.</span><span style=color:#a6e22e>low</span><span style=color:#f92672>)];</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Integer<span style=color:#f92672>(</span>i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>따라서, <code>autoboxing</code>은 내부적으로 컴파일러가 <code>valueOf()</code> 메소드를 호출했고,<br>이에 따라 새로운 Integer 객체를 생성해서, 이를 return 하고 있음을 볼 수 있다.</p><p>그렇다면, 덧셈은 어떻게 동작할까?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Integer integerValue <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    integerValue <span style=color:#f92672>=</span> integerValue <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><pre tabindex=0><code> public static void main(java.lang.String[]);
    Code:
       0: bipush        10
       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
       5: astore_1
       6: aload_1
       7: invokevirtual #3                  // Method java/lang/Integer.intValue:()I
      10: iconst_1
      11: iadd
      12: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      15: astore_1
      16: return
</code></pre><p>0, 2, 5 번호의 byte code는 위의 내용과 같다.<br><code>valueOf()</code> 메소드를 실행한 뒤에,<br>그 결과인 Integer 객체를 지역변수 Array의 1번에 할당했다.</p><p>6 번에서, 만들었던 이 Integer 객체를 꺼내왔고,<br>7 번에서, <code>intValue()</code>라는 메소드를 호출했다.<br>참고로 <code>intValue()</code>는 다음과 같이 생겼다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>intValue</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> value<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>다음으로 10번에서, 1 이라는 상수 값을 가져왔다.<br>(<code>iconst_1</code>은 <code>integerValue = interValue + 1</code> 에서, <code>1</code>을 담당한다.<br>만약, <code>1</code> 대신 <code>3</code>을 더했다면, 바이트 코드는 <code>iconst_3</code>이 된다.)</p><p>이렇게 까지 하면,<br>아까 Integer 객체에서 꺼낸 int 값과,<br>상수 1이 Stack에 쌓여 있다.</p><p>11번에서 이 두개를 더한다(<code>iadd</code>)</p><p>그리고, 다시 <code>Integer.valueOf()</code> 의 static method를 실행해서,<br>다시 Integer 객체로 만들고, 이를 다시 지역변수 Array의 1번에 저장한다.</p><p>와우, 긴 여정이 끝났다. 정리하면 다음과 같다.</p><p>(Integer 덧셈코드)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Integer integerValue <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>integerValue <span style=color:#f92672>=</span> integerValue <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
</span></span></code></pre></div><ol><li>int 값(10)을 boxing(Integer 객체로 만듦)하고, 저장한다.</li><li>저장한 Integer 값을 unboxing 한다.</li><li>unboxing 된 int 값에, 1을 더한다.</li><li>더한 결과(11)를 다시 boxing 하고, 저장한다.</li></ol><hr><blockquote><p>Note. 이런 동작방식을 증명하는 또 다른 방법은,<br>다음과 같은 코드를 실행해보는 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Integer value <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;value.getClass() = &#34;</span> <span style=color:#f92672>+</span> value<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;(value+1).getClass() = &#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span>value<span style=color:#f92672>+</span>1<span style=color:#f92672>).</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>());</span>
</span></span></code></pre></div><p>당연하게도, (value+1)은 unboxing된 int형이므로,<br>getClass()라는 메소드가 없다는 에러를 뱉는다.</p></blockquote><hr><p>이 과정을, 아까 수행한 <code>integerMethod()</code>에 대입해서 생각해보자.<br>다시 스크롤해서 올려보기 귀찮을테니, 코드를 여기에 다시 적겠다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>integerMethod</span><span style=color:#f92672>(</span>Integer value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    value <span style=color:#f92672>=</span> value <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>아직 덧셈 연산을 하기 전에는, 다음과 같은 형태를 갖고 있을 것이다.</p><p><img loading=lazy src=/assets/images/2020-10-27-22-14-26_2020-10-21-java_wrapper_class.md.png alt></p><p>그러나, 방금 정리했듯이,<br><strong>더한 결과를 다시 Boxing하므로</strong><br>다시 말해, <strong>새로운 new Integer() 객체를 생성하므로,</strong><br>덧셈을 하고나면, 다음의 그림과 같이 된다.</p><p><img loading=lazy src=/assets/images/2020-10-27-22-16-00_2020-10-21-java_wrapper_class.md.png alt></p><p>value 라는 변수는 위와 같이 11 이라는 <strong>새로운 객체</strong>를 가리키고 있으므로,<br><code>integerMethod()</code> 를 수행하더라도, 메소드의 종료 이후 결과값은 변하지 않는다.</p><h1 id=4-마치며>4. 마치며<a hidden class=anchor aria-hidden=true href=#4-마치며>#</a></h1><p>: 길고도 험난한 여정이었다.<br>C언어는 포인터라는 개념이 있기에,<br>메소드를 호출해서 그 내부의 값을 변경하려면 무조건 이를 이용해야 하는데,<br>Java에서는 primitives 와 object 의 동작방식이 다르고,<br>이에 더해 Wrapper class는 클래스임에도 불구하고 primitives 처럼 동작해서 자주 헷갈렸다.</p><p>이번 포스팅을 통해 확실하게 개념을 잡을 수 있었던 것 같다.<br>이상으로 포스팅을 마칩니다.</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value?page=1&tab=oldest#tab-top">Is Java “pass-by-reference” or “pass-by-value”?</a></li><li><a href=https://stackoverflow.com/questions/20804862/wrapper-classes-and-call-by-reference-in-java>Wrapper classes and call by reference in java [duplicate]</a></li><li><a href=https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings>Java bytecode instruction listings</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/backup/language/java/2020-10-23-how-junit_works_without_main/><span class=title>« Prev Page</span><br><span># (Java) Junit은 어떻게 Main method 없이 실행될까?</span></a>
<a class=next href=http://cjlee38.github.io/backup/tech/btb/2020-10-20-value_object/><span class=title>Next Page »</span><br><span># (번역) Value Object of Martin Fowler</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) Wrapper Class는 Call by Value 일까? on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%28Java%29%20Wrapper%20Class%eb%8a%94%20Call%20by%20Value%20%ec%9d%bc%ea%b9%8c%3f&url=http%3a%2f%2fcjlee38.github.io%2fbackup%2flanguage%2fjava%2f2020-10-21-java_wrapper_class%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) Wrapper Class는 Call by Value 일까? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fbackup%2flanguage%2fjava%2f2020-10-21-java_wrapper_class%2f&title=%23%20%28Java%29%20Wrapper%20Class%eb%8a%94%20Call%20by%20Value%20%ec%9d%bc%ea%b9%8c%3f&summary=%23%20%28Java%29%20Wrapper%20Class%eb%8a%94%20Call%20by%20Value%20%ec%9d%bc%ea%b9%8c%3f&source=http%3a%2f%2fcjlee38.github.io%2fbackup%2flanguage%2fjava%2f2020-10-21-java_wrapper_class%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) Wrapper Class는 Call by Value 일까? on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fbackup%2flanguage%2fjava%2f2020-10-21-java_wrapper_class%2f&title=%23%20%28Java%29%20Wrapper%20Class%eb%8a%94%20Call%20by%20Value%20%ec%9d%bc%ea%b9%8c%3f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) Wrapper Class는 Call by Value 일까? on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fbackup%2flanguage%2fjava%2f2020-10-21-java_wrapper_class%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) Wrapper Class는 Call by Value 일까? on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%28Java%29%20Wrapper%20Class%eb%8a%94%20Call%20by%20Value%20%ec%9d%bc%ea%b9%8c%3f%20-%20http%3a%2f%2fcjlee38.github.io%2fbackup%2flanguage%2fjava%2f2020-10-21-java_wrapper_class%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # (Java) Wrapper Class는 Call by Value 일까? on telegram" href="https://telegram.me/share/url?text=%23%20%28Java%29%20Wrapper%20Class%eb%8a%94%20Call%20by%20Value%20%ec%9d%bc%ea%b9%8c%3f&url=http%3a%2f%2fcjlee38.github.io%2fbackup%2flanguage%2fjava%2f2020-10-21-java_wrapper_class%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>