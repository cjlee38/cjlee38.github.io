<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java ) | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. 들어가며 : 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.
아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.
1. 해결할 문제 : LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 &ldquo;최대 증가 부분 수열&rdquo; 정도가 된다."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/backup/algorithm/algorithm/2020-12-15-ways_to_get_lis_length/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="# 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )"><meta property="og:description" content="0. 들어가며 : 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.
아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.
1. 해결할 문제 : LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 &ldquo;최대 증가 부분 수열&rdquo; 정도가 된다."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/backup/algorithm/algorithm/2020-12-15-ways_to_get_lis_length/"><meta property="article:section" content="backup"><meta property="article:published_time" content="2020-12-15T13:57:00+00:00"><meta property="article:modified_time" content="2020-12-15T13:57:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )"><meta name=twitter:description content="0. 들어가며 : 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.
아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.
1. 해결할 문제 : LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 &ldquo;최대 증가 부분 수열&rdquo; 정도가 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Backups","item":"http://cjlee38.github.io/backup/"},{"@type":"ListItem","position":2,"name":"# 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )","item":"http://cjlee38.github.io/backup/algorithm/algorithm/2020-12-15-ways_to_get_lis_length/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )","name":"# 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )","description":"0. 들어가며 : 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.\n아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.\n1. 해결할 문제 : LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 \u0026ldquo;최대 증가 부분 수열\u0026rdquo; 정도가 된다.","keywords":["null"],"articleBody":"0. 들어가며 : 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.\n아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.\n1. 해결할 문제 : LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 “최대 증가 부분 수열” 정도가 된다. 즉, 정수의 수열 S 가 주어졌을 때, S 에서 0개 이상의 숫자를 지우고 남은 수열을 “부분 수열” 이라고 칭하고, 그 수열 중에서 “오름차순으로 정렬” 된 수열을 “증가 부분 수열”, 그리고 그 중에서 가장 긴 수열을 “최대 증가 부분 수열” 이라고 한다.\n말로 하면 약간 헷갈리니, 다음의 예시를 보자. 앞으로 이 예시를 계속 사용할 것이다.\n 부분 수열의 예 : [3 8 9 2 1 4] 증가 부분 수열의 예 : [1 4 8] 최대 증가 부분 수열의 예: [3 5 7 8]  이 때, 최대 증가 부분 수열(이하, LIS) 또한 여러 개가 될 수 있다. (현 예에서는 [3 5 7 8] 이외에 [3 5 7 9] 또한 존재한다.) 그러나, 우리가 원하는 것은 “LIS 의 길이” 하나 이므로, 몇 개가 존재하던 상관이 없다.\n2. 첫 번째 방법 - 완전탐색 2-A 이론 : 사람이라면 몇 번 훑어보면 금방 찾을 수 있지만, 알다시피 컴퓨터는 우리 생각만큼 똑똑하지 않다. 나도 그랬듯이, 이 문제를 코딩으로 해결하고자 할 때 떠올릴 수 있는 방법은, 모든 경우를 탐색하는 것, 즉 완전탐색이다.\n완전탐색을 이해하는 것은 그리 어렵지 않다. 말로 자세히 풀어서 설명하기보단, 다음의 순서를 반복하는 것을 이해하는 것이 더 간단할 것 같다.\n 주어진 배열(= 부분수열)에서, 하나의 요소 X 를 선택한다. X 뒤쪽의 배열을 살펴보면서, X 보다 크면 이를 다음 탐색할 배열 A 에 넣는다. 배열 A 를 가지고, 1번을 반복한다. 만약 배열 A 가 비어 있는 경우, 재귀함수를 종료(스택을 하나 제거)하면서 0 을 return한다.  그림으로 표현하자면, 다음과 같다.\n[3 5 7 9 2 1 4 8] 이라는 배열이 주어져있고, 3 을 X 로 지정했다.\n그리고 나서, 그 뒤쪽의 배열 중, 3 보다 큰 녀석들(빨간박스) 을 새로운 배열로 만든다.\n그리고 이렇게 [5 7 9 4 8] 을 가지고, 또 다시 5 를 X로 지정했다.\n다시 그 뒤쪽을 살펴보면서, [7 9 8] 을 새로운 배열로 만든다.\n이러한 과정을 반복하면서, 배열이 비어 있는 경우, 0 을 return 하면 된다.\n살짝 머리가 아파지니, 그윽한 자바코드 냄새를 맡으면서 환기해보자.\n2-B 구현 public int lis1(ListInteger list) {  if (list.isEmpty()) return 0;   int ret = 0;  for(int i = 0; i  list.size(); i++) {  ListInteger sub = new ArrayList();  for (int j = i+1; j  list.size(); j++) {  if (list.get(i)  list.get(j)) {  sub.add(list.get(j));  }  }   ret = Math.max(ret, lis1(sub) + 1);  }   return ret; } 하나씩 살펴보자.\nif (list.isEmpty()) return 0; 리스트(배열)가 비어있는 경우에 0 을 돌려주는 것은 당연하다. 처음으로 주어진 배열 자체가 아예 비어있다면 LIS 의 길이 또한 0 이 될 것이며, 재귀함수의 호출 과정속에서도 배열이 비어있다는 것 또한 마찬가지로 LIS 의 길이가 0 이라는 것을 의미하기 때문이다. 이와 더불어, 재귀함수를 종료할 base case(기저사례) 이기도 하다.\nfor(int i = 0; i  list.size(); i++) {  ListInteger sub = new ArrayList();  for (int j = i+1; j  list.size(); j++) {  if (list.get(i)  list.get(j)) {  sub.add(list.get(j));  }  } } ret은 잠시 미뤄두고, 다음으로 주목할 부분은 for-loop 다. 0 번째부터 시작하는, 하나의 요소 X를 선택한 뒤(=list.get(i)), 그 뒤쪽의 값과 비교하면서, 만약 뒤쪽의 값이 더 크다면 이를 sub 라는 리스트에 추가한다.\nint ret = 0;  for ( i... ) {  for ( j... ) {   }  ret = Math.max(ret, lis1(sub) + 1); }  return ret; 그 다음으로 살펴볼 부분은 변수 ret 이다. 주목해야 할 부분은 ret = Math.max(ret, lis1(sub) + 1); 이 부분인데, 우리가 재귀함수를 열심히 쌓다가, 이제는 우리가 헤어져야 할 시간이 되면 0 이 return 된다.\n애초에 base case 에서부터 1 을 return 하지 않고, 0 을 return 하는 대신 여기에 + 1 을 넣어준 이유는,\n 원본의 배열이 애초에 비어 있을 때 0 을 return 하는게 타당하면서, 동시에, 재귀함수를 호출하던 과정 속에서 배열이 비어있을 때 또한 길이가 0 임을 의미히기도 하고, 이와 더불어 “어차피 우리가 선택한 sub 배열은 나보다 큰 녀석” 이고, 이는 곧 증가 부분 수열의 길이가 반드시 1 (혹은 그 이상) 늘어난다는 것을 의미하기 때문이다.    3 번이 헷갈리는 사람(나)을 위해, 다음과 같은 부연설명을 읊조려보자면,\n가령 원 배열이 [1 2] 가 있다고 해보자. 그렇다면, 첫 번째 재귀함수 과정 속에서 sub 에 2 가 들어갈 것이고, 두 번째 재귀함수 내에서 [2] 는 다시 아무것도 없는 배열 [] 를 호출할 것이다.\n세 번째 재귀함수에선, 배열에 아무것도 들어있지 않으므로 0 이 return 될 것이고, 다시 두 번째 재귀함수로 돌아왔을 때에는 for-loop 내에서 ret = Math.max(0, 0+1); 이 된다. for-loop 가 더 이상 나아갈 수 없으므로 1 을 그대로 return 하고, 첫 번째 재귀함수에서 마찬가지로 ret = Math.max(0, 1+1); 이 된다. i 가 1(즉, X 가 2인 경우) 에는 위와 같은 과정을 통해 1 이 return 될 것이고, Math.max(2, 1) 를 통해 최종적으로 2 가 return 된다.\n여전히 이해가 되지 않는다면, 반대로 [2 1] 인 경우를 상상해보자.\n  2-C 시간복잡도 : 이러한 완전탐색의 시간복잡도는 얼마나 될까? 대부분의 시간복잡도가 최악의 상황을 가정하니, 이 알고리즘에 최악이 될 수 있는 상황을 가정해보자. 아무래도 sub가 많아지면 많아질수록 최악이 될테니, [1 2 3 4 5 6 …] 과 이미 오름차순으로 정렬되었을 때가 가장 오래 걸릴 듯 싶다.\n배열을 하나씩 늘려가면서 함수가 호출되는 횟수를 살펴보자.(for문은 재귀함수의 호출로 연결된다는 점을 생각하자.)\n [] - 1 [1] - 2 [1 2] - 4 [1 2 3] - 8  패턴이 보인다. O(2^n) 이다. 통상적으로 O(n^2) 이어도 상당히 곤란한 시간복잡도인데, O(2^n) 이라고 하면 척 봐도 비효율적인 것 처럼 보인다.\n3. 두 번째 방법 - 동적계획법 : 위에서 살펴본 완전탐색이 비효율적인 이유는, 역시 같은 연산을 반복하기 때문이었다. 이전에 작성했던 재귀함수 글 에서 보았던 것처럼, 동적계획법을 이용해보자. 이렇게 동적계획법을 떠올릴 수 있는 기저는, 이 문제가 최적부분구조를 갖고 있기 때문이다.\n메모이제이션, 캐시 등 관점에 따라 다른 이름으로 부르지만, 어쨌든 여기서 중요시하는 내용은 “한번 계산한 부분은, 또 다시 계산하지 않는다.” 는 것이 핵심이다. 바로 위의 사진에서 보듯이, 배열이 비어있을 때를 중복으로 쳐다보기도 하지만, 배열이 [3]과 같은 부분도 중복해서 연산을 하는 것을 볼 수 있다.\n즉, [3] 의 꼬리를 잘라내보자.\n3-A. 이론 : 단순하게 동적계획법을 생각하면 어렵지 않을 것 같다. “처음 계산이면 캐시에 저장, 한번이라도 본 적이 있다면 꺼내서 사용” 하면 된다. 다만, 막상 코드로 쓰려고 키보드에 손을 올리는 순간 멈칫하게 된다. “캐시를 어떻게 만들어놓지?”\n이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다. 즉, [3 5 7 9 2 1 4 8] 라는 배열에서, 우리가 7 이라는 요소를 선택했을 때, 그 sub 가 될 수 있는 [9 8]은 언제나 동일하다. 이는 그 전의 호출에서 3의 선택으로 [5 7 9 4 8]이 넘어왔든, 5의 선택으로 [7 9 8]이 넘어왔든, 이번에 7 이 선택되었으면 그 sub가 되는 [9 8]은 항상 동일하다는 것이다.\n이를 다시 바꿔서 이해해보자. 우리가 7 을 선택했을 때, 즉 index 상으로 2 번을 선택했을 때 해당 증가 부분 수열의 길이가 계산되어 있다면, 그 값을 return 하면 된다. 계산되어 있지 않다면, 기존에 하던대로 계산하면 된다.\n3-B 구현 : 위 아이디어를 코드로 구현하기 이전에, 몇 가지 작업을 해둘 부분이 있다.\n먼저, 리스트의 가장 앞부분에 -1 을 넣어두자.(현재 예제는 자연수를 기준으로 하고 있기 때문에, 정수를 고려할 경우 Integer.MIN_VALUE를 넣어야 한다.) 이 내용은 조금 밑에서 설명하겠다.\nlist.add(0, Integer.MIN_VALUE); 그 다음으로, cache를 -1로 초기화 해놓자.\nListInteger cache = new ArrayList(); for (int i = 0; i  list.size(); i++) {  cache.add(-1); } -1 로 초기화해놓는 이유는, 기존의 list 와 쌍을 맞춰주기 위함이면서, 동시에 LIS 가 빈 배열로 인해 0 이 될 수도 있으니, 이를 구분하기 위해 -1 로 초기화 해두겠다는 것이다.\npublic int lis2(ListInteger list, ListInteger cache, int start) {  if (cache.get(start) != -1) return cache.get(start);   int ret = 0;  for(int next = start+1; next  list.size(); next++) {  if (list.get(start)  list.get(next)) {  ret = Math.max(ret, lis2(list, cache, next) + 1);  }   }  cache.set(start, ret);   return ret; }   여기서 잠깐, 기존 코드와의 통일성을 위해 List를 사용하였지만, 이번에는 list 와 cache의 크기가 고정되어 있기 때문에(앞서는 sub에 따라 크기가 달라졌다.), 단순히 array를 사용해도 상관 없다.\n  뭔가 기존 코드와 비슷하면서도 사뭇 다른 부분이 몇가지 보인다. 이 또한 하나씩 뜯어보자.\nif (cache.get(start) != -1) return cache.get(start); 가장 간단해 보이는 이 부분은 캐시에 저장된 부분이 있다면, 그 부분을 가져오겠다는 의미가 된다.\npublic int lis2(ListInteger list, ListInteger cache, int start) 그 다음으로 눈에 띄는 부분은, 함수가 받고자 하는 파라미터가 조금 변화하였다. 이 부분이 가벼워 보이지만 신중하게 바라봐야 하는 이유는, 바로 start 변수에 있다. 우리가 cache를 사용하려면, index를 기반으로 접근해야 한다. 그리고 이 index를 사용하기 위해서는, 항상 리스트의 길이는 고정되어야 한다. 말인 즉슨, sub 배열을 만들어줘서는 안된다는 뜻이다.\nsub 배열을 만들게 될 경우, 우리가 for-loop에서 사용할 index가 뒤틀리는 문제가 발생하게 된다. 반대로, sub 배열을 만들지 않고 원본 list를 사용하지 않더라도 전혀 문제가 되지 않는다. 왜냐하면, 우리가 사용하는 index 는 “앞의 내용을 전혀 신경쓰지 않아도” 되기 때문이다.\n위에서 작성한 내용을 다시 살펴보자.\n  이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다.\n  for(int next = start+1; next  list.size(); next++) {  if (list.get(start)  list.get(next)) {  ret = Math.max(ret, lis2(list, cache, next) + 1);  }  } 이에 맞춰서 for-loop 도 변화하였다. 우리는 리스트를 인덱스를 기준으로 살펴볼 것이므로, next 는 start + 1 부터 시작한다. 그리고 와중에 “나보다 큰 녀석\"을 발견하면, 그 녀석을 대상으로 다시 재귀함수를 호출하게 된다. 재귀함수의 결과에 더하는 1 은 앞에서 설명했으니 생략하겠다.\n또한, 만약 cache에서 답을 구하지 못하고, LIS 가 마지막으로 가더라도 상관없다. 자연스럽게 for-loop 의 조건에 성립하지 않으므로, 0 이 return 된다. 즉, 이전 코드의 if (list.isEmpty()) return 0; 와 같은 base case를 특별히 명시해둘 필요가 없는 것이다.\ncache.set(start, ret);  return ret; 처음 문제를 마주한 경우에는 당연히 cache를 저장하고, 그 값을 돌려주면 된다.\n그런데, 단순히 이렇게만 봤을때에 문제가 하나 있다. 바로 0 번째 인덱스가 가장 큰 값인 경우를 해결하지 못한다는 것이다. 그 이유는, 재귀함수를 처음 호출했을 때, if 문에 걸리지 않기 때문이다. 이를 위해 list.add(0, Integer.MIN_VALUE); 를 넣었던 것이다.\n다른 방법으로는,\n애초에 lis2() 함수 자체를 한번 더 묶어서,\nint max = 0; for (int i = 0; i  n; i++) {  max = Math.max(max, lis2(...)); } 처럼 사용하는 방법이 있다. 이 방식은 lis2() 의 반복을 밖에서 하느냐, 안에서 하느냐의 차이이지, 본질적으로는 같다. 다만, ret = 0 을 ret = 1로 바꾸어 주어야 한다. 또한, cache의 내용은 달라진다\n 0번 index에 값을 넣어주는 방법- [4 3 2 1 0 2 2 1 0] 바깥쪽에서 loop를 돌려주는 방법 - [4 3 2 1 3 3 2 1]  3-C 시간복잡도 : 아까 2-C 에서 보았던 꼬리란 꼬리는 다 끊어놓았기 때문에, 해당 코드는 결국 까보면 2중의 for-loop를 반복하게 된다. 따라서 시간복잡도는 O(n^2) 이 된다.\n4. 세 번째 방법 - 동적계획법 2 : 엥? 두 번째도 동적 계획법이었는데, 세 번쨰도 동적 계획법이라니 약간 당황스럽다. 하지만 읽어보면, 둘 다 동적계획법의 정신을 계승하는 알고리즘이란 것을 알 수 있다.\n4-A 이론 : 이번에는 조금 관점을 달리하자. 재귀함수를 호출하기 보다는, 두 개의 for-loop 로 해결할 것이다. 어떻게 할 것이냐?\n이는 배열의 요소를 하나씩 살펴보면서, “내가 될 수 있는 증가부분수열의 최대값은 몇이냐?” 를 보는 것이다. 아까는, cache에서, LIS 의 시초가 되는 녀석이 부분증가수열의 최대값이 되었다면, 지금은 LIS 의 유종의 미를 거두어주는 녀석이 부분증가수열의 최대값이 된다.\n즉,\n 전자의 경우 - [4 3 2 1 3 3 2 1] 후자의 경우 - [1 2 3 4 1 1 2 4]  가 된다.\n이를 어떻게 만드는고 하니, 아주 간단하게 다음과 같은 아이디어를 적용하면 된다\n 현재 내 값 X 를 기준으로 앞쪽을 봤을 때 나보다 작은 녀석들 중 (즉, 내가 뒤에 붙을 수 있는 후보들) , 증가 부분수열의 길이가 가장 긴 녀석 + 1 이 나의 증가부분수열의 길이.  글재주가 없어 말로 쓰니 헷갈린다. 얼른 예시를 보자.\n편의상 값(Value)를 담았다는 의미로 V 를, 증가부분수열의 길이(Length) 를 담았다는 의미로 L 테이블이라 칭하겠다.\n처음에는 이렇게 가장 앞에 0을 붙인채로 초기화한다.\nx 를 3으로 두었을 때, 내 앞에 있으면서, 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1을 더한게, 나의 length가 된다.\n마찬가지의 과정을 반복한다. 즉, x 를 9로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석들은 [0 3 5 7] 이다. 그리고 그 중에서, 가장 긴 증가부분수열의 길이를 갖고 있는 3 에 1 을 더한 4 가 나의 length가 된다.\nvalue 가 2 일 때도 마찬가지이다. x를 2로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1 을 더한게 나의 length, 즉 1이 된다.\n마지막의 경우를 살펴보자. X를 8로 두었을 때, 나보다 작은 녀석은 [3 5 7 2 1 4] 이다. 그리고 그 중, 가장 긴 증가부분수열의 길이를 갖고 있는 녀석은 3(7이 갖고있는) 이고, 여기에 1을 더한 4 가 답이 된다.\n이렇게 해서, 4 라는 최종 답을 구할 수 있다.\n4-B 구현 public int lis3(ListInteger V) {  ListInteger L = new ArrayList();   V.add(0, 0);  L.add(0);   int ret = 0;  for (int i = 1; i  V.size(); i++) {  int maxLen = 0;  for (int j = 0; j  i; j++) {  if (V.get(j)  V.get(i)) {  maxLen = Math.max(maxLen, L.get(j) + 1);  }  }  L.add(maxLen);  ret = Math.max(ret, maxLen);  }   return ret; } 코드는 그닥 어렵지 않다.\nListInteger L = new ArrayList();  V.add(0, 0); L.add(0); int ret = 0; 이 내용은 우리가 앞서 봤듯이, 미리 세팅을 해놓는 단계이다.\nfor (int i = 1; i  V.size(); i++) {  int maxLen = 0;  for (int j = 0; j  i; j++) {  if (V.get(j)  V.get(i)) {  maxLen = Math.max(maxLen, L.get(j) + 1);  }  }  L.add(maxLen);  ret = Math.max(ret, maxLen); } 그리고, for-loop 를 돌면서 한 놈씩 잡는다. 그리고 앞쪽을 살펴보면서, 나보다 작은 녀석 중 최대의 길이를 구한 뒤에, 나는 거기에 1 을 더한 값을 갖는다.\n정확히 위의 과정과 일치하는 내용이다. 코드가 워낙 간단해서, 뭐라고 내가 몇 마디 떠드는 것보다 코드를 읽는 편이 더 이해하기 수월할 것이다.\n4-C 시간복잡도. : 간단하게 2중 for-loop로 이루어져 있으니, 시간복잡도는 O(n^2) 라는 사실을 쉽게 유추할 수 있다.\n5. 네 번째 방법 - 이진탐색 : 그런데 O(n^2) 방법도 맘에 들지 않는다. 우리는 조금 더 최적화를 하고 싶다. 아마 이 글을 읽는 사람들도 위 세 방법을 이해하지 못해서 여기까지 오진 않았을 것 같다. 글을 읽느라 식어버린 커피를 원샷 때리고, 담배도 한 대 피워본 뒤, 차분하게 읽어보자.\n5-A 이론 이 알고리즘은 세 번째 방법을 개선한다. 세 번째 방법은, 우리가 뒤쪽으로 가면서 앞쪽에 있는 녀석들을 모두 살펴봐야 했었다. 앞쪽에 있는 녀석들은 하나씩 추가되기도 하고, 나보다 작을수도, 클 수도 있기 때문이다. 그런데, 관점을 살짝 뒤틀어보자.\n내가 선택한 X 라는 녀석이 더욱 긴 녀석이 되기 위해서는, 앞에 있는 녀석이 작은 편이 좋다. 가령, [5 6 1 2 X] 라는 배열이 있다고 해보자. 이 녀석들의 L 테이블은 {1 2 1 2} 로 구성되어있을 것은 자명하다. 여기서, X 가 999 라면, [5 6] 과 [1 2] 둘 다 이어갈 수 있지만, X 가 3 이라면 [1 2] 는 이어갈 수 있지만 [5 6] 은 이어갈 수 없다.\n즉, 값이 작으면 작을수록, X 가 들어왔을 때 이어나갈 수 있는 가능성이 높아진다!\n이러한 정보를 담는 테이블 C 를 만들어놓으면, 위 예시는 다음과 같이 된다.\n 5가 들어왔을 때 - [5] 6이 들어왔을 때 - [5 6] 1이 들어왔을 때 - [1 6] 2가 들어왔을 때 - [1 2] 3(X)이 들어왔을 때 - [1 2 3]  즉, C[i] 는 “길이가 i일때 최소인 값” 이 되고, 이를 계속 갱신해나가면 된다. 그리고 이 갱신 과정속에서, C 테이블은 항상 정렬이 되어있다!\n정렬이 되어있다는 말은, 곧 내가 위로 가야할지, 아래로 가야할지 판단이 가능하다는 뜻이고, 이는 이진탐색이 가능하다는 것을 의미한다.\n5-B 구현 public int lis4(ListInteger V) {  ListInteger C = new ArrayList();  C.add(0);   int ret = 0;  for (int i = 0; i  V.size(); i++) {  if (V.get(i)  C.get(ret)) {  ret += 1;  C.add(V.get(i));  } else {  int loc = binarySearch(C, 0, ret, V.get(i));  C.set(loc, V.get(i));  }  }   return ret; }  public int binarySearch(ListInteger C, int low, int high, int value) {  if (low == high) return low;   int mid = (low + high) / 2;  if (C.get(mid) == value) return mid;  else if (C.get(mid)  value) return binarySearch(C, mid+1, high, value);  else return binarySearch(C, low, mid, value); } : 함수를 두개로 나눠, 하나는 순수한 이진탐색, 하나는 위에서 설명한 과정을 구현하였다. 여기서 이진탐색까지 설명하는건 범위에서 벗어나므로, 따로 찾아보도록 하자.\nListInteger C = new ArrayList(); C.add(0); int ret = 0; 역시 구현에 앞서, 몇 가지 세팅이 필요하다.\n먼저, C 가 첫 번째 입력에도 이진탐색에 대응할 수 있도록, 0 을 넣어주자. 또한, ret이 최장증가부분수열의 길이를 나타내기도 하면서, 동시에 C 테이블의 가장 마지막 녀석의 index를 나타내기도 한다 (결국은 같은 말이다.)\n즉, 앞의 이론에서 이야기한 내용을 가슴속에 품은채로 생각해보면, C 테이블의 가장 마지막에 있는 녀석은, “가장 유리하면서”, 동시에 “가장 큰 값\"인데, 그것보다 더 큰 녀석이 나타났다는 것은 새로운 기록을 가진 녀석이 나타난다는 뜻이 된다.\n그러나, 위 조건에 성립하지 않는 녀석은 우리가 교체해야할 녀석이다. C 테이블에서 교체할 자리를 찾아서, 신규 데이터로 갱신해준다.C.set(loc, V.get(i));\n5-C 시간복잡도. : 꽤나 어려운 알고리즘이지만, 시간복잡도는 아주 깔끔하다. 각 원소를 반복하는데 N, 그리고 이분탐색하는데 logN이 더해져 최종적으로는 O(NlogN)이 된다.\n6. 마치며 : 이 글을 읽는 분들이 기나긴 터널의 끝을 떠나 한줄기 빛을 맞이하는 기분이었으면 좋겠다. 다만, 내가 방금 공부한 내용을 글로 옮기는 것은 공부하는데에는 효과적일지 모르겠으나, 남에게 정확한 정보를 전달한다는 점에서는 아무래도 완성도가 떨어지기 마련이다. 더욱이 이렇게 장문의 글을 쓰기가 쉽지 않아, 중간중간 어디 틀렸을까 걱정되기도 한다. 잘못된 부분이 있으면 언제든 지적 바란다.\n이상으로 포스팅을 마칩니다.\nReference  LIS의 길이를 구하는 3가지 알고리즘 나무위키 - 최장 증가 부분 수열  ","wordCount":"2797","inLanguage":"en","datePublished":"2020-12-15T13:57:00Z","dateModified":"2020-12-15T13:57:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/backup/algorithm/algorithm/2020-12-15-ways_to_get_lis_length/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://cjlee38.github.io/backup/>Backups</a></div><h1 class=post-title># 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )</h1><div class=post-meta><span title="2020-12-15 13:57:00 +0000 UTC">December 15, 2020</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/backup/Algorithm/algorithm/2020-12-15-ways_to_get_LIS_length.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label="0. 들어가며">0. 들어가며</a></li><li><a href=#1-%ed%95%b4%ea%b2%b0%ed%95%a0-%eb%ac%b8%ec%a0%9c aria-label="1. 해결할 문제">1. 해결할 문제</a></li><li><a href=#2-%ec%b2%ab-%eb%b2%88%ec%a7%b8-%eb%b0%a9%eb%b2%95---%ec%99%84%ec%a0%84%ed%83%90%ec%83%89 aria-label="2. 첫 번째 방법 - 완전탐색">2. 첫 번째 방법 - 완전탐색</a><ul><ul><li><a href=#2-a-%ec%9d%b4%eb%a1%a0 aria-label="2-A 이론">2-A 이론</a></li><li><a href=#2-b-%ea%b5%ac%ed%98%84 aria-label="2-B 구현">2-B 구현</a></li><li><a href=#2-c-%ec%8b%9c%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label="2-C 시간복잡도">2-C 시간복잡도</a></li></ul></ul></li><li><a href=#3-%eb%91%90-%eb%b2%88%ec%a7%b8-%eb%b0%a9%eb%b2%95---%eb%8f%99%ec%a0%81%ea%b3%84%ed%9a%8d%eb%b2%95 aria-label="3. 두 번째 방법 - 동적계획법">3. 두 번째 방법 - 동적계획법</a><ul><ul><li><a href=#3-a-%ec%9d%b4%eb%a1%a0 aria-label="3-A. 이론">3-A. 이론</a></li><li><a href=#3-b-%ea%b5%ac%ed%98%84 aria-label="3-B 구현">3-B 구현</a></li><li><a href=#3-c-%ec%8b%9c%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label="3-C 시간복잡도">3-C 시간복잡도</a></li></ul></ul></li><li><a href=#4-%ec%84%b8-%eb%b2%88%ec%a7%b8-%eb%b0%a9%eb%b2%95---%eb%8f%99%ec%a0%81%ea%b3%84%ed%9a%8d%eb%b2%95-2 aria-label="4. 세 번째 방법 - 동적계획법 2">4. 세 번째 방법 - 동적계획법 2</a><ul><ul><li><a href=#4-a-%ec%9d%b4%eb%a1%a0 aria-label="4-A 이론">4-A 이론</a></li><li><a href=#4-b-%ea%b5%ac%ed%98%84 aria-label="4-B 구현">4-B 구현</a></li><li><a href=#4-c-%ec%8b%9c%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label="4-C 시간복잡도.">4-C 시간복잡도.</a></li></ul></ul></li><li><a href=#5-%eb%84%a4-%eb%b2%88%ec%a7%b8-%eb%b0%a9%eb%b2%95---%ec%9d%b4%ec%a7%84%ed%83%90%ec%83%89 aria-label="5. 네 번째 방법 - 이진탐색">5. 네 번째 방법 - 이진탐색</a><ul><ul><li><a href=#5-a-%ec%9d%b4%eb%a1%a0 aria-label="5-A 이론">5-A 이론</a></li><li><a href=#5-b-%ea%b5%ac%ed%98%84 aria-label="5-B 구현">5-B 구현</a></li><li><a href=#5-c-%ec%8b%9c%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label="5-C 시간복잡도.">5-C 시간복잡도.</a></li></ul></ul></li><li><a href=#6-%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label="6. 마치며">6. 마치며</a><ul><ul><li><a href=#reference aria-label=Reference>Reference</a></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>: 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.</p><p>아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.</p><h1 id=1-해결할-문제>1. 해결할 문제<a hidden class=anchor aria-hidden=true href=#1-해결할-문제>#</a></h1><p>: LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 &ldquo;최대 증가 부분 수열&rdquo; 정도가 된다. 즉, 정수의 수열 S 가 주어졌을 때, S 에서 0개 이상의 숫자를 지우고 남은 수열을 &ldquo;부분 수열&rdquo; 이라고 칭하고, 그 수열 중에서 &ldquo;오름차순으로 정렬&rdquo; 된 수열을 &ldquo;증가 부분 수열&rdquo;, 그리고 그 중에서 가장 긴 수열을 <strong>&ldquo;최대 증가 부분 수열&rdquo;</strong> 이라고 한다.</p><p>말로 하면 약간 헷갈리니, 다음의 예시를 보자. 앞으로 이 예시를 계속 사용할 것이다.</p><ul><li>부분 수열의 예 : [3 8 9 2 1 4]</li><li>증가 부분 수열의 예 : [1 4 8]</li><li>최대 증가 부분 수열의 예: [3 5 7 8]</li></ul><p>이 때, 최대 증가 부분 수열(이하, LIS) 또한 여러 개가 될 수 있다. (현 예에서는 [3 5 7 8] 이외에 [3 5 7 9] 또한 존재한다.) 그러나, 우리가 원하는 것은 &ldquo;LIS 의 길이&rdquo; 하나 이므로, 몇 개가 존재하던 상관이 없다.</p><h1 id=2-첫-번째-방법---완전탐색>2. 첫 번째 방법 - 완전탐색<a hidden class=anchor aria-hidden=true href=#2-첫-번째-방법---완전탐색>#</a></h1><h3 id=2-a-이론>2-A 이론<a hidden class=anchor aria-hidden=true href=#2-a-이론>#</a></h3><p>: 사람이라면 몇 번 훑어보면 금방 찾을 수 있지만, 알다시피 컴퓨터는 우리 생각만큼 똑똑하지 않다. 나도 그랬듯이, 이 문제를 코딩으로 해결하고자 할 때 떠올릴 수 있는 방법은, 모든 경우를 탐색하는 것, 즉 <strong>완전탐색</strong>이다.</p><p>완전탐색을 이해하는 것은 그리 어렵지 않다. 말로 자세히 풀어서 설명하기보단, 다음의 순서를 반복하는 것을 이해하는 것이 더 간단할 것 같다.</p><ol><li>주어진 배열(= 부분수열)에서, 하나의 요소 <strong>X</strong> 를 선택한다.</li><li>X 뒤쪽의 배열을 살펴보면서, <strong>X 보다 크면 이를 다음 탐색할 배열 A</strong> 에 넣는다.</li><li>배열 A 를 가지고, 1번을 반복한다.</li><li>만약 배열 A 가 비어 있는 경우, 재귀함수를 종료(스택을 하나 제거)하면서 0 을 return한다.</li></ol><p>그림으로 표현하자면, 다음과 같다.</p><p><img loading=lazy src=/assets/images/2020-12-15-14-45-55_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p><strong>[3 5 7 9 2 1 4 8]</strong> 이라는 배열이 주어져있고, <strong>3 을 X</strong> 로 지정했다.<br>그리고 나서, 그 뒤쪽의 배열 중, 3 보다 큰 녀석들(빨간박스) 을 새로운 배열로 만든다.</p><p><img loading=lazy src=/assets/images/2020-12-15-14-47-27_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>그리고 이렇게 <strong>[5 7 9 4 8]</strong> 을 가지고, 또 다시 <strong>5 를 X</strong>로 지정했다.<br>다시 그 뒤쪽을 살펴보면서, [7 9 8] 을 새로운 배열로 만든다.</p><p>이러한 과정을 반복하면서, 배열이 비어 있는 경우, 0 을 return 하면 된다.<br>살짝 머리가 아파지니, 그윽한 자바코드 냄새를 맡으면서 환기해보자.</p><h3 id=2-b-구현>2-B 구현<a hidden class=anchor aria-hidden=true href=#2-b-구현>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lis1</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span> <span style=color:#66d9ef>return</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> sub <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span>1<span style=color:#f92672>;</span> j <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> j<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                sub<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ret <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>ret<span style=color:#f92672>,</span> lis1<span style=color:#f92672>(</span>sub<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>하나씩 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span> <span style=color:#66d9ef>return</span> 0<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>리스트(배열)가 비어있는 경우에 0 을 돌려주는 것은 당연하다. 처음으로 주어진 배열 자체가 아예 비어있다면 LIS 의 길이 또한 0 이 될 것이며, 재귀함수의 호출 과정속에서도 배열이 비어있다는 것 또한 마찬가지로 LIS 의 길이가 0 이라는 것을 의미하기 때문이다. 이와 더불어, 재귀함수를 종료할 base case(기저사례) 이기도 하다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> sub <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span>1<span style=color:#f92672>;</span> j <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> j<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            sub<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>ret은 잠시 미뤄두고, 다음으로 주목할 부분은 for-loop 다. 0 번째부터 시작하는, 하나의 요소 X를 선택한 뒤(=<code>list.get(i)</code>), 그 뒤쪽의 값과 비교하면서, 만약 뒤쪽의 값이 더 크다면 이를 <code>sub</code> 라는 리스트에 추가한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span> i<span style=color:#f92672>...</span> <span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span> j<span style=color:#f92672>...</span> <span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>ret<span style=color:#f92672>,</span> lis1<span style=color:#f92672>(</span>sub<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> ret<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>그 다음으로 살펴볼 부분은 변수 ret 이다. 주목해야 할 부분은 <code>ret = Math.max(ret, lis1(sub) + 1);</code> 이 부분인데, 우리가 재귀함수를 열심히 쌓다가, 이제는 우리가 헤어져야 할 시간이 되면 0 이 return 된다.</p><p>애초에 base case 에서부터 1 을 return 하지 않고, <strong>0 을 return 하는 대신 여기에 + 1 을 넣어준 이유</strong>는,</p><ol><li>원본의 배열이 애초에 비어 있을 때 0 을 return 하는게 타당하면서,</li><li>동시에, 재귀함수를 호출하던 과정 속에서 배열이 비어있을 때 또한 길이가 0 임을 의미히기도 하고,</li><li>이와 더불어 &ldquo;어차피 우리가 선택한 sub 배열은 나보다 큰 녀석&rdquo; 이고, 이는 곧 증가 부분 수열의 길이가 반드시 1 (혹은 그 이상) 늘어난다는 것을 의미하기 때문이다.</li></ol><hr><blockquote><p>3 번이 헷갈리는 사람(나)을 위해, 다음과 같은 부연설명을 읊조려보자면,<br>가령 원 배열이 [1 2] 가 있다고 해보자. 그렇다면, 첫 번째 재귀함수 과정 속에서 sub 에 2 가 들어갈 것이고, 두 번째 재귀함수 내에서 [2] 는 다시 아무것도 없는 배열 [] 를 호출할 것이다.<br>세 번째 재귀함수에선, 배열에 아무것도 들어있지 않으므로 0 이 return 될 것이고, 다시 두 번째 재귀함수로 돌아왔을 때에는 for-loop 내에서 <code>ret = Math.max(0, 0+1);</code> 이 된다. for-loop 가 더 이상 나아갈 수 없으므로 1 을 그대로 return 하고, 첫 번째 재귀함수에서 마찬가지로 <code>ret = Math.max(0, 1+1);</code> 이 된다. i 가 1(즉, X 가 2인 경우) 에는 위와 같은 과정을 통해 1 이 return 될 것이고, <code>Math.max(2, 1)</code> 를 통해 최종적으로 2 가 return 된다.<br>여전히 이해가 되지 않는다면, 반대로 [2 1] 인 경우를 상상해보자.</p></blockquote><hr><h3 id=2-c-시간복잡도>2-C 시간복잡도<a hidden class=anchor aria-hidden=true href=#2-c-시간복잡도>#</a></h3><p>: 이러한 완전탐색의 시간복잡도는 얼마나 될까? 대부분의 시간복잡도가 최악의 상황을 가정하니, 이 알고리즘에 최악이 될 수 있는 상황을 가정해보자. 아무래도 sub가 많아지면 많아질수록 최악이 될테니, [1 2 3 4 5 6 &mldr;] 과 이미 오름차순으로 정렬되었을 때가 가장 오래 걸릴 듯 싶다.</p><p>배열을 하나씩 늘려가면서 함수가 호출되는 횟수를 살펴보자.(for문은 재귀함수의 호출로 연결된다는 점을 생각하자.)</p><ul><li>[] -> 1</li><li>[1] -> 2</li><li>[1 2] -> 4</li><li>[1 2 3] -> 8</li></ul><p><img loading=lazy src=/assets/images/2020-12-15-15-23-11_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>패턴이 보인다. O(2^n) 이다. 통상적으로 O(n^2) 이어도 상당히 곤란한 시간복잡도인데, O(2^n) 이라고 하면 척 봐도 비효율적인 것 처럼 보인다.</p><h1 id=3-두-번째-방법---동적계획법>3. 두 번째 방법 - 동적계획법<a hidden class=anchor aria-hidden=true href=#3-두-번째-방법---동적계획법>#</a></h1><p>: 위에서 살펴본 완전탐색이 비효율적인 이유는, 역시 <strong>같은 연산을 반복</strong>하기 때문이었다. 이전에 작성했던 <a href=https://cjlee38.github.io/btb/recursive_function>재귀함수 글</a> 에서 보았던 것처럼, 동적계획법을 이용해보자. 이렇게 동적계획법을 떠올릴 수 있는 기저는, 이 문제가 <strong>최적부분구조</strong>를 갖고 있기 때문이다.</p><p>메모이제이션, 캐시 등 관점에 따라 다른 이름으로 부르지만, 어쨌든 여기서 중요시하는 내용은 <strong>&ldquo;한번 계산한 부분은, 또 다시 계산하지 않는다.&rdquo; 는 것이 핵심</strong>이다. 바로 위의 사진에서 보듯이, 배열이 비어있을 때를 중복으로 쳐다보기도 하지만, 배열이 [3]과 같은 부분도 중복해서 연산을 하는 것을 볼 수 있다.</p><p>즉, [3] 의 꼬리를 잘라내보자.</p><h3 id=3-a-이론>3-A. 이론<a hidden class=anchor aria-hidden=true href=#3-a-이론>#</a></h3><p>: 단순하게 동적계획법을 생각하면 어렵지 않을 것 같다. &ldquo;처음 계산이면 캐시에 저장, 한번이라도 본 적이 있다면 꺼내서 사용&rdquo; 하면 된다. 다만, 막상 코드로 쓰려고 키보드에 손을 올리는 순간 멈칫하게 된다. &ldquo;캐시를 어떻게 만들어놓지?&rdquo;</p><p>이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다. 즉, [3 5 7 9 2 1 4 8] 라는 배열에서, 우리가 7 이라는 요소를 선택했을 때, 그 sub 가 될 수 있는 [9 8]은 언제나 동일하다. 이는 그 전의 호출에서 3의 선택으로 [5 7 9 4 8]이 넘어왔든, 5의 선택으로 [7 9 8]이 넘어왔든, 이번에 7 이 선택되었으면 그 sub가 되는 [9 8]은 항상 동일하다는 것이다.</p><p><img loading=lazy src=/assets/images/2020-12-15-15-58-53_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>이를 다시 바꿔서 이해해보자. 우리가 7 을 선택했을 때, 즉 index 상으로 2 번을 선택했을 때 해당 증가 부분 수열의 길이가 계산되어 있다면, 그 값을 return 하면 된다. 계산되어 있지 않다면, 기존에 하던대로 계산하면 된다.</p><h3 id=3-b-구현>3-B 구현<a hidden class=anchor aria-hidden=true href=#3-b-구현>#</a></h3><p>: 위 아이디어를 코드로 구현하기 이전에, 몇 가지 작업을 해둘 부분이 있다.</p><p>먼저, 리스트의 가장 앞부분에 -1 을 넣어두자.(현재 예제는 자연수를 기준으로 하고 있기 때문에, 정수를 고려할 경우 <code>Integer.MIN_VALUE</code>를 넣어야 한다.) 이 내용은 조금 밑에서 설명하겠다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>MIN_VALUE</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>그 다음으로, cache를 -1로 초기화 해놓자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> cache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    cache<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(-</span>1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>-1 로 초기화해놓는 이유는, 기존의 list 와 쌍을 맞춰주기 위함이면서, 동시에 <strong>LIS 가 빈 배열로 인해 0 이 될 수도 있으니, 이를 구분하기 위해 -1 로 초기화 해두겠다</strong>는 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lis2</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> cache<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> start<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cache<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>start<span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> cache<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>start<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> next <span style=color:#f92672>=</span> start<span style=color:#f92672>+</span>1<span style=color:#f92672>;</span> next <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> next<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>start<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>next<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            ret <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>ret<span style=color:#f92672>,</span> lis2<span style=color:#f92672>(</span>list<span style=color:#f92672>,</span> cache<span style=color:#f92672>,</span> next<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    cache<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>start<span style=color:#f92672>,</span> ret<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><hr><blockquote><p>여기서 잠깐, 기존 코드와의 통일성을 위해 List를 사용하였지만, 이번에는 list 와 cache의 크기가 고정되어 있기 때문에(앞서는 sub에 따라 크기가 달라졌다.), 단순히 array를 사용해도 상관 없다.</p></blockquote><hr><p>뭔가 기존 코드와 비슷하면서도 사뭇 다른 부분이 몇가지 보인다. 이 또한 하나씩 뜯어보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cache<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>start<span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> cache<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>start<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>가장 간단해 보이는 이 부분은 캐시에 저장된 부분이 있다면, 그 부분을 가져오겠다는 의미가 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lis2</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> cache<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> start<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>그 다음으로 눈에 띄는 부분은, 함수가 받고자 하는 파라미터가 조금 변화하였다. 이 부분이 가벼워 보이지만 신중하게 바라봐야 하는 이유는, 바로 start 변수에 있다. 우리가 cache를 사용하려면, index를 기반으로 접근해야 한다. 그리고 이 index를 사용하기 위해서는, <strong>항상 리스트의 길이는 고정되어야 한다.</strong> 말인 즉슨, sub 배열을 만들어줘서는 안된다는 뜻이다.</p><p>sub 배열을 만들게 될 경우, 우리가 for-loop에서 사용할 index가 뒤틀리는 문제가 발생하게 된다. 반대로, sub 배열을 만들지 않고 원본 list를 사용하지 않더라도 전혀 문제가 되지 않는다. 왜냐하면, 우리가 사용하는 index 는 <strong>&ldquo;앞의 내용을 전혀 신경쓰지 않아도&rdquo; 되기 때문</strong>이다.</p><p>위에서 작성한 내용을 다시 살펴보자.</p><hr><blockquote><p>이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다.</p></blockquote><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> next <span style=color:#f92672>=</span> start<span style=color:#f92672>+</span>1<span style=color:#f92672>;</span> next <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> next<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>start<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>next<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ret <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>ret<span style=color:#f92672>,</span> lis2<span style=color:#f92672>(</span>list<span style=color:#f92672>,</span> cache<span style=color:#f92672>,</span> next<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>이에 맞춰서 for-loop 도 변화하였다. 우리는 리스트를 인덱스를 기준으로 살펴볼 것이므로, next 는 start + 1 부터 시작한다. 그리고 와중에 <strong>&ldquo;나보다 큰 녀석"을 발견</strong>하면, <strong>그 녀석을 대상으로 다시 재귀함수를 호출</strong>하게 된다. 재귀함수의 결과에 더하는 1 은 앞에서 설명했으니 생략하겠다.</p><p>또한, 만약 cache에서 답을 구하지 못하고, LIS 가 마지막으로 가더라도 상관없다. 자연스럽게 for-loop 의 조건에 성립하지 않으므로, 0 이 return 된다. 즉, 이전 코드의 <code>if (list.isEmpty()) return 0;</code> 와 같은 base case를 <strong>특별히 명시해둘 필요가 없는 것</strong>이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>cache<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>start<span style=color:#f92672>,</span> ret<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> ret<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>처음 문제를 마주한 경우에는 당연히 cache를 저장하고, 그 값을 돌려주면 된다.</p><p>그런데, 단순히 이렇게만 봤을때에 문제가 하나 있다. 바로 <strong>0 번째 인덱스가 가장 큰 값인 경우를 해결하지 못한다는 것이다.</strong> 그 이유는, 재귀함수를 처음 호출했을 때, if 문에 걸리지 않기 때문이다. 이를 위해 <code>list.add(0, Integer.MIN_VALUE);</code> 를 넣었던 것이다.</p><p><strong>다른 방법으로는,</strong></p><p>애초에 <code>lis2()</code> 함수 자체를 한번 더 묶어서,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> max <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    max <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>max<span style=color:#f92672>,</span> lis2<span style=color:#f92672>(...));</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>처럼 사용하는 방법이 있다. 이 방식은 <code>lis2()</code> 의 반복을 밖에서 하느냐, 안에서 하느냐의 차이이지, 본질적으로는 같다. 다만, <code>ret = 0</code> 을 <code>ret = 1</code>로 바꾸어 주어야 한다. 또한, cache의 내용은 달라진다</p><ul><li>0번 index에 값을 넣어주는 방법-> [4 3 2 1 0 2 2 1 0]</li><li>바깥쪽에서 loop를 돌려주는 방법 -> [4 3 2 1 3 3 2 1]</li></ul><h3 id=3-c-시간복잡도>3-C 시간복잡도<a hidden class=anchor aria-hidden=true href=#3-c-시간복잡도>#</a></h3><p>: 아까 2-C 에서 보았던 꼬리란 꼬리는 다 끊어놓았기 때문에, 해당 코드는 결국 까보면 2중의 for-loop를 반복하게 된다. 따라서 시간복잡도는 O(n^2) 이 된다.</p><h1 id=4-세-번째-방법---동적계획법-2>4. 세 번째 방법 - 동적계획법 2<a hidden class=anchor aria-hidden=true href=#4-세-번째-방법---동적계획법-2>#</a></h1><p>: 엥? 두 번째도 동적 계획법이었는데, 세 번쨰도 동적 계획법이라니 약간 당황스럽다. 하지만 읽어보면, 둘 다 동적계획법의 정신을 계승하는 알고리즘이란 것을 알 수 있다.</p><h3 id=4-a-이론>4-A 이론<a hidden class=anchor aria-hidden=true href=#4-a-이론>#</a></h3><p>: 이번에는 조금 관점을 달리하자. 재귀함수를 호출하기 보다는, 두 개의 for-loop 로 해결할 것이다. 어떻게 할 것이냐?</p><p>이는 배열의 요소를 하나씩 살펴보면서, <strong>&ldquo;내가 될 수 있는 증가부분수열의 최대값은 몇이냐?&rdquo;</strong> 를 보는 것이다. 아까는, cache에서, LIS 의 시초가 되는 녀석이 부분증가수열의 최대값이 되었다면, 지금은 <strong>LIS 의 유종의 미를 거두어주는 녀석이 부분증가수열의 최대값</strong>이 된다.</p><p>즉,</p><ul><li>전자의 경우 -> [4 3 2 1 3 3 2 1]</li><li>후자의 경우 -> [1 2 3 4 1 1 2 4]</li></ul><p>가 된다.</p><p>이를 어떻게 만드는고 하니, 아주 간단하게 다음과 같은 아이디어를 적용하면 된다</p><ul><li>현재 내 값 X 를 기준으로 앞쪽을 봤을 때 나보다 작은 녀석들 중 (즉, 내가 뒤에 붙을 수 있는 후보들) , 증가 부분수열의 길이가 가장 긴 녀석 + 1 이 나의 증가부분수열의 길이.</li></ul><p>글재주가 없어 말로 쓰니 헷갈린다. 얼른 예시를 보자.</p><p><img loading=lazy src=/assets/images/2020-12-15-18-06-24_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>편의상 값(Value)를 담았다는 의미로 V 를, 증가부분수열의 길이(Length) 를 담았다는 의미로 L 테이블이라 칭하겠다.</p><p>처음에는 이렇게 가장 앞에 0을 붙인채로 초기화한다.</p><p><img loading=lazy src=/assets/images/2020-12-15-18-07-19_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>x 를 3으로 두었을 때, 내 앞에 있으면서, 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1을 더한게, 나의 length가 된다.</p><p><img loading=lazy src=/assets/images/2020-12-15-18-08-52_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>마찬가지의 과정을 반복한다. 즉, x 를 9로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석들은 [0 3 5 7] 이다. 그리고 그 중에서, 가장 긴 증가부분수열의 길이를 갖고 있는 3 에 1 을 더한 4 가 나의 length가 된다.</p><p><img loading=lazy src=/assets/images/2020-12-15-18-10-01_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>value 가 2 일 때도 마찬가지이다. x를 2로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1 을 더한게 나의 length, 즉 1이 된다.</p><p><img loading=lazy src=/assets/images/2020-12-15-18-11-18_2020-12-15-ways_to_get_LIS_length.md.png alt></p><p>마지막의 경우를 살펴보자. X를 8로 두었을 때, 나보다 작은 녀석은 [3 5 7 2 1 4] 이다. 그리고 그 중, 가장 긴 증가부분수열의 길이를 갖고 있는 녀석은 3(7이 갖고있는) 이고, 여기에 1을 더한 4 가 답이 된다.</p><p>이렇게 해서, 4 라는 최종 답을 구할 수 있다.</p><h3 id=4-b-구현>4-B 구현<a hidden class=anchor aria-hidden=true href=#4-b-구현>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lis3</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> V<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> L <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    V<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> 0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    L<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> V<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> maxLen <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> j <span style=color:#f92672>&lt;</span> i<span style=color:#f92672>;</span> j<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                maxLen <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>maxLen<span style=color:#f92672>,</span> L<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        L<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>maxLen<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ret <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>ret<span style=color:#f92672>,</span> maxLen<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>코드는 그닥 어렵지 않다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> L <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>V<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> 0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>L<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>이 내용은 우리가 앞서 봤듯이, 미리 세팅을 해놓는 단계이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> V<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> maxLen <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> j <span style=color:#f92672>&lt;</span> i<span style=color:#f92672>;</span> j<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            maxLen <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>maxLen<span style=color:#f92672>,</span> L<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>j<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    L<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>maxLen<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>ret<span style=color:#f92672>,</span> maxLen<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>그리고, for-loop 를 돌면서 한 놈씩 잡는다. 그리고 앞쪽을 살펴보면서, 나보다 작은 녀석 중 최대의 길이를 구한 뒤에, 나는 거기에 1 을 더한 값을 갖는다.</p><p>정확히 위의 과정과 일치하는 내용이다. 코드가 워낙 간단해서, 뭐라고 내가 몇 마디 떠드는 것보다 코드를 읽는 편이 더 이해하기 수월할 것이다.</p><h3 id=4-c-시간복잡도>4-C 시간복잡도.<a hidden class=anchor aria-hidden=true href=#4-c-시간복잡도>#</a></h3><p>: 간단하게 2중 for-loop로 이루어져 있으니, 시간복잡도는 O(n^2) 라는 사실을 쉽게 유추할 수 있다.</p><h1 id=5-네-번째-방법---이진탐색>5. 네 번째 방법 - 이진탐색<a hidden class=anchor aria-hidden=true href=#5-네-번째-방법---이진탐색>#</a></h1><p>: 그런데 O(n^2) 방법도 맘에 들지 않는다. 우리는 조금 더 최적화를 하고 싶다. 아마 이 글을 읽는 사람들도 위 세 방법을 이해하지 못해서 여기까지 오진 않았을 것 같다. 글을 읽느라 식어버린 커피를 원샷 때리고, 담배도 한 대 피워본 뒤, 차분하게 읽어보자.</p><h3 id=5-a-이론>5-A 이론<a hidden class=anchor aria-hidden=true href=#5-a-이론>#</a></h3><p>이 알고리즘은 세 번째 방법을 개선한다. 세 번째 방법은, 우리가 뒤쪽으로 가면서 앞쪽에 있는 녀석들을 모두 살펴봐야 했었다. 앞쪽에 있는 녀석들은 하나씩 추가되기도 하고, 나보다 작을수도, 클 수도 있기 때문이다. 그런데, 관점을 살짝 뒤틀어보자.</p><p>내가 선택한 X 라는 녀석이 더욱 긴 녀석이 되기 위해서는, 앞에 있는 녀석이 작은 편이 좋다. 가령, [5 6 1 2 X] 라는 배열이 있다고 해보자. 이 녀석들의 L 테이블은 {1 2 1 2} 로 구성되어있을 것은 자명하다. 여기서, X 가 999 라면, [5 6] 과 [1 2] 둘 다 이어갈 수 있지만, X 가 3 이라면 [1 2] 는 이어갈 수 있지만 [5 6] 은 이어갈 수 없다.</p><p>즉, <strong>값이 작으면 작을수록</strong>, X 가 들어왔을 때 <strong>이어나갈 수 있는 가능성이 높아진다!</strong></p><p>이러한 정보를 담는 테이블 C 를 만들어놓으면, 위 예시는 다음과 같이 된다.</p><ul><li>5가 들어왔을 때 -> [5]</li><li>6이 들어왔을 때 -> [5 6]</li><li>1이 들어왔을 때 -> [1 6]</li><li>2가 들어왔을 때 -> [1 2]</li><li>3(X)이 들어왔을 때 -> [1 2 3]</li></ul><p>즉, C[i] 는 &ldquo;길이가 i일때 최소인 값&rdquo; 이 되고, 이를 계속 갱신해나가면 된다. 그리고 이 갱신 과정속에서, C 테이블은 <strong>항상 정렬이 되어있다!</strong></p><p><strong>정렬이 되어있다는 말은, 곧 내가 위로 가야할지, 아래로 가야할지 판단이 가능하다는 뜻이고, 이는 이진탐색이 가능하다는 것을 의미한다.</strong></p><h3 id=5-b-구현>5-B 구현<a hidden class=anchor aria-hidden=true href=#5-b-구현>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lis4</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> V<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> C <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>    C<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> V<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;</span> C<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>ret<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            ret <span style=color:#f92672>+=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            C<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> loc <span style=color:#f92672>=</span> binarySearch<span style=color:#f92672>(</span>C<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> ret<span style=color:#f92672>,</span> V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>            C<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>loc<span style=color:#f92672>,</span> V<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binarySearch</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> C<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> low<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> high<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>low <span style=color:#f92672>==</span> high<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> low<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>low <span style=color:#f92672>+</span> high<span style=color:#f92672>)</span> <span style=color:#f92672>/</span> 2<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>C<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>mid<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> value<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> mid<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>C<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>mid<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> value<span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> binarySearch<span style=color:#f92672>(</span>C<span style=color:#f92672>,</span> mid<span style=color:#f92672>+</span>1<span style=color:#f92672>,</span> high<span style=color:#f92672>,</span> value<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> binarySearch<span style=color:#f92672>(</span>C<span style=color:#f92672>,</span> low<span style=color:#f92672>,</span> mid<span style=color:#f92672>,</span> value<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>: 함수를 두개로 나눠, 하나는 순수한 이진탐색, 하나는 위에서 설명한 과정을 구현하였다. 여기서 이진탐색까지 설명하는건 범위에서 벗어나므로, 따로 찾아보도록 하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> C <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>C<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span></code></pre></div><p>역시 구현에 앞서, 몇 가지 세팅이 필요하다.<br>먼저, C 가 첫 번째 입력에도 이진탐색에 대응할 수 있도록, 0 을 넣어주자. 또한, ret이 최장증가부분수열의 길이를 나타내기도 하면서, 동시에 C 테이블의 가장 마지막 녀석의 index를 나타내기도 한다 (결국은 같은 말이다.)</p><p>즉, 앞의 이론에서 이야기한 내용을 가슴속에 품은채로 생각해보면, C 테이블의 가장 마지막에 있는 녀석은, &ldquo;가장 유리하면서&rdquo;, 동시에 &ldquo;가장 큰 값"인데, 그것보다 더 큰 녀석이 나타났다는 것은 새로운 기록을 가진 녀석이 나타난다는 뜻이 된다.</p><p>그러나, 위 조건에 성립하지 않는 녀석은 우리가 교체해야할 녀석이다. C 테이블에서 교체할 자리를 찾아서, 신규 데이터로 갱신해준다.<code>C.set(loc, V.get(i));</code></p><h3 id=5-c-시간복잡도>5-C 시간복잡도.<a hidden class=anchor aria-hidden=true href=#5-c-시간복잡도>#</a></h3><p>: 꽤나 어려운 알고리즘이지만, 시간복잡도는 아주 깔끔하다. 각 원소를 반복하는데 N, 그리고 이분탐색하는데 logN이 더해져 최종적으로는 O(NlogN)이 된다.</p><h1 id=6-마치며>6. 마치며<a hidden class=anchor aria-hidden=true href=#6-마치며>#</a></h1><p>: 이 글을 읽는 분들이 기나긴 터널의 끝을 떠나 한줄기 빛을 맞이하는 기분이었으면 좋겠다. 다만, 내가 방금 공부한 내용을 글로 옮기는 것은 공부하는데에는 효과적일지 모르겠으나, 남에게 정확한 정보를 전달한다는 점에서는 아무래도 완성도가 떨어지기 마련이다. 더욱이 이렇게 장문의 글을 쓰기가 쉽지 않아, 중간중간 어디 틀렸을까 걱정되기도 한다. 잘못된 부분이 있으면 언제든 지적 바란다.</p><p>이상으로 포스팅을 마칩니다.</p><h3 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h3><ul><li><a href=https://shoark7.github.io/programming/algorithm/3-LIS-algorithms>LIS의 길이를 구하는 3가지 알고리즘</a></li><li><a href=https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4>나무위키 - 최장 증가 부분 수열</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/backup/language/java/2020-12-21-java8-behavior-parameterization/><span class=title>« Prev Page</span><br><span># (Java8) 동작(≒메소드) 파라미터화</span></a>
<a class=next href=http://cjlee38.github.io/backup/algorithm/problem_solving/2020-12-10-problem_solving_21/><span class=title>Next Page »</span><br><span># 알고스팟 [ID:PICNIC] 소풍 ( Java )</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java ) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%3a%20LIS%ec%9d%98%20%ea%b8%b8%ec%9d%b4%ea%b5%ac%ed%95%98%ea%b8%b0%20%28%20feat.%20Java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fbackup%2falgorithm%2falgorithm%2f2020-12-15-ways_to_get_lis_length%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java ) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fbackup%2falgorithm%2falgorithm%2f2020-12-15-ways_to_get_lis_length%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%3a%20LIS%ec%9d%98%20%ea%b8%b8%ec%9d%b4%ea%b5%ac%ed%95%98%ea%b8%b0%20%28%20feat.%20Java%20%29&summary=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%3a%20LIS%ec%9d%98%20%ea%b8%b8%ec%9d%b4%ea%b5%ac%ed%95%98%ea%b8%b0%20%28%20feat.%20Java%20%29&source=http%3a%2f%2fcjlee38.github.io%2fbackup%2falgorithm%2falgorithm%2f2020-12-15-ways_to_get_lis_length%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java ) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fbackup%2falgorithm%2falgorithm%2f2020-12-15-ways_to_get_lis_length%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%3a%20LIS%ec%9d%98%20%ea%b8%b8%ec%9d%b4%ea%b5%ac%ed%95%98%ea%b8%b0%20%28%20feat.%20Java%20%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java ) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fbackup%2falgorithm%2falgorithm%2f2020-12-15-ways_to_get_lis_length%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java ) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%3a%20LIS%ec%9d%98%20%ea%b8%b8%ec%9d%b4%ea%b5%ac%ed%95%98%ea%b8%b0%20%28%20feat.%20Java%20%29%20-%20http%3a%2f%2fcjlee38.github.io%2fbackup%2falgorithm%2falgorithm%2f2020-12-15-ways_to_get_lis_length%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java ) on telegram" href="https://telegram.me/share/url?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%3a%20LIS%ec%9d%98%20%ea%b8%b8%ec%9d%b4%ea%b5%ac%ed%95%98%ea%b8%b0%20%28%20feat.%20Java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fbackup%2falgorithm%2falgorithm%2f2020-12-15-ways_to_get_lis_length%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>