<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 프로그래머스[Lv.3] - 순위 ( Java ) | cjlee38</title><meta name=keywords content="programmers"><meta name=description content="문제 링크
Problem 문제 설명
n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.
선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/backup-copy/algorithm/problem_solving/2020-11-18-problem_solving_19/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="# 프로그래머스[Lv.3] - 순위 ( Java )"><meta property="og:description" content="문제 링크
Problem 문제 설명
n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.
선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/backup-copy/algorithm/problem_solving/2020-11-18-problem_solving_19/"><meta property="article:section" content="backup copy"><meta property="article:published_time" content="2020-11-18T11:52:00+00:00"><meta property="article:modified_time" content="2020-11-18T11:52:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 프로그래머스[Lv.3] - 순위 ( Java )"><meta name=twitter:description content="문제 링크
Problem 문제 설명
n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.
선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"# 프로그래머스[Lv.3] - 순위 ( Java )","item":"http://cjlee38.github.io/backup-copy/algorithm/problem_solving/2020-11-18-problem_solving_19/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 프로그래머스[Lv.3] - 순위 ( Java )","name":"# 프로그래머스[Lv.3] - 순위 ( Java )","description":"문제 링크\nProblem 문제 설명\nn명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.\n선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.","keywords":["programmers"],"articleBody":"문제 링크\nProblem 문제 설명\nn명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.\n선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.\n제한사항\n 선수의 수는 1명 이상 100명 이하입니다. 경기 결과는 1개 이상 4,500개 이하입니다. results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다. 모든 경기 결과에는 모순이 없습니다.  입출력 예\n   n results return     5 [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] 2    입출력 예 설명\n 2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다. 5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.  Solve 문제에 대한 이해. : 나만 그렇게 느끼는 건진 모르겠는데, 코딩 테스트의 문제가 어려워질수록 문제 설명도 굉장히 불친절해진다. 이게 단순히 문제의 난이도를 높이기 위해서 말을 아끼는 것이라면 그러려니 하겠는데, 애초에 설명 자체가 부족하니 참 이해하기가 어렵다.\n잠깐 잡소리를 하자면, 대학 교수님들 중에 간혹 그런 분이 있다. 본질적으로 강의라는 것은 학생들에게 지식을 전파하기 위함이고, 시험은 이를 검증하는 것이 목표이다. 따라서, 학생들이 이해할 만한 선에서, 최대한의 깊고 다양한 지식을 학생들에게 전수하면서, 동시에 시험을 변별력 있게 내는 것은 타당하다. 그러나, 거꾸로 시험을 변별력 있게 내기 위해서, 강의를 하면서 일부러 말을 아끼고, 설명해야 할 것도 설명하지 않는 교수님을 몇 번 본적이 있다.\n잡소리는 이만하면 됐고, 어쨌든 이번 순위 문제도 이러한 문제에 해당하는 것 같은데, 문제 내용 중 “만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다.” 라는 명제는, 만약 A 선수가 B 선수를 이겼다면, A 선수는 B 선수에 비해 항상 실력이 좋다는 것을 의미합니다. 정도로 바꿔줬으면 좀 잘 와닿지 않았을까 싶다.\n또한, 이 문제에는 실제로 일어난 경기가 몇 번 일어났는지에 대해서 설명하고 있지 않다.\n무슨말인가 하면, 문제에서는 몇몇 경기 결과를 분실하였다. 라고 이야기 하였는데, 이는 곧 주어진 배열보다 더 많은 경기가 있었음을 의미한다. 그리고 이 경기가 몇 번 일어났는지, 매치 방식은 어떻게 되는지에 대한 정보가 전혀 없다. 밑에서 설명할 방법이 아니라, 토너먼트 방식일 수도 있지 않은가?\n차라리 이런 식의 문제 설명보다는, 서바이벌 방식의 권투 대회가 아직 진행중인데, 현재까지의 경기 결과를 가지고 순서가 이미 확정된 선수의 수를 구하려고 합니다. 정도의 설명이었다면 더욱 명료했을 것 같다.\n아무튼 정리하자면, 각 선수는 다른 선수들과 경기를 하는데, 그 대상은 자기 자신을 제외한 나머지 모두가 될 수 있고, A 가 B 를 이겼다는 것은, B 가 이긴 C, D 또한 A가 항상 이긴다. 그리고 이러한 가정은, 한 선수가 모든 선수와 게임을 직접 해 봐야 그 선수의 순위가 결정되는 것이 아니라, 대충 몇 번 싸워만 봐도 그 선수에 대한 순위를 알 수 있다는 결론으로 이어진다.\n접근 방법 : 문제의 유형이 그래프로 명시되어 있다 보니, 각 선수를 그래프의 Node 로 생각하고, 각 경기의 결과를 방향이 있는 간선으로 생각할 수 있다. 문제의 예시를 그림으로 그리면 다음과 같다.\n또한, 문제 설명을 기반으로 다음과 같이 정리할 수 있다.\n 경기 결과에 모순이 없다는 말은, 곧 방향 그래프의 Cycle이 없다는 의미가 된다. 따라서, 특정 Node가 가리킬 수 있는 다른 Node들의 리스트를 만든다.  그런데, 이렇게만 하면 정보가 부족하다. 가령, 2번 Node의 경우, 5번 Node로부터 승리했기 때문에 4위라는 순위를 얻을 수 있는데, 위 그래프만으로는 이를 설명할 수 없다. 따라서, 방향을 뒤집어서도, 특정 Node를 가리킬 수 있는 Node들의 리스트 또한 만들어 줘야 한다.\n즉, 바꿔 말하면, 정방향과 역방향의 그래프 두 개를 바탕으로, 내가(Node가) 직, 간접적으로 나갈 수 있는 Node 리스트의 합집합을 만들어 줘야 한다.\n위 그림을 바탕으로, 하나씩 살펴보자.\nNode 1\n 첫 번째 그림에서, Node 1 이 갈 수 있는 Node는 없다. 두 번째 그림에서, Node 1 이 갈 수 있는 Node는 2, 5 이다.  - count = 2\nNode 2\n 첫 번째 그림에서, Node 2 가 갈 수 있는 Node는 1, 3, 4 이다. 두 번째 그림에서, Node 2 가 갈 수 있는 Node는 5 이다.  - count = 4\nNode 3\n 첫 번째 그림에서, Node 3 가 갈 수 있는 Node는 4 이다. 두 번째 그림에서, Node 3 가 갈 수 있는 Node는 2, 5 이다.  - count = 3\nNode 4\n 첫 번째 그림에서, Node 4 가 갈 수 있는 Node는 없다 두 번째 그림에서, Node 4 가 갈 수 있는 Node는 2, 3, 5 이다.  - count = 3\nNode 5\n 첫 번째 그림에서, Node 5 가 갈 수 있는 Node는 1, 2, 3, 4 이다. 두 번째 그림에서, Node 5 가 갈 수 있는 Node는 없다.  - count = 4\n이렇게 정리했을 때, 노드의 개수 n 에서, 자기 자신을 제외한 나머지의 개수는 n-1 이므로, 4가 되는 Node 2, Node 5 의 개수 = 2 가 정답이 된다.\n구현. : 우선, 문제를 쉽게 하기 위해 Map 를 만들어 주었다. 그리고 위에서 이야기했던 것 처럼, 역방향도 고려해줘야 하기 때문에, winnerMap 과 loserMap 이라는 이름으로 두 개를 만들어 주었다.\nMapInteger, ListInteger winnerMap = initGames(n, results, true); MapInteger, ListInteger loserMap = initGames(n, results, false); // winnerMap = {1=[2], 2=[5], 3=[2], 4=[3, 2], 5=[]} // loserMap = {1=[], 2=[4, 3, 1], 3=[4], 4=[], 5=[2]} private MapInteger, ListInteger initGames(int n, int[][] results, boolean isWin) {  int WINNER = isWin ? 0 : 1;  int LOSER = isWin ? 1 : 0;  MapInteger, ListInteger map = new HashMap();   // 한 번의 for문으로 해결하려 하면, 비어 있는 List를 표현할 수 없다.  for (int i = 1; i  n; i++) {  map.put(i, new ArrayList());  }   for (int[] result : results) {  int winner = result[WINNER];  int loser = result[LOSER];  map.get(winner).add(loser);  }   return map; } 그리고 나서, 각 Node (1 ~ n이하) 의 iteration을 돌면서, 합집합을 구하기 위해 boolean[] visited = new boolean[n]; 를 만들고, 재귀함수를 통해 visited 를 채워나갔다.\n배열을 채우고 나서는, 해당 배열에 true 값이 몇개가 들어있는지 파악한 후, n-1 개 이면 int형 변수 answer를 1 증가시켰다.\nint answer = 0;  for (int i = 1; i  n; i++) {  boolean[] visited = new boolean[n];  recursive(winnerMap, visited, i);  recursive(loserMap, visited, i);  // 배열 채우기.   int battleCount = countBattle(visited);  if (battleCount == (n - 1)) answer++; } 재귀 함수 내부는, 내가 더이상 나갈 수 없을 때 까지, 즉 List가 비어있을 때까지 를 종료 조건으로 주었다.\nprivate void recursive(MapInteger, ListInteger map, boolean[] visited, int enemy) {  if (map.get(enemy).isEmpty()) return;   for (Integer val : map.get(enemy)) {  if (!visited[val - 1]) { // 이를 확인하지 않으면, 너무 깊게 들어갈 수 있다.  visited[val - 1] = true;  recursive(map, visited, val);  }  } } 이렇게 구한 answer 를 return 해주면 된다. 전체 코드는 다음과 같다.\npackage programmers.lv3;  import java.util.*;  public class p49191 {  public static void main(String[] args) {  int n = 5;  int[][] results = {  {4, 3},  {4, 2},  {3, 2},  {1, 2},  {2, 5}  };   p49191 p = new p49191();  int result = p.solution(n, results);  System.out.println(\"result = \" + result);  }   public int solution(int n, int[][] results) {  MapInteger, ListInteger winnerMap = initGames(n, results, true);  MapInteger, ListInteger loserMap = initGames(n, results, false);   int answer = 0;   for (int i = 1; i  n; i++) {  boolean[] visited = new boolean[n];  recursive(winnerMap, visited, i);  recursive(loserMap, visited, i);   int battleCount = countBattle(visited);  if (battleCount == (n - 1)) answer++;  }     return answer;  }   private void recursive(MapInteger, ListInteger map, boolean[] visited, int enemy) {  if (map.get(enemy).isEmpty()) return;   for (Integer val : map.get(enemy)) {  if (!visited[val - 1]) {  visited[val - 1] = true;  recursive(map, visited, val);  }  }  }   private int countBattle(boolean[] visited) {  int count = 0;   for (int i = 0; i  visited.length; i++)  if (visited[i]) count++;   return count;  }   private MapInteger, ListInteger initGames(int n, int[][] results, boolean isWin) {  int WINNER = isWin ? 0 : 1;  int LOSER = isWin ? 1 : 0;   MapInteger, ListInteger map = new HashMap();   for (int i = 1; i  n; i++) {  map.put(i, new ArrayList());  }   for (int[] result : results) {  int winner = result[WINNER];  int loser = result[LOSER];  map.get(winner).add(loser);  }   return map;  }   } ","wordCount":"1285","inLanguage":"en","datePublished":"2020-11-18T11:52:00Z","dateModified":"2020-11-18T11:52:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/backup-copy/algorithm/problem_solving/2020-11-18-problem_solving_19/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a></div><h1 class=post-title># 프로그래머스[Lv.3] - 순위 ( Java )</h1><div class=post-meta><span title="2020-11-18 11:52:00 +0000 UTC">November 18, 2020</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/backup%20copy/Algorithm/Problem_Solving/2020-11-18-problem_solving_19.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#solve aria-label=Solve>Solve</a><ul><li><a href=#%eb%ac%b8%ec%a0%9c%ec%97%90-%eb%8c%80%ed%95%9c-%ec%9d%b4%ed%95%b4 aria-label="문제에 대한 이해.">문제에 대한 이해.</a></li><li><a href=#%ec%a0%91%ea%b7%bc-%eb%b0%a9%eb%b2%95 aria-label="접근 방법">접근 방법</a></li><li><a href=#%ea%b5%ac%ed%98%84 aria-label=구현.>구현.</a></li></ul></li></ul></div></details></div><div class=post-content><p><a href=https://programmers.co.kr/learn/courses/30/lessons/17677>문제 링크</a></p><h1 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h1><p><strong>문제 설명</strong><br>n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.</p><p>선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.</p><p><strong>제한사항</strong></p><ul><li>선수의 수는 1명 이상 100명 이하입니다.</li><li>경기 결과는 1개 이상 4,500개 이하입니다.</li><li>results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.</li><li>모든 경기 결과에는 모순이 없습니다.</li></ul><p><strong>입출력 예</strong></p><table><thead><tr><th style=text-align:center>n</th><th style=text-align:center>results</th><th style=text-align:center>return</th></tr></thead><tbody><tr><td style=text-align:center>5</td><td style=text-align:center>[[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]</td><td style=text-align:center>2</td></tr></tbody></table><p><strong>입출력 예 설명</strong></p><ul><li>2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.</li><li>5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.</li></ul><h1 id=solve>Solve<a hidden class=anchor aria-hidden=true href=#solve>#</a></h1><h2 id=문제에-대한-이해>문제에 대한 이해.<a hidden class=anchor aria-hidden=true href=#문제에-대한-이해>#</a></h2><p>: 나만 그렇게 느끼는 건진 모르겠는데, 코딩 테스트의 문제가 어려워질수록 문제 설명도 굉장히 불친절해진다. 이게 단순히 문제의 난이도를 높이기 위해서 말을 아끼는 것이라면 그러려니 하겠는데, 애초에 설명 자체가 부족하니 참 이해하기가 어렵다.</p><p>잠깐 잡소리를 하자면, 대학 교수님들 중에 간혹 그런 분이 있다. 본질적으로 강의라는 것은 학생들에게 지식을 전파하기 위함이고, 시험은 이를 검증하는 것이 목표이다. 따라서, 학생들이 이해할 만한 선에서, 최대한의 깊고 다양한 지식을 학생들에게 전수하면서, 동시에 시험을 변별력 있게 내는 것은 타당하다. 그러나, 거꾸로 시험을 변별력 있게 내기 위해서, 강의를 하면서 일부러 말을 아끼고, 설명해야 할 것도 설명하지 않는 교수님을 몇 번 본적이 있다.</p><p>잡소리는 이만하면 됐고, 어쨌든 이번 순위 문제도 이러한 문제에 해당하는 것 같은데, 문제 내용 중 <strong>&ldquo;만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다.&rdquo;</strong> 라는 명제는, <strong>만약 A 선수가 B 선수를 이겼다면, A 선수는 B 선수에 비해 항상 실력이 좋다는 것을 의미합니다.</strong> 정도로 바꿔줬으면 좀 잘 와닿지 않았을까 싶다.</p><p>또한, 이 문제에는 실제로 일어난 경기가 몇 번 일어났는지에 대해서 설명하고 있지 않다.</p><p>무슨말인가 하면, 문제에서는 <strong>몇몇 경기 결과를 분실하였다.</strong> 라고 이야기 하였는데, 이는 곧 주어진 배열보다 더 많은 경기가 있었음을 의미한다. 그리고 이 경기가 몇 번 일어났는지, 매치 방식은 어떻게 되는지에 대한 정보가 전혀 없다. 밑에서 설명할 방법이 아니라, 토너먼트 방식일 수도 있지 않은가?</p><p>차라리 이런 식의 문제 설명보다는, <strong>서바이벌 방식의 권투 대회가 아직 진행중인데, 현재까지의 경기 결과를 가지고 순서가 이미 확정된 선수의 수를 구하려고 합니다.</strong> 정도의 설명이었다면 더욱 명료했을 것 같다.</p><p>아무튼 정리하자면, 각 선수는 다른 선수들과 경기를 하는데, 그 대상은 자기 자신을 제외한 나머지 모두가 될 수 있고, A 가 B 를 이겼다는 것은, B 가 이긴 C, D 또한 A가 <strong>항상</strong> 이긴다. 그리고 이러한 가정은, 한 선수가 모든 선수와 게임을 직접 해 봐야 그 선수의 순위가 결정되는 것이 아니라, <strong>대충 몇 번 싸워만 봐도 그 선수에 대한 순위를 알 수 있다는 결론</strong>으로 이어진다.</p><h2 id=접근-방법>접근 방법<a hidden class=anchor aria-hidden=true href=#접근-방법>#</a></h2><p>: 문제의 유형이 그래프로 명시되어 있다 보니, 각 선수를 그래프의 Node 로 생각하고, 각 경기의 결과를 방향이 있는 간선으로 생각할 수 있다. 문제의 예시를 그림으로 그리면 다음과 같다.</p><p><img loading=lazy src=/assets/images/2020-11-19-01-14-52_2020-11-18-problem_solving_19.md.png alt></p><p>또한, 문제 설명을 기반으로 다음과 같이 정리할 수 있다.</p><ol><li>경기 결과에 모순이 없다는 말은, 곧 방향 그래프의 Cycle이 없다는 의미가 된다.</li><li>따라서, 특정 Node가 <strong>가리킬 수 있는</strong> 다른 Node들의 <strong>리스트를 만든다.</strong></li></ol><p>그런데, 이렇게만 하면 정보가 부족하다. 가령, 2번 Node의 경우, 5번 Node로부터 승리했기 때문에 4위라는 순위를 얻을 수 있는데, 위 그래프만으로는 이를 설명할 수 없다. 따라서, <strong>방향을 뒤집어서도</strong>, 특정 Node를 가리킬 수 있는 Node들의 리스트 또한 만들어 줘야 한다.</p><p><img loading=lazy src=/assets/images/2020-11-19-01-03-25_2020-11-18-problem_solving_19.md.png alt></p><p>즉, 바꿔 말하면, <strong>정방향과 역방향의 그래프 두 개를 바탕</strong>으로, <strong>내가(Node가) 직, 간접적으로 나갈 수 있는 Node 리스트의 합집합</strong>을 만들어 줘야 한다.</p><p>위 그림을 바탕으로, 하나씩 살펴보자.</p><p><strong>Node 1</strong></p><ul><li>첫 번째 그림에서, Node 1 이 갈 수 있는 Node는 없다.</li><li>두 번째 그림에서, Node 1 이 갈 수 있는 Node는 2, 5 이다.</li></ul><p>-> count = 2</p><p><strong>Node 2</strong></p><ul><li>첫 번째 그림에서, Node 2 가 갈 수 있는 Node는 1, 3, 4 이다.</li><li>두 번째 그림에서, Node 2 가 갈 수 있는 Node는 5 이다.</li></ul><p>-> count = 4</p><p><strong>Node 3</strong></p><ul><li>첫 번째 그림에서, Node 3 가 갈 수 있는 Node는 4 이다.</li><li>두 번째 그림에서, Node 3 가 갈 수 있는 Node는 2, 5 이다.</li></ul><p>-> count = 3</p><p><strong>Node 4</strong></p><ul><li>첫 번째 그림에서, Node 4 가 갈 수 있는 Node는 없다</li><li>두 번째 그림에서, Node 4 가 갈 수 있는 Node는 2, 3, 5 이다.</li></ul><p>-> count = 3</p><p><strong>Node 5</strong></p><ul><li>첫 번째 그림에서, Node 5 가 갈 수 있는 Node는 1, 2, 3, 4 이다.</li><li>두 번째 그림에서, Node 5 가 갈 수 있는 Node는 없다.</li></ul><p>-> count = 4</p><p>이렇게 정리했을 때, 노드의 개수 <code>n</code> 에서, 자기 자신을 제외한 나머지의 개수는 <code>n-1</code> 이므로, 4가 되는 Node 2, Node 5 의 개수 = 2 가 정답이 된다.</p><h2 id=구현>구현.<a hidden class=anchor aria-hidden=true href=#구현>#</a></h2><p>: 우선, 문제를 쉽게 하기 위해 <code>Map&lt;Integer, List&lt;Integer>></code> 를 만들어 주었다. 그리고 위에서 이야기했던 것 처럼, 역방향도 고려해줘야 하기 때문에, <code>winnerMap</code> 과 <code>loserMap</code> 이라는 이름으로 두 개를 만들어 주었다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> winnerMap <span style=color:#f92672>=</span> initGames<span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> results<span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> loserMap <span style=color:#f92672>=</span> initGames<span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> results<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// winnerMap = {1=[2], 2=[5], 3=[2], 4=[3, 2], 5=[]}
</span></span></span><span style=display:flex><span><span style=color:#75715e>// loserMap = {1=[], 2=[4, 3, 1], 3=[4], 4=[], 5=[2]}
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>initGames</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> results<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> isWin<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> WINNER <span style=color:#f92672>=</span> isWin <span style=color:#f92672>?</span> 0 <span style=color:#f92672>:</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> LOSER <span style=color:#f92672>=</span> isWin <span style=color:#f92672>?</span> 1 <span style=color:#f92672>:</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 한 번의 for문으로 해결하려 하면, 비어 있는 List를 표현할 수 없다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> result <span style=color:#f92672>:</span> results<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> winner <span style=color:#f92672>=</span> result<span style=color:#f92672>[</span>WINNER<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> loser <span style=color:#f92672>=</span> result<span style=color:#f92672>[</span>LOSER<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>        map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>winner<span style=color:#f92672>).</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>loser<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>그리고 나서, 각 Node (1 ~ n이하) 의 iteration을 돌면서, 합집합을 구하기 위해 <code>boolean[] visited = new boolean[n];</code> 를 만들고, 재귀함수를 통해 visited 를 채워나갔다.</p><p>배열을 채우고 나서는, 해당 배열에 true 값이 몇개가 들어있는지 파악한 후, <code>n-1</code> 개 이면 int형 변수 answer를 1 증가시켰다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> visited <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>n<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    recursive<span style=color:#f92672>(</span>winnerMap<span style=color:#f92672>,</span> visited<span style=color:#f92672>,</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    recursive<span style=color:#f92672>(</span>loserMap<span style=color:#f92672>,</span> visited<span style=color:#f92672>,</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 배열 채우기.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> battleCount <span style=color:#f92672>=</span> countBattle<span style=color:#f92672>(</span>visited<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>battleCount <span style=color:#f92672>==</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>))</span> answer<span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>재귀 함수 내부는, <strong>내가 더이상 나갈 수 없을 때 까지</strong>, 즉 List가 비어있을 때까지 를 종료 조건으로 주었다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>recursive</span><span style=color:#f92672>(</span>Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> map<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> visited<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> enemy<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>enemy<span style=color:#f92672>).</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span> <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Integer val <span style=color:#f92672>:</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>enemy<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>visited<span style=color:#f92672>[</span>val <span style=color:#f92672>-</span> 1<span style=color:#f92672>])</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// 이를 확인하지 않으면, 너무 깊게 들어갈 수 있다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            visited<span style=color:#f92672>[</span>val <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            recursive<span style=color:#f92672>(</span>map<span style=color:#f92672>,</span> visited<span style=color:#f92672>,</span> val<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>이렇게 구한 answer 를 return 해주면 된다. 전체 코드는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> programmers.lv3<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.*<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>p49191</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 5<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> results <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>{</span>4<span style=color:#f92672>,</span> 3<span style=color:#f92672>},</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>{</span>4<span style=color:#f92672>,</span> 2<span style=color:#f92672>},</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>{</span>3<span style=color:#f92672>,</span> 2<span style=color:#f92672>},</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>{</span>1<span style=color:#f92672>,</span> 2<span style=color:#f92672>},</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>{</span>2<span style=color:#f92672>,</span> 5<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        p49191 p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> p49191<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span><span style=color:#a6e22e>solution</span><span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> results<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;result = &#34;</span> <span style=color:#f92672>+</span> result<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>solution</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> results<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> winnerMap <span style=color:#f92672>=</span> initGames<span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> results<span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> loserMap <span style=color:#f92672>=</span> initGames<span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> results<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> visited <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>n<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>            recursive<span style=color:#f92672>(</span>winnerMap<span style=color:#f92672>,</span> visited<span style=color:#f92672>,</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            recursive<span style=color:#f92672>(</span>loserMap<span style=color:#f92672>,</span> visited<span style=color:#f92672>,</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> battleCount <span style=color:#f92672>=</span> countBattle<span style=color:#f92672>(</span>visited<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>battleCount <span style=color:#f92672>==</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>))</span> answer<span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> answer<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>recursive</span><span style=color:#f92672>(</span>Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> map<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> visited<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> enemy<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>enemy<span style=color:#f92672>).</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span> <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Integer val <span style=color:#f92672>:</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>enemy<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>visited<span style=color:#f92672>[</span>val <span style=color:#f92672>-</span> 1<span style=color:#f92672>])</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                visited<span style=color:#f92672>[</span>val <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                recursive<span style=color:#f92672>(</span>map<span style=color:#f92672>,</span> visited<span style=color:#f92672>,</span> val<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>countBattle</span><span style=color:#f92672>(</span><span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> visited<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> visited<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>visited<span style=color:#f92672>[</span>i<span style=color:#f92672>])</span> count<span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>initGames</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> n<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> results<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> isWin<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> WINNER <span style=color:#f92672>=</span> isWin <span style=color:#f92672>?</span> 0 <span style=color:#f92672>:</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> LOSER <span style=color:#f92672>=</span> isWin <span style=color:#f92672>?</span> 1 <span style=color:#f92672>:</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;());</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> result <span style=color:#f92672>:</span> results<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> winner <span style=color:#f92672>=</span> result<span style=color:#f92672>[</span>WINNER<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> loser <span style=color:#f92672>=</span> result<span style=color:#f92672>[</span>LOSER<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>            map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>winner<span style=color:#f92672>).</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>loser<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> map<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/programmers/>programmers</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/backup-copy/algorithm/problem_solving/2020-11-18-problem_solving_20/><span class=title>« Prev Page</span><br><span># 프로그래머스[Lv.4] - 숫자 블록 ( Java )</span></a>
<a class=next href=http://cjlee38.github.io/backup-copy/tech/spring/2020-11-11-what_is_spring/><span class=title>Next Page »</span><br><span># [Spring 학습 정리] Spring Framework 란?</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.3] - 순위 ( Java ) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.3%5d%20-%20%ec%88%9c%ec%9c%84%20%28%20Java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fproblem_solving%2f2020-11-18-problem_solving_19%2f&hashtags=programmers"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.3] - 순위 ( Java ) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fproblem_solving%2f2020-11-18-problem_solving_19%2f&title=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.3%5d%20-%20%ec%88%9c%ec%9c%84%20%28%20Java%20%29&summary=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.3%5d%20-%20%ec%88%9c%ec%9c%84%20%28%20Java%20%29&source=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fproblem_solving%2f2020-11-18-problem_solving_19%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.3] - 순위 ( Java ) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fproblem_solving%2f2020-11-18-problem_solving_19%2f&title=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.3%5d%20-%20%ec%88%9c%ec%9c%84%20%28%20Java%20%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.3] - 순위 ( Java ) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fproblem_solving%2f2020-11-18-problem_solving_19%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.3] - 순위 ( Java ) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.3%5d%20-%20%ec%88%9c%ec%9c%84%20%28%20Java%20%29%20-%20http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fproblem_solving%2f2020-11-18-problem_solving_19%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 프로그래머스[Lv.3] - 순위 ( Java ) on telegram" href="https://telegram.me/share/url?text=%23%20%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%8a%a4%5bLv.3%5d%20-%20%ec%88%9c%ec%9c%84%20%28%20Java%20%29&url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fproblem_solving%2f2020-11-18-problem_solving_19%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>