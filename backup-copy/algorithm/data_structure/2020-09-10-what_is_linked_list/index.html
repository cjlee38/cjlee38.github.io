<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title># 마음으로 이해하는 자료구조 : LinkedList ( feat. C ) | cjlee38</title><meta name=keywords content="null"><meta name=description content="0. 들어가며 : 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.
변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),
주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.
두 번째로 마주하는 관문은, 자료구조다.
기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,
자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.
물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다."><meta name=author content="cjlee38"><link rel=canonical href=http://cjlee38.github.io/backup-copy/algorithm/data_structure/2020-09-10-what_is_linked_list/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://cjlee38.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://cjlee38.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://cjlee38.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://cjlee38.github.io/apple-touch-icon.png><link rel=mask-icon href=http://cjlee38.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="# 마음으로 이해하는 자료구조 : LinkedList ( feat. C )"><meta property="og:description" content="0. 들어가며 : 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.
변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),
주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.
두 번째로 마주하는 관문은, 자료구조다.
기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,
자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.
물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다."><meta property="og:type" content="article"><meta property="og:url" content="http://cjlee38.github.io/backup-copy/algorithm/data_structure/2020-09-10-what_is_linked_list/"><meta property="article:section" content="backup copy"><meta property="article:published_time" content="2020-09-10T01:51:00+00:00"><meta property="article:modified_time" content="2020-09-10T01:51:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="# 마음으로 이해하는 자료구조 : LinkedList ( feat. C )"><meta name=twitter:description content="0. 들어가며 : 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.
변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),
주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.
두 번째로 마주하는 관문은, 자료구조다.
기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,
자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.
물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"# 마음으로 이해하는 자료구조 : LinkedList ( feat. C )","item":"http://cjlee38.github.io/backup-copy/algorithm/data_structure/2020-09-10-what_is_linked_list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"# 마음으로 이해하는 자료구조 : LinkedList ( feat. C )","name":"# 마음으로 이해하는 자료구조 : LinkedList ( feat. C )","description":"0. 들어가며 : 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.\n변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),\n주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.\n두 번째로 마주하는 관문은, 자료구조다.\n기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,\n자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.\n물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다.","keywords":["null"],"articleBody":"0. 들어가며 : 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.\n변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),\n주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.\n두 번째로 마주하는 관문은, 자료구조다.\n기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,\n자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.\n물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다.\n이번 포스팅을 통해, 머릿 속에 있는 이 개념을 “자연스럽게” 머리, 가슴까지만 천천히 흘려보내보자.\n1. Array A. 형태 : 처음 LinkedList, 즉 연결 리스트를 처음 배웠을 때, 가장 많이 비교되는 대상은 배열이다.\n둘 다 연속적인 데이터를 표현하고 있기에 큰 차이가 없는 것으로 생각할 수도 있지만, 실제로 동작하는 방식은 꽤나 다르다.\n먼저, 기존의 C로 만든 배열에 대해서 이해해보자.\n#include  int main() {  int numbers[5] = {1, 2, 3, 4, 5};  int i = 0;   for(i = 0; i  5; i++) {  printf(\"%d\\n\", numbers[i]);  }   return 0; } // 1, 2, 3, 4, 5가 순서대로 출력. 위 간단한 코드에서, 우리가 쳐다봐야 할 부분은 printf() 함수를 사용하는 부분이다.\n배열의 요소를 순차적으로 탐색하고 있다. 이는 우리가 자연스럽게 이해하고 있는 부분이다.\n그러나, 기존의 printf()를 printf(\"%p\\n\", \u0026numbers[i]); 로 바꾸면 어떻게 되는가?\n이 코드는 기존의 “값\"을 출력하던 것을, 대신에 “주소값\"을 출력하게 해준다. 결과는 다음과 같다.\n 0x7ffc5c6f9810\n0x7ffc5c6f9814\n0x7ffc5c6f9818\n0x7ffc5c6f981c\n0x7ffc5c6f9820\n 뭔가 복잡해 보이지만, 아주 잠깐만 자세히 들여다보면, 뭔가 패턴이 있는 것을 알 수 있다.\n그 패턴은, 가장 끝 두자리만 바뀔 뿐, 앞은 똑같다는 것이다.\n또한, 16진수로 표기되어 있다는 점을 감안하면, 4씩 늘어나는 것도 알 수 있다.\n이것으로 우리는 “아, 배열은 여러 개의 변수를 만드는 건데, 이것들이 이어서 붙어있다” 라는 것을 알 수 있다.\nB. 장점 : 이 배열이라는 녀석의 특징이 “이어서 붙여져” 있다는 것을 알았다면,\n우리는 내가 찾고자 하는 녀석의 위치를 알고 있다면, 아주 순식간에 찾아낼 수 있다 는 장점을 알 수 있다.\n즉, 10개의 서랍이 있는 서랍장에서,\n3번째에 내가 찾고 있는 빨간 옷이 있다는 것을 이미 알고 있다면,\n3번째 서랍장을 바로 열면 되는 것이다.\n{: .alignCenter}\n{: .caption} C. 단점 : 이렇게 아주 간단하고 유용한 배열은, 삽입과 제거에서 문제점을 안고 있다.\n가령, 위 [1, 2, 3, 4, 5] 라는 배열에서, 나는 중간에 10이라는 숫자를 집어넣고 싶다고 해보자 - [1, 2, 10, 3, 4, 5]\n뭔가 간단해보인다. 그냥 넣으면 되는거아닌가? 하지만, 컴퓨터는 그렇게 똑똑하지 않다.\n이는 현실로 비유하면, 아주 좁은 간격으로 세워놓은 도미노에, 새로운 블럭 하나를 중간에 집어넣는것으로 생각해 볼 수 있다.\n기존에 세워놓은 블럭에, 새로운 블럭을 집어넣고 싶다면(기존에는 이를 집어넣을 공간이 충분하지 않다면) 그 뒤에 있는 블럭들을 다 뒤로 밀어줘야 한다.\n{: .alignCenter}\n{: .caption} 즉, 5번째(컴퓨터에서의 index는 4) 에 있는 5라는 숫자를 6번째으로 밀어주고,\n4번째에 있는 4라는 숫자를 5번째로 밀어줘야 한다.\n언제까지? 10이 들어갈 여유가 될 때 까지.\n지금은 예시가 간단하지만, 만약 배열 안에 원소가 1억 개가 있다고 해보자.\n그리고 더 최악으로, 우리는 “첫 번째\"에 새로운 원소를 추가해야 한다고 해보자. 1억 번을 다 밀어야 한다.\n제거의 경우도 마찬가지다. [1, 2, 3, 4, 5] 에서, 3을 지우고 싶다. 어떻게 해야 할까?\n아마 3번째에 있는 3이라는 숫자를, 4번째에서 가져와서 4로 바꿔주고,\n그렇다면 4번째에 있는 4라는 숫자를, 5번째에서 가져와서 5라는 숫자로 바꿔주면 될 것이다.\n이 또한, 도미노로 생각해보면, 중간에 블럭 하나를 치우겠다고 하면,\n그 뒤에 있는 모든 블럭을 앞으로 가져와야 한다. 그래야 도미노가 제대로 쓰러질테니까\n2. LinkedList A. 형태 : 연결 리스트는, 위 배열에서 등장한 문제를 아주 손쉽게 해결해 줄 수 있다. 이를 구현하기 위해선, 포인터가 필요하다.\n왜인지는 다음의 예시를 차분히 읽어가면서 이해해보자.\n 가령, 학교에서 선생님이 방학 중에 각 학생들에게 어떤 공지사항을 알려주고 싶다고 해보자. 선생님은 방학 중이어도 일을 하기 때문에, 너무 바빠서 모든 학생들에게 공지를 해 줄 시간이 없다. 그래서, A라는 한 명의 학생에게 전화를 해서 알려주면, A 학생은 내용을 전달받고, B 학생에게 전화해서 공지사항을 전달해준다. 이렇게 해서 모든 학생들에게 전화를 돌리고 싶다고 해보자.\n 그럼 배열을 안쓰고 이렇게 전화를 한다고 하면, 어떻게 구현해야 할까?\n어떻게 해야 할지 계획은 세우지 못해도, 일단 각 학생들의 변수를 만들고 보면, int A, int B, int C… 이런식으로 만들 것이다.\n근데 이렇게만 하면, int A가 int B와 연결고리. 즉 전화번호가 없다. 무슨 수로 공지사항을 전달할 것인가?\n이 때, 포인터라는 개념이 등장한다. 이 포인터라는 녀석이 다음 학생의 전화번호가 되는 셈이다.\n어떻게 포인터가 전화번호의 개념이 될까? 코드로 한번 살펴보자.\ntypedef struct Node { \tint called = 0; // 공지사항을 안내 받았는가? 0이면 받지 않음, 1이면 받음.  struct Node *next; // 다음 학생의 전화번호. }Node;   Note. 이 Node라는 녀석은, int, float 등등의 primitive 데이터 타입이 아닌, 우리가 새로 정의한 데이터 타입이다.\n따라서, 다음과 같이 사용해야 한다.\nNode *newNode = (Node*)malloc(sizeof(Node)); // newNode만큼의 공간을 확보 newNode-called = 0; // newNode의 called를 0으로 정의 newNode-next = existingNode; // newNode의 포인터(전화번호)를 다음 Node를 가리키도록 함.   이 구조체 Node 라는 녀석은 학생이다. 학생은 공지사항을 안내 받았는지에 대한 called 변수, 그리고 “다음 학생의 전화번호. 즉 Node를 가리키는 포인터” 를 갖고 있다.\n즉, 학생을 int A 라고 하는 정수형 변수로 만드는 것이 아니라, Node 라고 하는 녀석으로 만든다면, “서로 간의 연결고리가 이어진다”.\n이렇게 연결된 Data들을 묶어서 이름 그대로의 “Linked List” 라고 부르는 것이다.\nB. 장점 : 그렇다면, 이 LinkedList라는 것을 활용하면, 배열의 단점을 해소할 수 있지 않을까?\n학생의 예시로 다시 돌아와보자. 공지를 하려고 하는데, C 라는 학생이 전학을 가버려서 더 이상 해당 반의 학생이 아니게 되었다. 10명의 학생이 있었다면, 이제는 9명인 셈이다.\n이를 배열로 해결하려 한다면, 꽤 골머리 아픈 일인 것임을 아까 배웠다. LinkedList는 어떨까?\n아주 간단하다. C라는 학생의 전화번호를 알고 있는 학생은 B 학생이므로, B 학생이 갖고 있던 C의 전화번호를, D 라는 학생으로 바꿔주기만 하면 된다!\n그러면 끝이다.\nC. 단점 : 그러나, 이렇게 대단해 보이는 LinkedList에도 단점이 있다. 이는, 배열에서의 장점이었던 부분이다. 무엇일까?\n내가 **“몇 번째에 데이터가 있는지 알더라도, 곧바로 접근할 수 없다”**는 것이다.\n왜일까? 아주 단순하다. 사람이 됐건, 컴퓨터가 됐건, 특정 index에 있는 데이터를 “곧바로 접근\"할 수는 없기 때문이다.\n아까 1-B에서 들었던 서랍을 생각해보자. 이번에는, 서랍이 아니라, 바구니라고 해보자.\n우리는 검은색 바구니에 우리가 찾는 빨간 옷이 있다는 것을 알고 있다.\n근데, 정작 중요한 검은색 바구니가 어디에 위치한지 모른다.\n왜일까? 이 검은색 바구니. 즉, 변수는 “컴퓨터가 알아서 빈 공간에 배치” 하기 때문이다.\n학생의 예시로 생각해보면, Z라는 학생에게 도달하기 위해서는,\n반드시 A가 갖고 있는 B의 전화번호라는 포인터를 통해서, B에게 가고,\nB가 갖고 있는 C의 전화번호라는 포인터를 통해서, C에게 가고.. 를 반복해야 한다.\n끝이 아니다. 첫 번째 문제 : 지금까지의 내용을 읽고, 다음과 같은 의문을 가질 수 있다.\n“C의 전화번호는 B가 갖고있고, B의 전화번호는 A가 갖고 있는데, 그럼 A의 전화번호는 누가 갖고있어요?\"\n물론, 선생님이 전화번호를 알고 있기는 하다. 근데, 선생님도 같은 Node로 표현할 것인가?\n선생님은 학생들과 달리 조금 특별한데, 이걸로 될까? 학생을 추가하고, 삭제하고, 관리하는 녀석이 있었으면 좋겠다.\n내가 자료구조 수업을 들었을 당시 받았던 과제는, “웹 브라우저 흉내내기” 였다.\n즉, 우리가 웹페이지를 돌아다니면서, 뒤로가기를 누르면 이전 웹페이지가 나오고, 또 뒤로가기를 누르면 그 이전.. 뭐 이런식이다.\n또한, 앞으로가기, 홈페이지 가기 등등을 만드는 것이 필요했다.\n그렇다면, 뒤로가기를 했다가, 다시 앞으로 가기 등의 행위를 하려면, 무엇이 필요할까? 정답은 다음과 같다.\n 다음 Node를 가리키는 포인터 뿐만 아니라, “이전 Node를 가리키는 포인터도 필요하다.” 이런 형태를 Doubly Linked List\"라고 부른다! “현재 페이지” 가 어디인지를 알아야 한다.  1번 문제를 해결하기 위한 Node의 구조체는 다음과 같다.\n#define LEN 100  typedef struct Node { \tchar data[LEN]; // 웹페이지의 주소를 저장(e.g. www.naver.com) \tstruct Node *next; // 다음 페이지를 가리키는 포인터 \tstruct Node *prev; // 이전 페이지를 가리키는 포인터 }Node; 또한, 2번 문제를 해결하기 위한 Node의 구조체는 다음과 같다.\ntypedef struct LinkedList { \tNode *head; // 첫 페이지를 가리키는 포인터 \tNode *cur; // 현재 페이지를 가리키는 포인터 \tNode *last; // 마지막 페이지를 가리키는 포인터 \tint NumOfData; // 방문 페이지의 개수 }List; 위 내용을 다 이해 했다면, 해당 코드를 이해하기는 수월할 것이다.\n두 번째 문제 : 학생 예시에서, 이러한 의문 또한 가질 수 있다. 무엇이냐?\n“학생 C가 전학을 가서, B가 갖고있는 C의 전화번호를 D의 전화번호로 바꾸어줬다면, C에 앞으로 접근 못하는 것 아닌가요?”\n맞다. 이를 Memory Leak. 메모리 누수라 한다. 메모리 누수는 중요하다.\n바구니를 아무리 안쓴다고 한들, 그 내용이 쓰레기라면 집 구석에 박아 놓으면 안된다.\n쓰레기가 암만 소량이라고 하더라도, 쌓이게 되면 결국 버려야 하는 것이다.\n잘 분리수거하고, 종량제 봉투에 깔끔하게 담아 버려야 한다.\n코드로는 어떻게 버려야 할까? 순서는 다음과 같다.\n 버릴 대상을 가리키는 임시 포인터 delNode를 만든다. (주의하자. delNode는 Node가 아닌 pointer다.) B학생의 전화번호를 D학생으로 바꾼다. free(delNode) 를 통해, delNode라는 포인터가 가리키는 노드(즉, C학생)를 삭제한다.  Node *delNode;  delNode = plist-last; bNode-next = dNode; free(delNode) 이렇게 하면, 쓰레기를 잘 분리수거해서 버리게 된다.\nArray? LinkedList? : 그렇다면, 언제 무엇을 사용할까?\n“결국 과정은 다르지만 결과는 같으니, 어려운 리스트보다는 배열을 사용할래요” 하면 안된다.\n이는 컴퓨터 알고리즘의 기초 중 기초인 시간복잡도에서 차이가 난다.\nArray의 시간복잡도는, 특정 index 접근은 O(1), 삽입/제거는 O(N) 이다. LinkedList의 시간복잡도는, 특정 index 접근은 O(N), 삽입/제거는 O(1) 이다.\n따라서, “내가 데이터의 변경을 자주 할 것 같으면 LinkedList, index 접근을 자주 할 것 같으면 array\"를 선택하면 된다.\n  Note. O(1), O(N)은 최악의 경우를 가정한 시간복잡도를 나타내는 “빅오 표기법\"으로 나타낸 수치이다.\nO(1)은, 최악의 경우에도 연산을 1번만 하고, O(N)은 최악의 경우에 N번, 즉 데이터의 개수만큼 연산을 한다는 의미이다.\n빅오 표기법에 대해서는 추후에 작성하겠다.\n  마치며 : 가볍게 쓰자고 마음 먹었는데, 아무래도 쉽게 쓰려다 보니 포스팅이 많이 길어졌다.\n그래도 뭐, 나쁘게 생각하지는 않는다. 이렇게 한번 이해하고 나면,\n본인이 작성한 코드가 잘못 되더라도, “왜 잘못되었는지에 대한 추론” 이 가능해지기 때문이다.\n어디서 잘못되었는지를 알아야, 머리가 살짝 고생하더라도 몸이 편해지는 것 같다.\n","wordCount":"1466","inLanguage":"en","datePublished":"2020-09-10T01:51:00Z","dateModified":"2020-09-10T01:51:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://cjlee38.github.io/backup-copy/algorithm/data_structure/2020-09-10-what_is_linked_list/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"http://cjlee38.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://cjlee38.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://cjlee38.github.io/assets/icon.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://cjlee38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://cjlee38.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://cjlee38.github.io/>Home</a></div><h1 class=post-title># 마음으로 이해하는 자료구조 : LinkedList ( feat. C )</h1><div class=post-meta><span title="2020-09-10 01:51:00 +0000 UTC">September 10, 2020</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/backup%20copy/Algorithm/Data_Structure/2020-09-10-what_is_linked_list.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label="0. 들어가며">0. 들어가며</a></li><li><a href=#1-array aria-label="1. Array">1. Array</a><ul><li><a href=#a-%ed%98%95%ed%83%9c aria-label="A. 형태">A. 형태</a></li><li><a href=#b-%ec%9e%a5%ec%a0%90 aria-label="B. 장점">B. 장점</a></li><li><a href=#c-%eb%8b%a8%ec%a0%90 aria-label="C. 단점">C. 단점</a></li></ul></li><li><a href=#2-linkedlist aria-label="2. LinkedList">2. LinkedList</a><ul><li><a href=#a-%ed%98%95%ed%83%9c-1 aria-label="A. 형태">A. 형태</a></li><li><a href=#b-%ec%9e%a5%ec%a0%90-1 aria-label="B. 장점">B. 장점</a></li><li><a href=#c-%eb%8b%a8%ec%a0%90-1 aria-label="C. 단점">C. 단점</a></li></ul></li><li><a href=#%eb%81%9d%ec%9d%b4-%ec%95%84%eb%8b%88%eb%8b%a4 aria-label="끝이 아니다.">끝이 아니다.</a><ul><li><a href=#%ec%b2%ab-%eb%b2%88%ec%a7%b8-%eb%ac%b8%ec%a0%9c aria-label="첫 번째 문제">첫 번째 문제</a></li><li><a href=#%eb%91%90-%eb%b2%88%ec%a7%b8-%eb%ac%b8%ec%a0%9c aria-label="두 번째 문제">두 번째 문제</a></li><li><a href=#array-linkedlist aria-label="Array? LinkedList?">Array? LinkedList?</a></li></ul></li><li><a href=#%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label=마치며>마치며</a></li></ul></div></details></div><div class=post-content><h1 id=0-들어가며>0. 들어가며<a hidden class=anchor aria-hidden=true href=#0-들어가며>#</a></h1><p>: 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.<br>변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),<br>주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.</p><p>두 번째로 마주하는 관문은, 자료구조다.<br>기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,<br>자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.<br>물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다.</p><p>이번 포스팅을 통해, 머릿 속에 있는 이 개념을 <strong>&ldquo;자연스럽게&rdquo;</strong> 머리, 가슴까지만 천천히 흘려보내보자.</p><h1 id=1-array>1. Array<a hidden class=anchor aria-hidden=true href=#1-array>#</a></h1><h2 id=a-형태>A. 형태<a hidden class=anchor aria-hidden=true href=#a-형태>#</a></h2><p>: 처음 LinkedList, 즉 연결 리스트를 처음 배웠을 때, 가장 많이 비교되는 대상은 배열이다.<br>둘 다 연속적인 데이터를 표현하고 있기에 큰 차이가 없는 것으로 생각할 수도 있지만, 실제로 동작하는 방식은 꽤나 다르다.</p><p>먼저, 기존의 C로 만든 배열에 대해서 이해해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> numbers[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, numbers[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 1, 2, 3, 4, 5가 순서대로 출력.
</span></span></span></code></pre></div><p>위 간단한 코드에서, 우리가 쳐다봐야 할 부분은 printf() 함수를 사용하는 부분이다.<br>배열의 요소를 순차적으로 탐색하고 있다. 이는 우리가 자연스럽게 이해하고 있는 부분이다.</p><p>그러나, 기존의 printf()를 <code>printf("%p\n", &numbers[i]);</code> 로 바꾸면 어떻게 되는가?<br>이 코드는 기존의 &ldquo;값"을 출력하던 것을, 대신에 &ldquo;주소값"을 출력하게 해준다. 결과는 다음과 같다.</p><blockquote><p>0x7ffc5c6f9810<br>0x7ffc5c6f9814<br>0x7ffc5c6f9818<br>0x7ffc5c6f981c<br>0x7ffc5c6f9820</p></blockquote><p>뭔가 복잡해 보이지만, 아주 잠깐만 자세히 들여다보면, 뭔가 패턴이 있는 것을 알 수 있다.<br>그 패턴은, <strong>가장 끝 두자리만 바뀔 뿐, 앞은 똑같다</strong>는 것이다.</p><p>또한, 16진수로 표기되어 있다는 점을 감안하면, 4씩 늘어나는 것도 알 수 있다.</p><p>이것으로 우리는 <strong>&ldquo;아, 배열은 여러 개의 변수를 만드는 건데, 이것들이 이어서 붙어있다&rdquo;</strong> 라는 것을 알 수 있다.</p><h2 id=b-장점>B. 장점<a hidden class=anchor aria-hidden=true href=#b-장점>#</a></h2><p>: 이 배열이라는 녀석의 특징이 &ldquo;이어서 붙여져&rdquo; 있다는 것을 알았다면,<br>우리는 <strong>내가 찾고자 하는 녀석의 위치를 알고 있다면, 아주 순식간에 찾아낼 수 있다</strong> 는 장점을 알 수 있다.</p><p>즉, 10개의 서랍이 있는 서랍장에서,<br><em>3번째에 내가 찾고 있는 빨간 옷이 있다는 것을 이미 알고 있다면,</em><br>3번째 서랍장을 바로 열면 되는 것이다.</p><p><img loading=lazy src=/assets/images/2020-09-10-05-43-44_2020-09-10-what_is_linked_list.md.png alt=drawer>
{: .alignCenter}</p><p>{: .caption}
&lt; DRAWER ></p><h2 id=c-단점>C. 단점<a hidden class=anchor aria-hidden=true href=#c-단점>#</a></h2><p>: 이렇게 아주 간단하고 유용한 배열은, <strong>삽입과 제거</strong>에서 문제점을 안고 있다.</p><p>가령, 위 [1, 2, 3, 4, 5] 라는 배열에서, 나는 중간에 10이라는 숫자를 집어넣고 싶다고 해보자 -> [1, 2, 10, 3, 4, 5]</p><p>뭔가 간단해보인다. 그냥 넣으면 되는거아닌가? 하지만, 컴퓨터는 그렇게 똑똑하지 않다.</p><p>이는 현실로 비유하면, <strong>아주 좁은 간격으로 세워놓은 도미노에, 새로운 블럭 하나를 중간에 집어넣는것</strong>으로 생각해 볼 수 있다.<br>기존에 세워놓은 블럭에, 새로운 블럭을 집어넣고 싶다면(기존에는 이를 집어넣을 공간이 충분하지 않다면) 그 뒤에 있는 블럭들을 다 뒤로 밀어줘야 한다.</p><p><img loading=lazy src=/assets/images/2020-09-10-05-56-41_2020-09-10-what_is_linked_list.md.png alt=domino>
{: .alignCenter}</p><p>{: .caption}
&lt; DOMINO ></p><p>즉, 5번째(컴퓨터에서의 index는 4) 에 있는 5라는 숫자를 6번째으로 밀어주고,<br>4번째에 있는 4라는 숫자를 5번째로 밀어줘야 한다.<br>언제까지? 10이 들어갈 여유가 될 때 까지.</p><p>지금은 예시가 간단하지만, 만약 배열 안에 원소가 1억 개가 있다고 해보자.<br>그리고 더 최악으로, 우리는 &ldquo;첫 번째"에 새로운 원소를 추가해야 한다고 해보자. 1억 번을 다 밀어야 한다.</p><p><strong>제거의 경우도 마찬가지다.</strong> [1, 2, 3, 4, 5] 에서, 3을 지우고 싶다. 어떻게 해야 할까?<br>아마 3번째에 있는 3이라는 숫자를, 4번째에서 가져와서 4로 바꿔주고,<br>그렇다면 4번째에 있는 4라는 숫자를, 5번째에서 가져와서 5라는 숫자로 바꿔주면 될 것이다.</p><p>이 또한, 도미노로 생각해보면, 중간에 블럭 하나를 치우겠다고 하면,<br><strong>그 뒤에 있는 모든 블럭을 앞으로 가져와야 한다. 그래야 도미노가 제대로 쓰러질테니까</strong></p><h1 id=2-linkedlist>2. LinkedList<a hidden class=anchor aria-hidden=true href=#2-linkedlist>#</a></h1><h2 id=a-형태-1>A. 형태<a hidden class=anchor aria-hidden=true href=#a-형태-1>#</a></h2><p>: 연결 리스트는, 위 배열에서 등장한 문제를 아주 손쉽게 해결해 줄 수 있다. 이를 구현하기 위해선, 포인터가 필요하다.<br>왜인지는 다음의 예시를 차분히 읽어가면서 이해해보자.</p><blockquote><p>가령, 학교에서 선생님이 방학 중에 각 학생들에게 어떤 공지사항을 알려주고 싶다고 해보자. 선생님은 방학 중이어도 일을 하기 때문에, 너무 바빠서 모든 학생들에게 공지를 해 줄 시간이 없다. 그래서, A라는 한 명의 학생에게 전화를 해서 알려주면, A 학생은 내용을 전달받고, B 학생에게 전화해서 공지사항을 전달해준다. 이렇게 해서 모든 학생들에게 전화를 돌리고 싶다고 해보자.</p></blockquote><p>그럼 <strong>배열을 안쓰고</strong> 이렇게 전화를 한다고 하면, 어떻게 구현해야 할까?</p><p>어떻게 해야 할지 계획은 세우지 못해도, 일단 각 학생들의 변수를 만들고 보면, int A, int B, int C&mldr; 이런식으로 만들 것이다.<br>근데 이렇게만 하면, int A가 int B와 연결고리. 즉 전화번호가 없다. 무슨 수로 공지사항을 전달할 것인가?</p><p>이 때, 포인터라는 개념이 등장한다. 이 포인터라는 녀석이 다음 학생의 전화번호가 되는 셈이다.<br>어떻게 포인터가 전화번호의 개념이 될까? 코드로 한번 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Node {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> called <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 공지사항을 안내 받았는가? 0이면 받지 않음, 1이면 받음.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> Node <span style=color:#f92672>*</span>next; <span style=color:#75715e>// 다음 학생의 전화번호.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}Node;
</span></span></code></pre></div><hr><blockquote><p>Note. 이 Node라는 녀석은, int, float 등등의 primitive 데이터 타입이 아닌, 우리가 새로 정의한 데이터 타입이다.<br>따라서, 다음과 같이 사용해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Node <span style=color:#f92672>*</span>newNode <span style=color:#f92672>=</span> (Node<span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(Node)); <span style=color:#75715e>// newNode만큼의 공간을 확보
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>newNode<span style=color:#f92672>-&gt;</span>called <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// newNode의 called를 0으로 정의
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>newNode<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> existingNode; <span style=color:#75715e>// newNode의 포인터(전화번호)를 다음 Node를 가리키도록 함.
</span></span></span></code></pre></div></blockquote><hr><p>이 구조체 Node 라는 녀석은 <strong>학생</strong>이다. 학생은 공지사항을 안내 받았는지에 대한 called 변수, 그리고 <strong>&ldquo;다음 학생의 전화번호. 즉 Node를 가리키는 포인터&rdquo;</strong> 를 갖고 있다.</p><p>즉, 학생을 int A 라고 하는 정수형 변수로 만드는 것이 아니라, Node 라고 하는 녀석으로 만든다면, <strong>&ldquo;서로 간의 연결고리가 이어진다&rdquo;</strong>.</p><p>이렇게 연결된 Data들을 묶어서 이름 그대로의 &ldquo;Linked List&rdquo; 라고 부르는 것이다.</p><h2 id=b-장점-1>B. 장점<a hidden class=anchor aria-hidden=true href=#b-장점-1>#</a></h2><p>: 그렇다면, 이 LinkedList라는 것을 활용하면, 배열의 단점을 해소할 수 있지 않을까?</p><p>학생의 예시로 다시 돌아와보자. 공지를 하려고 하는데, C 라는 학생이 전학을 가버려서 더 이상 해당 반의 학생이 아니게 되었다. 10명의 학생이 있었다면, 이제는 9명인 셈이다.</p><p>이를 배열로 해결하려 한다면, 꽤 골머리 아픈 일인 것임을 아까 배웠다. LinkedList는 어떨까?</p><p>아주 간단하다. C라는 학생의 전화번호를 알고 있는 학생은 B 학생이므로, <strong>B 학생이 갖고 있던 C의 전화번호를, D 라는 학생으로 바꿔주기만 하면 된다!</strong></p><p>그러면 끝이다.</p><h2 id=c-단점-1>C. 단점<a hidden class=anchor aria-hidden=true href=#c-단점-1>#</a></h2><p>: 그러나, 이렇게 대단해 보이는 LinkedList에도 단점이 있다. 이는, 배열에서의 장점이었던 부분이다. 무엇일까?<br>내가 **&ldquo;몇 번째에 데이터가 있는지 알더라도, 곧바로 접근할 수 없다&rdquo;**는 것이다.</p><p>왜일까? 아주 단순하다. 사람이 됐건, 컴퓨터가 됐건, 특정 index에 있는 데이터를 &ldquo;곧바로 접근"할 수는 없기 때문이다.</p><p>아까 1-B에서 들었던 서랍을 생각해보자. 이번에는, 서랍이 아니라, 바구니라고 해보자.<br>우리는 검은색 바구니에 우리가 찾는 빨간 옷이 있다는 것을 알고 있다.<br>근데, 정작 중요한 검은색 바구니가 어디에 위치한지 모른다.</p><p>왜일까? 이 검은색 바구니. 즉, 변수는 <strong>&ldquo;컴퓨터가 알아서 빈 공간에 배치&rdquo;</strong> 하기 때문이다.</p><p>학생의 예시로 생각해보면, Z라는 학생에게 도달하기 위해서는,<br>반드시 A가 갖고 있는 B의 전화번호라는 포인터를 통해서, B에게 가고,<br>B가 갖고 있는 C의 전화번호라는 포인터를 통해서, C에게 가고.. 를 반복해야 한다.</p><h1 id=끝이-아니다>끝이 아니다.<a hidden class=anchor aria-hidden=true href=#끝이-아니다>#</a></h1><h2 id=첫-번째-문제>첫 번째 문제<a hidden class=anchor aria-hidden=true href=#첫-번째-문제>#</a></h2><p>: 지금까지의 내용을 읽고, 다음과 같은 의문을 가질 수 있다.</p><p><strong>&ldquo;C의 전화번호는 B가 갖고있고, B의 전화번호는 A가 갖고 있는데, 그럼 A의 전화번호는 누가 갖고있어요?"</strong></p><p>물론, 선생님이 전화번호를 알고 있기는 하다. 근데, 선생님도 같은 Node로 표현할 것인가?<br>선생님은 학생들과 달리 조금 특별한데, 이걸로 될까? 학생을 추가하고, 삭제하고, 관리하는 녀석이 있었으면 좋겠다.</p><p>내가 자료구조 수업을 들었을 당시 받았던 과제는, <strong>&ldquo;웹 브라우저 흉내내기&rdquo;</strong> 였다.<br>즉, 우리가 웹페이지를 돌아다니면서, 뒤로가기를 누르면 이전 웹페이지가 나오고, 또 뒤로가기를 누르면 그 이전.. 뭐 이런식이다.<br>또한, 앞으로가기, 홈페이지 가기 등등을 만드는 것이 필요했다.</p><p>그렇다면, 뒤로가기를 했다가, 다시 앞으로 가기 등의 행위를 하려면, 무엇이 필요할까? 정답은 다음과 같다.</p><ol><li>다음 Node를 가리키는 포인터 뿐만 아니라, &ldquo;이전 Node를 가리키는 포인터도 필요하다.&rdquo; <strong>이런 형태를 Doubly Linked List"라고 부른다!</strong></li><li><strong>&ldquo;현재 페이지&rdquo;</strong> 가 어디인지를 알아야 한다.</li></ol><p>1번 문제를 해결하기 위한 Node의 구조체는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define LEN 100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Node {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> data[LEN]; <span style=color:#75715e>// 웹페이지의 주소를 저장(e.g. www.naver.com) 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>struct</span> Node <span style=color:#f92672>*</span>next; <span style=color:#75715e>// 다음 페이지를 가리키는 포인터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>struct</span> Node <span style=color:#f92672>*</span>prev; <span style=color:#75715e>// 이전 페이지를 가리키는 포인터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}Node;
</span></span></code></pre></div><p>또한, 2번 문제를 해결하기 위한 Node의 구조체는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> LinkedList {
</span></span><span style=display:flex><span>	Node <span style=color:#f92672>*</span>head; <span style=color:#75715e>// 첫 페이지를 가리키는 포인터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	Node <span style=color:#f92672>*</span>cur; <span style=color:#75715e>// 현재 페이지를 가리키는 포인터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	Node <span style=color:#f92672>*</span>last; <span style=color:#75715e>// 마지막 페이지를 가리키는 포인터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>int</span> NumOfData; <span style=color:#75715e>// 방문 페이지의 개수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}List;
</span></span></code></pre></div><p>위 내용을 다 이해 했다면, 해당 코드를 이해하기는 수월할 것이다.</p><h2 id=두-번째-문제>두 번째 문제<a hidden class=anchor aria-hidden=true href=#두-번째-문제>#</a></h2><p>: 학생 예시에서, 이러한 의문 또한 가질 수 있다. 무엇이냐?</p><p><strong>&ldquo;학생 C가 전학을 가서, B가 갖고있는 C의 전화번호를 D의 전화번호로 바꾸어줬다면, C에 앞으로 접근 못하는 것 아닌가요?&rdquo;</strong></p><p>맞다. 이를 Memory Leak. 메모리 누수라 한다. 메모리 누수는 중요하다.<br>바구니를 아무리 안쓴다고 한들, 그 내용이 쓰레기라면 집 구석에 박아 놓으면 안된다.<br>쓰레기가 암만 소량이라고 하더라도, 쌓이게 되면 결국 버려야 하는 것이다.<br>잘 분리수거하고, 종량제 봉투에 깔끔하게 담아 버려야 한다.</p><p>코드로는 어떻게 버려야 할까? 순서는 다음과 같다.</p><ol><li>버릴 대상을 가리키는 <strong>임시 포인터</strong> delNode를 만든다. (주의하자. delNode는 Node가 아닌 pointer다.)</li><li>B학생의 전화번호를 D학생으로 바꾼다.</li><li><code>free(delNode)</code> 를 통해, <strong>delNode라는 포인터가 가리키는 노드(즉, C학생)를 삭제한다.</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Node <span style=color:#f92672>*</span>delNode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>delNode <span style=color:#f92672>=</span> plist<span style=color:#f92672>-&gt;</span>last;
</span></span><span style=display:flex><span>bNode<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> dNode;
</span></span><span style=display:flex><span>free(delNode)
</span></span></code></pre></div><p>이렇게 하면, 쓰레기를 잘 분리수거해서 버리게 된다.</p><h2 id=array-linkedlist>Array? LinkedList?<a hidden class=anchor aria-hidden=true href=#array-linkedlist>#</a></h2><p>: 그렇다면, 언제 무엇을 사용할까?<br>&ldquo;결국 과정은 다르지만 결과는 같으니, 어려운 리스트보다는 배열을 사용할래요&rdquo; 하면 안된다.</p><p>이는 컴퓨터 알고리즘의 기초 중 기초인 시간복잡도에서 차이가 난다.<br>Array의 시간복잡도는, 특정 index 접근은 O(1), 삽입/제거는 O(N) 이다.
LinkedList의 시간복잡도는, 특정 index 접근은 O(N), 삽입/제거는 O(1) 이다.</p><p>따라서, &ldquo;내가 데이터의 변경을 자주 할 것 같으면 LinkedList, index 접근을 자주 할 것 같으면 array"를 선택하면 된다.</p><hr><blockquote><p>Note. O(1), O(N)은 최악의 경우를 가정한 시간복잡도를 나타내는 &ldquo;빅오 표기법"으로 나타낸 수치이다.<br>O(1)은, 최악의 경우에도 연산을 1번만 하고, O(N)은 최악의 경우에 N번, 즉 데이터의 개수만큼 연산을 한다는 의미이다.<br>빅오 표기법에 대해서는 추후에 작성하겠다.</p></blockquote><hr><h1 id=마치며>마치며<a hidden class=anchor aria-hidden=true href=#마치며>#</a></h1><p>: 가볍게 쓰자고 마음 먹었는데, 아무래도 쉽게 쓰려다 보니 포스팅이 많이 길어졌다.<br>그래도 뭐, 나쁘게 생각하지는 않는다. 이렇게 한번 이해하고 나면,<br>본인이 작성한 코드가 잘못 되더라도, <strong>&ldquo;왜 잘못되었는지에 대한 추론&rdquo;</strong> 이 가능해지기 때문이다.<br>어디서 잘못되었는지를 알아야, 머리가 살짝 고생하더라도 몸이 편해지는 것 같다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://cjlee38.github.io/tags/null/>null</a></li></ul><nav class=paginav><a class=prev href=http://cjlee38.github.io/backup-copy/language/java/2020-09-10-journey_to_java_hashmap/><span class=title>« Prev Page</span><br><span># (Java) HashMap 으로의 여행</span></a>
<a class=next href=http://cjlee38.github.io/backup-copy/diary/2020-09-09-why_data_engineer/><span class=title>Next Page »</span><br><span># 왜 나는 데이터 엔지니어를 바라보는가</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : LinkedList ( feat. C ) on twitter" href="https://twitter.com/intent/tweet/?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20LinkedList%20%28%20feat.%20C%20%29&url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fdata_structure%2f2020-09-10-what_is_linked_list%2f&hashtags=null"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : LinkedList ( feat. C ) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fdata_structure%2f2020-09-10-what_is_linked_list%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20LinkedList%20%28%20feat.%20C%20%29&summary=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20LinkedList%20%28%20feat.%20C%20%29&source=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fdata_structure%2f2020-09-10-what_is_linked_list%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : LinkedList ( feat. C ) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fdata_structure%2f2020-09-10-what_is_linked_list%2f&title=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20LinkedList%20%28%20feat.%20C%20%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : LinkedList ( feat. C ) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fdata_structure%2f2020-09-10-what_is_linked_list%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : LinkedList ( feat. C ) on whatsapp" href="https://api.whatsapp.com/send?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20LinkedList%20%28%20feat.%20C%20%29%20-%20http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fdata_structure%2f2020-09-10-what_is_linked_list%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share # 마음으로 이해하는 자료구조 : LinkedList ( feat. C ) on telegram" href="https://telegram.me/share/url?text=%23%20%eb%a7%88%ec%9d%8c%ec%9c%bc%eb%a1%9c%20%ec%9d%b4%ed%95%b4%ed%95%98%eb%8a%94%20%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%20%3a%20LinkedList%20%28%20feat.%20C%20%29&url=http%3a%2f%2fcjlee38.github.io%2fbackup-copy%2falgorithm%2fdata_structure%2f2020-09-10-what_is_linked_list%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://cjlee38.github.io/>cjlee38</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>