[{"content":" 주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 \u0026lsquo;정론\u0026rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !\n 약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었습니다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었습니다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠습니다.\n정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었죠. 그런데 잠깐, 여기서 도메인이란 무엇일까요 ?\n도메인에 대한 정의 도메인은 결국, \u0026ldquo;내가 문제를 해결하고자 하는 영역\u0026quot;으로 정의할 수 있습니다. 가령 쇼핑몰 사이트를 만든다고 하면, 쇼핑의 대상이 되는 상품과 이에 따른 주문/결제 시스템이 바로 도메인입니다. 이 과정에서 사용되는 jackson과 같은 라이브러리들은 나의 관심사가 아닙니다. 한편, jackson과 같은 소프트웨어를 만든다고 하면, 이러한 직렬화/역직렬화 과정을 처리하는 과정이 도메인입니다.\n 도메인에 도움을 주는 이런 부가 기술들을 저는 \u0026lsquo;코드 레벨\u0026rsquo;, 혹은 \u0026lsquo;코드 관점\u0026rsquo; 이라고 표현하는데, 정확한 용어가 있는지는 모르겠습니다. 아시는 분은 댓글 남겨주세요 :)\n 그렇다면 왜 도메인이 중요할까요 ? 우리가 소프트웨어로 문제를 해결하고자 하는 이유는, 만들어낸 소프트웨어가 가치를 창출해내기 때문입니다. 주어진 문제를 코드로 해결하기 위해선 여러 방법이 존재합니다. main 메소드에 수천라인의 코드를 박아넣을 수도 있고, 단 하나의 데이터베이스 쿼리로 해결할 수도 있죠. 단 한번만 만들어지고, 절대 변하지 않을 예정이라면 이렇게 해도 문제가 되지 않을것입니다. 문제가 되는 경우는, 나를 포함한 누군가가 이 코드를 수정해야할 일이 생겼을 때 발생하죠.\n그리고 이러한 코드를 특정한 곳에 모아두지 않으면, 새로운 요구사항을 반영하고, 버그를 수정할 때 여러 곳을 살펴봐야 합니다. 사람의 인지능력은 한계가 있기 때문에 수백개가 넘어가는 클래스와 수천, 수만 라인의 코드를 모두 파악하는 것은 어렵습니다. \u0026lsquo;관심사의 분리\u0026rsquo; 라는 개념이 바로 여기서 등장하는 것이죠.\n 이에 비해 단기 기억은 보관돼 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적인 측면 모두에서 제약을 받는다. 공간적인 제약은 조지 밀러(George Miller)의 매직넘버 7(7 ± 2 규칙)로 널리 알려져 있다. 조지 밀러의 이론에 따르면 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 5개에서 많아 봐야 9개 정도를 넘지 못한다고 한다.\n또한 허버트 사이먼(Herbert A. Simon)에 따르면 사람이 새로운 정보를 받아들이는 데 5초 정도의 시간이 소요된다고 한다. 컴퓨터 프로그램을 작성할 때는 시간과 공간의 트레이드오프를 통해 효율을 향상시킬 수 있지만 사람의 경우에는 트레이드오프의 여지가 전혀 없다. 사람의 단기 기억에 있어 시간과 공간의 두 측면 모두가 병목지점으로 작용하는 것이다.\n(출처 : 오브젝트, 조영호 저)\n 그리고 이러한 비즈니스 규칙을 모아놓는 곳, 소프트웨어의 본질과 정수를 담아둔 곳이 바로 도메인입니다. 그렇기에 우리는 도메인을 보호하고, 변경의 여지가 높은 외부 환경으로부터 격리하는 것을 두 번째 우선순위로 잡아야합니다. (당연히 첫 번째는, 올바르게 동작하는 것입니다.)\n 아, 물론 DDD를 다루진 않을겁니다. 저도 잘 모르거든요.\n 레이어드 아키텍처 도메인이 가장 중요하고, 우리가 보호해야할 대상이란 점은 알았습니다. 이번에는 practical 한 이야기를 해볼건데요. 바로 이 글의 타이틀에도 작성되어 있는 레이어드 아키텍쳐입니다. 레이어드 아키텍쳐는 Spring MVC 에서 주로(그리고 거의 대부분) 채택되는 아키텍쳐이기도 합니다. 우리에게는 @Controller, @Service, @Repository 과 같은 친숙한 어노테이션으로도 알려져있죠.\n 참고로 위 세 개의 어노테이션을 들어가보면 모두 DDD 에 어느정도 근간을 두고 있음을 알 수 있습니다.\n 구글에 layered architecture 를 검색해보면 여러 글이 나오지만, 결국 논하고자 하는 바는 \u0026ldquo;의존성은 한 쪽으로만 이루어져야 한다\u0026quot;는 것입니다. 가령 컨트롤러에서 레포지토리를 곧바로 의존한다고 하더라도 순수한 레이어드 아키텍쳐 관점에서는 문제가 되지 않습니다. 컨트롤러는 레포지토리보다 상위에 위치하니까요.\n 이제 각 세 개의 레이어가 중점적으로 다뤄야 할 관심사에 대해서 알아보겠습니다.\n 참고로 본 글에서는 presentation == controller, application == service 로 취급합니다.\n Controller 컨트롤러는 외부 API 요청을 받아내는 역할을 합니다. 개발자 입장에서는 외부 통신을 받아내는 가장 첫 번째 관문이기도 하죠.(물론 interceptor나 filter 도 있긴 합니다만, 여기선 신경쓰지 않겠습니다.) 컨트롤러 level 에서 주로 처리해야할 사항은 주로 \u0026lsquo;코드 관점\u0026rsquo;에 집중되어 있습니다. 내가 원하는 올바른 값이 들어 왔는지? 올바른 사용자가 요청을 보낸 것인지? 내가 원하는 양식(e.g. json)대로 값을 요청했는지? 등을 확인하고, 이에 걸맞게 코드의 객체로 역직렬화하는 과정이 주요 관심사입니다.\n때로는 컨트롤러의 코드가 너무 짧아서 아무것도 하는 일이 없어보이기도 합니다. 그저 서비스로의 메소드를 호출하고, return 받은 결과를 곧바로 상태코드와 함께 넘겨주는 작업밖에 하지 않으니까요. 하지만 \u0026lsquo;코드 관점\u0026rsquo;의 작업은 \u0026lsquo;라이브러리\u0026rsquo;, 혹은 \u0026lsquo;프레임워크\u0026rsquo;가 개입하기 아주 좋은 환경이기도 합니다. 모든 개발자가 json 오브젝트를 역직렬화하고, 모든 개발자가 내가 정의한 URI 에 요청이 들어오기를 바랍니다. 따라서 \u0026ldquo;하는 일이 없는 것 처럼 보이는 것\u0026rdquo; 일 뿐, 실제로는 여러 작업이 발생하고 있습니다.\n 이번 글을 계기로 DispatcherServlet 에게 고마움을 전합니다.\n Service 서비스는 도메인의 시작점 역할을 합니다. 서비스 상위에 위치하는 컨트롤러로부터 특정한 요청을 받고, 하위에 위치하는 도메인을 모아서, 내가 원하는 비즈니스를 처리합니다.\n이 글을 읽는 많은 분들이 객체지향의 5가지 원칙인 SOLID에 대해 알고 계실 것이라 생각합니다. 그리고 이러한 SOLID 원칙을 지키기 위한 방법 중 하나로 의존성 주입(Dependency Injection) 이 있죠. 의존성을 주입받는다는 것은, A 라는 클래스가 B 라는 클래스를 사용할 때, 어떠한 구현체가 들어오는지에 대해선 관심이 없고, 그저 (A 입장에서)\u0026lsquo;주어진 객체가 내가 원하는 것을 알아서 잘 수행해주기를 바라는 태도\u0026rsquo; 로 이해할 수 있습니다. 비슷한 주제로 \u0026lsquo;메소드를 호출하는 것이 아니라 메세지를 전달하는 것\u0026rsquo; 이라는 내용도 있는데, 여기서는 생략하겠습니다.\n아무튼 간에, 이렇듯 의존성을 주입받게 되면, 생성의 책임은 \u0026lsquo;나를 만드는 곳\u0026rsquo;으로 위임하게 됩니다. 아래 그림과 같이 의존성의 방향성이 있다고 가정해보겠습니다.\nclass A { \tB b;  \tpublic A(B b) { \tthis.b = b; \t} }  class B { \tC c;  \tpublic B(C c) { \tthis.c = c; \t} } 여기서 A 클래스는 B 클래스를, B 클래스는 C 클래스를 의존하고 있습니다. 위와 같은 구조가 주어졌을 때, A 클래스의 인스턴스를 생성하고, 사용하려면 아래와 같이 작성해야 합니다.\nA a = new A(new B(new C())); 그런데 곰곰히 생각해보면, 이렇게 생성하는 것이 괜찮을까요 ? 결국 이 A 객체를 사용하는 곳도 의존성을 주입받아야 하는 것은 아닐까요? 이를 바꿔 말하면, 이렇게 객체의 생성을 미루고 미루다 보면 최종적으로 도착하는 지점이 어딘가에서 주어져야 합니다. 이 지점을 바로 composition root 라고 부릅니다. 그리고 우리는 DI 컨테이너 라는 이름으로 Composition Root라는 개념을 구현합니다.\n 참고로, 의존성 주입에는 세 가지 방법이 있는데, 메소드 주입의 경우 composition root 관점으로 바라봤을 때 해결할 수 없기 때문에 논란의 여지가 있다고 말하는 듯 합니다.\n  따라서 의존성 주입에는 의존성을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.\n 생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결 setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결 메서드 주입(method injection): 메소드 실행시 인자를 이용한 의존성 해결 메소드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있다. 개인적으로는 외부에서 객체가 필요로 하는 의존성을 해결한다는 측면에서 의존성 주입의 한 종류로 간주한다.\n(출처 : 오브젝트, 조영호 저)   Controller 나 Service와 같은 객체들의 조립은 spring에서 처리해주지만, 우리가 만든 도메인은 조립해주지 않습니다.\n 모든 도메인 객체를 spring bean으로 등록할 수도 있지만, spring 이라는 프레임워크에 대한 의존성이 생깁니다. spring bean 으로 등록하는 것이 반드시 나쁜 것만은 아닙니다. 하지만 spring 프레임워크에 예기치 못한 버그가 발생한다면 어떨까요 ? 도메인이 보호해야 할 중요한 대상이라는 점을 감안하면, 일말의 가능성이라도 배제하는 것이 좋다는 입장이 있는 반면, 생산성을 위해 spring에게 맡기는 것도 하나의 방법이 될 수 있습니다. 결국은 마법의 단어, \u0026lsquo;트레이드오프\u0026rsquo; 죠.\n 그리고 제가 생각하는 \u0026lsquo;도메인 객체\u0026rsquo;의 composition root 가 바로 \u0026lsquo;서비스\u0026rsquo; 레이어 입니다.\nRepository repository 는 과연 어느 레이어에 속할까요 ? Repository 와 Dao의 차이점에 대해 조금이라도 찾아본 사람은 repository 를 도메인이라고 부릅니다. 왜 레포지토리는 도메인 레이어에 속할까요? 자꾸 DDD 이야기가 나와서 저도 조금 불편한데, 에릭 에반스의 도메인 주도 설계에서는 레포지토리를 다음과 같이 정의합니다.\n “repository is a mechanism for encapsulating storage, retrieval, and search behavior, which emulates a collection of objects.”\n레포지토리는 저장, 검색 및 검색 동작을 캡슐화하는 메커니즘으로, 객체 모음을 모방한다.\n 즉, 레포지토리는 \u0026ldquo;어디에 저장되어 있는지는 모르지만 아무튼 내가 원하는 객체가 저장된 곳\u0026rdquo; 으로 이야기할 수 있습니다. 말인 즉슨, 도메인 객체의 생명 주기를 관리한다는 것이죠. 이는 바꿔 말하면 레포지토리는 도메인 객체를 알고 있어야 함을, 즉 도메인을 의존해야 함을 의미합니다. (앞서, 레이어드 아키텍쳐가 의존성을 한 방향으로만 향하게 했다는 점을 감안하면, 그 하위 infrastructure layer에 속할 수 없겠죠.)\n하지만 여기서 한 가지 문제가 발생합니다. \u0026ldquo;어디에 저장되어 있는지는 모르겠는데\u0026rdquo;, 도대체 어디서부터 데이터를 가져올 수 있을까요 ? 우리는 소중하디 소중한 데이터베이스에 객체에 대한 정보가 저장되어 있음을 알고 있습니다. 그러면 레포지토리가 도메인에 대한 정보를 알고 있으면서 동시에 데이터베이스에 요청을 필요로 하는 모순이 발생합니다. 그리고 이 지점에서 객체지향의 특성이 한 가지 발휘됩니다. 바로 \u0026lsquo;다형성\u0026rsquo; 입니다.\n 그림 5.2에서 HL1 모듈은 ML1 모듈의 F() 함수를 호출한다. 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않는다. HL1은 단순히 ML1 모듈의 F()를 호출할 뿐이다.\n하지만 ML1 과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.\n(출처 : 클린 아키텍쳐, 로버트 C 마틴 저)\n 위 그림에서 HL1 객체를 서비스로, I 인터페이스를 레포지토리 인터페이스로, ML1 객체를 I 인터페이스를 상속하는, 실제 데이터베이스 요청을 진행하는 객체로 바라보면 이야기했던 모순을 해결할 수 있습니다. 실제 코드를 보더라도, 서비스 객체는 레포지토리 인터페이스를 import할 뿐, 구현체에 대한 정보는 그 어디에서도 찾아볼 수 없습니다.\n 이러한 점에서 객체지향은 절차지향과 차이점을 보입니다. 절차지향은 실행 제어 흐름에 따라 의존성의 방향이 일방적으로 향할 수 밖에 없습니다.  마무리 줄곧 항상 고민하고 생각해왔던 내용인데, 이번 기회를 통해 속시원하게 풀어낼 수 있어서 조금은 후련하네요.\n글 서두에도 적었던 내용인데, 개인적으로만 생각하고 정의내린 내용이라 틀린 내용도, 잘 모르는 내용도 많습니다. 지적과 훈수는 언제든 댓글 부탁드리겠습니다. 긴 글 읽어주셔서 감사합니다.\n이상으로 포스트를 마칩니다.\n","permalink":"http://cjlee38.github.io/post/tech/architecture/2022-10-19-domain-layered-architecture/","summary":"주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 \u0026lsquo;정론\u0026rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !\n 약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었습니다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었습니다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠습니다.","title":"# 개인적인, 도메인과 레이어드 아키텍처"},{"content":"1. 문자 인코딩이란 문자 인코딩이란 사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말합니다. 1 우리가 작성한 모든 텍스트는 결국 CPU 상에서 2진수로 처리됩니다. 사람이 작성한 글을 2진수로 변환하고, 2진수를 다시 사람이 읽을 수 있도록 만드는 작업을 각각 인코딩(encoding)과 디코딩(decoding)이라고 표현합니다.\n이러한 인코딩을 하기 위해서는 서로 약속한 \u0026lsquo;문자열 세트\u0026rsquo;가 필요합니다. 가장 대표적인 문자열 세트는 ASCII 입니다. ASCII는 1963년 미국 ANSI에서 표준화한 7 bit 부호 체계로 128 개의 기호(33개의 제어문자와 95개의 출력문자)를 표현할 수 있습니다. 1 bit 은 Parity bit으로 7개의 bit 중 1의 개수가 홀수면 1, 짝수면 0으로 값을 할당하여 전송 과정 중 오류를 탐지하는 용도로 사용합니다.\nExtended ASCII는 이러한 parity bit 를 없애고 zone bit 를 추가하여, 8개의 bit로 총 256 개의 문자를 사용할 수 있도록 하였습니다.\n2. 한글? ASCII 코드는 영문자와 아라비안 숫자를 자유롭게 표현할 수 있었지만, 한글을 비롯한 여러 국가들의 문자를 표기할 수는 없었습니다. 1 byte만으로 수많은 언어의 문자들을 표현하기에는 아무래도 무리겠죠.\n이를 개선하기 위해 마이크로소프트사에서 EUC-KR 와 이를 확장한 CP949 를 도입하였습니다. 두 문자열 세트는 \u0026lsquo;완성형\u0026rsquo; 이라고 하여, 2 byte 로 하나의 완성된 문자를 표현하는 방식입니다. 즉, 가, 힣과 같은 특정한 문자에 코드를 할당합니다. 이의 반대인 조합형은 한글의 제자 원리에 기반하여 초성, 중성, 종성에 각각 코드를 할당하는 방식입니다.\nEUC-KR 은 현대 한글에서 자주 사용하는 2350자 만을 지원하였습니다. 이는 반대로 말하면 자주 사용하지 않는 글자는 표현을 못한다는 의미가 됩니다. CP949 는 이를 개선하기 위해 EUC-KR을 확장하여 약 8000여 자를 추가하였다고 하지..만, 사실상 지금은 표준에 밀려 웬만하면 사용을 지양해야 하는 방식이 되어버렸습니다.\n3. 유니코드 : 이렇듯 한글을 포함하여 여러 국가가 제각기 원하는대로 문자를 표현하고자 하다보니 여러 문제가 발생했습니다. 네트워크가 발전함에 따라 다른 국가의 홈페이지를 접속했더니 알 수 없는 글자로 표시되는 것이었습니다. 이러한 문제를 해결하고자, 전 세계의 모든 문자를 표현할 수 있도록 유니코드 라는 표준을 제정하게 되었습니다.\n유니코드에서 값을 나타내기 위해서는 Code point 를 사용하고, U+ 를 붙여 표시합니다. 가령, A 의 유니코드 값은 U+0041 혹은 \\u0041 로 표현합니다. 유니코드는 평면 논리적 개념을 이용하여 구획을 나누며, 이 중 0번 평면이 기본 다국어 평면(BMP, Basic Multilingual Plain)으로 쓰입니다.\n4. UTF-8 유니코드로 세계의 모든 문자를 표시할 수 있게 되었는데, 이를 결국 \u0026ldquo;어떻게 저장할 것인가?\u0026rdquo; 에 대한 문제가 다시 대두되었습니다. 우리가 오늘날 대부분 사용하는 인코딩 방식인 UTF-8은 유니코드를 위한 가변 길이 문자 인코딩 방식 중 하나입니다.\nUTF-8 인코딩은 유니코드 한 문자를 나타내기 위해 1byte에서 최대 4byte를 사용합니다. 가령, a 는 1 byte를 사용하지만, 가 는 3byte를 사용합니다. 이를 조금 더 자세히 살펴보겠습니다.\n우선 UTF-8은 ASCII 와의 호환성을 위해 7 bit 이내의 코드값에는 맨 앞 비트를 0으로 붙입니다. 즉, a 를 나타내기 위해서 01000001 를 사용합니다.\n7 bit 초과, 11 bit 이내의 코드 값은 (128 ~ 2047)은 총 2 byte로 표현합니다. 즉, 110XXXXX 10XXXXXX 로 표현합니다. 첫 번째 byte의 110 은 순서대로 \u0026lsquo;이 문자가 1byte를 초과한다\u0026rsquo;, \u0026lsquo;이 뒤에 1개의 byte가 더 있다\u0026rsquo;, \u0026lsquo;여기까지가 범위를 나타낸 것이었고, 앞으로는 실제 값에 해당한다\u0026rsquo;를 의미합니다. 두 번째 byte의 10 은 \u0026lsquo;이 byte는 앞선 byte의 후속이다\u0026rsquo; 를 의미합니다.\n이렇게 각각의 맨 앞 비트에 몇 byte가 더 추가될것인지에 대한 정보를 공유하고, 남은 11 자리로 문자를 표현하는데 사용합니다.\n5. MySQL 에서 문자열 다루기 5.1. utf8mb3 ? utf8mb4 ? 여기까지 간단하게 컴퓨터에서 어떻게 문자열을 처리하는지에 대해 알아보았습니다. 그렇다면 본 주제인 MySQL 의 인코딩에 대해 알아보겠습니다.\nMySQL 5.X 를 기준으로 기본 인코딩은 utf8mb3 를 사용했습니다. 기존에 사용하던 utf8은 utf8mb3의 alias 입니다. MySQL 8.X 로 넘어와서는 utf8mb4를 사용하죠.(utf8mb3 는 deprecated 될 예정입니다.2) 그렇다면 이 두 인코딩 방식의 차이는 무엇일까요 ?\nMySQL 8.0 공식문서에서는 다음과 같이 설명합니다.\n utf8mb3 는 BMP 문자만 지원하고, 문자당 3 byte만을 할당한다는 점에서 utf8mb4와 대조됩니다.\n BMP 문자에 대해서, utf8mb4 와 utf8mb3 는 동일한 특성을 지닙니다 : 같은 코드 값, 인코딩, 길이를 가집니다. 추가 문자(supplementary character)의 경우, utf8mb4 는 저장을 위해 4 byte를 필요로 하지만, utf8mb3 는 해당 문자를 저장할 수 없습니다. utf8mb3 칼럼을 utf8mb4 로 바꿀 때, 당신은 추가 문자가 없기 때문에(애초에 저장된 적이 없으므로) 이에 대해 걱정할 필요가 없습니다.   5.2. MySQL 에서 문자열의 길이 세기 위 내용들을 통해, 우리는 MySQL 에서 왜 length() 와 char_length() 가 따로 존재하는지 알 수 있습니다. length() 함수는 문자열의 byte 길이를 구하는 반면, char_length() 는 글자의 길이를 구합니다.\nlength(\u0026#39;한글\u0026#39;) -- 6 length(\u0026#39;english\u0026#39;) -- 7  char_length(\u0026#39;한글\u0026#39;) -- 2 char_length(\u0026#39;english\u0026#39;) -- 7 5.3. MySQL의 varchar, 그리고 인덱스 MySQL에서 주로 사용하는 varchar 자료형은 첫 2 byte 에 문자열의 길이에 대한 정보를 저장합니다. (정확히는 길이가 255 이하인 경우 1 byte를, 초과인 경우 2 byte를 사용합니다.) 그리고, 앞서 MySQL 5.X 버전을 기준으로 default 로 사용되던 utf8mb3 는 최대 3 byte를 사용한다는 것을 확인하였습니다.\nMySQL 에서 문자열을 index로 사용할 경우, 최대 767(3 * 255 + 2) bytes를 사용할 수 있습니다. 이는 바꿔말하면 utf8mb3 를 기준으로, varchar(255) 자료형을 사용하면 모든 문자열을 인덱스에 담을 수 있다 가 됩니다. 하지만 8.X 버전에 들어서면서 utf8mb4 를 사용하게 될 경우에는 성립하지 않습니다.\n 좀 더 정확히는, InnoDB를 기준으로, Dynamic 혹은 Compressed row format 을 사용한다면 3072 byte를, REDUNDANT 혹은 COMPACT row format을 사용하면 767 bytes를 사용할 수 있습니다. 자세한 내용은 공식문서를 확인하세요.\n reference  한글 인코딩의 이해 1편: 한글 인코딩의 역사와 유니코드 What is the difference between utf8mb4 and utf8 charsets in MySQL? MySQL 8.0 Reference Manual, 10.9.1 The utf8mb4 Character Set (4-Byte UTF-8 Unicode Encoding)    위키피디아 : 문자 인코딩\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n MySQL 8.0 Reference Manual, 10.9.8 Converting Between 3-Byte and 4-Byte Unicode Character Sets\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"http://cjlee38.github.io/post/tech/btb/2022-10-03-encoding-with-mysql/","summary":"1. 문자 인코딩이란 문자 인코딩이란 사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말합니다. 1 우리가 작성한 모든 텍스트는 결국 CPU 상에서 2진수로 처리됩니다. 사람이 작성한 글을 2진수로 변환하고, 2진수를 다시 사람이 읽을 수 있도록 만드는 작업을 각각 인코딩(encoding)과 디코딩(decoding)이라고 표현합니다.\n이러한 인코딩을 하기 위해서는 서로 약속한 \u0026lsquo;문자열 세트\u0026rsquo;가 필요합니다. 가장 대표적인 문자열 세트는 ASCII 입니다. ASCII는 1963년 미국 ANSI에서 표준화한 7 bit 부호 체계로 128 개의 기호(33개의 제어문자와 95개의 출력문자)를 표현할 수 있습니다.","title":"# 문자 인코딩과 MySQL varchar"},{"content":"0. 서론 우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.\n 서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정 서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유 인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유  레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다.\n    Mean Min Max     요청 처리 시간 307.872 16.496 3234.609   쿼리 시간 236.812 1.437 3133.169   쿼리 개수 43.6 2 1002    평균 처리 시간이 짧은지 느린지는 확언할 수 없지만, 최대 처리 시간이 약 3초 남짓, 쿼리 개수가 1002개가 나가는 모습은 분명 문제가 있다고 이야기할 수 있습니다. 각각의 API 에서 요청이 어떻게 처리되는지 확인한 뒤, 하나씩 해결해본 경험을 말씀드리겠습니다.\n1. ID 기반 조회 저희 서비스에서 각 entity 는 서로 직접 참조를 맺고 있었습니다. 가령 Poll 이라는 entity 안에 Team 이라는 필드를 직접 가지고 있는 형태였죠. 그리고 repository 에서는 다음과 같은 메소드를 쓰고 있었습니다.\n// PollRepository#findAllByTeamId List\u0026lt;Poll\u0026gt; findAllByTeamId(Long teamId); 위 메소드는 얼핏 보면 아무런 문제가 없어보입니다. ID 값을 기반으로 조회해오겠다는 뜻이니까요. 하지만 실제로 나가는 쿼리는 다음과 같았습니다.\nselect \tpoll0_.id as id1_3_, \tpoll0_.created_at as created_2_3_, \tpoll0_.updated_at as updated_3_3_, \t... from \tpoll poll0_ left outer join \tteam team1_ \ton poll0_.team_id=team1_.id where \tteam1_.id=? 분명 poll 이라는 테이블안에는 team_id 라는 외래키가 존재함에도 불구하고 left outer join 이 불필요하게 나가는 모습을 확인할 수 있습니다. 종종 JPQL과 SQL을 헷갈리고 이런 식으로 작성하는 경우가 많은데요. poll 이라는 entity가 갖고있는 객체는 team_id가 아닌 team이고, 따라서 team이 갖고 있는 다시 갖고 있는 id 를 기반으로 조회하고자 위와 같은 쿼리가 나가게 되는 것입니다.\n개선 방법은 간단하게, entity를 기반으로 조회하도록 변경하는 것입니다.\nselect \tpoll0_.id as id1_3_, \tpoll0_.created_at as created_2_3_, \tpoll0_.updated_at as updated_3_3_, \t... from \tpoll poll0_ where \tpoll0_.team_id=? 따라서 불필요한 join 쿼리 없이 곧바로 where 절로 접근할 수 있게 되었습니다.\n2. 단건 처리 (1) 사용하던 메소드 시그니쳐는 아래와 같습니다.\nAvailableTimeRepository#deleteAllByAppointment void deleteAllByAppointment(Appointment appointment) 이에 대응하는 쿼리는 delete from appointment_available_time where appointment_id = ? 으로, 즉 appointment를 where 절에 걸어서 delete 쿼리가 나가길 기대했지만, 실제 실행 결과는 아래와 같았습니다.\n위와 같이 appointment_id 가 아닌 id 를 기반으로 available_time을 삭제하고 있었습니다. 그 이유는 구현체인 SimpleJpaRepository 를 보면 유추할 수 있습니다.\ndeleteAll 메소드 자체는 단순히 entity의 목록을 반복하면서 삭제하기를 반복하고만 있었습니다. 이를 해결하기 위해서 직접 JPQL을 작성해주었습니다.\n@Modifying @Query(\u0026#34;DELETE FROM AvailableTime at WHERE at.appointment = :appointment\u0026#34;) void deleteAllByAppointment(@Param(\u0026#34;appointment\u0026#34;) Appointment appointment); 직접 작성한 JPQL 의 결과로 날아가는 쿼리는 아래와 같습니다.\ndelete from \tappointment_available_time where \tappointment_id=?  deleteAll 메소드 바로 밑에 deleteAllInbatch 라는 메소드가 있지만, deleteAllInBatchByAppointment와 같이 활용할 수 없는 것으로 파악했습니다. 공식 문서에서도 @Query 를 이용해서 처리하고 있다는 것을 확인할 수 있었습니다. 혹시 InBatch clause 를 이용할 수 있는 방법이 있다면 댓글 부탁드립니다.\n 3. 단건 처리 (2) 여러 이유로 영속성 컨텍스트에 엔티티를 담을수 없어, 직접 update 메소드를 repository 를 통해 직접 처리하고 있는 경우가 있었습니다. 대략 다음과 같이 구성되어 있었습니다.\n// PollRepository#closedById 시그니쳐 @Query(\u0026#34;update Appointment a set a.status = \u0026#39;CLOSED\u0026#39; where a.id = :id\u0026#34;) void closeById(@Param(\u0026#34;id\u0026#34;) Long id);  // 사용할 때 for (Poll poll: polls) { \tpollRepository.closed(poll.getId())) } 앞서 2번과 비슷하게도, 이 부분 또한 반복문을 통해 처리되기 때문에 단건으로 처리됩니다. 어차피 업데이트할 엔티티는 이미 정해져있기 떄문에 굳이 번거롭게 매번 쿼리를 날려 불필요한 딜레이 시간을 가질 필요가 없습니다. 따라서 다음과 같이 수정하였습니다.\n@Modifying @Query(\u0026#34;update Appointment a set a.status = \u0026#39;CLOSED\u0026#39; where a in :appointments\u0026#34;) void closeAll(@Param(\u0026#34;appointments\u0026#34;) Iterable\u0026lt;Appointment\u0026gt; appointments); JPQL 에서는 위와 같이 in 절도 처리할 수 있습니다.1\n4. N+1 문제 N+1 문제는 JPA를 사용하면서 가장 흔하게 발생하고 또 신경써줘야 하는 문제입니다. 모든 N+1 문제를 해결하면서 동시에 ORM의 장점을 취하는 silver bullet은 존재하지 않고, 본인이 사용하는 로직이 N+1 문제가 어떻게 발생하느냐에 따라 적절한 해결책을 선택해야 합니다. N+1 문제를 해결하기 위한 근본적인 해결책은 entity 간의 직접적인 참조를 하지 않는 것이지만, ORM 이라는 기술이 제공해주는 다양한 장점을 불가피하게 버릴 수밖에 없습니다.\n모락의 도메인에서 Team 은 여러 Member 를 가질 수 있고, Member 또한 여러 Team 을 가질 수 있습니다. 이러한 다대다 관계를 풀어내기 위해 TeamMember라는 중간 엔티티(테이블)를 두었습니다. 그리고, Member가 속해있는 Team의 목록을 조회하기 위해서는 아래와 같은 로직을 사용했습니다.\n// TeamMemberRepository#findAllByMember List\u0026lt;TeamMember\u0026gt; findAllByMember(Member member);  // 사용할 때 List\u0026lt;TeamMember\u0026gt; teamMembers = teamMemberRepository.findAllByMember(member); List\u0026lt;Team\u0026gt; teams = teamMembers.stream() \t.map(teamMember -\u0026gt; teamMember.getTeam()) \t.collect(Collectors.toList()); TeamMember를 조회하는 것 까지는 좋았으나, 여러 TeamMember에 대해서 각각의 team을 구해온다면 N+1 문제가 발생합니다. 가령, 1명의 멤버가 10개의 팀에 속해있다고 가정해봅시다. 그렇다면 전체 쿼리는 다음과 같이 구성됩니다.\n Member 조회 (1번) select * from member where id = ? Member가 속해 있는 TeamMember 목록을 조회 (1번) select * from team_member where member_id = ? TeamMember 목록에서 각각의 Team을 조회 select * from team where id = ? * 10  따라서 총 12 번의 쿼리가 날아갑니다. 만약 소속된 Team이 1000개 였다면 총 1002번의 쿼리가 날아갔겠죠. 다행히 아직까지는 저희 도메인 정책상 페이지네이션과 같은 로직은 존재하지 않기 때문에, fetch join을 이용하여 비교적 간단하게 해결할 수 있었습니다.\n@Query(\u0026#34;SELECT tm FROM TeamMember tm JOIN FETCH tm.team WHERE tm.member = :member\u0026#34;) List\u0026lt;TeamMember\u0026gt; findAllByMember(@Param(\u0026#34;member\u0026#34;) Member member); 위와 같은 JPQL 을 작성한다면 teamMember entity를 조회하는 과정에서 team entity를 join해서 가져오게 됩니다. 따라서 1000 개의 team이 있다 하더라도 쿼리 개수 자체는 3번에서 끝나게 됩니다.\n @EntityGraph 를 사용해도 N+1 문제는 해결할 수 있지만, 이에 대한 쿼리를 살펴보면 left outer join 을 사용합니다.  하지만 직접 fetch join을 사용하게 되면 inner join 을 사용합니다.   5. 최종 결과 개선 과정을 거친 뒤, 최종 성능 측정 결과 표는 아래와 같습니다.\n    Mean Min Max     요청 처리 시간 37.478 9.44 219.352   쿼리 시간 1.698 0.307 7.87   쿼리 개수 5.6 2 13    평균을 기준으로, 각각 약 8, 140, 7 배 가량 개선하였습니다.\n  DBA와 개발자가 모두 행복해지는 Hibernate의 in_clause_parameter_padding 옵션\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"http://cjlee38.github.io/post/tech/jpa/2022-09-25-query-enhancement/","summary":"0. 서론 우아한테크코스의 레벨4, 5차 데모에서 주어진 요구사항 중 하나는 아래와 같습니다.\n 서비스에서 사용하는 쿼리를 정리하고, 각 쿼리에서 사용하는 인덱스 설정 서비스에서 사용하는 모든 조회 쿼리와 테이블에 설정한 인덱스 공유 인덱스를 설정할 수 없는 쿼리가 있는 경우, 인덱스를 설정할 수 없는 이유 공유  레벨 3 기간 동안 쿼리가 어떻게 나가는지에 대해서 전혀 신경을 쓰지 않았었습니다. 20 만 건의 더미 데이터를 넣어놓고 쿼리 개수와 시간을 측정해보았을 때의 결과는 처참했죠. 아래는 저희가 측정한 API 성능표입니다.","title":"# 모락 쿼리 성능 개선기"},{"content":"0. 서론 팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.\n코드는 대략 다음과 같이 구성되어 있었습니다.\n@Service @Transactional public class PollService {  \t@Scheduled(cron = \u0026#34;0 0/1 * * * ?\u0026#34;) \tvoid notifyClosedByScheduled() { \tList\u0026lt;Poll\u0026gt; pollsToBeClosed = pollRepository.findAllToBeClosed(LocalDateTime.now()); \tfor (Poll poll : pollsToBeClosed) { \tpoll.close(poll.getHost()); \tnotificationService.notifyMenuStatus( \tpoll.getTeam(), MessageFormatter.formatClosed(FormattableData.from(poll)) \t); \t} \t} } 대략 위와 같이 서비스가 구성되어 있었고, poll entity 내부에서는 member(host) 객체를 lazy loading 하고 있는 상황이었습니다. 이번 포스팅에서는 위와 같은 상황에서 겪었던 Transactional이 동작하지 않는 문제와, 이를 해결하면서 알게된 (기초적인) 사실들을 이야기해보고자 합니다.\n1. 발단  could not initialize proxy - no session\n 가장 첫 번째로 당면한 문제는 프록시 초기화 문제였습니다. 위와 같은 상황에서, poll 객체의 상태를 close하기 위해서 주어진 member가 host인지 확인합니다. host를 직접 꺼내다 다시 넣어주었으니, 로직상 문제는 없었죠. 하지만 같은 객체인지 비교하기 위해 equals 메소드가 호출되는 순간, 위와 같은 문제가 발생했습니다.\n가장 첫 번째로 의심한 부분은 Transaction 여부였습니다. JPA의 객체는 기본적으로 Transaction 하위에 있는 영속성 컨텍스트 내부에서 활동하고, 영속성 컨텍스트가 끊어지면, 즉 Transaction이 끊어지면 위와 같은 문제가 발생하기 때문입니다.\n테스트 코드에서는 잘 동작하던 코드였기에, 어느 부분이 문제인지 확인이 되지 않았습니다. 따라서 application.yml 에 다음과 같은 설정을 추가하고 스케줄링 동작시 로그를 확인해보았습니다.\nlogging:  level:  org:  springframework:  transaction.interceptor: TRACE 위 설정은 트랜잭션이 언제 동작하는지 확인할 수 있는 설정입니다.(참고)\n[2022-08-22 21:50:19:3733][scheduled-task-pool-1] TRACE o.s.t.i.TransactionInterceptor - No need to create transaction for [org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAllToBeClosed]: This method is not transactional. Hibernate: {쿼리문} 제가 class level에 분명히 @Transactional 어노테이션을 붙였음에도 불구하고, 메소드를 호출할 때에는 Transaction 을 생성하는 로그가 찍히지 않았습니다. 대신, 위와 같이 조회 쿼리일때에는 \u0026ldquo;트랜잭션이 필요없다\u0026rdquo; 라는 로그만 뱉어주고 있었죠. 게다가 더욱 아이러니한 점은, save 메소드를 호출할 때에는 트랜잭션을 잠깐 얻고, 쿼리를 날린 후 곧바로 종료시켜버리고 있었습니다.\n2. 의문 하나. 문제를 해결하기에 앞서, 가장 먼저 의문이 들었던 부분은 ?왜 save를 할 때는 transaction이 동작하고, findAllTobeClosed 와 같은 조회 쿼리는 동작하지 않았을까?\u0026quot; 였습니다.\n그 원인은, JPA가 조회하는 로직일때는 transaction이 필요하지 않기 때문입니다. 다음은 한 스택오버플로우 글에서 인용한 JTA spec의 일부입니다.\n The persist, merge, remove, and refresh methods must be invoked within a transaction context when an entity manager with a transaction-scoped persistence context is used. If there is no transaction context, the javax.persistence.TransactionRequiredException is thrown.\n  The find method (provided it is invoked without a lock or invoked with LockModeType.NONE) and the getReference method are not required to be invoked within a transaction context. If an entity manager with transaction-scoped persistence context is in use, the resulting entities will be detached; if an entity manager with an extended persistence context is used, they will be managed. See section 3.3 for entity manager use outside a transaction.\n 즉, 조회로직은 transaction context 내에서 일어날 필요가 없다는 뜻입니다. 그렇다면 save는 어떨까요? 이는 SimpleJpaRepository를 살펴보면 알 수 있습니다.\nSimpleJpaRepository는 Repository 인터페이스의 최상위 구현체이자, CrudRepository의 default 구현체입니다. 우리가 Repository 혹은 JpaRepository를 상속한 인터페이스를 만들면, JpaRepositoryFactoryBean가 SimpleJpaRepository 를 상속하여 만든 프록시 객체로 우리가 만든 인터페이스의 구현체를 생성합니다.\n그리고 이 SimpleJpaRepository 에는 save 메소드가 기본으로 구현되어있으며, 여기에는 @Transactional 어노테이션이 붙어있습니다.\n3. 의문 둘. 두 번째로 들었던 의문은 \u0026ldquo;왜 service method 레벨에서 transaction이 걸리지 않았을까 ?\u0026rdquo; 입니다. 처음에 구글링을 통해 얻었던 정보는 \u0026ldquo;스케줄러와 서비스를 분리해라\u0026rdquo; 였습니다. 말인즉슨, @Scheduled 가 먼저 처리되고 나서 @Transactional 이 처리되기 때문에, 등록된 @Scheduled 는 @Transactional 과 상관이 없다는 것입니다.\n또 다른 정보로는, PlatformTransactionManager 의 default 구현체가 DataSourceTransactionManager 인 경우, JPA 스펙 구현체인 Hibernate의 AbstractTransactionImpl 안에 있는 begin 메소드를 호출하지 않는다는 것이고, 따라서 커스텀하게 TransactionManager를 설정해주어야 한다는 정보였습니다.\n하지만 결론부터 말씀드리자면 제 경우에는 둘 다 해당하지 않았습니다. @Scheduled 와 @Transactional 어노테이션이 처리되는 순서에 대해서 살펴보았을 때에도 문제가 없었고, 제가 사용하고 있던 트랜잭션 매니저는 JpaTransactionManager 였습니다.\n 제가 현재 사용하고 있는 스프링부트 버전은 2.6.6 이고, hibernate 버전은 5.6.7 입니다.\n 눈치채셨을지도 모르겠지만 해결법은 의외로 기초적이고 간단한 내용이었는데, 바로 서비스 메소드의 접근제어자를 public으로 선언하는 것이었습니다. 외부 패키지(e.g. controller) 에서 사용할 수 없도록 접근제어자를 package-private으로 두었는데, 이것이 화근이었습니다.\n이는 공식문서에서도 잘 나와있는 내용이었습니다.\n When you use transactional proxies with Spring’s standard configuration, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private, or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings.\n 그렇다면 또 다시 드는 의문은 왜 꼭 \u0026ldquo;public이어야 하는가?\u0026rdquo; 입니다. 이 또한 Spring Core 공식문서 중 AOP 내용을 뒤져보면 간략하게나마 알 수 있습니다.\n Due to the proxy-based nature of Spring’s AOP framework, calls within the target object are, by definition, not intercepted. For JDK proxies, only public interface method calls on the proxy can be intercepted. With CGLIB, public and protected method calls on the proxy are intercepted (and even package-visible methods, if necessary). However, common interactions through proxies should always be designed through public signatures.\n 즉, JDK 프록시는 public 메소드만 intercept 할 수 있고, CGLIB은 package-private 까지 가져올수 있지만, 일반적으로 public 시그니쳐를 통해 동작하도록 되어있다는 내용입니다.\n참고로, 이와 같은 사실을 통해, 다음과 같은 설정으로 @Transactional이 protected나 package-private 에서도 동작하게 만들 수는 있습니다. 자세한 내용은 이곳을 참고하세요\n/** * Register a custom AnnotationTransactionAttributeSource with the * publicMethodsOnly flag set to false to enable support for * protected and package-private @Transactional methods in * class-based proxies. * * @see ProxyTransactionManagementConfiguration#transactionAttributeSource() */ // @EnableTransactionManagement 이 등록되어 있어야 합니다. @Bean TransactionAttributeSource transactionAttributeSource() {  return new AnnotationTransactionAttributeSource(false); } 4. 부록. 스케줄링이 어떻게 동작하는지 한번 코드로 살펴보았습니다.\n스프링에는 의존관계를 주입하며 bean을 생성하는 AutowireCapableBeanFactory가 있습니다. 아래 위 코드는 해당 인터페이스의 추상 클래스인 AbstractAutowireCapableBeanFactory 중 일부입니다 (line 450)\n위 코드에서 알 수 있다시피, bean을 등록하고 난 뒤, post-processor에 의해 후처리 작업을 진행합니다. 후처리 작업은 post-processor에 의해 처리된 결과가 null이 아니라면 계속해서 바꿔치기를 진행합니다.\n여기서 getBeanPostProcessor()를 확인해보면, 15개의 post-processor가 등록되어있는 것을 확인할 수 있습니다. 이 중, 5번째에 해당하는 AnnotationAwareAspectJAutoProxyCreator 가 @Transactional 어노테이션을 처리하는 녀석입니다. 그리고, 14번째에 있는 ScheduledAnnotationBeanPostProcessor 가 바로 @Scheduled 어노테이션을 처리하는 녀석이구요.\n그리고 Transactional을 위해 AnnotationAwareAspectJAutoProxyCreator 에 의해, 처리 되기 전(result)에는 일반 객체였지만, 처리된 녀석(current)이 프록시 객체임을 확인할 수 있습니다.\n그렇다면 스케줄링은 어떻게 등록되고, 실행될까요 ? ScheduledAnnotationBeanPostProcessor 로 이동해보겠습니다.\n앞서 보았던 postProcessAfterInitialization() 메소드 내부를 살펴보면,\n아래와 같이 @Scheduled 어노테이션이 붙어있는 메소드들에 대해서, processScheduled() 메소드 를 호출하고 있음을 확인할 수 있습니다. 해당 메소드로 다시 넘어가보겠습니다.\n위 코드는 fixedDelay, cron 등 @Scheduled 어노테이션에 달았던 여러 설정값을 처리하고, 이를 task로 만드는 작업을 진행합니다. (코드가 너무 길어, cron 부분만 떼왔습니다.) 그리고 나서, registrar 에 CronTask를 등록합니다.\n당장은 빨간 박스로 친 부분만 실행된다는 점에 유의해서 살펴보시면 됩니다. 새로 등록된 Task이므로, CronTask 리스트에 등록하면서, 동시에 unresolvedTask에 등록합니다.\n여기까지 진행한 다음, 빈 초기화가 모두 끝난 이후를 확인해보겠습니다. 애플리케이션이 실행되고나면, SimpleApplicationEventMultiCaster 의 multicast 를 호출해 ApplicationListener 에게 invoke 할 것을 명령합니다.\n이 Listener 중 하나가 방금 보았던 ScheduledAnnotationBeanPostProcessor 입니다. 그리고 invoke()는 onApplicationEvent()를, onApplicationEvent()는 finishRegistration()을 순차적으로 호출합니다. 이 때, 우리가 등록한 SchedulingConfigurer Configuration이 있다면 이를 등록합니다.\n즉, 위의 List\u0026lt;SchedulingConfigurer\u0026gt; configures 에 아래 코드와 같이 우리가 정의한 configuration이 들어갑니다.\n그리고 finishRegistration()은 최종적으로 this.registrar.afterPropertiesSet(); 을, 그리고 이는 registrar 내부의 scheduleTasks()를 호출합니다.\n그러면 앞서 익숙한 메소드명이 보입니다. 바로 scheduleCronTask() 입니다.\ntaskScheduler가 null이 아니기때문에(앞서 커스텀 정의한 configuration에서 ThreadPoolTaskScheduler을 넣어줬으니까요.), future에 ScheduledFuture 를 넣어줍니다.\n넣어준 ScheduledFuture 의 구현체는 ReschedulingRunnable로, 자기 자신이 실행해야할 시각을 설정합니다. 그리고 java에 의해 설정된 시각에 동작합니다.\n자, 이제 마무리입니다. java에 의해 run 메소드가 호출되면, 해야 할 일을 수행하고, triggerContext에 의해 다음 실행 시각을 다시 계산한뒤 schedule 을 다시 호출합니다.\n5. 마무리. 사실 처음 작성했던 코드가 의도한대로 동작하지 않았던 문제의 해결방법은 그리 어렵지 않았습니다. 단순히 public 접근제어자를 붙이기만 해주면 되니까요. 하지만 그 이면에서 왜 이런 문제가 발생했는지, @Scheduled가 어떻게 동작하는지 등의 궁금증을 해결할 수 있는 계기가 되었습니다.\n트러블슈팅과 관련해서 레퍼런스도 많이 발견하지 못했는데, 혹여라도 난항을 겪는 분들께 도움이 되었길 바라겠습니다. 감사합니다.\n","permalink":"http://cjlee38.github.io/post/tech/spring/2022-08-21-spring-scheudeld-with-transactional/","summary":"0. 서론 팀 프로젝트를 진행하면서, 특정 시간에 맞추어 Entity의 상태를 업데이트하고, 슬랙 메시지를 발송하는 기능을 개발하고 있었습니다. 제이슨이 추천해주신 여러가지 선택지 중에서, 러닝커브나 유지보수성을 감안하여 스프링의 스케줄링 기능을 활용하기로 결정했고, 약간의 학습 이후 본격적인 개발에 착수했습니다.\n코드는 대략 다음과 같이 구성되어 있었습니다.\n@Service @Transactional public class PollService {  \t@Scheduled(cron = \u0026#34;0 0/1 * * * ?\u0026#34;) \tvoid notifyClosedByScheduled() { \tList\u0026lt;Poll\u0026gt; pollsToBeClosed = pollRepository.findAllToBeClosed(LocalDateTime.now()); \tfor (Poll poll : pollsToBeClosed) { \tpoll.","title":"# 스프링 @Scheduled 와 @Transactional에 얽힌 이야기"},{"content":"스프링에서 환경을 분리하는 방법 : 발단은 우아한테크코스 레벨 2, \u0026lsquo;장바구니\u0026rsquo; 미션에서 시작됩니다. 장바구니 미션의 goal은 총 3가지 였는데요. 레거시 코드 다루기, 프론트엔드와 협업 경험, 그리고 AWS EC2를 통한 배포입니다.\n처음으로 배포를 진행하다보니 우여곡절도 많았고, 자동화할 수 있는 부분도 잘 몰라서 수동으로 하는 등의 여러 고생을 했었는데, 이번 미션에서도 같은 주제로 이야기가 나오고 해서, 환경을 분리하는 방법 에 대해서 공유해보고자 합니다.\n1. application.yml(혹은 properties) 분리 : 프로젝트를 local에서만 개발하는게 아니라면, 그리고 develop 이나 staging, production 을 구분해서 개발하게 된다면 필연적으로 서로 다른 설정값이 필요하게 됩니다.\nlocal 에서는 테스트 용도이므로 H2 의 in-memory DB 를 사용할 수 있지만, production 환경에서 반드시 안정적인 밴더사의 RDBMS와 인스턴스를 사용하게 됩니다.\nlocal에서 개발을 마치고, 이제 production 에서 코드를 가져와 실행하려면 당연히 datasource 를 바꿔주어야겠죠.\n# as-is (local) spring:  datasource:  url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE  username: sa  # to-be (production, or develop ...) spring:  datasource:  url: jdbc:h2:192.168.XXX.XXX:3306;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE  username: sa 그런데 이를 매번 바꿔주려니 여간 귀찮은 일이 아닙니다. 개인 노트북에서 작업을 끝낸 후, ssh 로 들어가거나, 어찌저찌 자동화해서 정상적으로 github에서 코드를 clone 해왔더라도, 위 설정파일을 수작업으로 매 번 고쳐주어야 하니까요.\n1.1 Profile 이를 위해 스프링에서는 profile 이라는 개념이 존재합니다. 스프링에서는 다음과 같이 설명합니다.\n Spring Profiles provide a way to segregate parts of your application configuration and make it only available in certain environments.\n 즉, 어플리케이션의 설정의 일부를 분리해서, 특정 환경에서만 사용할 수 있는 기능을 제공합니다. 다음은 사용법입니다.\nspring:  profiles:  active: local  ---  spring:  config:  activate:  on-profile: prd  datasource:  driver-class-name: com.mysql.cj.jdbc.Driver  url: jdbc:mysql://${DATABASE_HOST}:3306/${DATABASE_NAME}?serverTimezone=Asia/Seoul\u0026amp;character_set_server=utf8mb4  username: ${USERNAME}  password: ${PASSWORD} ---  spring:  config:  activate:  on-profile: local  datasource:  url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE  username: ${USERNAME}  h2:  console:  enabled: true  jpa:  show-sql: true  hibernate:  ddl-auto: validate  properties:  hibernate:  format_sql: true 가장 먼저 살펴볼 부분은, 파일이 --- 으로 구분되었다는 점입니다. 이 세 개의 dash를 기준으로 각 설정파일이 분리됨을 의미하며, properties 에서는 Springboot 2.4.0 부터 #--- 기호로 구분할 수 있습니다.\n Note. 파일을 직접 분리해서 여러 개로 관리할 수도 있습니다. 이 때는 application-${env}.yml 혹은 application-${env}.properties 의 형태로 관리하며, env 가 밑에서 설명할 각각의 profile이 됩니다.\n spring:  profiles:  active: local 다음으로는 가장 맨 위의 section 에 있는, active 입니다. 이는 현재 내가 실행하고자 하는 profile 을 나타내며, 쉼표로 구분해 여러 개의 profile을 가져올 수도 있습니다. 즉, 여기서는 local 을 사용하겠다는 의미입니다.\n두 번째는 잠시 넘어가고 세 번째 section을 살펴보겠습니다.\nspring:  config:  activate:  on-profile: local  datasource:  url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE  username: ${USERNAME}  h2:  console:  enabled: true  jpa:  show-sql: true  hibernate:  ddl-auto: validate  properties:  hibernate:  format_sql: true 밑에서부터 잠깐 보면, datasource는 memory-db 로 설정되어 있고, h2-console 도 실행하고, sql도 모두 출력하는 등, production 환경에서 사용하지 않을 옵션들을 지정하였습니다.\n그리고 가장 위쪽을 보면 on-profile 에 local 로 지정되어 있습니다. 즉, profile이 local로 설정된 경우에 이 section, 즉 세 번째 section을 설정하겠다는 의미입니다. 따라서 위 active 키에서 local로 지정하였으므로 해당 section을 설정하게 됩니다. 반대로 production 환경은 실제 운영 환경에서 사용할 옵션들을 지정합니다. 실제 데이터베이스 URL을 통해, 아이디/패스워드를 사용해 로그인하겠다는 설정들이 담겨 있습니다.\nspring:  config:  activate:  on-profile: prd  datasource:  driver-class-name: com.mysql.cj.jdbc.Driver  url: jdbc:mysql://${DATABASE_HOST}:3306/${DATABASE_NAME}?serverTimezone=Asia/Seoul\u0026amp;character_set_server=utf8mb4  username: ${USERNAME}  password: ${PASSWORD} 그런데 보다보면 한 가지 이상하게 생긴 녀석이 있습니다. ${DATABASE_HOST} 와 같이 생긴 녀석인데, 이는 \u0026ldquo;내가 OS 환경변수로부터 이 정보를 가져오겠다\u0026rdquo; 라는 의미입니다.\n환경변수는 ~/.bash_profile 등으로도 관리할 수 있지만, 하나의 인스턴스에 여러 프로젝트를 띄울 수도 있으므로 여기서는 직접 관리하도록 합니다. 이러한 설정 방법은 아래 1.3절에서 알아봅니다.\n1.2 JVM property : Java의 jar 파일은 다음과 같은 형태로 실행할 수 있습니다.\njava -jar MY_PROJECT-0.0.1.jar 이 때, -D 를 이용해 JVM 의 System property를 설정할 수 있습니다.(-X, -XX 등 도 있지만 이는 다음에 알아봅시다.) 이 property는 스프링에게까지 전달되며, 스프링에 대한 옵션을 지정할 수 있습니다.\n일례로, 다음과 같이 실행하여 스프링의 기본 포트인 8080을 8181로 수정할 수 있습니다.\njava -jar -Dserver.port=8181 MY_PROJECT-0.0.1.jar 그렇다면, 이런식으로 위에서 보았던 profile도 설정해줄 수 있으리라고 짐작할 수 있습니다. 즉, 다음과 같이 실행합니다.\njava -jar -DSpring.profiles.active=prd MY_PROJECT-0.0.1.jar 스프링의 설정은 대부분 \u0026ldquo;구체적일수록\u0026rdquo; 우선권을 가집니다. application.yml 에 설정한 local보다, 실행할 때 지정해준 prd 가 더 구체적이기 때문에, 최종 active 는 prd 가 됩니다.\n이렇게 우리는 clone해온 코드에 한 줄도 고치지 않고 환경을 바꿔가며 실행할 수 있습니다.\n1.3 환경변수 어플리케이션을 배포하는 방법에는 여러가지가 있겠지만, 가장 간단한 방법은 쉘스크립트를 작성하는 것입니다. 위에서 작성한 명령어에 몇 줄을 추가하여 쉘 스크립트를 작성해보겠습니다.\nexport DATABASE_HOST=192.168.XXX.XXX export DATABASE_NAME=my_database export USERNAME=my_username export PASSWORD=mypassword  java -jar -DSpring.profiles.active=prd MY_PROJECT-0.0.1.jar 위와같이 작성한뒤, 스크립트를 실행하면 앞서 yml 파일에서 작성했던 ${DATABASE_HOST} 와 같은 부분이 작성한 192.168.XXX.XXX 로 변해서 실행되는 것을 확인할 수 있습니다.\nPlatform : 데이터베이스 스키마, 혹은 데이터 또한 상황에 따라 나눌 수 있습니다. 위 예시와 같이 production과 local 환경에 따라 기존 테이블을 drop할지 말지, 혹은 더미 데이터를 넣어둘지 말지 등을 결정할 수 있습니다. 혹은, A 밴더사의 RDBMS에서 제공하는 SQL 문법이 B 밴더사의 RDBMS 에서 동작하지 않을 수 있는 경우도 있구요.\n이러한 경우에 활용할 수 있는 것이 바로 platform 입니다.\n스프링은 구동시 classpath(여기서는 src/main/resources 혹은 src/test/resources)로부터 schema.sql, 혹은 data.sql 로부터 DDL을 읽어와 실행합니다.\n그리고 이 때, 위 application-${env}.yml 과 마찬가지로, schema-${platform}.sql 혹은 data-${platform}.sql 의 형태로 내가 지정한 platform 에 맞는 DDL을 읽어올 수 있습니다. 다음은 사용 예시입니다.\nspring:  sql:  init:  platform: local  mode: always 위처럼 platform을 local 이라고 설정해두면, schema-local.sql, data-local.sql 을 찾아 실행하게 됩니다.\n그 아래에 있는 mode에는 never, embedded, always의 세 가지 옵션이 있습니다. 각각의 이름에서 유추할 수 있듯이, DDL 스크립트로부터 초기화하지 않으려면 never를, embedded(in-memory)인 경우에만 초기화하려면 embedded, 항상 초기화하려면 always\t를 사용하면 됩니다.\n 단, 이 때 DDL 스크립트가 비어있으면 안됩니다. 아예 파일 자체가 존재하지 않는건 괜찮지만, DDL 스크립트가 비어있으면 스프링을 구동하는 도중 예외를 던집니다.\n 역시 profile과 마찬가지로 스프링 실행시 System property 로 설정할 수도 있습니다. (-Dspring.sql.init.platform=local) 또한, profile과 적절히 조합하여 특정 profile에 걸맞는 DDL 을 실행할 수도 있습니다.\n","permalink":"http://cjlee38.github.io/post/tech/spring/2022-08-13-spring-environment-seperation/","summary":"스프링에서 환경을 분리하는 방법 : 발단은 우아한테크코스 레벨 2, \u0026lsquo;장바구니\u0026rsquo; 미션에서 시작됩니다. 장바구니 미션의 goal은 총 3가지 였는데요. 레거시 코드 다루기, 프론트엔드와 협업 경험, 그리고 AWS EC2를 통한 배포입니다.\n처음으로 배포를 진행하다보니 우여곡절도 많았고, 자동화할 수 있는 부분도 잘 몰라서 수동으로 하는 등의 여러 고생을 했었는데, 이번 미션에서도 같은 주제로 이야기가 나오고 해서, 환경을 분리하는 방법 에 대해서 공유해보고자 합니다.\n1. application.yml(혹은 properties) 분리 : 프로젝트를 local에서만 개발하는게 아니라면, 그리고 develop 이나 staging, production 을 구분해서 개발하게 된다면 필연적으로 서로 다른 설정값이 필요하게 됩니다.","title":"# 스프링에서 환경을 분리하는 방법"},{"content":"깃 서브모듈 트러블슈팅 : 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby \u0026amp; ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 jekyll 대신, hugo 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다.\nhugo 블로그는 보통 submodule을 기반으로 제작됩니다. jekyll의 경우 깃허브 자체에서 지원해주는 정적 사이트 생성기이기 때문에, 따로 빌드를 하지 않아도 됐던 것으로 기억합니다. 하지만 hugo는 그렇지 않습니다. 따라서 hugo 자체에서 지원해주는 기능으로 정적 사이트를 빌드한 뒤, 빌드 결과물을 깃허브에 업로드해야 합니다. 대개 다음과 같은 구조를 가집니다.\n메인 모듈에서 테마를 include 해온 뒤, 블로그 글을 작성하고, static site를 생성한 뒤, 그 결과물을 github에 업로드하는 방식입니다. 제가 블로그를 생성한 상황에서는 위와 같이 메인, 그리고 public 이라는 빌드 결과물이 깃허브에 업로드된 상태였습니다. 앞으로 메인 모듈을 \u0026lsquo;메인\u0026rsquo;, public을 \u0026lsquo;서브\u0026rsquo; 로 축약해서 이야기하도록 하겠습니다.\n이전 생성 경험을 토대로 제작하는데에 큰 무리가 없었는데, 팀원들이 테스트를 시작하자 문제가 발생했습니다. 제가 혼자 사용할 때는 문제가 없었는데, 팀원들이 사용하려고 깃허브에서 clone 해오는 순간 문제가 발생한 것이죠. 프로젝트에서도 서브모듈을 활용하기로 결정되어 있었기 때문에, 해당 문제는 꼭 해결해야 한다는 생각이 들어, 이를 해결한 기록을 남겨보고자 합니다.\n발생한 문제는 총 두 가지였습니다. 하나씩 살펴보도록 하겠습니다.\n메인 git clone 시 submodule을 가져오지 않는다. : 메인을 clone 해오는 경우, 자연스럽게 submodule도 가져올 것이라고 예상할 수 있습니다. 하지만 예상과 달리 submodule은 가져오지 않고, 가져오려고 해도 제대로 동작하지 않았습니다. 서브모듈에 대한 개념이 부족했던 지라, \u0026lsquo;서브모듈에 대한 정보를 가져오지 않는걸까?\u0026rsquo; 라는 생각이 들어 서브모듈을 직접 추가해보았습니다.\ngit submodule add -b ${branch} https://github.com/${organization}/${sub_repository} public\n위 명령어는 서브모듈이 존재하는 repository 를 현재 깃 프로젝트에 추가하되, ${branch} 라는 이름의 브랜치를 가져오고, 그 이름을 public 으로 설정하겠다는 의미입니다. 따라서 public 이라는 디렉토리에 서브모듈로 등록됩니다. (public은 hugo에서 빌드 결과물을 생성해놓는 디렉토리입니다.) 그런데 위와 같은 명령어를 실행할 경우, 다음과 같은 메세지가 등장합니다.\n\u0026#39;public\u0026#39; already exists in the index 뭔가 이상합니다. public에 대한 정보를 이미 가져온 것일까요 ? 이는 반만 맞습니다. 정확히는, submodule이 존재한다는 것, 그리고 그 녀석의 이름이 public 이라는 것 까지는 알고 있습니다. 코드를 한 곳에서 관리하는 것이 효율적이기 때문에, submodule의 소스코드는 별도의 repository에서 관리하는 상태입니다. 따라서 서브가 이미 존재하니, 깃은 \u0026lsquo;인덱스에 이미 존재한다\u0026rsquo; 라고 대답합니다. git submodule status 를 입력하면 다음과 같습니다.\ngit submodule status  -d2d76400942ad9fe3616f60775053a32750d3bbb public -9af128a8a638d139771afc30a8f331a73ce810b1 themes/PaperMod submodule에 대한, 즉 \u0026lsquo;서브\u0026rsquo; 프로젝트에 대한 상세 정보는 가져오지 못한 상태입니다. 이는 프로젝트의 .git 디렉토리를 확인해보면 알 수 있습니다. 프로젝트를 생성한 제 로컬에서는 .git/modules 디렉토리를 가보면 public, 그리고 테마와 관련된 /themes/${theme} 이 있는 것을 확인할 수 있습니다. 하지만 clone 해온 팀원의 프로젝트에서는 위 modules 디렉토리 자체가 없거나, 있더라도 그 내부가 비어있음을 확인할 수 있습니다.\n아무튼 이 정보를 알려주기 위해선 .gitmodules 라는 특수한 파일이 필요합니다. 해당 파일을 생성한 뒤, 다음과 같은 내용을 추가해주었습니다.\n[submodule \u0026#34;public\u0026#34;] \tpath = public \turl = https://github.com/${organization}/${sub_repository} \tbranch = ${branch} [submodule \u0026#34;themes/${theme}\u0026#34;] \tpath = themes/${theme} \turl = https://github.com/${organization}/${theme_repository} \tbranch = ${branch} 그리고, 다음의 두 명령어를 통해 submodule의 상세정보를 등록하고, 가져옵니다.\ngit submodule init git submodule update 이렇게 하면, 이제 public 디렉토리에 서브모듈에 대한 소스코드까지 포함되어 있는 것을 확인할 수 있습니다. 만약 .gitmodules 라는 파일이 remote(깃허브)에도 작성되어 있다면, 다음부터는 clone 해올 때 --recursive 혹은 --resurse-submodules 라는 옵션을 줘서 init 과 update 를 한번에 진행할 수 있습니다.\ngit clone ${main_repo} --recursive # 혹은 git clone ${main_repo} --recurse-submodules 메인 git clone 시 ref 에러가 발생한다. : 정확한 에러 문구는 다음과 같습니다.\nfatal: remote error: upload-pack: not our ref ${commit-id}\n대충 다음과 같이 생겼습니다.\n이 또한 submodule 의 특수성으로 인해 발생하는 문제입니다. 결론부터 말씀드리자면, \u0026lsquo;메인\u0026rsquo; 프로젝트에서 갖고 있는 submodule 의 정보는 \u0026lsquo;서브\u0026rsquo; 프로젝트(레포지토리) 자체가 아닌, \u0026lsquo;서브\u0026rsquo; 프로젝트의 \u0026lsquo;특정 commit-id\u0026rsquo; 를 갖고 있습니다.\n위에서 hugo 특성상 submodule을 활용한다고 말씀드렸습니다. 따라서 보통 아래와 같은 shell script를 활용합니다.\n# 정적 사이트 생성 hugo -t PaperMod  # \u0026#39;서브\u0026#39; 프로젝트 commit \u0026amp; push cd public git add . git commit -m ${commit-message} git push ${origin} ${branch}  # \u0026#39;메인\u0026#39; 프로젝트 commit \u0026amp; push cd .. git add . git commit -m ${commit-message} git push ${origin} ${branch} 그림, 예시와 함께 문제 상황이 발생한 이유를 설명해보겠습니다. (아래 예시에서의 push는 말 그대로의 push를, deploy는 위 스크립트를 실행하는 것이라고 생각해주시면 되겠습니다. )\n 팀원 \u0026lsquo;갑\u0026rsquo;이 로컬에서 \u0026lsquo;메인\u0026rsquo; repository에 \u0026lsquo;서브\u0026rsquo; repository를 submodule로 추가하고, \u0026lsquo;부모\u0026rsquo;의 repository에 deploy 했습니다. 그 순간, \u0026lsquo;메인\u0026rsquo; repository에서는 \u0026lsquo;서브\u0026rsquo; repository의 특정 commit-id(SA(sub-A)라고 하겠습니다)를 가져갑니다. (이 때 중요한 것은, \u0026lsquo;부모\u0026rsquo;의 repository에 push 할 때, \u0026lsquo;서브\u0026rsquo; repository는 push되지 않는다는 것입니다. \u0026lsquo;서브\u0026rsquo; repository는 별도로 push 과정을 거쳐야 하기 때문에 push가 아닌 deploy를 사용합니다.) 다음으로, 팀원 \u0026lsquo;을\u0026rsquo;이 부모 repository를 clone 해옵니다. 이 때, \u0026lsquo;서브\u0026rsquo; repository 또한 --recursive 옵션을 통해 가져왔습니다. 해당 옵션을 통해 가져왔기 때문에, \u0026lsquo;서브\u0026rsquo; repository의 SA 커밋을 가져와서, HEAD로 가리킵니다. 3-1. 그런데 현재 \u0026lsquo;을\u0026rsquo;의 local에 있는 \u0026lsquo;서브\u0026rsquo;가 가리키고 있는 HEAD는 특정 브랜치가 아닙니다. 임시로 생성된 \u0026lsquo;커밋 브랜치\u0026rsquo;의 SA 커밋입니다.(커밋 브랜치는 임의로 붙인 이름입니다. 정확한 이름은 모르겠습니다.) 여기까지는 문제가 없습니다.  4. 이 상태에서, \u0026lsquo;을\u0026rsquo;이 \u0026lsquo;서브\u0026rsquo;에 새로운 파일을 추가하고, commit 합니다.(해당 commit-id 를 SB라고 하겠습니다.)\n4-1. 그런데 이 SB commit-id 는 \u0026lsquo;서브\u0026rsquo;의 특정 브랜치 다음에 생긴 브랜치가 아닙니다. 위에서 언급한 임시의 \u0026lsquo;커밋 브랜치\u0026rsquo; 다음에 위치합니다.\n5. 그리고 \u0026lsquo;을\u0026rsquo; 이 \u0026lsquo;메인\u0026rsquo; repository에 push합니다.\n5-1. \u0026lsquo;메인\u0026rsquo; 입장에서는, \u0026lsquo;서브\u0026rsquo;의 commit-id가 SB 라는 정보를 가져갑니다. 즉, 가리키는 commit-id는 SA에서 SB로 바꿔치기됩니다.\n6. 이번에는 팀원 \u0026lsquo;병\u0026rsquo; 이 \u0026lsquo;메인\u0026rsquo; repository를 clone 해옵니다. 역시 마찬가지로, --recursive 옵션을 통해 가져왔고, \u0026lsquo;서브\u0026rsquo; repository의 SB commit을 가져오려하는 순간 문제가 발생합니다.\n7. 왜냐하면, \u0026lsquo;서브\u0026rsquo; repository의 그 어디에도 SB commit은 존재하지 않기 때문입니다.\n그렇다면 \u0026ldquo;6~7번 사이에서 \u0026lsquo;서브\u0026rsquo; repository에 push 하면 되지 않나요?\u0026rdquo;(=7번에서 push가 아닌 deploy를 하면 되지 않나요?) 라고 의문을 제시할 수 있습니다만, 불가능합니다. 왜냐하면, 위 4번과 6번에서 말씀드렸다시피 commit의 위치가 특수한 곳에 존재하기 때문입니다. 따라서, push를 하려고 하면 다음과 같은 메시지를 볼 수 있습니다.\n이를 해결하기 위한 방법은 간단합니다. \u0026lsquo;서브\u0026rsquo; repository에 push하기 전에, 브랜치를 바꿔주면 됩니다. 즉, 위 쉘 스크립트를 수정하면 다음과 같이 됩니다.\n# 정적 사이트 생성 hugo -t PaperMod  # \u0026#39;서브\u0026#39; 프로젝트 commit \u0026amp; push cd public git checkout ${branch} # \u0026lt;- 이 부분을 추가합니다. git add . git commit -m ${commit-message} git push ${origin} ${branch}  # \u0026#39;메인\u0026#39; 프로젝트 commit \u0026amp; push cd .. git add . git commit -m ${commit-message} git push ${origin} ${branch} 여담 : github에서 clone 해올 때, 항상 특정 브랜치의 최신 커밋을 가져오도록 하면 좋을 것 같은데, 왜 이렇게 commit을 가져오도록 되어있는지 의문이 들었습니다. 그런데, 다시 생각해보면 이는 당연합니다.\n 말씀드렸던 대로, \u0026lsquo;메인\u0026rsquo; repository를 clone 할 때, 항상 \u0026lsquo;서브\u0026rsquo; repository의 최신 commit을 가져오게 된다고 가정해보겠습니다. \u0026lsquo;메인\u0026rsquo; repository를 개발한 사람이 정상적으로 잘 동작하는 것을 확인하고 push를 했는데, 시간이 지나 \u0026lsquo;메인\u0026rsquo; 에서 참조하고있는 \u0026lsquo;서브\u0026rsquo; repository가 업데이트 되었습니다. 그런데 \u0026lsquo;서브\u0026rsquo; repository 개발자의 실수로 버그가 있는 코드를 push했습니다.\n\u0026lsquo;메인\u0026rsquo; repository를 추가로 개발하려는 다른 사람이 clone 해왔는데, \u0026lsquo;메인\u0026rsquo; repository 또한 문제가 발생합니다. 왜냐하면, \u0026lsquo;서브\u0026rsquo; repository의 가장 최신 커밋을 가져왔기 때문에 \u0026lsquo;메인\u0026rsquo; 또한 버그가 발생했기 때문입니다.\n 우리가 Java 진영에서 흔히 사용하는 gradle이나 maven, 혹은 파이썬에서 pip 와 같은 툴들이 \u0026lsquo;특정 버전\u0026rsquo;을 관리하도록 한 이유도 이와 같겠죠. 또 다른 예시는 하단 reference 2번의 예시를 참고해주시면 되겠습니다. 이상으로 글을 마치겠습니다. 감사합니다.\nreference   git submodule update needed only initially?\n  How can I specify a branch/tag when adding a Git submodule?\n This does make some sense when you think about it, though. Let\u0026rsquo;s say I create repository foo with submodule bar. I push my changes and tell you to check out commit a7402be from repository foo.\nThen imagine that someone commits a change to repository bar before you can make your clone.\nWhen you check out commit a7402be from repository foo, you expect to get the same code I pushed. That\u0026rsquo;s why submodules don\u0026rsquo;t update until you tell them to explicitly and then make a new commit.    git submodule 브랜치 추적\n  git submodule 이해하기\n  ","permalink":"http://cjlee38.github.io/post/git/git-submodule/","summary":"깃 서브모듈 트러블슈팅 : 우테코 레벨3를 시작하면서, 본격적인 팀 프로젝트 작업에 착수했습니다. 여러가지 의견이 오고가던 중, 개인이 공부한 내용을 정리하는 블로그를 하나 만들자는 이야기가 나왔습니다. 공동의 소유라는 느낌을 갖기 위해, github organization 에 github blog를 만들기로 했죠. M1 맥에서 ruby \u0026amp; ruby bundle에 대한 문제를 겪었던 저와 다른 팀원의 경험을 토대로, 흔히 사용하는 jekyll 대신, hugo 를 사용하기로 결정하였습니다. 또한, 지금 현재 제가 사용하고 있는 깃허브 블로그도 hugo 로 제작되었기 때문에, 제가 블로그의 생성을 맡았습니다.","title":"# 깃 서브모듈 트러블슈팅"},{"content":"코틀린을 처음 접하면, 익숙한 field 라는 용어 대신 property 라는 용어를 접하게 됩니다. property 라는 용어는 지난 파이썬 Property까지 가는 길 에서 한번 다뤘던 개념과 사실상 같다고 보아도 무방합니다. property는 단순하게 이야기하면 클래스 내에 담겨있는 field, getter , setter 를 통칭하여 의미합니다. Java 에서는 이를 private 으로 필드를 숨기고, getter 와 setter 를 제공함으로서 property를 흉내냅니다.\npublic class SomeObject {  \tprivate int someInteger; \tprivate String someString;  \tpublic int getSomeInteger() { \treturn this.someInteger; \t}  \tpublic String getSomeString() { \treturn this.someString; \t}  \tpublic void setSomeInteger(int otherInteger) { \tthis.someInteger = otherInteger; \t}  \tpublic void setSomeString(String otherString) { \tthis.someString = otherString; \t} } 코틀린에서 변수는 기본적으로 val 과 var 를 통해 작성합니다. val은 value 를 의미하여 한 번 초기화 된 이후로는 read-only 입니다. Java 의 final 키워드를 붙인 변수라고 생각할 수 있습니다. var 는 variable 을 의미하며, ‘변할 수 있는 값’, 즉 ‘변수’ 이라는 의미에 걸맞게 값을 수정할 수 있습니다. 그리고 이를 property 관점에서 살펴보면 var 는 순수 property , val 은 read-only property 라고 표현합니다. 하지만 편의상 둘 다 묶어 property 라고 표현합니다.\nclass SomeObject { \tval someString: String = \u0026#34;string\u0026#34; \tvar someInteger: Int = 123 } property는 겉에서 보기에는 마치 public 으로 열려있는 field 처럼 보이지만, 내부적으로 getter 와 setter 메소드 호출을 통해 이루어집니다.(The syntax for reading and writing of properties is like for fields, but property reads and writes are (usually) translated to \u0026lsquo;getter\u0026rsquo; and \u0026lsquo;setter\u0026rsquo; method calls.) 그리고 이러한 getter, setter 를 묶어서 accessor, 즉 접근자라고 부릅니다.\n하지만 property를 아무런 추가 작업 없이 순수하게 getter, setter 로만 사용한다면 큰 의미가 없겠죠. 뭔가 내가 원하는대로 작업을 할 수 있어야 합니다. property 는 다음과 같은 형태를 가지고 있습니다.\nvar \u0026lt;propertyName\u0026gt;[: \u0026lt;PropertyType\u0026gt;] [= \u0026lt;property_initializer\u0026gt;] [\u0026lt;getter\u0026gt;] [\u0026lt;setter\u0026gt;] 위에 보이는 형태에서 getter, setter 부분을 우리가 직접 정의할 수 있고, 이를 custom accessor 라고 부릅니다. 다음은 Age 라는 \u0026lsquo;나이\u0026rsquo;에 해당하는 클래스에 대한 예제입니다.\nclass Age {  val value = 20  get() = field + 1 }  fun main() {  val age = Age()  println(age.value) // 21 } 위 코드를 보면, Age 클래스 내부에 value에 대한 값을 20으로 정의하였습니다. 하지만 그 값을 얻어내는 데 있어 그 값을 1 늘려서 받도록 처리하였습니다. 그렇기에 age.value 는 20 대신 21이라는 값을 얻어냄을 확인할 수 있습니다. 여기서 주의해서 볼 점은, custom getter 를 정의할 때 field 라는 키워드를 사용한다는 점입니다.\nproperty가 field와 accessor를 묶어서 부른다는 점을 감안하면, field라는 값이 실제로 들어있는 값에 해당함을 직감할 수 있습니다. 엄밀하게는 공식 문서에서는 이를 backing field 라고 부르며, 다음과 같이 설명합니다.\n In Kotlin, a field is only used as a part of a property to hold its value in memory. Fields cannot be declared directly. However, when a property needs a backing field, Kotlin provides it automatically. This backing field can be referenced in the accessors using the field identifier\n 다음은 setter에 대한 예제입니다.\nclass Age {  var value = 20  get() = field + 1  set(value) {  field = value - 2  } } 위 예제에서는 custom setter가 추가 된 것 이외에도, value의 타입이 var 로 바뀌었다는 점에 주목해야 합니다. 즉, val 은 앞서 언급했다시피 final에 해당하므로, setter가 동작할 수 없습니다. 한편 var는 변경가능하므로, setter를 정의할 수 있습니다.\n또한 property 에 대해 한 가지 더 알아야 할 점은, \u0026ldquo;반드시 field를 가질 필요는 없다\u0026rdquo; 라는 것입니다. 위 Age 코드에서, \u0026lsquo;성인인가?\u0026lsquo;에 대한 boolean 값을 메소드가 아닌 property로 저장할 필요가 있다고 가정해보겠습니다.\nclass Age {  var value = 20  get() = field + 1  set(value) {  field = value - 2  }  val isAdult = value \u0026gt; 20 }  fun main() {  val age = Age()  println(age.value) // 21  println(age.isAdult) // true // #1   age.value = 10   println(age.isAdult) // ? #2 } 위 코드를 실행했을 때, #2 에 해당하는 print문은 어떤 결과물을 내놓을까요 ? 정답은 true 입니다. 왜냐하면, instance가 생성되는 시점에 isAdult가 초기화되고, 그 값은 변하지 않기 때문입니다.\n #1 에 해당하는 코드 또한 true를 반환하다는 점도 유의해서 살펴보시기 바랍니다. isAdult가 참조하고 있는 대상이 value 이고, custom getter 를 통해 가져오기 때문에 true가 반환됩니다.\n 이 상황에서 우리는 isAdult가 \u0026lsquo;매 번 새로이 계산되는 것\u0026rsquo; 을 원합니다. 이를 value의 custom setter에 isAdult를 초기화하는 것 대신 property의 특성을 활용하면 다음과 같이 작성할 수 있습니다.\nclass Age {  var value = 20  get() = field + 1  set(value) {  field = value - 2  }  val isAdult: Boolean  get() = value \u0026gt; 20 } isAdult 에는 아무런 값도 할당되어 있지 않지만, getter를 통해 매 번 새로운 값을 가져올 수 있고, val 이기 때문에 setter를 정의할 수 없으므로 isAdult를 사용함에 있어 전혀 문제가 되지 않습니다.\n 이러한 특성을 활용해 Backing Property 라는 개념도 존재합니다. Backing Property는 외부에 드러내는 값을 드러내고, 내부로 숨기고 싶은 값을 private 접근자와 함께 이름 앞에 _(언더스코어)를 붙여줍니다. 공식문서 참고\n ","permalink":"http://cjlee38.github.io/post/kotlin/kotlin-property/","summary":"코틀린을 처음 접하면, 익숙한 field 라는 용어 대신 property 라는 용어를 접하게 됩니다. property 라는 용어는 지난 파이썬 Property까지 가는 길 에서 한번 다뤘던 개념과 사실상 같다고 보아도 무방합니다. property는 단순하게 이야기하면 클래스 내에 담겨있는 field, getter , setter 를 통칭하여 의미합니다. Java 에서는 이를 private 으로 필드를 숨기고, getter 와 setter 를 제공함으로서 property를 흉내냅니다.\npublic class SomeObject {  \tprivate int someInteger; \tprivate String someString;  \tpublic int getSomeInteger() { \treturn this.","title":"# Kotlin Property"},{"content":"우아한 테크코스 : 우아한 테크코스는 우아한형제들에서 진행하는 교육 프로그램입니다. 이미 알만한 사람들은 다 알고 있고, 이 글을 보고 있는 독자분도 아마 우아한 테크코스에 합격하려면 어떻게 해야 할까? 하는 생각으로 왔으리라 생각합니다\u0026hellip;만 본 글은 그저 일기에 가깝습니다. 이번 4기에 합격하고나서(사실은 1차 합격때부터) 써야지, 써야지 했는데 여유가 나지 않아서 이제와서 쓰게 되었습니다. 😢\n왜 지원했는가? : 사실 지원 동기를 따지라면, 그 누구도 할 것 없이 가장 첫 번째로 꼽는 것은 바로 \u0026lsquo;취업\u0026rsquo; 일 것입니다. 그런데 왜 \u0026ldquo;하필\u0026rdquo; 우아한테크코스인가? 에 대해서 이야기를 하고자 잠깐 과거 이야기를 해보겠습니다.\n처음 코딩을 접하고나서 : 대학교 2학년, 21살의 나이에 처음 코딩을 접하고나서, 앞으로 개발을 하겠노라 마음먹었었습니다. 이전 글 에 이와 관련해서 자세히 이야기를 적었기도 했었구요. 한창 데이터 사이언스를 배우겠다고 까불다가 된통 얻어맞고, 웹 백엔드 개발로 시작하겠다고, 휴학을 한게 약 1년 반전이었습니다. 지인들은 한둘씩 바라던 곳으로 취업을 해가는데, 스스로 부족함이 많다 생각하여 교육프로그램을 듣겠노라 결정했죠.\n이전에는.. 사실 이번 4기가 첫 번째 지원은 아닙니다. 엄밀히 따지자면 3수가 되겠네요.\n2기때는 코딩으로 할 수 있는게 무엇인지도 잘 몰랐고, 또 우아한형제들에서 바라는 지원서를 쓰지도 않았습니다. 그냥 기록일지를 쓴 것과 다름이 없었죠. 살면서 처음 쳐봤던 코딩테스트가 우테코 코딩테스트였던 것 같기도 하네요.\n3기때는 심기일전해서 친구의 도움을 받아 자소서를 썼습니다. 최대한 멋있는 문장과 나만의 철학을 글 속에 녹여내려고 며칠을 보냈습니다. 코딩테스트는 마지막 문제를 제외하고 다 맞았다는 자신이 있었으나, 결과는 탈락이었습니다. 지금와서 그 이유를 돌이켜보자면, 자소서 속 저는 \u0026ldquo;너무 말뿐인 사람\u0026quot;이지 않았나 싶었습니다. 제출했던 증거자료들도 턱없이 부족했구요.\n4기 때는.. : 4기때는 심기일전하여, 다른 사람들의 후기를 이것저것 찾아보며, \u0026ldquo;이 사람은 무슨 생각으로 지원서를 작성했을까?\u0026rdquo; 와 같은, 태도적인 측면을 많이 살펴보고, 또 저도 그렇게 쓰려고 노력했습니다.\n처음에는 정말 막막했습니다. 내가 지금까지 노력해온게 뭐가 있지? 내가 이야기하는 나의 생각을 뒷받침할만한 근거가 무엇이 있지? 이러한 생각들을 끝없이 하며, 내가 남에게 인정받았던 것들에 대해서 계속해서 떠올려냈습니다.\n나의 집요함을 표방하고자, 며칠 간 수십 통의 메일을 교수님께 질의응답했던 내용을 첨부하였고(교수님 죄송합니다 😂),\n개발에 대한 진심을 보여주고자, 만들었던 토이프로젝트에 대한 이야기를 풀어냈습니다.\n끝없이 학습하고자 하는 의지는 수 년간 헬스를 한 이후에도 더 나은 자세를 위해 PT를 받았던 것,\n나의 성실성은 매일 아침 6시에 운동을 갔던 것,\n나의 태도는 헬스를 하면서 얻어낸 자신감, 그리고 동시에 겸손함을 묶어 풀어냈습니다.\n왜 우아한 테크코스인가? 는 조교활동을 하면서 배웠던 교학상장(敎學相長) 의 이야기를 다뤘습니다.\n포비는 설명회 때 \u0026ldquo;헬스같은 진부한 이야기는 쓰지마라\u0026rdquo; 라고 이야기했는데, 그럼에도 불구하고 오랫동안 해왔던 것이 웨이트 트레이닝밖에 없었기에 이를 적었습니다. 아마 운동 이외에 다른 부분에서 여러 인상을 남겨서 자소서는 합격하지 않았나 싶네요.\n3 주간의 프리코스 : 우아한테크코스의 대부분 교육자료는 오픈소스로 제공되기 때문에, 아마 어떤 식으로 흘러가는지는 대부분 아시리라 생각합니다.\n프로그래밍 요구사항과 함께(e.g. else는 쓰지 마라) 미션이 주어지고, 1주일 동안 과제를 해결하고 제출하는 식이죠. 당시에는 nine to six로 일을 하고 있었기 때문에, 저녁시간에 짬을 내서 밤을 새워가며 미션을 풀었던 기억이 납니다. 각 주차 별 피드백 또한 어느정도 공개가 되어있기 때문에, 어떤 점에 주의하면서 코딩을 해야겠다 라고 생각을 하면서도 이를 따르지 못했던 점에 대해서 굉장히 아쉬워하기도 했구요.\n또한, 프로그램을 작성하기 이전, 기능 요구사항을 먼저 작성해야 합니다. 사실 이 부분은 아직도 정확히 \u0026ldquo;어떻게 써야한다\u0026rdquo; 라는 감을 잡기가 어려운데, 다른 분의 후기를 보니 \u0026lsquo;이제는 익숙한 기능요구사항을 먼저 작성했다\u0026rsquo; 와 같은 내용을 보고 당황했던 적도 많았습니다.\n특히 답답했던 점은, 피드백이 \u0026ldquo;공통 피드백\u0026quot;이다 보니 내가 작성한 코드가 괜찮은가? 였습니다. 너무 답답한 나머지, 바쁜 지인에게 코드리뷰를 부탁하기도 했었고, 또 객체지향의 사실과 오해, 오브젝트와 같은 책을 읽기도 하였습니다.\n프리코스 1주차 - 숫자 야구 게임\n프리코스 2주차 - 자동차 경주 게임\n프리코스 3주차 - 자판기 미션\n프리코스의 마지막인 최종 테스트는 5시간동안 진행되었습니다. 지금까지 테스트의 양상을 보아 \u0026ldquo;약간의\u0026rdquo; 알고리즘이 섞인 미션일거라 생각했는데, 예상했던 것과는 전혀 다른 미션이 주어져서, 손을 벌벌 떨면서 시험을 치뤘던 기억이 납니다.\n프리코스 최종 테스트 - 페어매칭관리\n그래도 어떻게든 어필하고자, 프리코스 기간동안 학습했던 내용들, 그리고 마지막 3주차 미션이 끝난 이후 리팩토링을 하고, 또 복습했던 내용들을 정리하기도 하였습니다.\n프리코스 3주차 - 자판기 미션 리팩토링\n그리고 다들 그렇듯이, 합격 메일을 받고나서 어안이 벙벙했습니다. 최선을 다하지 못했던 것 같아 아쉬움이 많았는데, 다행히 합격을 받을 수 있었습니다. 우테코에서 떨어지면 앞으로 무엇을 해야하나 한창 계획을 짜고 있었는데, 덕분에 잠시 나중으로 미뤄두기로 했습니다.\n앞으로 10개월, 열심히 살아보겠습니다. 감사합니다.\n","permalink":"http://cjlee38.github.io/post/diary/2022-02-28-woowacourse/","summary":"우아한 테크코스 : 우아한 테크코스는 우아한형제들에서 진행하는 교육 프로그램입니다. 이미 알만한 사람들은 다 알고 있고, 이 글을 보고 있는 독자분도 아마 우아한 테크코스에 합격하려면 어떻게 해야 할까? 하는 생각으로 왔으리라 생각합니다\u0026hellip;만 본 글은 그저 일기에 가깝습니다. 이번 4기에 합격하고나서(사실은 1차 합격때부터) 써야지, 써야지 했는데 여유가 나지 않아서 이제와서 쓰게 되었습니다. 😢\n왜 지원했는가? : 사실 지원 동기를 따지라면, 그 누구도 할 것 없이 가장 첫 번째로 꼽는 것은 바로 \u0026lsquo;취업\u0026rsquo; 일 것입니다.","title":"# 조금 늦은 우테코 4기 합격 후기"},{"content":"0. 계기 코드를 작성하면서 언제나 들었던 고민은 \u0026ldquo;더러워보인다\u0026rdquo; 였습니다. 누구도 아닌 나 스스로가 작성한 코드이니, 해결책 또한 마땅히 보이지 않았습니다.\n이보다 더 문제인 점은, 가끔은 한참을 고민하면 어디를 수정해야 할지 발견해낼 수 있었으나, 대부분의 경우 \u0026ldquo;이 클래스에 이 메소드가 있는 것이 맞는가?\u0026rdquo; \u0026ldquo;이 메소드가 이 파라미터를 필요로 하는 것이 맞는가?\u0026rdquo; 와 같이, 정답이 없는 문제들이었습니다.\n더더욱 문제인 점은, 저에게는 이러한 고민에 대해서 조언해줄 사람을 찾기가 어렵다는 점입니다. 개발자에 대한 관심이 쏠리면서, 특정 기술, 프레임워크, 라이브러리에 대해서는 수많은 인터넷 강의, 블로그 자료가 영어는 물론 한국어로도 쏟아져 나옵니다.\n하지만 \u0026ldquo;좋은 코드\u0026quot;를 작성하는 방법은 정량적으로 측정할 수 없기 때문에, 어디를 찾아봐도 \u0026ldquo;반드시 이렇게 작성해야 한다.\u0026rdquo; 라는 지표를 내세우는 사람은 없습니다.\n이러한 고민을 하던 와중, 복잡한 머릿속을 좀 정리시켜줄 수 있을까 해서 객체지향의 사실과 오해를 구매하게 되었습니다.\n1. 서술적 관점 이 책의 저자이신 조영호님도 서문에서 다음과 같이 이야기합니다.\n 이 책은 객체지향이란 무엇인가라는 원론적이면서도 다소 위험스러운 질문에 대한 제 나름의 대답을 말씀드리기 위해 쓰여졌습니다.\n\u0026hellip; 중략 \u0026hellip;\n책을 덮은 후 여러분들이 지금까지 해왔던 방식을 뒤돌아보면서 깊은 사색에 잠길 수만 있다면 이 책은 그 목적을 다한 것이라고 생각합니다.\n 이 책에는 코드가 거의 나오지 않습니다. 중간에 짤막하게 예시로, 예금이라는 주제로 코드를 설계하고 작성하는 과정을 보여주지만, 핵심은 코드가 아닙니다. 개인적으로 느끼기에 이 책이 독자에게 제공하고자 하는 것은 사상입니다.\n책은 계속해서 비슷한 이야기를 들려줍니다. 클래스는 객체가 아니다. 객체지향의 본질은 자율적인 객체가 서로 협력하는 것이다 등의 이야기를 반복해서 소개합니다.\n따라서 이 책을 통해 저자는 다양한 코드를 보여주기보다, 큰 개념의 원칙을 바탕으로, 다양한 관점의 추상적이고 모호한 규칙을 시사하면서, 객체지향적인 코드를 작성하는 법을 체화시켜주고자 합니다.\n2. 사상적 관점 책에서는 여러 키워드(e.g. 책임, 협력, 메시징 등)가 등장하고, 위에서 언급했듯 여러 관점에서 객체간의 관계, 존재 의의를 살펴봅니다. 하지만 저는 아직 쥐뿔도 모르기에, 다음과 같은 몇 가지 문장으로 정리해보았습니다.\n0. 본질을 잊지 말 것. 절차지향이던, 객체지향이던, 함수형이던 여러 프로그래밍 패러다임이 있고, 저마다의 특징, 장단점 또한 존재합니다. 그 와중에, 객체지향이 왜 유명하고, 많이 쓰일까요?\n책에는 \u0026ldquo;세상을 자율적이고 독립적인 객체들로 분해할 수 있는 인간의 기본적인 인지 능력으로 인해, 많은 사람들이 객체지향을 직관적이고 이해하기 쉽다고 말한다\u0026rdquo; 는 내용이 있습니다. 그렇다면, 객체지향이 직관적이고 쉽게 이해할 수 있기에 \u0026ldquo;어떤 효용성이 있는지\u0026quot;를 생각해봐야 할 것 같습니다.\n제가 갖고 있는 소견은, \u0026ldquo;쉬운 변경\u0026rdquo; 입니다. 그렇기에 저는 일단 코드를 설계하고, 작성할 때 \u0026ldquo;이 부분이 바뀌면 어떡하지? 어떻게 하면 쉽게 교체할 수 있을까?\u0026rdquo; 를 최우선으로 생각합니다. 이러한 생각은 Scalable 이라는 키워드나, 결합도, 응집도와 같은 표현으로도 설명될 수 있을 것 같습니다.\n1. 객체지향은 현실세계의 은유 객체지향의 세계에서는 현실 세계와 조금 다릅니다. 현실 세계에서는 내가 물컵을 들고 마시면, 물의 양이 줄어듭니다. 하지만 객체지향의 세계는 내가 물컵에게 \u0026ldquo;마신다\u0026rdquo; 라는 메시지를 보내고, 물컵은 메시지에 따라 스스로의 양을 줄입니다. 이러한 관점은 조금 이상해보입니다.\n하지만 휴대폰의 버튼을 생각해보면 고개를 끄덕이게 됩니다. 우리가 휴대폰의 볼륨 버튼을 누르면, 볼륨이 줄어드는걸까요, 아니면 휴대폰이 버튼의 눌림이라는 메시지를 통해 스스로의 볼륨을 줄이는 걸까요? 제 생각에는 아무래도 후자에 가까워 보입니다.\n객체지향이라고 명칭하는, 내가 창조하는 소프트웨어 세계에서는 모든 것이 살아 숨쉬는 생명체입니다.\n2. \u0026ldquo;해줘\u0026rdquo; 객체는 해당 객체가 수행해야 할 책임이 있습니다. 식당을 예시로 생각해봅시다.\n식당에서 손님이라는 객체는 음식을 시키고, 먹고, 돈을 지불할 책임이 있습니다. 식당 주인이라는 객체는 주문을 받고, 음식을 조리하고, 계산 처리를 해줄 의무가 있습니다.\n그렇다면 이를 코드로 표현하면 어떨까요? 아마 다음과 같은 상상을 해볼 수 있을 것 같습니다.\npublic class Customer { \tpublic void order() { \tOwner owner = new RestaurantOwner(); \towner.order(Food.JIN_RAMEN); \t} } 제 눈에 이러한 코드는 굉장히 자연스럽고 당연하게 보입니다. 하지만 많은 사람들이 다음과 같이 쓰지는 않습니다.\npublic class Customer { \tpublic void order() { \tOwner owner = new RestaurantOwner(); \towner.set_pot(\u0026#34;양은\u0026#34;); // 양은 냄비 준비 \towner.pour_water(\u0026#34;양은\u0026#34;, \u0026#34;생수\u0026#34;, 550); // 양은 냄비에 550ml 생수 채우기 \towner.fire_on(3); // 3번 화구 불 킴 \t... \t} } 분명 위와 같은 코드로도 동작은 하겠지만, 분명히 비정상적인 상황입니다. 우리는 절대 식당에서 \u0026ldquo;양은 냄비로 준비해서, 550ml의 물을 담아서 3번 화구에서 끓여주세요\u0026rdquo; 라고 요청하지 않습니다. 왜일까요?\n첫 째는, 우리는 그러한 권리, 즉 책임이 없기 때문입니다. 상황에 따라 적절하게 파를 많이 넣어달라던지 등의 추가 요청은 있을 수 있지만, 대개 손님은 식당에서 맛있는 요리가 나오기를 기대할 뿐입니다.\n둘 째는, 우리는 그 식당에 무슨 냄비가 있는지, 무슨 물을 쓰는지, 화구는 몇 개가 있는지따위는 알지 못하기 때문입니다. 저런 요청이 올 때마다 모두 검증해야 하기 때문입니다. 아마 다음과 같이 상상해볼 수 있겠죠.\npublic class RestaurantOwner implements Owner { \t\tString pots[] = {\u0026#34;스테인리스\u0026#34;, \u0026#34;알루미늄\u0026#34;}  \tpublic void set_pot(String pot_type) { \tvalidate_pot(pot_type) \t... \t}  \tprivate void validate_pot(String pot_type) { \tfor (String pot : pots) { \tif (pot.equals(pot_type)) \treturn ; \t} \traise IllegalArgumentException(\u0026#34;그건 없는데요 손님?\u0026#34;) \t} } 3. 맡은 바는 충실하게 식당에서 라면을 주문했는데, 식당 주인의 실수로 계란을 빠트렸습니다. 손님은 라면을 먹다가 계란이 없다는 사실을 발견하고 식당 주인에게 항의합니다.\n현실에서는 항의정도로 그쳐서 그나마 다행이지만, 소프트웨어 세계에서는 프로그램이 죽어버릴 수도 있습니다. 명백히 기대한 바와 다른 결과이기 때문이죠. 방문하는 손님은 음식이 완벽하게 조리되어 나오기를 기대하기 때문에, 이러한 상황은 발생해서는 안됩니다.\n이동욱님의 블로그 포스팅 중, 일급 컬렉션 에서는 비즈니스 로직을 서비스 메소드에서 처리하지 않고, 이를 객체화 하여 스스로 검증 로직을 갖도록 만듭니다. (잠깐 멈추고 한번 읽어보고 오시는 것도 좋습니다.)\n식당 예시에서는, 이러한 검증 로직은 최소 라면 객체가, 그게 아니라면 아무리 못해도 최소한 식당 주인이 갖고 있어서 온전한 라면을 손님에게 제공해야 합니다. 손님 이라는 객체가 검증하는 것은 명백히 잘못된 상황입니다.\n4. 적절한 추상화 우리가 어떤 클래스, 메소드, 변수 등에 대해서 이름을 정할 때, 본능적으로 관련이 있는 단어를 사용합니다. 메소드로 생각해보면, a() b() 와 같은 짓은 하지 않죠. 왜? 이 함수가 무슨 일을 하는지 한번에 떠올리지 못하기 때문입니다. 내가 쓴 코드지만 며칠이 지나면 까먹어버리니까요.\n그렇다면 public void get() public void set()은 어떤가요? 간단한 객체를 리턴하는 정도면 무리가 없어보이지만, 만약 파일을 읽고, 그 안에서 뭔가 수정하고, 변경하고, 필터링을 거치는 등의 많은 작업이 일어나면, 이러한 단어로 내용을 모두 함축시키는 것은 조금 무리가 있어보입니다.\n말인 즉슨, 안에서 너무 많은 일이 일어나고 있다는 뜻인데요. 단순히 메소드를 나눈다고 할 지라도, 하나의 클래스가 너무 많은 역할을 담당하고 있습니다. 이럴 때 그 중간 지점을 찾아내서, 추상화가 필요합니다.\npublic class RestaurantOwner implements Owner { \t\tList\u0026lt;Stove\u0026gt; stoves = new ArrayList\u0026lt;\u0026gt;();  \tpublic Ramen cook_ramen(...) { \tPot pot = new Pot(\u0026#34;양은\u0026#34;); \tpot.pour(550); \tstoves.get(3).put_on(pot); \t... \t}  \tpublic Udon cook_udon(...) { \tPot pot = new Pot(\u0026#34;양은\u0026#34;); \tpot.pour(400); \tstoves.get(1).put_on(pot); \t... \t} } 요리사 라면과 우동을 조리하는 것은 현실에선 자연스러워 보이지만, 관점을 조금 바꿔보면 다음과 같이 작성할 수 있습니다.\npublic class RestaurantOwner implements Owner {  \tpublic Food cook(FoodMenu menu) { \tFood food = Food.of(menu); \treturn food; \t} } 사실 생각해보면, 우리가 메뉴판을 보고 라면을 \u0026ldquo;조리해달라\u0026rdquo;, 우동을 \u0026ldquo;조리해달라\u0026rdquo; 라고 이야기하지, 메뉴판도 보지 않고 \u0026ldquo;라면을 조리해주세요\u0026rdquo;, \u0026ldquo;우동을 조리해주세요\u0026rdquo; 라고 이야기 하지 않습니다.\n메소드가 한 가지 일만을 해야한다, 단일책임원칙 과 같은 문장은 아마 이와 같은 맥락에서 이야기하는 것이라 생각합니다.\n5. 기타.  한 번에 좋은 코드를 작성하려고 하지 말 것. 설계는 코드를 작성하는 도중에 반드시 바뀐다. 설계를 최대한 빨리 마치고 코드 작성을 들어가야 한다.   \u0026hellip; 작성중\n 3. 마무리 아직 많은 코드를 작성하고, 다양한 문제에 맞닥뜨려본 경험이 없어 많은 내용을 이해하진 못했고, 또 제가 이해한 내용이 틀렸을 수도 있습니다. 나중에 기회가 된다면 다시 한번 펴볼만한 가치가 차고 넘치는 책이라 생각합니다.\n저와 비슷한 고민을 하고 있는 분들은 이 책을 꼭 한번 구매해보시기를 추천드립니다. 저는 조영호님의 다른 책인 오브젝트를 주문하러 가보겠습니다. 감사합니다.\n","permalink":"http://cjlee38.github.io/post/diary/2021-10-22-oop_truth_and_misunderstanding/","summary":"0. 계기 코드를 작성하면서 언제나 들었던 고민은 \u0026ldquo;더러워보인다\u0026rdquo; 였습니다. 누구도 아닌 나 스스로가 작성한 코드이니, 해결책 또한 마땅히 보이지 않았습니다.\n이보다 더 문제인 점은, 가끔은 한참을 고민하면 어디를 수정해야 할지 발견해낼 수 있었으나, 대부분의 경우 \u0026ldquo;이 클래스에 이 메소드가 있는 것이 맞는가?\u0026rdquo; \u0026ldquo;이 메소드가 이 파라미터를 필요로 하는 것이 맞는가?\u0026rdquo; 와 같이, 정답이 없는 문제들이었습니다.\n더더욱 문제인 점은, 저에게는 이러한 고민에 대해서 조언해줄 사람을 찾기가 어렵다는 점입니다. 개발자에 대한 관심이 쏠리면서, 특정 기술, 프레임워크, 라이브러리에 대해서는 수많은 인터넷 강의, 블로그 자료가 영어는 물론 한국어로도 쏟아져 나옵니다.","title":"# 객체지향의 사실과 오해를 읽고, 짧은 감상문"},{"content":" Note 1. 개인적으로 공부해가며 작성한 글이기 때문에 틀린 내용이 있을 수 있습니다. 틀린 내용을 발견하시면 언제든 지적 부탁드립니다.\nNote 2. 이해를 돕기 위해 일부 내용은 Java와 비교해가며 글을 작성했습니다.\n 0. 들어가며 : 한동안 Java를 애용하다가, Python을 다뤄야 하는 일이 생겨서 다시 Python을 붙잡게 되었습니다. Java의 syntax에 대해서 어느정도 이해하고 있다고 자만하던 중이었기 때문에, Python을 사용하면서 \u0026ldquo;왜 Python에는 Java의 이런 기능이 없지? 역시 Java가 짱이야\u0026rdquo; 라는 생각도 하곤 했습니다.\n그런데 python의 getter와 setter에 대해서 알아보던 중, @property 라는 녀석을 이해해보려고 자료를 찾다 보니, Python의 진면목 일부를 엿볼 수 있는 기회가 되었습니다.\npython의 아주 기본적인 문법만 알고 있던 사람들에게 본 글이 시야를 넓히는데 도움이 되길 바라면서, 시작하겠습니다.\n1. 그래서 @Property 가 뭔가요 ? 흔히 \u0026ldquo;객체지향\u0026rdquo; 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용합니다.\nJava에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리하죠.\n따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있습니다.\nclass Person {   private String name;  private int age;   public Person(String name, int age) {  this.name = name;  this.age = age;  }   public String getName() {  return this.name;  }   public int getAge() {  return this.age;  }   public void setAge(int age) {  if (age \u0026lt;= 0)  throw new IllegalArgumentException(\u0026#34;나이는 0 이하가 될 수 없습니다.\u0026#34;);  this.age = age;  } }  public class Main {  public static void main(String[] args) {  Person person = new Person(\u0026#34;Mr.Kim\u0026#34;, 26);  System.out.println(person.getName()); // \u0026#34;Mr.Kim\u0026#34;;  person.setAge(-62); // IllegalArgumentException(\u0026#34;나이는 0 이하가 될 수 없습니다.\u0026#34;)  } } 그러나 python 에서는 programming language 수준에서 접근 권한을 제어할 수 없습니다. 따라서 _(언더스코어) 를 활용하는 방법을 제공하지만, 결국 _{클래스명}__{변수명} 으로 접근이 가능합니다.(이후 뒤에서 설명할 property도 결국 직접 접근하는 방법은 있습니다.)\n따라서 python 에서는 기본적으로 모두 public 이라고 생각하면 됩니다. 하지만 그렇다고 해서 getter/setter를 쓸 필요가 없다는 것은 아닙니다. 당장 위와 같은 예시만 보더라도, setAge() 메소드를 호출할 때, 나이가 음수인지 아닌지 검증하는 로직이 필요하기 때문입니다. 위 코드를 python 으로는 다음과 같이 쓸 수 있습니다.\nclass Person :  def __init__(self, name, age) :  self._name = name  self._age = age   # 다른 메소드는 편의상 생략합니다.   def set_age(self, new_age) :  if new_age \u0026lt;= 0 :  raise Exception(\u0026#34;나이는 0 이하가 될 수 없습니다.\u0026#34;)  self._age = new_age  if __name__ == \u0026#39;__main__\u0026#39; :  person = Person(\u0026#34;Mr.Kim\u0026#34;, 26)  person.set_age(-62) # Exception(\u0026#39;나이는 0 이하가 될 수 없습니다.\u0026#39;) 여기까지는 Java와 똑같습니다. 하지만, 이런 식의 코드 사용은 explicit 하지 못하다는 단점이 있습니다. 만약 기존 나이에서 1살을 더해줘야 한다면, 다음과 같이 작성해야 합니다.\nperson.set_age(person.get_age() + 1) 뿐만 아니라, person._age = -62 와 같은 코드는 방어할 수가 없어진다는 문제도 여전히 남아있죠. 그러나 @property 를 활용하면 다음과 같은 코드가 가능합니다.\nperson.age += 1 person.age = -62 # Exception(\u0026#39;나이는 0 이하가 될 수 없습니다.\u0026#39;) ??? 어떻게 된 일일까요?\n변수에 값을 직접 대입하는 것 같은데, 로직에 따른 Exception을 던지고 있습니다. 어떻게 이것이 가능한지는 차차 알아보기로 하고, 일단 생김새부터 살펴봅시다. 위 Person 클래스에 @Property를 적용하면 다음과 같이 작성할 수 있습니다.\nclass Person :  def __init__(self, name, age) :  self._name = name  self._age = age   @property  def age(self) :  return self._age   @age.setter  def age(self, new_age) :  if new_age \u0026lt;= 0 :  raise Exception(\u0026#34;나이는 0 이하가 될 수 없습니다.\u0026#34;)  self._age = new_age 대충 살펴 봤을때, 눈에 띄는 차이점은 다음과 같습니다.\n 함수의 이름이 get_age 혹은 set_age 가 아니라, 그냥 age 자체로 바뀌었습니다. 계속 언급했던 @property 가 age 메소드 위에 붙었습니다. 또한, @age.setter 라는 녀석도 두 번째 age 메소드 위에 붙었습니다.  이러한 변화가 어떻게 앞서 언급했던 동작에 영향을 미쳤는지 하나씩 알아가봅시다.\n@property를 이해하기 위한 배경지식들은 다음과 같습니다.\n Everything is Object Decorator Descriptor Object  1. Everything is Object Python에서 다루는 모든 값은 객체입니다. Java에서는 일반적으로 값을 Primitive Type, Reference Type 으로 구분하죠. 반면 Python에서는 int, bool과 같은 값들도 모두 객체로 다뤄집니다.\na = 1 print(id(a)) # 4341049696 id 함수는 Built-in 함수로, 객체가 가지고 있는 주소값을 나타냅니다. 따라서 id(a)라는 코드는 1 이라는 값이 할당된 메모리 주소를 반환합니다. Java에서는 Integer 와 비슷하다고 생각하시면 될 것 같습니다.\n이에 더해, Python 에서는 함수마저도 객체입니다.\ndef my_func() :  return \u0026#34;hello world\u0026#34;  print(my_func.__str__()) # \u0026#39;\u0026lt;function my_func at 0x7ffd70cf1f70\u0026gt;\u0026#39; 위 예시에서 보시다시피, my_func 이라는 이름의 함수를 만든 뒤, 해당 함수가 갖고 있는 __str__ 이라는 메소드를 호출할 수 있습니다. 즉, my_func 자체는 Function 이라는 클래스를 상속하는 클래스입니다.\n간단하게 생각하면, def my_func() 라는 키워드는 my_func = {함수 바디} 와 같이 변수로 정의되는 것을 상상해볼 수 있겠습니다.\n Note. 함수가 객체라는 이야기를 할 때, 1급 시민 이라는 키워드가 자주 등장합니다. 1급 시민이란, 변수에 할당할 수 있어야 하고, argument로 전달될 수 있으며, return 으로 반환될 수 있는 값들을 말합니다. Java에서 메소드는 일급 객체가 아니지만, 인터페이스를 활용해 1급 시민의 흉내를 낼 수 있게 되었습니다.\n 2. Decorator 데코레이터를 이야기하려면 Python 함수가 갖는 또 다른 특징을 알아야 합니다.\n1) 함수는 중첩이 가능하다. python은 다음과 같이 함수를 중첩해서 정의할 수 있습니다.\ndef outer() :  def inner() :  print(\u0026#39;inner called\u0026#39;)  print(\u0026#39;outer called\u0026#39;)  inner()  return inner  var = outer() # outer called \\n inner called (1) var() # inner called (2) outer 함수 안에 inner 함수를 정의한 뒤, inner 함수를 호출했습니다. 따라서 var = outer() 를 통해 outer함수를 호출할 때, 내부에 있는 inner 함수 (1)도 실행됩니다.\n다음으로 return inner를 통해 inner 함수 그 자체를 돌려주고, 해당 함수 객체는 var 라는 변수에 저장됩니다. 따라서 var() 를 통해 함수를 실행하는 것은 결국 inner 함수를 실행하는 것과 같습니다.\n2) Enclosed Function Locals python의 함수가 갖는 두 번째 특징은, 이러한 중첩 함수로 인해 조금 특별한 변수 scope가 생긴다는 것입니다.\nC를 처음 배웠을 무렵, 지역변수 전역변수와 같은 개념에 대해서 배우고, \u0026ldquo;내가 허용된 범위의 바깥 변수는 알 수 없다\u0026rdquo;, \u0026ldquo;가까운 scope부터 찾아 나간다\u0026rdquo; 정도의 개념으로 정리하고 넘어갔었습니다.\npython에서는 후자, 즉 \u0026ldquo;가까운 scope부터 찾아 나간다\u0026quot;는 맞는 말이지만, 전자인 \u0026ldquo;내가 허용된 범위 바깥 변수는 알 수 없다\u0026rdquo; 는 조금 다릅니다. 요약하자면, \u0026ldquo;내가 허용된 범위 바깥 변수에 접근할 수는 있지만, 수정할 수는 없다.\u0026rdquo; 정도가 될 것 같습니다.\nx = 1 def outer() :  y = 2  def inner() :  z = 3  print(z, y, x)  inner()  return inner  a = outer() # 3 2 1 a() # 3 2 1 아까 예시를 들었던 outer/inner 함수를 약간 변형해보았습니다. outer 함수가 실행되던 와중에 inner가 호출되든, 함수 객체를 return 받은 a가 호출되든 상관없이, 모두 3 2 1을 출력합니다.\n Note. python에서는 가까운 곳부터 찾아나가는 접근법을 LEGB 규칙 이라고 명명했습니다. 순서대로 Local, Enclosed function locals, Global, Built-in 의 약자이며, z, y, x 변수가 이에 해당합니다. 마지막 Built-in 변수는 __name__과 같이 \u0026ldquo;내가 정의하지도 않았는데 기존에 정의되어 있던 값들\u0026quot;을 말합니다.\n 하지만 다음의 예시는 쓰기에 대해서는 조금 다른 결과임을 보여줍니다.\nx = 1 def outer() :  y = 2  def inner() :  z = 3  y += 1 # UnboundLocalError: local variable \u0026#39;y\u0026#39; referenced before assignment  x += 1 # UnboundLocalError: local variable \u0026#39;x\u0026#39; referenced before assignment   print(z, y, x)  inner()  return inner  a = outer() a() inner 내부에서 y와 x에 대해서 값을 1씩 더하려고 하자 할당되기 전에 참조되었다는 에러를 발생시킵니다. 즉, 자기 자신의 scope 바깥에 있는 변수에 대해서는 \u0026ldquo;쓰기\u0026rdquo; 연산에 대해, 즉 \u0026ldquo;변경\u0026quot;에 대해 제한되어 있습니다.\n Note. 만약 해당 값을 수정하고 싶다면 nonlocal 혹은 global 키워드를 통해 \u0026ldquo;내가 외부의 값을 수정하고자 한다\u0026rdquo; 라는 의도를 드러내야 합니다.\n 3) Closure Closure는 위키피디아에서 다음과 같이 설명하고 있습니다.\n컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 이러한 설명은 처음 Closure를 접한 사람들에게 전혀 도움이 되지 않습니다. 심지어 Closure라는 네이밍 그 자체에서도 어떠한 힌트를 얻기는 어렵습니다. 예시를 살펴보면서 이해해보겠습니다.\ndef outer(val) :  def inner() :  print(\u0026#39;inner called\u0026#39;)  print(val)  print(\u0026#39;outer called\u0026#39;)  return inner  a = outer(10) # ??? a() # ??? 첫 번째로 실행한 a = outer(10), 두 번째로 실행한 a() 코드가 각각 어떻게 돌아갈지 한번 상상해볼까요?\na = outer(10)에 의해 outer 함수를 호출했고, argument로 10을 넘겨주고, 이를 val 이라는 이름으로 받아냅니다. 그 내부에서 inner 함수를 정의했고, outer called 를 출력한 뒤, inner 함수 객체를 돌려줍니다.\n두 번째로 a() 를 통해, a 변수가 갖고 있는 inner 함수 객체를 호출합니다. inner called를 출력한 뒤, val을 출력하려고 하는데, 여기서 의문점이 하나 생깁니다. 해당 함수는 자신 바깥에 있는, 즉 val 변수를 참조하고 있습니다. 앞서 이야기한 LEGB 규칙에 따르면, L 에서 E를 참조하는 셈이죠.\n여기서 val은 살아 있을까요? 바꿔말하면, val 변수를 참조해서 아까 넣어준 10 이라는 값을 얻어낼 수 있을까요? 정답은 \u0026ldquo;YES\u0026rdquo; 입니다.\n이렇게 보니 마치 outer 라는 클래스가 val 이라는 멤버변수를 가지고 있는 것처럼 느껴집니다. 여기까지 읽고 나서, 다시 위키피디아의 정의를 살펴보겠습니다.\n컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 이렇게 보니 100% 이해하지는 못하더라도, 어떤 느낌으로 설명하고 있는지는 알 것 같습니다. Closure라는 이름 또한 직역 시 \u0026ldquo;폐쇄\u0026rdquo; 라는 뜻을 갖고 있는데, 조금 과장해서 \u0026ldquo;폐쇄망\u0026rdquo; \u0026hellip; \u0026ldquo;인트라넷\u0026rdquo; \u0026hellip; \u0026ldquo;나만의 구역\u0026rdquo; .. 과 같은 연결고리로 생각이 들기도 합니다.\n Note. 어떠한 함수 A 가 Closure이기 위해서는 다음의 세 가지 조건이 만족되어야 합니다.\n A 함수는 다른 함수 B 안에 정의된 함수, 즉 중첩된 함수여야 한다. 자신을 둘러싼 함수 B scope 의 값을 참조해야 한다. B 함수는 A 함수를 반환해야 한다.   여기서 한 단계 더 나아가보겠습니다.\ndef outer(func) :  def inner() :  print(\u0026#39;inner called\u0026#39;)  func()  print(\u0026#39;outer called\u0026#39;)  return inner  def my_func() :  print(\u0026#39;my_func called\u0026#39;)  a = outer(my_func) # outer called a() # inner called \\n my_func called 앞서는 val 이라는 숫자 값을 넣어줬지만, 이번에는 my_func 이라는 함수를 넣어주고 있습니다. 거듭 반복해서 보여드리고 있듯이, 함수 또한 객체이기 떄문에(a.k.a 1급 시민) 다른 함수의 argument로 전달될 수 있습니다.\n여기서는 outer 라는 함수의 argument로 my_func을 전달하고 있고, 좀 전과 마찬가지로 my_func는 outer 함수의 호출이 끝나더라도 inner에 의해 참조되고 있습니다.\n4) 드디어.. Decorator를 알기 위한 사전 지식은 준비되었으니, 이제 본격적으로 알아보겠습니다.\n바로 위의 예시에서는 a = outer(my_func) 라는 함수를 통해 closure를 만들고, a() 를 통해 inner 함수, 즉 closure 를 호출했습니다. Decorator를 활용하면 이를 보다 손쉽게 정의할 수 있습니다.\n즉, 다음의 두 코드는 같습니다.\n기존\ndef outer(func) :  ...  def my_func() :  ...  a = outer(my_func) # outer called a() # inner called \\n my_func called 데코레이터\ndef outer(func) :  ...  @outer # outer called def my_func() :  ...  a = my_func() # inner called \\n my_func called  여기서 한 가지 주의할 점은, 데코레이터 버전에서 outer called 는 @outer를 붙여서 my_func를 정의하는 시점에 호출된다는 점입니다.\n이렇게 보니 Decorator 라는 이름이 왜 Decorator 인지 알 것 같습니다. 또한, Spring의 AOP는 Python에서는 Decorator를 활용해 간단히 구현할 수 있겠다는 생각도 듭니다.\n3. Descriptor Object Descriptor 는 객체 A가 갖고있는 속성인 객체 B를 다룰 때 조회, 저장 및 삭제를 사용자 정의할 수 있는 객체 B를 디스크립터라고 이야기합니다.\n이 Descriptor라는 녀석은 객체 A의 클래스 변수로서 정의되어야 합니다. (the descriptor must be in either the owner’s class dictionary or in the class dictionary for one of its parents)\n역시, 예시를 보면서 진행하겠습니다.\nclass Age :  def __init__(self, age) :  self._age = age   def __get__(self, obj, objtype) :  print(\u0026#34;__get__ method called\u0026#34;)  return self._age   def __set__(self, obj, val) :  print(\u0026#34;__set__ method called\u0026#34;)  self._age = val   def __delete__(self, obj) :  print(\u0026#34;__delete__ method called\u0026#34;)  self._age = -1  class Person :  age = Age(26)  p = Person() print(p.age) # __get__ method called \\n 26 p.age = 20 # __set__ method called del p.age # __delete__ method called print(p.age) # __get__method called \\n -1 Age 라는 클래스를 만들고, __get__, __set__, __delete__ 메소드를 정의했습니다. 이 세개의 메소드는 스페셜 메소드 라고 불리우며, 객체가 갖는 특성을 지정할 수 있습니다. 가장 대표적으로 __init__ 메소드는 인스턴스 생성시에 동작하는 행위에 대해서 정의할 수 있습니다.\n어떠한 객체에 위에서 언급한 세 개의 __get__, __set__, __delete__ 메소드가 정의되었을 경우, 해당 객체를 \u0026ldquo;디스크립터\u0026rdquo; 라고 부르게 됩니다.\n Note. __get__ 메소드만 정의된 경우에는 Non-data Descriptor, __set__ 메소드 혹은 __delete__ 메소드가 정의된 경우에는 Data Descriptor 라고 부르게 됩니다. 이 둘의 차이는 우선순위에 있습니다만, 여기서는 다룰 내용이 아닌지라 스킵하겠습니다.\n 이렇게 Descriptor를 정의할 경우, 해당 객체로 접근할 때 우리가 생각했던 것처럼 값에 직접 접근하는 것이 아니라, 메소드 호출을 통해 접근하게 됩니다. 그림으로 보면 다음과 같이 상상해 볼 수 있겠습니다.\nDescriptor 라는 특별한 개념이 없다면, 코드 상으로는 객체가 위 그림과 비슷한 형태로 구성될 것이라고 예측할 수 있습니다. Person 안에 Age 객체가, 그리고 Age 객체 안에 _age 라는 멤버변수, __getter__, __setter__ 라는 메소드를 가질 뿐이죠. 따라서 p.age 로 접근하게 되면 Age() 객체로 접근할 것처럼 보입니다. 하지만 실질적으로는 다음 그림과 같습니다.\np.age를 호출하게 되는 순간, Person 객체 내에 있는 Age() 객체를 가져오려 하는데, __get__ 메소드가 오버라이드 되어 실질적으로는 Age() 객체가 아닌 그 내부의 self._age를 돌려주게 됩니다.\n이러한 동작 방식을 보고나면, 왜 Data Descriptor 라는 이름을 갖게 되었는지 이해되기 시작합니다. Data Descriptor로 정의된 객체는, 일반적으로 생각하는 것처럼 값을 갖고 메소드라는 행위를 갖지 않고, 대신 내가 원하는 Data(여기서는 _age라는 int 변수겠죠)에 대한 톨게이트와 같은 역할을 하게 됩니다.\n4. Property 장황한 이야기를 끝내고, 드디어 Property에 대한 이야기를 해보겠습니다. 앞서 보여드렸던 Property 사용 예시는 다음과 같습니다.\nclass Person :  def __init__(self, name, age) :  self._name = name  self._age = age   @property  def age(self) :  return self._age   @age.setter  def age(self, new_age) :  if new_age \u0026lt;= 0 :  raise Exception(\u0026#34;나이는 0 이하가 될 수 없습니다.\u0026#34;)  self._age = new_age Decorator에 대해서 이해하고 왔으니, @property 라는 코드를 통해, property 라는 함수(함수는 다시 객체이니 정확히는 property라는 객체겠죠)로 age 라는 메소드를 전달한다는 사실을 알 수 있습니다.\n따라서, 아래와 같은 코드는\n@property def age( ... ) :  ... 실질적으로는 다음과 같다고 볼 수 있겠죠.\nage = property(age) 아까전에 def my_func() 라는 코드는 my_func = {함수바디}와 같이 변수로 정의되는 것을 상상해볼 수 있다고 말씀드렸었는데요. 같은 맥락임을 확인할 수 있습니다. 왜냐하면, @property 데코레이터를 사용해 age = property(age)로, 즉 클래스 변수로 만들었기 때문입니다. (Descriptor는 반드시 클래스 변수에 있어야 한다는 사실을 떠올려보세요.)\n파이썬 공식 문서에 있는 property의 생김새는 다음과 같습니다.\nclass Property:  \u0026#34;Emulate PyProperty_Type() in Objects/descrobject.c\u0026#34;   def __init__(self, fget=None, fset=None, fdel=None, doc=None):  self.fget = fget  self.fset = fset  self.fdel = fdel  if doc is None and fget is not None:  doc = fget.__doc__  self.__doc__ = doc   def __get__(self, obj, objtype=None):  if obj is None:  return self  if self.fget is None:  raise AttributeError(\u0026#34;unreadable attribute\u0026#34;)  return self.fget(obj)   def __set__(self, obj, value):  if self.fset is None:  raise AttributeError(\u0026#34;can\u0026#39;t set attribute\u0026#34;)  self.fset(obj, value)   def __delete__(self, obj):  if self.fdel is None:  raise AttributeError(\u0026#34;can\u0026#39;t delete attribute\u0026#34;)  self.fdel(obj)   def getter(self, fget):  return type(self)(fget, self.fset, self.fdel, self.__doc__)   def setter(self, fset):  return type(self)(self.fget, fset, self.fdel, self.__doc__)   def deleter(self, fdel):  return type(self)(self.fget, self.fset, fdel, self.__doc__) 자, 이제 어떻게 코드가 동작하는지에 대해서 이해할 준비가 되었으니, 한 줄씩 따라가보며 총 정리해보겠습니다.\n@property def age( ... ) :  ... 위 코드를 통해 age = property(age) 가 실행된다고 말씀드렸었죠. property의 생성자 인자로 age라는 메소드를 넘겨줬으니, 이 age는 __init__ 메소드 내부에서 fget 이라는 변수에 할당됨을 확인할 수 있습니다. 그리고 @property를 적용한 Person 클래스의 현재 생김새는 다음과 같습니다.\nclass Person :  def __init__(self, name, age) :  self._name = name  self._age = age   def age(self) :  return self._age   age = property(age)   @age.setter  def age(self, new_age) :  if new_age \u0026lt;= 0 :  raise Exception(\u0026#34;나이는 0 이하가 될 수 없습니다.\u0026#34;)  self._age = new_age 다음으로 @age.setter 부분을 살펴봅니다. 현재 age는 property 객체인 상태입니다. 그러면 @age.setter는 다음과 같이 해석됩니다. age가 계속 나와 헷갈리니 주석을 참고하세요.\nage = property(age) # age(1번) = property(age(2번)) # age 라는 이름의 변수(1번)에 \u0026#39;age 메소드\u0026#39;(2번)를 인자로 넘긴 property 객체를 저장합니다. age = age.setter(age) # age(3) = age(1).setter(age(4)) # age라는 이름의 변수(3번)에, property 객체를 갖고 있는 age 변수(1번)의 setter 메소드에 새로운 age 메소드(4)를 넘겨줍니다. 그리고 setter 메소드를 살펴볼까요?\ndef setter(self, fset):  return type(self)(self.fget, fset, self.fdel, self.__doc__) type(self) 부분은 자기 자신에 대한 type을 구하고 있습니다. self는 property 이니 다음과 같이 해석됩니다.\ndef setter(self, fset):  return property(self.fget, fset, self.fdel, self.__doc__) 자기 자신에 대해서 생성자를 호출하고 있네요. 꼭 마치 자바에서 생성자에 this()와 비슷해 보입니다. 또한, 나머지는 self 키워드를 붙여서 자기 자신이 갖고 있던 녀석들을 넘겨주고, fset 위치에만 age(self, new_age) 라는 메소드를 넘겨주고 있습니다.\n이제 Person 객체에서 age를 접근할 때 무슨일이 일어날까요? p.age 로 꺼낸 age는 property 객체라는 사실은 이 쯤 되면 잘 아실거라 생각합니다. property 객체는 연이어 __get__ 메소드를 호출하겠죠.\ndef __get__(self, obj, objtype=None):  if obj is None:  return self  if self.fget is None:  raise AttributeError(\u0026#34;unreadable attribute\u0026#34;)  return self.fget(obj) __get__ 메소드의 인자 obj는 자기 자신을 실행한 인스턴스, objtype은 해당 클래스를 의미합니다. p.age로 인스턴스를 통해 실행했으니 obj는 p일 것이고, objtype 은 Person 이네요.\nobj가 None이 아니고, fget 또한 아까 할당되었으니, return self.fget(obj)가 실행됩니다.\n즉, fget(obj) 의 fget은 앞서 정의한 def age(self) 이니, 아까 내가 정의한 getter 메소드, 즉 다음 메소드가 실행됩니다.\ndef age(self) :  return self._age 다음으로 __set__ 메소드를 살펴볼까요? p.age = -10 이라고 작성했다면, 역시 p.age 변수가 갖고 있는 객체는 property 객체이고, 해당 객체의 __set__ 메소드가 호출됩니다.\ndef __set__(self, obj, value):  if self.fset is None:  raise AttributeError(\u0026#34;can\u0026#39;t set attribute\u0026#34;)  self.fset(obj, value) 마찬가지로 obj는 자기 자신을 실행한 인스턴스, 즉 p 이고, value는 -10 입니다. fset 변수는 앞서 할당한 def age(self, new_age) 함수 객체이고, None이 아니니 self.fset(obj, value)를 실행합니다. 즉, 다음 메소드가 실행됩니다.\ndef age(self, new_age) :  if new_age \u0026lt;= 0 :  raise Exception(\u0026#34;나이는 0 이하가 될 수 없습니다.\u0026#34;)  self._age = new_age 마지막으로 __delete__ 는 __setter__와 같으니 추가적으로 다루지는 않겠습니다.\n5. 마무리 여러 개념을 융합해서 새로운 개념을 이해하는 것은 언제나 어려운 일이기 때문에 꽤 구구절절 설명하는 경향도 없잖아 있었습니다. 그러다보니 약 600줄에 가까운 글이 되었습니다.\n그렇기에 한줄한줄 곱씹어가며 글을 읽으셨다면 크게 어렵지 않으셨을 것이라 생각합니다. 그 동안 프로퍼티를 사용만 하고 그 동작 원리에 대해 잘 모르셨던 분들에게 좋은 설명이 되었기를, 그리고 기존 프로그래밍의 사고를 확장시킬 수 있는 계기가 되었기를 바랍니다.\n감사합니다.\n Reference  Python의 Closure에 대해 알아보자 Wikidocs 레벨업 파이썬 - 클로저 Python 공식문서 - Descriptor Hardcore in Programming - Descriptor [Python 지식]- Descriptor 우선순위  ","permalink":"http://cjlee38.github.io/post/language/python/2021-09-16-journey-to-property/","summary":"Note 1. 개인적으로 공부해가며 작성한 글이기 때문에 틀린 내용이 있을 수 있습니다. 틀린 내용을 발견하시면 언제든 지적 부탁드립니다.\nNote 2. 이해를 돕기 위해 일부 내용은 Java와 비교해가며 글을 작성했습니다.\n 0. 들어가며 : 한동안 Java를 애용하다가, Python을 다뤄야 하는 일이 생겨서 다시 Python을 붙잡게 되었습니다. Java의 syntax에 대해서 어느정도 이해하고 있다고 자만하던 중이었기 때문에, Python을 사용하면서 \u0026ldquo;왜 Python에는 Java의 이런 기능이 없지? 역시 Java가 짱이야\u0026rdquo; 라는 생각도 하곤 했습니다.","title":"# (Python) @Property까지 가는 길"},{"content":"Java Generic 2 0. 들어가며 지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다. 그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.\npublic class MyList\u0026lt;T\u0026gt; {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } private Object[] array 그리고 this.array = new Object[capacity]; 이 부분인데요. 얼핏 생각하면 private T[] array this.array = new T[capacity]; 이렇게 생성하면 더 깔끔할 것 같은데, 왜 그렇게 하지 않을까요? 여기에는 (저에게) 복잡한 엔지니어링의 철학이 스며들어있는데요. 이를 자세히 살펴보겠습니다.\n1. Basis (1) Covariant vs Contravariant vs Invariant 갑작스럽게 익숙치 않은 두 단어가 나타납니다. covariant는 공변, contravariant는 반공변, invariant는 무공변 이라는 단어로 해석되는데, 단어만 놓고 봤을때는 무슨 의미인지 파악하기가 조금 어렵습니다. 간략하게 정리하자면 다음과 같습니다.\n A, B 가 타입이고, f는 타입의 변경이라고 가정합니다.\n B가 A의 서브타입일 때, f(B)는 f(A)의 서브타입이다. -\u0026gt; 이 때 f는 공변입니다. B가 A의 서브타입일 때, f(A)는 f(B)의 서브타입이다. -\u0026gt; 이 때 f는 반공변입니다. A와 B가 아무런 관계를 갖지 않는다 -\u0026gt; 이 때 f는 무공변입니다.   헷갈리니, 조금 더 자세히 풀어봅시다. 자바에서 배열은 다음과 같이 작성할 수 있습니다.\nObject[] array = new String[10]; Object와 String은 하나의 타입이고, 따라서 배열의 경우 f(Object)는 Object[] 로 만드는 것이고, f(String)은 String[] 이 되겠죠. 이러한 경우에, String[] 은 Object[] 의 서브타입이 될 수 있으므로, 공변입니다.\n한편, 제네릭은 어떨까요?\nList\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); 위와 같은 코드는 컴파일 되지 않습니다. 당연히, List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;Object\u0026gt;();와 같은 반공변 코드도 안되겠죠. 따라서 제네릭은 무공변입니다. 즉, 제네릭은 타입을 가지고 상속관계를 결정지을 수 없다는 얘기가 되죠. List와 List은 얼핏 생각하기에 상속관계를 가질 것 같지만, 실제로 둘은 관계가 없습니다.\n Note 1. 하지만 같은 타입이라면 상속관계가 성립합니다. 즉, Collection과 List, 그리고 ArrayList은 추이적 관계를 갖습니다.\n  Note 2. 공변, 반공변, 무공변 등은 프로그래밍 언어의 설계적인 특성입니다. 가령, 다음과 같은 코드는 자바에서 올바르게 Override 할 수 있습니다.\nclass Super { \tObject getSomething() {} } class Sub extends Super { \tString getSomething() {} } 이를 Covariant Return Type 이라고 부르고, JDK 1.5 부터 생겨난 기능입니다.\n한편, 다음과 같은 코드는 자바에서 Override가 아닌, Overload 됩니다. 타 언어에서는 Override가 가능합니다.\nclass Super { \tvoid doSomething(String param) { ... } } class Sub extends Super { \tvoid doSomething(Object param) { ... } }  2. Basis (2) Type Erasure Type Erasure는 제네릭이 JDK 1.5부터 도입되었기 때문에, 이전 버전에 작성된 코드와의 호환성을 위해 도입된 기능입니다. Type Erasure의 기능은 다음 세 가지로 요악할 수 있습니다.\n 제네릭의 타입 파라미터(e.g. T)를 일반적인 클래스, 인터페이스 등으로 교체합니다. 만약 bound(경계)가 명시되어 있는 경우, 해당 bound로 교체하고, unbounded(경계가 없는) 인 경우 Object로 교체합니다. 필요하다면, 타입 캐스팅을 집어 넣습니다. 다형성을 유지하기 위해, 브릿지 메소드를 생성합니다.  2번은 간단하니, 1번과 3번만 살펴봅시다\n2-1. Replace Type Parameters 다음과 같은 코드가 있다고 가정해봅시다.\npublic class Node\u0026lt;T\u0026gt; {   private T data;  private Node\u0026lt;T\u0026gt; next;   public Node(T data, Node\u0026lt;T\u0026gt; next) {  this.data = data;  this.next = next;  }   public T getData() { return data; }  // ... } 여기서 T는 unbounded, 즉 경계가 없기 때문에 다음과 같이 Object로 교체됩니다.\npublic class Node {   private Object data;  private Node next;   public Node(Object data, Node next) {  this.data = data;  this.next = next;  }   public Object getData() { return data; }  // ... } 만약 T가 다음과 같이 Comparable이라는 경계를 갖고있다면,\npublic class Node\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; {   private T data;  private Node\u0026lt;T\u0026gt; next;   public Node(T data, Node\u0026lt;T\u0026gt; next) {  this.data = data;  this.next = next;  }   public T getData() { return data; }  // ... } 해당 bound의 클래스(혹은 인터페이스) 로 교체됩니다.\npublic class Node {   private Comparable data;  private Node next;   public Node(Comparable data, Node next) {  this.data = data;  this.next = next;  }   public Comparable getData() { return data; }  // ... } 여기서 말하는 \u0026ldquo;경계\u0026rdquo; 가 무엇인지 모르셔도 괜찮습니다. 다음 3편에서(😂) 설명하겠습니다.\n2-2. Bridge Method Bridge Method는 타입 삭제로 인해 발생할 수 있는 문제를 해결하기 위해 나타난 기능입니다. 다음과 같은 코드가 있다고 가정해봅시다.\npublic class Node\u0026lt;T\u0026gt; {   public T data;   public Node(T data) { this.data = data; }   public void setData(T data) {  System.out.println(\u0026#34;Node.setData\u0026#34;);  this.data = data;  } }  public class MyNode extends Node\u0026lt;Integer\u0026gt; {  public MyNode(Integer data) { super(data); }   public void setData(Integer data) {  System.out.println(\u0026#34;MyNode.setData\u0026#34;);  super.setData(data);  } } 그리고, 위와 같이 정의된 클래스를 다음과 같이 사용하겠습니다.\nMyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning n.setData(\u0026#34;Hello\u0026#34;); // Causes a ClassCastException to be thrown. Integer x = mn.data; 타입 제거가 발생한다면, 컴파일 이후는 다음과 같은 모습일텐데요.\nMyNode mn = new MyNode(5); Node n = (MyNode)mn; // A raw type - compiler throws an unchecked warning n.setData(\u0026#34;Hello\u0026#34;); // Causes a ClassCastException to be thrown. Integer x = (String)mn.data; 실제로 실행하려고 보면, ClassCastException 이라는, 다소 당황스러운 에러 메시지가 발생하게 됩니다. 그 이유는, 위에 정의된 Node, 그리고 MyNode의 타입 제거 이후의 모습과, 브릿지 메소드가 생성되었을 때의 모습을 살펴보면 알 수 있습니다. 가장 먼저, 타입 제거가 된 모습은 다음과 같습니다.\npublic class Node {   public Object data;   public Node(Object data) { this.data = data; }   public void setData(Object data) {  System.out.println(\u0026#34;Node.setData\u0026#34;);  this.data = data;  } }  public class MyNode extends Node {   public MyNode(Integer data) { super(data); }   public void setData(Integer data) {  System.out.println(\u0026#34;MyNode.setData\u0026#34;);  super.setData(data);  } } 위 코드를 보면, MyNode가 Node 클래스를 상속하고 있는데, Node \u001b클래스의 setData() 메소드와 MyNode 클래스의 setData() 메소드의 시그니처가 다릅니다. 하나는 Object를, 하나는 Integer를 파라미터로 받고 있는데요. 이렇게 될 경우 setData 메소드는 override가 아닌 overload 가 되겠죠. 코드가 여기까지만 변환되었다면, n 변수가 호출하는 setData 메소드는 mn 변수가 호출하는 setData는 다른 메소드이니 문제가 발생하게 됩니다. 즉, 다형성을 유지할 수 없어지게 되는데요. 이러한 문제를 해결하기 위해, 컴파일러는 다음과 같은 메소드를 클래스 내에 삽입합니다.\npublic void setData(Object data) {  setData((Integer) data); } 이러한 메소드를 브릿지 메소드라 부르고, 해당 메소드내에 있는 (Integer) 캐스팅으로 인해 ClassCastException이 발생하게 됩니다.\n3. So \u0026hellip; 본격적으로 왜 Object[] array를 만들수 없는지에 대해 알아보겠습니다. 타입 파라미터 형태의 배열을 만들 수 없는 이유를 말하는데 뭐 이리 잡설이 기냐 라고 얘기할 수도 있겠습니다만, 이러한 요소들을 이해하고 있지 않으면, 그 이유를 이해하기가 어렵기 때문입니다.\n앞서, 자바의 배열은 공변이라고 말씀드렸습니다. 따라서, 다음과 같은 코드는 문제가 없습니다.\nObject[] array = new String[10]; 하지만, 반공변은 아니기 때문에, 다음과 같은 코드는 당연히 실행할 수 없겠죠.\nObject[] array = new Object[10]; Integer[] iarray = array; 그렇다면 지난 시간의 MyList 코드를 가져와서, 타입 파라미터의 배열을 만들 수 있다고 가정해보겠습니다. 그리고, 해당 배열을 가져오는 함수도 하나 만들어보죠.\npublic class MyList\u0026lt;T\u0026gt; {  private final int capacity = 10;  private int size;  private T[] array;   public MyList() {  this.array = new T[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  }   // 새로 추가한 코드  public T[] getArray() {  return array;  }  } 그리고, 다음과 같이 사용해보겠습니다.\nMyList\u0026lt;String\u0026gt; myList = new MyList\u0026lt;\u0026gt;(); String[] array = myList.getArray(); 겉보기에는 멀쩡해보이는데요. myList에서 얻어온 getArray() 는 타입 파라미터로 넣어준 String[]의 배열이고, 이를 String[] array 에서 받아내고 있으니까요.\n그런데, 앞서 이야기 했던 Type Erasure에 대해 다시 생각해보겠습니다. Type Erasure는 Unbounded인 경우 타입 파라미터를 모두 Object로 교체한다고 했었는데요. 그렇다면 실제 컴파일 이후 MyList의 생성자 부분 코드는 this.array = new Object[capacity]; 이겠네요. 역시 마찬가지로, getArray() 함수 또한 Object[] 배열을 돌려줄 것이구요. 그런데 이를 String[] 배열에서 받아내고 있습니다. 이는 금방 보았던 공변성에 어긋나게 되고, 문제가 발생하게 됩니다.\n4. Plus 4-1. Casting to Type Parameter\u0026rsquo;s array 타입 파라미터의 배열 생성이 불가능하다면, Object의 배열을 생성한 뒤, 타입 파라미터로 캐스팅하는 것은 어떨까요? 즉 다음과 같습니다.\nT[] array = (T[]) new Object[10]; 이 또한 괜찮은 선택지인 것 처럼 보이지만, 실제로는 잘못된 다운캐스팅(Downcasting) 으로 인해 실패하게 됩니다. 생성하는 객체가 Object 객체의 배열이기 때문에, 이를 다른 타입의 객체 배열로 캐스팅하는 것은 성립이 되지 않습니다. 다운캐스팅은 다음과 같이 실제로 생성하는 객체가 해당 타입이거나, 혹은 그 상위일때에만 가능합니다.\nObject[] array = new String[10]; String[] sArray = (String[]) array; 여기서 new String[10]; 을 new Object[10]; 으로 바꾸게 되면 ClassCastException이 발생합니다.\n4-2. Array of Generic Class 다음으로 살펴볼 예시는, 제네릭 클래스의 배열입니다.\nList\u0026lt;String\u0026gt;[] arrOfList = new ArrayList\u0026lt;String\u0026gt;[10]; 이와 같은 코드는 실제로 컴파일 되지 않지만, 가능하다고 가정해봅니다.\nObject[] objarr = arrOfList; objarr[0] = new ArrayList\u0026lt;Integer\u0026gt;(); 이 때, 위와 같이 코드를 작성하면, 문제가 발생하지 않습니다. Type Erasure로 인해 런타임 당시에는 결국 List\u0026lt;String\u0026gt;[] 이 아닌 List[] 니까요. 위에서는 List만 받기로 했는데, List를 할당하고 있으니 예외가 발생해야 하는데, 그렇지 않죠. 애초에 제네릭의 탄생 목적이 사용하는 타입의 안정성을 보장하기 위한 것인데(즉, 제한된 종류의 타입만 한정지어서 사용하도록 하고, 이에 관련된 문제는 컴파일 도중에 잡아낼 수 있도록이죠), String을 넣기로 약속한 곳에 Integer를 넣을 수 있다면 제네릭의 안정성이 전혀 보장될 수 없습니다. 그렇기 때문에 애초에 Generic Array Creation 이라는 경고 문구가 등장합니다.\n예외가 발생한다고 해서, 다음과 같은 코드를 작성해서도 안됩니다.\nList\u0026lt;String\u0026gt;[] listOfArr = new ArrayList[10]; 아예 제네릭을 빼버리는건데요. 그러면 다음과 같이 흐름이 이어질 경우 역시 타입 캐스팅 도중에 ClassCastException이 발생하게 됩니다.\nObject[] objarr = listOfArr;  List\u0026lt;Integer\u0026gt; iList = new ArrayList\u0026lt;\u0026gt;(); iList.add(123); objarr[0] = ilist;  System.out.println(strlistarr[0].get(0)); // exception occurs here 억지를 부려서 List\u0026lt;String\u0026gt;만 받기로 약속한 listOfArr 에 List\u0026lt;Integer\u0026gt;를 넣어줬는데요. 꺼낼때에는 listOfArr은 \u0026ldquo;당연히 내 안에 들어있는 녀석들은 String이겠군\u0026rdquo; 하고 캐스팅을 하려다 문제가 발생하게 됩니다. 지난 편에 제네릭을 소개할 때 보여드렸던, 실수할 수 있는 케이스와 결국 같은 맥락입니다.\n지금까지 제네릭 속에 들어있는 프로그래밍 이론에 관해서 다뤄보고, 이에 기인한 제네릭의 주의점에 대해서 알아보았습니다. 꽤나 복잡하고 많은 양을 다루었다고 생각했는데, 아직도 갈 길이 멉니다. 다음 시간에는 타입 경계, 그리고 와일드카드에 대해서 이야기해보고자 합니다. 감사합니다.\n5. Reference 공변성과 반공변성은 무엇인가? | edykim java - How to create a generic array? - Stack Overflow Covariance and contravariance (computer science) - Wikipedia\n","permalink":"http://cjlee38.github.io/post/language/java/2021-08-29-java-generics-2/","summary":"Java Generic 2 0. 들어가며 지난 시간에는 제네릭이 왜 필요한지, 어떻게 사용하는지, 그리고 어떻게 만들 수 있는지 등에 대해 살펴봤습니다. 그런데 한 가지, List 를 흉내낸 MyList 의 경우 생성자에서 여전히 Object 형을 사용했었습니다. 지난 시간의 코드를 다시 가져와보겠습니다.\npublic class MyList\u0026lt;T\u0026gt; {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } private Object[] array 그리고 this.","title":"# 제네릭 톺아보기 2"},{"content":"0. 들어가며 제네릭은 Java Collection Framework 를 사용하면 필연적으로 마주치는 문법 중 하나입니다. 처음 보았을 때에는 \u0026lt;\u0026gt; 형태의 다이아몬드가 당황스럽지만, 몇 번 써보고 나면 그리 어려운 개념이 아니라는걸 알게 되죠. 하지만 이건 사용자 관점일 뿐, 제네릭을 한 번이라도 만들어보려고 하면 손가락이 멈칫하게 됩니다.(특히 제가 그렇습니다.) 매 번 제네릭과 관련한 무언가를 만들어보려고 할 때마다 다시 찾아보는 것이 지겨워서, 직접 한 번 정리해볼까 합니다.\n1. Why Use Generics ? 제네릭은 클래스(혹은 인터페이스, 메소드)를 정의할 때, Type 을 파라미터로 넘겨줄 수 있도록 하는 녀석입니다. 조금 바꿔 말하면, 같은 클래스여도 그 내부에 들어있는 필드나 메소드의 속성을 다르게 정의 할 수 있다는 뜻이 됩니다. 간단하게 예시를 살펴보겠습니다.\nJava Collection Framework 안에 있는 ArrayList를 간단하게 직접 만들어보겠습니다.\npublic class MyList {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(Object o) {  array[size++] = o;  }   public Object get(int index) {  return array[index];  } } 해당 MyList 안에는, 객체가 담길 수 있는 Object 형의 배열이 있고, 크기는 10 으로 할당해주었습니다. 이는 해당 리스트 안에는 어떠한 객체도 들어올 수 있다는 말이 되죠. 또 다시 바꿔 말하면, 이 안에는 String이 들어올수도, Integer가 들어올 수도 있다는 말이 됩니다. 따라서, 다음과 같이 사용해야 합니다.\npublic class Main {  public static void main(String[] args) {  MyList myList = new MyList();  myList.add(\u0026#34;hello world!\u0026#34;);  myList.add(123);  String str = (String) myList.get(0);  Integer integer = (Integer) myList.get(1);  } } 이렇게 매 번 값을 꺼내올 때마다 타입을 캐스팅 해줘야 하죠. 의도한 것이라면 다행이지만, 의도하지 않았다면 실수할 여지가 다분합니다. String 만 넣고 싶은데, 실수로 Integer를 넣는다면 상당히 골치 아파지겠죠. 그렇다면 이를 방지하기 위해서, 각 타입마다 MyList를 만들어주어야 할까요?\npublic class MyStringList {  private final int capacity = 10;  private int size;  private String[] array;   public MyStringList() {  this.array = new String[capacity];  }   public void add(String o) {  array[size++] = o;  }   public String get(int index) {  return array[index];  } }  public class MyIntegerList {  private final int capacity = 10;  private int size;  private Integer[] array;   public MyIntegerList() {  this.array = new Integer[capacity];  }   public void add(Integer o) {  array[size++] = o;  }   public Integer get(int index) {  return array[index];  } } 얼핏 보아도, 중복되는 코드가 상당히 거슬립니다. String, Integer 와 같은 녀석을 동적으로 넘겨줄 수 있다면 좋을텐데요. 앞서 했던 말을 다시 살펴보겠습니다.\n 제네릭은 클래스(혹은 인터페이스, 메소드)를 정의할 때, Type 을 파라미터로 넘겨줄 수 있도록 하는 녀석입니다.\n 다시 보니 제네릭이 어떤 부분에서 도움을 줄 수 있는지 알 수 있을 것 같습니다. 이렇게 특정 타입을 동적으로 넘겨주어 제한시킬 수도 있지만, 또 다른 강점은 컴파일 타임에 이를 검사할 수 있다는 점입니다. 만약 이러한 기능이 없었다면, 캐스팅을 시도하는 코드가 실행되기 전까지는 올바른 코드인지 기계적으로 알아낼 수 있는 방법이 없겠죠.\n2. Generics Basic 그렇다면 제네릭을 왜 써야 하는지까지는 배웠습니다. 그렇다면 어떻게 만들 수 있을지 한번 살펴보겠습니다.\npublic class MyList\u0026lt;T\u0026gt; {  private final int capacity = 10;  private int size;  private Object[] array;   public MyList() {  this.array = new Object[capacity];  }   public void add(T o) {  array[size++] = o;  }   public T get(int index) {  return (T) array[index];  } } 변화한 점은 다음과 같습니다.\n 클래스의 이름 뒤에 \u0026lt;T\u0026gt; 라는 녀석이 생겼습니다. 이 T가 의미하는 바가 무엇인지는 차차 살펴보기로 합시다. 우선은 T 라는 이름으로 Type을 제한한다는 점만 알아둡시다. 어쨌든 이 녀석은 \u0026ldquo;T 라는 이름의 제네릭을 사용하겠다\u0026rdquo; 라는 의미를 갖게 됩니다. add 메소드와 get 메소드에 T 가 붙었습니다. 이는 클래스 이름 뒤에 새로 생겼던 T 를 활용하는 부분입니다. 만약 MyList의 Type 을 String으로 지정한다면, add 메소드는 파라미터로 String o 라는 녀석을 파라미터로 받게 될겁니다.  여기서 한 가지 신경쓸 점은, array 배열은 여전히 Object 형 이라는 점 입니다. 이 부분은 꽤 복잡한 개념을 다루어야 하므로 2편에서 다루겠습니다.\n Type Parameter Naming Convetions\n앞서 클래스의 이름 뒤에 \u0026lt;T\u0026gt;가 새로 생겼다고 말씀드렸는데요. 이 T 라는 이름은, 정해진 문법이 아닌 일종의 \u0026ldquo;약속\u0026rdquo; 입니다. 즉, Convetion 이죠. 오라클 공식 문서에서는 다음과 같이 설명하고 있습니다.\nE - Element (used extensively by the Java Collections Framework)\nK - Key\nN - Number\nT - Type\nV - Value\nS,U,V etc. - 2nd, 3rd, 4th types\n 이렇게 만든 제네릭은, 다음과 같이 사용하면 됩니다. 간단하네요.\npublic class Main {  public static void main(String[] args) {  MyList\u0026lt;String\u0026gt; temp = new MyList\u0026lt;String\u0026gt;();  temp.add(\u0026#34;World Hello ?\u0026#34;);  System.out.println(temp.get(0));  } } 한 가지 기존 ArrayList와 다른 점이 있다면, new MyList\u0026lt;String\u0026gt;() 인데요. 자세히 보면 \u0026lt;String\u0026gt; 이라는 녀석이 두 번이나 들어갔습니다. 기존의 ArrayList\u0026lt;\u0026gt;() 와는 대비되죠. 사실, MyList\u0026lt;\u0026gt;()라고 작성해도 됩니다. 이는 컴파일러가 갖고 있는 타입 추론 이라는 기능에 의한 것입니다. 여기서는 자세히 다룰 내용이 아니니, 궁금하신 분은 여기 를 참고해보시면 되겠습니다.\n또한, 제네릭에 사용할 Type Parameter는 다음과 같이 여러 개가 될 수 있습니다.\nclass Pair\u0026lt;K, V\u0026gt; {  private K key;  private V value;   public Pair(K key, V value) {  this.key = key;  this.value = value;  }   public K getKey() { return key; }  public V getValue() { return value; } } 3. Generic Method 제네릭은 클래스 뿐만 아니라, 메소드에 한정해서 사용할 수도 있습니다.\npublic class Util {  public static \u0026lt;T\u0026gt; void print(T t) {  System.out.println(t.toString());  }   public static \u0026lt;K, V\u0026gt; boolean compare(Pair\u0026lt;K, V\u0026gt; p1, Pair\u0026lt;K, V\u0026gt; p2) {  return p1.getKey().equals(p2.getKey()) \u0026amp;\u0026amp;  p1.getValue().equals(p2.getValue());  } } 위와 같이 ReturnType 바로 앞에 Type Parameter를 명시함으로서 제네릭 메소드임을 알리고, 메소드 파라미터 혹은 그 내부에서 다음과 같이 제네릭을 사용할 수 있죠. 역시 마찬가지로, 사용할 때에는 아래와 같이 사용하면 됩니다.\npublic class Main {  public static void main(String[] args) {  String str = \u0026#34;Hello world!\u0026#34;;  Util.test(str);   Pair\u0026lt;String, Integer\u0026gt; pair1 = new Pair\u0026lt;\u0026gt;(\u0026#34;FOO\u0026#34;, 1);  Pair\u0026lt;String, Integer\u0026gt; pair2 = new Pair\u0026lt;\u0026gt;(\u0026#34;BAR\u0026#34;, 2);  Util.\u0026lt;String, Integer\u0026gt; compare(pair1, pair2);  Util.compare(pair1, pair2); // 타입 추론에 의해 생략 가능  } } 지금까지 기본적인 제네릭의 생성, 그리고 사용법에 대해 알아봤습니다. 다음에는 제네릭을 사용할 때의 주의점에 대해 알아보겠습니다.\n","permalink":"http://cjlee38.github.io/post/language/java/2021-08-10-java-generics-1-copy/","summary":"0. 들어가며 제네릭은 Java Collection Framework 를 사용하면 필연적으로 마주치는 문법 중 하나입니다. 처음 보았을 때에는 \u0026lt;\u0026gt; 형태의 다이아몬드가 당황스럽지만, 몇 번 써보고 나면 그리 어려운 개념이 아니라는걸 알게 되죠. 하지만 이건 사용자 관점일 뿐, 제네릭을 한 번이라도 만들어보려고 하면 손가락이 멈칫하게 됩니다.(특히 제가 그렇습니다.) 매 번 제네릭과 관련한 무언가를 만들어보려고 할 때마다 다시 찾아보는 것이 지겨워서, 직접 한 번 정리해볼까 합니다.\n1. Why Use Generics ? 제네릭은 클래스(혹은 인터페이스, 메소드)를 정의할 때, Type 을 파라미터로 넘겨줄 수 있도록 하는 녀석입니다.","title":"# 제네릭 톺아보기 1"},{"content":"0. 들어가며 코딩테스트를 준비하는 여러분 중 대부분은 아마 백준이나 프로그래머스를 많이 사용하실텐데요. 해당 사이트에서 주어지는 환경 날 것을 그대로 사용하기는 아무래도 어렵고, IDE 에서 코드를 작성한 뒤 복사 붙여넣기 하는 경우가 대부분일 것 같습니다.\n저는 자바를 좋아하는데, 프로그래머스에서는 클래스 내의 함수를 작성하는 형태로 문제가 주어지기 때문에, 그닥 어렵지 않게 코드를 작성하고, 또 그 결과를 확인할 수 있는 반면, 표준 입출력을 활용하는 백준은 코드 작성이 조금 귀찮은 편입니다.\n상대적으로 코드가 (조금 더) 긴 BufferedReader 클래스를 활용해야 조금 더 빠른 입출력이 가능하다는 점이나 , 코드가 올바르게 작성됐는지 확인하기 위해 표준 입력에 매번 테스트케이스를 복사해서 넣어주어야 한다는 점이 그렇죠.\n제가 지금까지 작업해왔던 방식을 생각해보면 다음과 같습니다.\n 문제를 읽어본다. 어떻게 문제를 풀지 생각하면서, IDE 내에 코드를 작성한다. 완성된 코드를 실행한다. 예제 입력을 클립보드에 복사하고, 이를 표준 입력에 붙여 넣는다. 결과가 올바른지 확인한다.  이 과정을 조금 간소화하고자, Live Template 그리고 Junit 을 이용하기로 했습니다.\n1. Live Template Live Template은, 코드의 템플릿을 저장해두면, 코드의 작성을 편리하게 사용할 수 있도록 해주는 intellij의 기능 중 하나입니다. 지금까지 코드를 작성하면서, sout , psvm, main, iter 등 다양한 축약을 이용해왔는데, 이 녀석들이 바로 Live Template 이었습니다.\n해당 설정은 다음에서 확인할 수 있습니다.\n Preferences -\u0026gt; Editor -\u0026gt; Live Template\n Java 부분을 살펴보니, 지금껏 사용했던 것들 이외에도 여러 유용한 것들이 있는 것을 볼 수 있습니다. 이것은 나중에 천천히 살펴보기로 하고, 우선 우측 상단의 + 버튼부터 눌러봅시다.\n1. Live Template 2. Template Group  의 두 가지 항목이 있을텐데요. 템플릿 그룹을 먼저 만든 뒤, 해당 그룹에 내가 만든 템플릿을 넣어보도록 하겠습니다. 템플릿 그룹은 간단하게 이름만 지어주면, 해당 그룹이 생긴것을 볼 수 있는데요. 저는 좀 눈에 띄게 -*- custom-*- 이라고 만들었습니다.\n기존에 제가 만들어둔 템플릿도 보이네요. 해당 내용은 잠시 후에 보여드리는 것으로 하고, 손댈 부분만 살펴보면 다음과 같습니다.\n  Abbreviation : 사용할 축약어를 의미합니다. 가령 sout, psvm 정도가 되겠네요. Description : 일종의 주석입니다. 해당 축약어의 설명 정도로 표현할 수 있겠네요. Template Text : 실제 나타날 코드가 작성될 부분입니다. Edit Variables : 템플릿에서 사용할 변수에 대한 상세한 내용을 작성할 수 있습니다.   1, 2번이야 쉽게 쓸 수 있지만, 3,4 번은 조금 난해하게 다가옵니다. 이럴 때엔 남에꺼 보고 베끼는게 최고입니다. 다시 Java 탭으로 돌아가서, 대충 iter 를 한번 살펴봅시다.\n더더욱 모르겠습니다. 방금 했던 말은 취소하고, 역시 공식 문서를 봅시다.\nLive template variables , IntelliJ IDEA\n공식 문서를 보고 오니 대충 알 것 같습니다. $ $ 기호로 묶어서 변수를 정의할 수 있고, 이에 대한 내용은 predefined functions 를 활용해서 좀 더 편하게 작성할 수 있다는 것처럼 보이네요. 본 포스팅에서의 핵심은 Live template이 아니니 대충 이정도만 알고 넘어가도 될 것 같습니다.\n앞서 생성했던 템플릿으로 돌아와서, 마저 작성해봅니다. Abbreviation 은 temp, Description은 생략하고, Template text에 다음과 같이 입력했습니다.\nimport java.io.*; import java.util.StringTokenizer;  public class bj$NUMBER$ {   private static StringTokenizer st;   public static void main(String[] args) throws IOException {  try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));) {   // == do == //    // == done //  } catch (Exception e) {  e.printStackTrace();  }  }   private static StringTokenizer tokenize(BufferedReader br) throws IOException {  return new StringTokenizer(br.readLine());  }   private static int bInt(BufferedReader br) throws IOException {  return Integer.parseInt(br.readLine());  }   private static int sInt(StringTokenizer st) {  return Integer.parseInt(st.nextToken());  }   static class Solution {   public int run() {   return -1;  }   } // end of class } 제가 기존에 주로 사용하던 형태는 이와 같습니다. 몇 가지 편의를 위해 tokenize, bInt 와 같은 함수도 추가했습니다. 클래스 이름쪽도 한번 살펴보면, bj$NUMBER$ 와 같은 형태로 구성되어 있습니다. 해당 bj부분에 문제 번호를 입력할 예정입니다.\n이렇게 작성하고나서, No applicable contexts 옆의 Define 을 눌러서, Java 를 체크해줍시다.\n그리고, java 파일을 하나 생성해서, temp 입력 후 tab 을 눌러 잘 동작하는지 확인해봅니다.\n한 단계만 더 나가보겠습니다. 저는 각 문제마다 주석을 다는데, 예시는 다음과 같습니다.\n/** * uri = https://www.acmicpc.net/problem/2573 * name = 빙산 * tier = gold 4 * date = 2021-07-29, 목, 20:3 */ 따라서, 템플릿 텍스트는 다음과 같이 써주었는데요.\n/** * uri = https://www.acmicpc.net/problem/$NUMBER$ * name = $NAME$ * tier = $TIER$ * date = $DATE$ */  public class bj$NUMBER$ { ... } 여기서 다른 부분은 어쩔 수 없이 수기로 입력해야 하지만, 날짜는 아무래도 현재시각으로 자동으로 입력되면 좋겠죠. 아까 보았던 Edit variables 버튼을 눌러봅시다.\n저는 Live template variables, IntelliJ IDEA 에서 다음과 같은 내용을 확인했기 때문에, 이를 활용해서 작성했습니다.\n이렇게 까지 해주면, 크게 불편함 없이 템플릿을 활용할 수 있습니다.\npackage BOJ;  import java.io.*; import java.util.StringTokenizer;  /** * uri = https://www.acmicpc.net/problem/TEMP * name = * tier = * date = 2021-07-30, 금, 7:53 */  public class Temp { ... } 2. JUnit JUnit은 스프링을 공부하면서 손쉽게 사용할 수 있었는데요. Gradle 혹은 Maven 기반의 프로젝트로 생성되다 보니, 의존성만 추가하면 사용하는데에 큰 무리가 없었습니다. 문제는 지금까지 PS 로 사용하고 있던 프로젝트가 일반적인 Java 프로젝트 였다는 것입니다. 찾아보니, Intellij에서 Maven 프레임워크를 추가할 수 있는 기능을 제공하고 있었습니다.\n좌측 프로젝트 탭에서, 최상위 경로인 PS를 우클릭하면, 위와 같이 Add Framework Support 를 볼 수 있습니다. 클릭하고, Maven을 추가하면 됩니다. 그리고 역시, pom.xml 에 Junit 의존성을 추가해주었습니다.\n\u0026lt;dependencies\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.7.0\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;  \u0026lt;/dependency\u0026gt;   \u0026lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junit-jupiter-engine\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.7.0\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;  \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 다음 문제는, \u0026ldquo;어떻게 테스트 케이스를 작성할 것인가?\u0026rdquo; 입니다. 기존에 터미널에 입력하던 표준 입출력을, 문자열로 다룰 수 있어야 하는데요. BufferedReader 클래스의 인자로 넘겨주는 Reader 추상 클래스를 구현하는 클래스를 넘겨줄 수도 있겠습니다만, 문제는 Writer 입니다. 기존의 코드를 수정하지 않고 표준 출력을 문자열로 받아내고 싶었습니다. 찾아보니, System.setOut() 혹은 System.setIn() 메소드를 통해, 적절하게 입출력 스트림 자체를 제어할 수 있었습니다.\n그리고 여기에 ByteArrayInputStream과 ByteArrayOutputStream 을 세팅해서, ByteArray로부터 읽고, ByteArray로 쓸 수 있도록 해봅시다.\nByteArrayInputStream inputStream = new ByteArrayInputStream(inputExample.getBytes(StandardCharsets.UTF_8)); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); System.setOut(new PrintStream(outputStream)); System.setIn(inputStream); 잘 동작하는지 확인하기 위해, 가장 쉬운 1000번 문제인 A + B 를 테스트해보겠습니다.\n@Test public void test() throws Exception {  // given  String inputExample = \u0026#34;3 4\u0026#34;; // 예제 입력   ByteArrayInputStream inputStream = new ByteArrayInputStream(inputExample.getBytes(StandardCharsets.UTF_8));  ByteArrayOutputStream outputStream = new ByteArrayOutputStream();  System.setOut(new PrintStream(outputStream));  System.setIn(inputStream);   // when  Temp.main(new String[]{}); // 테스트 실행   // then  String outputExample = outputStream.toString();  assertEquals(outputExample, \u0026#34;8\u0026#34;); // 결과 확인 } 3 + 4 는 8이 아니니, 에러가 발생해야 합니다. 결과는 다음과 같습니다.\n마지막으로, 해당 테스트는 IDE 에서만 사용할 것이므로, 반복되는 코드를 제거하고자 해당 Input / Output Stream 을 하나의 클래스로 만들겠습니다.\npublic class StreamHandlerForTest {   private ByteArrayInputStream inputStream;  private ByteArrayOutputStream outputStream;   public StreamHandlerForTest(String input) {  inputStream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));  outputStream = new ByteArrayOutputStream();  System.setIn(inputStream);  System.setOut(new PrintStream(outputStream));  }   public String get() {  return outputStream.toString();  } } 그리고, 테스트는 여러개가 들어갈 수 있으니, Parameterized Test를 사용해서 다음과 같이 깔끔하게 정리하겠습니다.\nclass TempTest {   private StreamHandlerForTest handler;   @ParameterizedTest  @MethodSource(\u0026#34;provideParameters\u0026#34;)  public void test(String input, String output) throws Exception {  // given  handler = new StreamHandlerForTest(input);   // when  Temp.main(new String[]{}); // 테스트 실행   // then  assertEquals(output, handler.get());  }   private static Stream\u0026lt;Arguments\u0026gt; provideParameters() {  return Stream.of(  Arguments.of(\u0026#34;3 4\u0026#34;, \u0026#34;7\u0026#34;),  Arguments.of(\u0026#34;1 9\u0026#34;, \u0026#34;10\u0026#34;)  );  } } 마찬가지로, 이 녀석 또한 Live Template에 적용시켰습니다. 하는 방법은 위에서 다뤘으니 여기선 다루지 않겠습니다. 삶이 조금 더 윤택해진 것 같습니다.\n 해당 템플릿은 여기 에 업로드 했습니다.\n ","permalink":"http://cjlee38.github.io/post/tech/etc/2021-07-30-make_test_for_boj/","summary":"0. 들어가며 코딩테스트를 준비하는 여러분 중 대부분은 아마 백준이나 프로그래머스를 많이 사용하실텐데요. 해당 사이트에서 주어지는 환경 날 것을 그대로 사용하기는 아무래도 어렵고, IDE 에서 코드를 작성한 뒤 복사 붙여넣기 하는 경우가 대부분일 것 같습니다.\n저는 자바를 좋아하는데, 프로그래머스에서는 클래스 내의 함수를 작성하는 형태로 문제가 주어지기 때문에, 그닥 어렵지 않게 코드를 작성하고, 또 그 결과를 확인할 수 있는 반면, 표준 입출력을 활용하는 백준은 코드 작성이 조금 귀찮은 편입니다.\n상대적으로 코드가 (조금 더) 긴 BufferedReader 클래스를 활용해야 조금 더 빠른 입출력이 가능하다는 점이나 , 코드가 올바르게 작성됐는지 확인하기 위해 표준 입력에 매번 테스트케이스를 복사해서 넣어주어야 한다는 점이 그렇죠.","title":"# 백준PS 테스트 만들기(feat. Java)"},{"content":"UTM ? 2021.07.25 기준, 아직까지는 M1 Mac에서는 VirtualBox나 Vmware 같은 가상머신 소프트웨어가 지원되지 않는 것으로 확인됩니다.\n Is Apple Silicon ready?  Parallels 같은 유료 소프트웨어도 있지만, 비싼 가격에 섣불리 구매하기가 망설여지는데, 찾아보니 UTM 이라는 소프트웨어로 대체할 수 있다는 소식을 발견했습니다.\n Virtual Box vs. UTM: Run Virtual Machines on Your Apple Silicon M1 Mac UTM - 나무위키   MacOS Version : Big Sur 11.4\n 설치 방법 설치 방법은 간단합니다. 우선, 아래 링크로 접속해서 다운로드 해주세요. (앱스토어에서 구매는 일종의 Donation 개념입니다. 자동 업데이트 정도의 차이가 있다고 하네요.) UTM , Virtual machines for Mac\n다운로드 이후에, 실행하면 다음과 같은 화면을 볼 수 있는데요.\n새 가상머신 만들기를 클릭해서, VirtualBox 에서 사용하던 것 처럼 직접 iso 파일을 넣어줄 수도 있지만, 갤러리라는 곳을 활용하면 좀 더 간편하게 사용할 수 있습니다.\n아치 리눅스나 데비안, 우분투, 또는 윈도우도 보이네요. 저는 여기서 Debian 10.4, Minimal을 선택하겠습니다. 윈도우의 경우, 다음을 참고해주세요\n Windows 10 , UTM -\u0026gt; 하단의 Instructions 페러렐즈 안쓰고 무료로 M1 맥에 윈도우 설치하기 – Toyrit UTM으로 M1 맥에 설치된 윈도우에 인터넷 드라이버 설치 – Toyrit YouTube  다운로드 버튼을 클릭하면, Debian ARM.utm 이라는 파일을 다운받게 됩니다. 그리고, 이 파일을 실행하기만 하면 됩니다. 간단하네요.\n여기서 Debian GNU/Linux 를 선택하면 됩니다.\n초기 비밀번호는 다음과 같이 세팅되어 있습니다.\n root의 경우 root / password user(debian)의 경우 debian / debian  Options 실행중인 가상머신을 종료한 후, 좌측의 가상 머신 list 중 새로 생긴 Debian ARM 을 우클릭하면, Edit 버튼을 확인할 수 있습니다. 여기서 여러 옵션을 선택할 수 있는데, 제가 수정한 옵션만 나열해보겠습니다.\n1. Memory [System] 탭으로 가면, 메모리가 초기에는 1024mb로 설정되어 있을 텐데, 저는 그냥 편하게 사용하고자 8192mb를 할당해주었습니다.\n2. Display [Display] 탭에는, 그래픽 인터페이스와 콘솔 인터페이스를 선택할 수 있습니다. 설치한 OS에 GUI가 같이 들어있는 경우 당연히 그래픽 인터페이스를 선택하겠지만, 저는 Minimal을 선택했기 때문에 GUI 가 필요 없다고 생각해서 콘솔 인터페이스를 선택했는데, 곧 그래픽 인터페이스가 낫다는 것을 깨달았습니다.\nlsblk 명령어는 filesystem으로부터 명시된 block devices (간단하게, 보조기억장치(하드디스크))에 대한 정보를 출력합니다. 그런데, 콘솔 인터페이스에서는 모양이 예쁘게 나오지 않더라구요.\n기대했던 모습은 아래와 같았습니다.\n뿐만 아니라, manpage도 조금씩 깨져서 나오는 경향이 있었습니다.\n우측 상단의 화살표 두개가 있는 버튼이 Send Console Resize Command 로, 드래그한 화면에 콘솔 크기를 맞춰주는 명령어가 입력되는데, 이를 활용해도 일부 크기가 맞지 않는 현상은 여전했습니다.\n설정된 옵션은 다음과 같습니다.\n3. Disk 초기에 아무것도 건드리지 않으면, 디스크 공간이 약 10G 정도 할당이 되어있습니다.\n[Drive] 탭으로 이동해서 확인해보면 아마 아래와 같은 모습일텐데요. 저는 조금 더 사용하고 싶어서, 추가적으로 디스크를 붙였습니다. 우측 상단의 New Drive를 클릭하고, VirtIO, 그리고 사용할 용량인 64gb 를 입력했습니다. 그리고 순서를 바꿔서, 기존에 있던 두 개의 드라이브 사이, 즉 두 번째에 위치시켰습니다. 참고로, VirtIO 로 디스크를 등록할 경우, 해당 drive는 /dev/vdX (X는 a부터 순서대로 붙인 특정 알파벳입니다.) 로 연결됩니다. 만약 sda 로 사용하고 싶다면(즉, /dev/sdX), VirtIO가 아닌 SCIC 를 선택해주면 됩니다.\n Note. sda 와 vda 의 차이는 다음을 참고하세요.\nsda -\u0026gt; Full virtualization\nvda -\u0026gt; Paravirtualization\nhttps://developer.ibm.com/articles/l-virtio/\n 결론 여러 기능들이 잘 동작하는지는 좀 더 사용해봐야 알겠지만, 당장 가상머신을 돌릴 수 있다는 것만으로도 충분히 만족스럽습니다.\nM1 Mac에 대한 정보가 많이 없는데, 도움이 되었으면 좋겠습니다. 감사합니다.\n","permalink":"http://cjlee38.github.io/post/tech/etc/2021-07-25-virtual_machine_in_m1/","summary":"UTM ? 2021.07.25 기준, 아직까지는 M1 Mac에서는 VirtualBox나 Vmware 같은 가상머신 소프트웨어가 지원되지 않는 것으로 확인됩니다.\n Is Apple Silicon ready?  Parallels 같은 유료 소프트웨어도 있지만, 비싼 가격에 섣불리 구매하기가 망설여지는데, 찾아보니 UTM 이라는 소프트웨어로 대체할 수 있다는 소식을 발견했습니다.\n Virtual Box vs. UTM: Run Virtual Machines on Your Apple Silicon M1 Mac UTM - 나무위키   MacOS Version : Big Sur 11.4\n 설치 방법 설치 방법은 간단합니다.","title":"# Virtual Machine in M1 Mac"},{"content":"문제링크\nProblem Solve 접근 방법 : 문제를 푸는 원리만 이해하면, 구현은 쉽게 할수 있는 문제다.\n우선, 주어진 문제의 이해를 위해 factorial(10) 을 구해보면, 3628800 이라는 숫자가 나온다. 그리고 가장 뒤쪽에서부터 0의 개수를 세보면, 2개 라는 정답을 얻을 수 있다.\n그러나, 이를 직접 계산해서 0의 개수를 세는, 즉 시뮬레이션을 하게 되면 아주 치명적인 문제가 발생하는데, 문제의 입력 조건에서도 보이듯이 최대 factorial(500)까지 갈 수 있고, 이는\n122013682599111006870123878542304692625357434280319284219241358838584537315388 199760549644750220328186301361647714820358416337872207817720048078520515932928 547790757193933060377296085908627042917454788242491272634430567017327076946106 280231045264421887878946575477714986349436778103764427403382736539747138647787 849543848959553753799042324106127132698432774571554630997720278101456108118837 370953101635632443298702956389662891165897476957208792692887128178007026517450 776841071962439039432253642260523494585012991857150124870696156814162535905669 342381300885624924689156412677565448188650659384795177536089400574523894033579 847636394490531306232374906644504882466507594673586207463792518420045936969298 102226397195259719094521782333175693458150855233282076282002340262690789834245 171200620771464097945611612762914595123722991334016955236385094288559201872743 379517301458635757082835578015873543276888868012039988238470215146760544540766 353598417443048012893831389688163948746965881750450692636533817505547812864000 000000000000000000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000\n라는 아주 말도안되게 큰 숫자가 나온다.\n물론 BigInteger 과 같은 클래스를 활용하는 방법이야 있겠지만, 문제의 본질에서 한참을 어긋나게 된다. 그렇다면 어떻게 해결해야 할까? 조금만 고민을 해보면, 두 자리수 이상의 숫자에서, 0 이라는 숫자로 끝난다는 것은, 이 숫자가 5 라는 숫자를 반드시 인수로 갖고 있다는 뜻이 된다.\n즉, 10 이라는 숫자는 2 * 5 로 구성되어 있으며, 20 이라는 숫자는 4 * 5 라는 숫자로 구성되어 있다. 그렇다면 단순히 5 의 개수를 세면 되는가? 정답은 그렇다 이긴 한데, 여기에 근거를 조금 더 붙여보자.\n가령, 25 라는 숫자는, 5 * 5 로 구성되어 있으므로, 5를 인수로 갖고 있음에도 불구하고 0 이 등장하지 않는다. 15 라는 숫자 또한 마찬가지로, 3 * 5 로 구성되어 있으므로, 5 를 인수로 갖고 있음에도 불구하고, 뒤에 0 이 붙지 않는다.\n그 이유는, 바로 2 라는 숫자의 부재 때문이다. 2 가 없는 5 는, 10 이라는 숫자를 구성할 수 없다. 그리고 그 기저를 한 단계 더 파고들어보면, 짝수와 홀수가 갖는 곱셈의 성질에 대해서도 생각해 볼 수 있다.\n무슨 말인가 하면, 짝/홀수의 곱셈에서, 곱셈은 or 로, 짝수는 true 로 비유해볼 수 있다는 것이다. 즉,\n 짝수 * 짝수 = 짝수 짝수 * 홀수 = 짝수 홀수 * 짝수 = 짝수 홀수 * 홀수 = 홀수  그렇기에, 0 이라는 숫자로 끝나기 위해서는 반드시 짝수가 하나 이상 포함되어 있어야 하며, 그 짝수의 최소(즉, 소인수) 인 2 가 5와 쌍을 이루어주어야, ~0 이라는 형태의 숫자를 만들어낼 수 있는 것이다.\n그러나 우리가 해결하고자 하는 문제인 팩토리얼은, 연속된 자연수를 곱하는 것이고, 따라서 당연하게도 2 의 배수에 해당하는 숫자는 5의 배수에 해당하는 숫자보다 훨씬 더 많이 존재한다. 바꿔 말해, 재료는 충분하다는 이야기다.\n다시 본론으로 돌아와서, 주어진 팩토리얼의 계산 결과가 10 이라면, 이는 2 * 5 로 구성되어 있기에, 즉 하나의 쌍이 적절하게 주어져있기 때문에 하나의 0 이 붙는다.\n절대 그럴수는 없지만, 만약 팩토리얼의 계산 결과가 50 이라면 ? 2 * 5 * 5 로 구성되어 있고, 2 라는 재료가 하나 부족하기 때문에, 0 의 개수는 하나가 된다.\n문제의 예시로 돌아가서 생각해보자. factorial(10) 은 3628800 인데, 여기에는 5 가 두 번 들어간다. 그리고 그 재료가 되는 2의 배수는 [2, 4(2 * 2), 6(2 * 3), 8(2 * 2 * 2), 10(2 * 5)] 의 총 8개로, 주어진 5를 모두 사용하고도 남는다.\n조금 더 연장해보자.\nfactorial(15) 는, 5 가 세 번 들어가니, 0 이 총 세 개 붙을 것이라 예상해볼 수 있다. 그리고 이 결과값은 1307674368000 로, 0 이 세 개 붙는다.\n그렇다면 facotrial(25)는 어떨까? 단순하게 쳐다보면 5 가 다섯 번 들어간다고 생각할 수 있지만, 사실은 마지막에 25 를 곱하는 과정에서 5 가 두 번 들어가기에, 총 여섯 개의 5 가 들어가게 된다. 그리고 다시 말하지만, 2 의 재료 또한 충분하기 때문에, 여섯 개의 5 에 모두 쌍을 맞추어줄 수 있다. 실제 계산 결과값 또한 15511210043330985984000000 이다.\n구현 : 여기까지 이해했다면, 구현하는데에는 전혀 어려움이 없다. 1부터 주어진 숫자까지 반복하는 과정 속에서, 현재 숫자가 5 로 나누어진다면, 또 5 를 곱해서 나눠보고.. 를 그 내부에서 반복하면 된다.\n전체 코드는 다음과 같다.\npackage BOJ.clazz.lv3;  import java.io.*;  /** * uri = https://www.acmicpc.net/problem/1676 * name = 팩토리얼 0의 개수 */  public class bj1676 {   public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));   int n = Integer.parseInt(br.readLine());  int ans = 0;   for (int i = 1; i \u0026lt;= n; i++) {  int div = 5;  while (i % div == 0) {  ans++;  div *= 5;  }  }   bw.write(ans + \u0026#34;\u0026#34;);  bw.flush();  bw.close();  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2021-01-02-problem_solving_22/","summary":"문제링크\nProblem Solve 접근 방법 : 문제를 푸는 원리만 이해하면, 구현은 쉽게 할수 있는 문제다.\n우선, 주어진 문제의 이해를 위해 factorial(10) 을 구해보면, 3628800 이라는 숫자가 나온다. 그리고 가장 뒤쪽에서부터 0의 개수를 세보면, 2개 라는 정답을 얻을 수 있다.\n그러나, 이를 직접 계산해서 0의 개수를 세는, 즉 시뮬레이션을 하게 되면 아주 치명적인 문제가 발생하는데, 문제의 입력 조건에서도 보이듯이 최대 factorial(500)까지 갈 수 있고, 이는\n122013682599111006870123878542304692625357434280319284219241358838584537315388 199760549644750220328186301361647714820358416337872207817720048078520515932928 547790757193933060377296085908627042917454788242491272634430567017327076946106 280231045264421887878946575477714986349436778103764427403382736539747138647787 849543848959553753799042324106127132698432774571554630997720278101456108118837 370953101635632443298702956389662891165897476957208792692887128178007026517450 776841071962439039432253642260523494585012991857150124870696156814162535905669 342381300885624924689156412677565448188650659384795177536089400574523894033579 847636394490531306232374906644504882466507594673586207463792518420045936969298 102226397195259719094521782333175693458150855233282076282002340262690789834245 171200620771464097945611612762914595123722991334016955236385094288559201872743 379517301458635757082835578015873543276888868012039988238470215146760544540766 353598417443048012893831389688163948746965881750450692636533817505547812864000 000000000000000000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000","title":"# 백준[No.1676] - 팩토리얼 0의 개수 ( Java )"},{"content":"0. Dependency Injection 이란? : Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,\n객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다. 이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.\n이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.\n자세한 내용은 이전의 포스팅 혹은 다른 참고자료를 이용해 공부하자.\n          SRP Single Responsibility Principle 클래스는 하나의 책임만을 가져야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.   LSP Liskov Substitution Principle 상위 클래스는 하위 클래스로 대체할 수 있어야 한다.   ISP Interface Segregation Principle 클라이언트별로 세분화된 인터페이스를 만들어라.   DIP Dependeny Inversion Principle 구체 클래스가 아닌 추상 클래스에 의존해라.     그런데 아직 공부가 부족해서 그런지, 의존성이 뭐냐? 라고 물어보면 한마디로 \u0026ldquo;이거다\u0026rdquo; 라고 짚어내기는 어려운 것 같다. 역시 예시를 보자.\nclass Computer {  private CableMouse mouse;   public Computer() {  this.mouse = new CableMouse();  }   public void moveMouse() {  mouse.move();  } } Computer 클래스에서 CableMouse 라는 객체를 가지고 있다. 뭐 컴퓨터가 마우스를 갖고 있는거야 당연해보이지만, 당연하지 않다. 왜일까? Computer 객체가 생성 될 때 반드시 CableMouse가 생기기 때문이다. 이게 정상적인 상황일까? 절대 그렇지 않다. 컴퓨터는, 조금 불편하겠지만 마우스가 없더라도 컴퓨터로서의 기능을 여전히 할 수 있기 때문이다.\n이를 코드 관점으로 바라보면, Computer 객체가 CableMouse에 의존하고 있다. 라고 표현한다. 혹은, Computer 와 CableMouse 사이엔 강한 결합이 존재한다고 말할 수 있다.\n1. Dependency Injection 이 필요한 이유? : 그렇다면 DI 를 이용해서, SOLID 원칙을 지킬 수 있다는 뜻일까? 대답은 그렇다. 이긴 한데, 어떻게 그게 가능한 것인지, 위 Computer 예시를 조금씩 수정해나가면서 알아가보자.\nExample.1 : 우선 위 예제를 그대로 갖고 오자. 그리고, CableMouse와 WirelessMouse 또한 만들어보자.\nclass Computer {  private CableMouse mouse;   public Computer() {  this.mouse = new CableMouse();  }   public void moveMouse() {  mouse.move();  } }  class CableMouse {  public void move() {  System.out.println(\u0026#34;CableMouse moved\u0026#34;);  } }  class WirelessMouse {  public void move() {  System.out.println(\u0026#34;WirelessMouse moved\u0026#34;);  } } 아까 위 예시에서 봤듯이, 현재 Computer 클래스는 CableMouse에 대한 의존성을 갖고 있다. 여기서, 컴퓨터가 사용하는 유선마우스를 무선마우스로 바꾼다면 어떻게 해야할까?\nclass Computer {  WirelessMouse mouse; // 변경된 부분   public Computer() {  this.mouse = new WirelessMouse(); // 변경된 부분  }   public void moveMouse() {  mouse.move();  } } 위와 같이, CableMouse를 쓰는 부분을 모두 WirelessMouse로 고쳐야 한다. SOLID 원칙에 입각해서 보면, 다음과 같다.\n   SOLID Compliance Reason     Single Responsibility Principle X Computer 클래스는, 하나의 역할만 하고 있지 않다. 마우스 객체를 생성하고, 사용하는 역할까지 하고 있다.   Open Closed Principle X 유선 마우스를 무선 마우스로 변경하기 위해서, Computer 클래스를 수정해야 했다.   Liskov Substitution Principle X 아직 유선 마우스와 무선 마우스는 서로 독립적인 클래스이므로, 아직 super/sub의 개념이 없다.   Interface Segregation Principle X 마찬가지로 아직 Interface가 존재하지 않는다.   Dependency Inversion Principle X \u0026ldquo;무선\u0026quot;마우스, \u0026ldquo;유선\u0026rdquo; 마우스 라는 구체적인 클래스에 의존하고 있다.    아무래도 보아하니, 우선 interface 를 만드는 것이 급선무인 것 처럼 보인다. 우선 Mouse interface를 만들어보자. 그리고, CableMouse와 WirelessMouse가 이를 구현할 수 있도록 해보자.\nExample.2 interface Mouse {  void move(); }  class CableMouse implements Mouse {  @Override  public void move() {  System.out.println(\u0026#34;CableMouse moved\u0026#34;);  } }  class WirelessMouse implements Mouse {  @Override  public void move() {  System.out.println(\u0026#34;WirelessMouse moved\u0026#34;);  } } 마지막으로, Mouse 객체의 변경이 용이하도록(즉, 다형성을 이용하도록), Data type을 CableMouse인 구체 클래스가 아닌, Mouse 라는 interface를 사용하도록 하자.\nclass Computer {  private Mouse mouse;   public Computer() {  this.mouse = new CableMouse(); // 여기는..?  }   public void moveMouse() {  mouse.move();  } } 그런데 이렇게 interface 를 만든다고 해서 모두 해결된 것이 아니다. 여전히, 생성자에서 new CableMouse() 라는 구체 클래스를 사용하고 있고, WirelessMouse로 바꾸기 위해서는 코드를 수정해야 하기 때문이다.\nSOLID 5원칙을 기준으로 다시 하나씩 점검해보자.\n   SOLID Compliance Reason     Single Responsibility Principle X 여전히, 마우스 객체를 클래스에서 생성하고 있다.   Open Closed Principle X 여전히, 유선 마우스를 무선 마우스로 변경하기 위해서, Computer 클래스가 수정되어야 한다.   Liskov Substitution Principle O 마우스 interface가 기대한 대로 유/무선 마우스 클래스가 동작하고 있으므로, LSP를 지키고 있다.   Interface Segregation Principle O 인터페이스가 작은(응집된) 역할만 하고 있으므로, ISP를 준수하고 있다.   Dependency Inversion Principle X 다형성을 이용했음에도 불구하고, CableMouse 라는 여전히 구체 클래스에 의존하고 있다.    결국 문제가 되는 부분은, Computer 클래스에서 Mouse를 직접 만든다는 것이다. Mouse 객체를 외부에서 받을 수 있도록, 즉 의존성을 주입받을 수 있도록 수정해보자.\nExample.3 class Computer {  private Mouse mouse;   public Computer(Mouse mouse) {  this.mouse = mouse;  }   public void moveMouse() {  mouse.move();  } }    SOLID Compliance Reason     Single Responsibility Principle O Computer 클래스에서 마우스를 직접 생성하지 않고, 외부에서 입력받는다.   Open Closed Principle O 유선 마우스에서 무선 마우스로 바꾸더라도, Computer 클래스는 변하지 않는다.   Liskov Substitution Principle O 마우스 interface가 기대한 대로 유/무선 마우스 클래스가 동작하고 있으므로, LSP를 지키고 있다.   Interface Segregation Principle O 인터페이스가 작은(응집된) 역할만 하고 있으므로, ISP를 준수하고 있다.   Dependency Inversion Principle O Computer 클래스는 CableMouse, WirelessMouse 라는 구체 클래스에 전혀 의존하지 않는다.    드디어 SOLID 원칙을 모두 준수하는(우리가 당연스럽게 작성해왔던) 설계의 코드를 만들 수 있었다. 이제 행복하게 사용하기만 하면 될\u0026hellip;까? Computer 객체를 사용하는 Person 이라는 객체가 있으면 어떨까?\nclass Person {  public static void main(String[] args) {  Mouse mouse = new CableMouse(); // 여기  Computer computer = new Computer(mouse);  computer.moveMouse();  } } 역시 또 CableMouse를 WirelessMouse로 바꾸기 위해 주석으로 달아놓은 코드를 수정해야 하는 문제가 생긴다. 결국 이렇게 보면 반쪽짜리 SOLID 가 되는 것이다. 그런데 여기까지 오면, 이런 의문이 생긴다.\n맞는 말이다. 결국 어딘가에서는 내가 사용하고자하는 마우스가 유선인지, 무선인지에 대한 지정은 해줘야한다. 그러나 여기서 잠깐 짚고 넘어갈 것이 있다.\n1) SOLID 원칙을 준수함으로써 얻는 이득 우리가 SOLID 원칙을 지킴으로써 얻고자 하는것은 한 쪽의 코드를 변경했을 때, 다른 쪽의 코드를 변경하는 상황을 막는 것. 즉, 약한 결합력(light coupling) 이다. 이를 통해, 코드 설계를 이해하기에, 유지보수하기에, 확장하기에 쉽도록 만들 수 있다. 우리가 Computer 클래스를 사용하는 Person 클래스의 코드를 변경하더라도, Computer 클래스의 코드는 전혀 변화하지 않는다.\n2) 역할과 구현 : 가령, 어떤 흥행하는 뮤지컬이 있다고 해보자. 주연 A의 역할을 배우 a가 맡았고, 주연 B의 역할을 배우 b가 맡았다. 그런데 b가 갑자기 아파서, c 라는 사람이 b의 역할을 대신해야 한다. 이게 문제가 될까? 문제가 되지 않는다. 왜냐하면, B 라는 역할을 수행하던 b가 하던대로(즉, 각본대로), c 또한 잘 해내면 되기 때문이다.\n위 예시로 바꿔서 생각해보자. Computer는 뮤지컬이고, Mouse는 주연이다. Mouse 의 역할을 기존 CableMouse 라는 배우가 담당했는데, 사정이 생겨서 WirelessMouse 가 대체해야 한다. 문제가 될까? 그렇지 않다. 똑같이 마우스를 움직이고, 클릭하는 기능만 제대로 수행할 수 있으면 되기 때문이다. 잘 생각해보면, 결국 1번과 비슷한 이야기다.\n즉, 위 두 이야기를 고려했을 때, Computer 클래스에는 전혀 문제가 없다는 이야기다. 그렇다면 문제가 됐던 Person 클래스의 코드를 수정해야 하는데, 관건은 도대체 어디서 실제 객체를 생성할 것이냐? 가 문제가 되는 것이다.\n뮤지컬 주연은 배우를 선택하지 않는다. 배우를 선택하는 건 뮤지컬 감독이 한다. 마찬가지다. Mouse 라는 주연, 즉 인터페이스는 CableMouse 라는 배우, 즉 객체를 선택하지 않는다. 우리는 뮤지컬 감독의 역할이 필요하다. 즉, 감독의 역할을 맡는 config 설정파일을 생성할 수도 있고, 혹은 Config 라는 클래스를 만들어서 사용할 수도 있다. 그리고 이렇게 Config 에서 실 객체를 넣어주는 작업을 바로 Dependency Injection이라 한다.\nclass Config {  public static Mouse getMouse() {  return new CableMouse();  } }  class Person {  public static void main(String[] args) {  Mouse mouse = Config.getMouse();  Computer computer = new Computer(mouse);  computer.moveMouse();  } } 이렇게 하면, 유선 마우스를 무선 마우스로 바꾼다면, Config 라는 클래스의 new CableMouse() 를 new WirelessMouse() 로 수정하기만 하면 된다.\n2. 아직 끝이 아니다. : 그런데, 마우스와 같은 간단한 경우가 아니라, 사용자가 많은 주문 서비스라면 어떨까? 가령, 사용자가 초당 100 명이라고 한다면, 매 초마다 100개의 객체가 생성되었다가, 삭제되었다가를 반복할 것이다.\n객체들이 특정한 상태가 요구되지 않는다면, 싱글톤 패턴을 이용하는 것이 해결책이 될 수 있다.\nclass Computer {  private static final Computer instance = new Computer();   private Computer() {}   public static Computer getInstance() {  return instance;  } }   Note. 위 Computer 클래스는 간단하게 싱글톤 패턴의 예시를 보여줄 뿐, 위에서 했던 내용과는 연관이 없다.\n  싱글톤 패턴은, 클래스의 instance가 1개만 생성되는 것을 보장하는 디자인 패턴을 의미한다. 따라서, instance가 여러 개 생성되는 것을 막기 위해서, private constructor를 사용했다.\n그리고 이 instance를 얻기 위해서는, 반드시 미리 생성된 getInstance() 메소드를 호출해야 한다.\n그러나, 싱글톤 패턴을 이용할 경우, 다음과 같은 문제점들이 있다.\n 싱글톤 패턴을 구현하는 코드 자체가 많아진다.(e.g. multi-thread 환경의 동기화) 구체 클래스의 instance를 가져오는 메소드를 호출하므로, 구체 클래스에 의존하게 된다.\n따라서, DIP를 위반하게 된다. 테스트가 어렵다. private 생성자를 사용하므로, 자식 클래스를 만들기 어렵다. 즉, 유연성이 떨어진다.  이렇게 되면 골치가 아프다. 우리는 Singleton 패턴의 단점을 최소화하면서, 동시에 Dependency injection 을 사용하고 싶다. 그리고 여기서, 드디어 Spring이 등장한다.\nSpring 은 이 두마리 토끼를 다 잡을 수 있도록 지원해준다. 그것이 어떻게 가능한 것인지, 그 동작 방식은 무엇인지에 대해 다루기는 양이 꽤 되므로 다음 포스팅에서 다루기로 하고, 마틴 파울러의 저서, \u0026lsquo;리팩토링\u0026rsquo; 에서 남긴 말로 포스팅을 마무리한다.\n 컴퓨터가 이해할 수 있는 코드는 어느 바보나 다 짤 수 있다.\n좋은 프로그래머는 사람이 이해할 수 있는 코드를 짠다. - Martin Fowler\n Reference  Spring프레임워크를 사용하여 DI(Dependency Injection) 해보기 인프런, 김영한 님 스프링 강좌 유튜브, 뉴렉처 님 스프링 강좌  ","permalink":"http://cjlee38.github.io/post/tech/spring/2020-12-29-dependency_injection/","summary":"0. Dependency Injection 이란? : Dependency Injection(이하, DI)는 Spring에서만 사용되는 용어가 아니라,\n객체지향프로그래밍(이하, OOP)에서 통용되는 개념이다. 이를 이해하기 위해서는, OOP에서 중요시 여기는 SOLID의 5원칙에 대해서 알아야 한다.\n이번 포스팅에서는 SOLID 5원칙에 무엇이 있는지만 심플하게 짚고 넘어가자.\n자세한 내용은 이전의 포스팅 혹은 다른 참고자료를 이용해 공부하자.\n          SRP Single Responsibility Principle 클래스는 하나의 책임만을 가져야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.","title":"# [Spring 학습 정리] Dependency Injection 의 필요성"},{"content":" 모던 자바 인 액션(라울-게이브리얼 우르마 저, 한빛미디어)을 기반으로 작성하였습니다.\n 0. 들어가며 : 스트림이나 람다 같은 프로그래밍 테크닉들을 사용하면서, \u0026ldquo;이게 어떻게 동작하지?\u0026rdquo; 라는 그 원리에 대해서는 전혀 생각을 해보지 못했었다. 모던 자바 인 액션을 보면서 이런 동작 원리에 대해서 새로운 시야가 트인 느낌이라, 각 내용을 내 입맛에 맞게 정리해보고자 한다. 그런 기념에서, 첫 번째 포스팅은 2장의 동작(동적,Dynamic이 아니다.) 파라미터화 코드 전달하기 이다.\n1. 예제 : 가령 예를들어서, 과일 재고 목록을 관리하는 애플리케이션이 있다고 해보자. 그리고, 처음에는 \u0026ldquo;녹색 사과를 모두 찾고 싶어요\u0026rdquo; 라고 요구사항이 들어왔다.\nstep.1 이에 대한 메소드는, 지금까지는 아마 당연하게도 이런식으로 작성했을 것이다.\npublic List\u0026lt;Apple\u0026gt; filterGreenApples(List\u0026lt;Apple\u0026gt; inventory) {  List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  for (Apple apple : inventory) {  if (\u0026#34;GREEN\u0026#34;.equals(apple.getColor())) {  result.add(apple);  }  }   return result; } 그런데, 요구사항이 변경되어서, 녹색사과 뿐만이 아니라 빨간색 사과도 찾고 싶어졌다고 해보자.\nstep.2 빨간색 사과를 찾는, 위와 같은 형태의 filterRedApples() 메소드를 만드는 것은 꽤나 바보같은 짓일 것 같다. 그렇다면, 조금 더 현명하게 처리해서, \u0026quot;GREEN\u0026quot; 이라고 하드코딩되어 있는 부분을, 파라미터에 의해 결정되도록 수정할 수 있을 것이다.\npublic List\u0026lt;Apple\u0026gt; filterApplesByColor(List\u0026lt;Apple\u0026gt; inventory, String color) {  List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  for (Apple apple : inventory) {  if (apple.getColor().equals(color)) {  result.add(apple);  }  }   return result; } 그런데, 이걸로 끝일까? 흔히 말해, 어떤 것이 와도 두렵지 않으려면, 이정도 코드로는 아마 감당하기 힘들 것이다. 가령, 무게가 150g 이상인 사과를 찾고싶다면 어떻게 해야할까?\npublic List\u0026lt;Apple\u0026gt; filterApplesByWeight(List\u0026lt;Apple\u0026gt; inventory, int weight) {  List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  for (Apple apple : inventory) {  if (apple.getWeight() \u0026gt; weight) {  result.add(apple);  }  }   return result; } 이런 코드를 추가하는 것만으로 만족할 수 있을까? 게다가, if 조건문을 제외하면 나머지 코드가 색깔로 필터링하는 코드와 전부 동일하다는 것을 확인할 수 있다. 중복되는 코드를 지양해야 하는 개발자에게는, 이는 딱히 좋은 선택지로는 보이지 않는다.\nstep.3 심지어, 다음과 같은 코드는 더욱 최악이다.\npublic List\u0026lt;Apple\u0026gt; filterApples(List\u0026lt;Apple\u0026gt; inventory, String color, boolean flag) {  List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  for(Apple apple : inventory) {  if (flag \u0026amp;\u0026amp; apple.getColor().equals(color) ||  (!flag \u0026amp;\u0026amp; apple.getWeight() \u0026gt; weight)) {  result.add(apple);  }  }   return result; } 이런 코드는 도대체 무엇을 의미할까? 게다가, 사용하는 입장에서도 이는 껄끄럽다.\nList\u0026lt;Apple\u0026gt; greenApples = filterApples(inventory, \u0026#34;GREEN\u0026#34;, 0, true); 이 true와 false는 무엇을 의미하는걸까? 이 또한 알 수 없다.\n결국 지금까지 문제가 되었고, 우리가 개선해야 할 부분은 저 if문이고, 따라서 우리가 원하는 것은 요구사항을 밖에서 전달하는 것 이다. 그렇다면 요구사항을 밖에서 전달하기 위해, 전략패턴을 사용할 수 있다.\nstep.4 이를 위해, 프레디케이트를 갖는 인터페이스를 만들어서 이를 활용해보자.\n  Note. 참 또는 거짓을 반환하는 메소드를 Predicate라 칭한다.\n  public interface ApplePredicate {  boolean test(Apple apple); } 그리고, 이를 구현하는 클래스를 만들어보자.\n// 무게가 150 초과면 참, 아니면 거짓. public class AppleHeavyWeightPredicate implements ApplePredicate {  public boolean test(Apple apple) {  return apple.getWeight() \u0026gt; 150;  } }  // 사과의 색깔이 초록색이면 참, 아니면 거짓 public class AppleGreenColorPredicate implements ApplePredicate {  public boolean test(Apple apple) {  return \u0026#34;GREEN\u0026#34;.equals(apple.getColor());  } } 그리고, 이에 맞게 기존의 filter 메소드를 수정해보자.\npublic List\u0026lt;Apple\u0026gt; filterApples(List\u0026lt;Apple\u0026gt; inventory, ApplePredicate p) {  List\u0026lt;Apple\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  for(Apple apple : inventory) {  if(p.test(apple)) result.add(apple);  }   return result; } 기존 코드와의 차이점이 보이는가? 우린 앞으로 어떤 조건이 주어지더라도, 저 filterApples() 라는 메소드는 전혀 고칠 필요가 없다. 새로운 요구사항이 주어지는 대로, ApplePredicate를 구현하는 새로운 클래스를 만들어서 그 인스턴스를 파라미터로 전달해주면 된다. 가령 다음과 같다.\nAppleGreenColorPredicate p = new AppleGreenColorPredicate(); List\u0026lt;Apple\u0026gt; greenApples = filterApples(inventory, p); 그런데 위 코드는, 다음과 같이 수정해볼 수 있다.\nList\u0026lt;Apple\u0026gt; greenApples  = filterApples(inventory, new AppleGreenColorPredicate()); 이러한 코드 작성은 우리가 아주 자연스럽게 해왔던 것이다. p 라는 녀석이 앞으로 재활용될 가능성이 없다면, 변수를 할당할 필요 없이 곧바로 메소드의 인자로 인스턴스를 넘겨주는것. 같은 말을 또 하자면, 우리는 인스턴스를 넘겨주었다.\nstep.5 인스턴스를 넘겨주었다는 사실에 기반해, 우리는 또 하나의 아이디어를 떠올릴 수 있다. 그것은 바로 익명 클래스이다. 익명 클래스는 말 그대로, 이름이 없는 클래스이다. 그리고 이 녀석은, 클래스의 선언과 인스턴스화가 동시에 수행된다.\n우리는 ApplePredicate 를 구현하는 AppleGreenColorPredicate 라는 이름의 클래스를 만들었다. 그렇다면, 익명 클래스라는 녀석은 ApplePredicate를 구현하지만, 위와 같은 이름이 존재하지 않는 클래스를 말하는 것이다. 어떻게 생겼는가 하면, 다음과 같이 생겼다.\nList\u0026lt;Apple\u0026gt; greenApples = filterApples(inventory, new ApplePredicate() {  public boolean test(Apple apple) {  return \u0026#34;GREEN\u0026#34;.equals(apple.getColor());  } }) 보다시피, ApplePredicate 를 구현하는 클래스이긴 하지만, 어떤 이름을 갖지는 않는다. 이와 더불어, 기존의 전략패턴에서 사용했던 클래스들이 만약 일회용으로 사용되고 버려질 경우 생기는 코드의 낭비에 대해서도 나름대로 대처할 수 있다.\nstep.6 그런데, 여기서도 아직 불만족스럽다. 개발자란 종족은 끝없이 편의성을 추구하고, 쓸데없는 짓을 하면 몸에 두드러기가 난다. 다시 위 코드를 보자. new ApplePredicate() 라는 코드, 그리고 public boolean test(Apple apple) 이라는 코드는 꼭 필요한가? 익명 클래스를 여러 개 사용한다면, 딱히 중요해보이지는 않는데 저 코드를 또 써야 한다.\n똑똑한 intellij 또한 Anonymous new ApplePredicate() can be replaced with lambda 라는 안내 문구를 보여준다. 따라서 이를 람다로 수정하면 다음과 같이 수정할 수 있다.\nList\u0026lt;Apple\u0026gt; greenApples  = filterApples(inventory, apple -\u0026gt; \u0026#34;GREEN\u0026#34;.equals(apple.getColor())); step.7 마지막으로는, 사과가 아니라, 오렌지 등의 다른 경우에 대처할 수 있도록 업그레이드 해보자. 즉, 메소드 이름이 filterApples() 가 아니라 filter가 되는 것이다. 특별할건 없고, 제네릭을 이용하기만 하면 된다.\nPredicate 인터페이스와 filter 메소드를 다음과 같이 수정하면 된다.\npublic interface Predicate\u0026lt;T\u0026gt; {  boolean test(T t); }  public \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; filter(List\u0026lt;T\u0026gt; list, Predicate\u0026lt;T\u0026gt; p) {  List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;();  for(T e : list) {  if(p.test(e)) {  result.add(e);  }  }   return result; } 그리고, 사용할 때는 다음과 같이 사용하면 된다.\n// 사과 List\u0026lt;Apple\u0026gt; greenApples = filter(appleInventory, apple -\u0026gt; \u0026#34;GREEN\u0026#34;.equals(apple.getColor()));  // 오렌지 List\u0026lt;Orange\u0026gt; heavyOranges = filter(orangeInveotry, orange -\u0026gt; orange.getWeight() \u0026gt; 200); 2. 생각해볼 점. : 이렇게 각 단계별로 코드가 유연함과 간결함의 두 마리 토끼를 잡을 수 있도록 발전해나가면서, 요구사항에 우아하게 대처할 수 있는 모습을 볼 수 있었다. 그런데, 단순히 이렇게 감탄하고 끝날 것이 아니라, 이 과정 속에서 한 가지 거대한 격변이 있었음을 기억해야 한다.\n프로그래밍에서 가장 핵심이 되는 것은, 값을 변경하는 것이다. Query가 아닌 Command의 특성을 갖는 메소드에서, 기존에 우리는 변화할 수 있는 값을 넘겨주었다. int, double 등의 primitive type의 데이터부터 시작해서, 객체(인스턴스) 또한 변화할 수 있는 값이다. 그리고 이런 녀석들을 우리는 일급 값 이라고 부른다.\n그리고 이렇게 인자로 전달할 수 없는 녀석은 이급 값이라고 부른다. 무엇이 해당할까? 바로 클래스와 메소드이다.\n이전에는, 우리는 다음과 같은 코드는 본 적이 없다.\nList\u0026lt;Apple\u0026gt; result = filter(inventory, public boolean my_function(...) {  // do something }) 메소드의 인자로 메소드를 넘기는 경우는 본 적이 없다. 그런데, step.6 를 보면, 람다라는 익명 함수를 넘겨줄 수 있다. 이는 기존의 이급 값이었던 메소드를, 일급 값으로 만들 수 있게 되었음을 의미한다!\n사실, step.6 에서 어떻게 함수를 파라미터로 받을 수 있는가? 에 대해서는 다루지 않았는데, 이는 다음 장의 람다 표현식의 원리에 대해서 자세히 다뤄야할 내용이라 생략했다. 역시, 다음 포스팅에서 마저 알아보기로 하자.\n이상으로 포스팅을 마칩니다.\n","permalink":"http://cjlee38.github.io/post/language/java/2020-12-21-java8-behavior-parameterization/","summary":"모던 자바 인 액션(라울-게이브리얼 우르마 저, 한빛미디어)을 기반으로 작성하였습니다.\n 0. 들어가며 : 스트림이나 람다 같은 프로그래밍 테크닉들을 사용하면서, \u0026ldquo;이게 어떻게 동작하지?\u0026rdquo; 라는 그 원리에 대해서는 전혀 생각을 해보지 못했었다. 모던 자바 인 액션을 보면서 이런 동작 원리에 대해서 새로운 시야가 트인 느낌이라, 각 내용을 내 입맛에 맞게 정리해보고자 한다. 그런 기념에서, 첫 번째 포스팅은 2장의 동작(동적,Dynamic이 아니다.) 파라미터화 코드 전달하기 이다.\n1. 예제 : 가령 예를들어서, 과일 재고 목록을 관리하는 애플리케이션이 있다고 해보자.","title":"# (Java8) 동작(≒메소드) 파라미터화 "},{"content":"0. 들어가며 : 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.\n아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.\n1. 해결할 문제 : LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 \u0026ldquo;최대 증가 부분 수열\u0026rdquo; 정도가 된다. 즉, 정수의 수열 S 가 주어졌을 때, S 에서 0개 이상의 숫자를 지우고 남은 수열을 \u0026ldquo;부분 수열\u0026rdquo; 이라고 칭하고, 그 수열 중에서 \u0026ldquo;오름차순으로 정렬\u0026rdquo; 된 수열을 \u0026ldquo;증가 부분 수열\u0026rdquo;, 그리고 그 중에서 가장 긴 수열을 \u0026ldquo;최대 증가 부분 수열\u0026rdquo; 이라고 한다.\n말로 하면 약간 헷갈리니, 다음의 예시를 보자. 앞으로 이 예시를 계속 사용할 것이다.\n 부분 수열의 예 : [3 8 9 2 1 4] 증가 부분 수열의 예 : [1 4 8] 최대 증가 부분 수열의 예: [3 5 7 8]  이 때, 최대 증가 부분 수열(이하, LIS) 또한 여러 개가 될 수 있다. (현 예에서는 [3 5 7 8] 이외에 [3 5 7 9] 또한 존재한다.) 그러나, 우리가 원하는 것은 \u0026ldquo;LIS 의 길이\u0026rdquo; 하나 이므로, 몇 개가 존재하던 상관이 없다.\n2. 첫 번째 방법 - 완전탐색 2-A 이론 : 사람이라면 몇 번 훑어보면 금방 찾을 수 있지만, 알다시피 컴퓨터는 우리 생각만큼 똑똑하지 않다. 나도 그랬듯이, 이 문제를 코딩으로 해결하고자 할 때 떠올릴 수 있는 방법은, 모든 경우를 탐색하는 것, 즉 완전탐색이다.\n완전탐색을 이해하는 것은 그리 어렵지 않다. 말로 자세히 풀어서 설명하기보단, 다음의 순서를 반복하는 것을 이해하는 것이 더 간단할 것 같다.\n 주어진 배열(= 부분수열)에서, 하나의 요소 X 를 선택한다. X 뒤쪽의 배열을 살펴보면서, X 보다 크면 이를 다음 탐색할 배열 A 에 넣는다. 배열 A 를 가지고, 1번을 반복한다. 만약 배열 A 가 비어 있는 경우, 재귀함수를 종료(스택을 하나 제거)하면서 0 을 return한다.  그림으로 표현하자면, 다음과 같다.\n[3 5 7 9 2 1 4 8] 이라는 배열이 주어져있고, 3 을 X 로 지정했다.\n그리고 나서, 그 뒤쪽의 배열 중, 3 보다 큰 녀석들(빨간박스) 을 새로운 배열로 만든다.\n그리고 이렇게 [5 7 9 4 8] 을 가지고, 또 다시 5 를 X로 지정했다.\n다시 그 뒤쪽을 살펴보면서, [7 9 8] 을 새로운 배열로 만든다.\n이러한 과정을 반복하면서, 배열이 비어 있는 경우, 0 을 return 하면 된다.\n살짝 머리가 아파지니, 그윽한 자바코드 냄새를 맡으면서 환기해보자.\n2-B 구현 public int lis1(List\u0026lt;Integer\u0026gt; list) {  if (list.isEmpty()) return 0;   int ret = 0;  for(int i = 0; i \u0026lt; list.size(); i++) {  List\u0026lt;Integer\u0026gt; sub = new ArrayList\u0026lt;\u0026gt;();  for (int j = i+1; j \u0026lt; list.size(); j++) {  if (list.get(i) \u0026lt; list.get(j)) {  sub.add(list.get(j));  }  }   ret = Math.max(ret, lis1(sub) + 1);  }   return ret; } 하나씩 살펴보자.\nif (list.isEmpty()) return 0; 리스트(배열)가 비어있는 경우에 0 을 돌려주는 것은 당연하다. 처음으로 주어진 배열 자체가 아예 비어있다면 LIS 의 길이 또한 0 이 될 것이며, 재귀함수의 호출 과정속에서도 배열이 비어있다는 것 또한 마찬가지로 LIS 의 길이가 0 이라는 것을 의미하기 때문이다. 이와 더불어, 재귀함수를 종료할 base case(기저사례) 이기도 하다.\nfor(int i = 0; i \u0026lt; list.size(); i++) {  List\u0026lt;Integer\u0026gt; sub = new ArrayList\u0026lt;\u0026gt;();  for (int j = i+1; j \u0026lt; list.size(); j++) {  if (list.get(i) \u0026lt; list.get(j)) {  sub.add(list.get(j));  }  } } ret은 잠시 미뤄두고, 다음으로 주목할 부분은 for-loop 다. 0 번째부터 시작하는, 하나의 요소 X를 선택한 뒤(=list.get(i)), 그 뒤쪽의 값과 비교하면서, 만약 뒤쪽의 값이 더 크다면 이를 sub 라는 리스트에 추가한다.\nint ret = 0;  for ( i... ) {  for ( j... ) {   }  ret = Math.max(ret, lis1(sub) + 1); }  return ret; 그 다음으로 살펴볼 부분은 변수 ret 이다. 주목해야 할 부분은 ret = Math.max(ret, lis1(sub) + 1); 이 부분인데, 우리가 재귀함수를 열심히 쌓다가, 이제는 우리가 헤어져야 할 시간이 되면 0 이 return 된다.\n애초에 base case 에서부터 1 을 return 하지 않고, 0 을 return 하는 대신 여기에 + 1 을 넣어준 이유는,\n 원본의 배열이 애초에 비어 있을 때 0 을 return 하는게 타당하면서, 동시에, 재귀함수를 호출하던 과정 속에서 배열이 비어있을 때 또한 길이가 0 임을 의미히기도 하고, 이와 더불어 \u0026ldquo;어차피 우리가 선택한 sub 배열은 나보다 큰 녀석\u0026rdquo; 이고, 이는 곧 증가 부분 수열의 길이가 반드시 1 (혹은 그 이상) 늘어난다는 것을 의미하기 때문이다.    3 번이 헷갈리는 사람(나)을 위해, 다음과 같은 부연설명을 읊조려보자면,\n가령 원 배열이 [1 2] 가 있다고 해보자. 그렇다면, 첫 번째 재귀함수 과정 속에서 sub 에 2 가 들어갈 것이고, 두 번째 재귀함수 내에서 [2] 는 다시 아무것도 없는 배열 [] 를 호출할 것이다.\n세 번째 재귀함수에선, 배열에 아무것도 들어있지 않으므로 0 이 return 될 것이고, 다시 두 번째 재귀함수로 돌아왔을 때에는 for-loop 내에서 ret = Math.max(0, 0+1); 이 된다. for-loop 가 더 이상 나아갈 수 없으므로 1 을 그대로 return 하고, 첫 번째 재귀함수에서 마찬가지로 ret = Math.max(0, 1+1); 이 된다. i 가 1(즉, X 가 2인 경우) 에는 위와 같은 과정을 통해 1 이 return 될 것이고, Math.max(2, 1) 를 통해 최종적으로 2 가 return 된다.\n여전히 이해가 되지 않는다면, 반대로 [2 1] 인 경우를 상상해보자.\n  2-C 시간복잡도 : 이러한 완전탐색의 시간복잡도는 얼마나 될까? 대부분의 시간복잡도가 최악의 상황을 가정하니, 이 알고리즘에 최악이 될 수 있는 상황을 가정해보자. 아무래도 sub가 많아지면 많아질수록 최악이 될테니, [1 2 3 4 5 6 \u0026hellip;] 과 이미 오름차순으로 정렬되었을 때가 가장 오래 걸릴 듯 싶다.\n배열을 하나씩 늘려가면서 함수가 호출되는 횟수를 살펴보자.(for문은 재귀함수의 호출로 연결된다는 점을 생각하자.)\n [] -\u0026gt; 1 [1] -\u0026gt; 2 [1 2] -\u0026gt; 4 [1 2 3] -\u0026gt; 8  패턴이 보인다. O(2^n) 이다. 통상적으로 O(n^2) 이어도 상당히 곤란한 시간복잡도인데, O(2^n) 이라고 하면 척 봐도 비효율적인 것 처럼 보인다.\n3. 두 번째 방법 - 동적계획법 : 위에서 살펴본 완전탐색이 비효율적인 이유는, 역시 같은 연산을 반복하기 때문이었다. 이전에 작성했던 재귀함수 글 에서 보았던 것처럼, 동적계획법을 이용해보자. 이렇게 동적계획법을 떠올릴 수 있는 기저는, 이 문제가 최적부분구조를 갖고 있기 때문이다.\n메모이제이션, 캐시 등 관점에 따라 다른 이름으로 부르지만, 어쨌든 여기서 중요시하는 내용은 \u0026ldquo;한번 계산한 부분은, 또 다시 계산하지 않는다.\u0026rdquo; 는 것이 핵심이다. 바로 위의 사진에서 보듯이, 배열이 비어있을 때를 중복으로 쳐다보기도 하지만, 배열이 [3]과 같은 부분도 중복해서 연산을 하는 것을 볼 수 있다.\n즉, [3] 의 꼬리를 잘라내보자.\n3-A. 이론 : 단순하게 동적계획법을 생각하면 어렵지 않을 것 같다. \u0026ldquo;처음 계산이면 캐시에 저장, 한번이라도 본 적이 있다면 꺼내서 사용\u0026rdquo; 하면 된다. 다만, 막상 코드로 쓰려고 키보드에 손을 올리는 순간 멈칫하게 된다. \u0026ldquo;캐시를 어떻게 만들어놓지?\u0026rdquo;\n이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다. 즉, [3 5 7 9 2 1 4 8] 라는 배열에서, 우리가 7 이라는 요소를 선택했을 때, 그 sub 가 될 수 있는 [9 8]은 언제나 동일하다. 이는 그 전의 호출에서 3의 선택으로 [5 7 9 4 8]이 넘어왔든, 5의 선택으로 [7 9 8]이 넘어왔든, 이번에 7 이 선택되었으면 그 sub가 되는 [9 8]은 항상 동일하다는 것이다.\n이를 다시 바꿔서 이해해보자. 우리가 7 을 선택했을 때, 즉 index 상으로 2 번을 선택했을 때 해당 증가 부분 수열의 길이가 계산되어 있다면, 그 값을 return 하면 된다. 계산되어 있지 않다면, 기존에 하던대로 계산하면 된다.\n3-B 구현 : 위 아이디어를 코드로 구현하기 이전에, 몇 가지 작업을 해둘 부분이 있다.\n먼저, 리스트의 가장 앞부분에 -1 을 넣어두자.(현재 예제는 자연수를 기준으로 하고 있기 때문에, 정수를 고려할 경우 Integer.MIN_VALUE를 넣어야 한다.) 이 내용은 조금 밑에서 설명하겠다.\nlist.add(0, Integer.MIN_VALUE); 그 다음으로, cache를 -1로 초기화 해놓자.\nList\u0026lt;Integer\u0026gt; cache = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) {  cache.add(-1); } -1 로 초기화해놓는 이유는, 기존의 list 와 쌍을 맞춰주기 위함이면서, 동시에 LIS 가 빈 배열로 인해 0 이 될 수도 있으니, 이를 구분하기 위해 -1 로 초기화 해두겠다는 것이다.\npublic int lis2(List\u0026lt;Integer\u0026gt; list, List\u0026lt;Integer\u0026gt; cache, int start) {  if (cache.get(start) != -1) return cache.get(start);   int ret = 0;  for(int next = start+1; next \u0026lt; list.size(); next++) {  if (list.get(start) \u0026lt; list.get(next)) {  ret = Math.max(ret, lis2(list, cache, next) + 1);  }   }  cache.set(start, ret);   return ret; }   여기서 잠깐, 기존 코드와의 통일성을 위해 List를 사용하였지만, 이번에는 list 와 cache의 크기가 고정되어 있기 때문에(앞서는 sub에 따라 크기가 달라졌다.), 단순히 array를 사용해도 상관 없다.\n  뭔가 기존 코드와 비슷하면서도 사뭇 다른 부분이 몇가지 보인다. 이 또한 하나씩 뜯어보자.\nif (cache.get(start) != -1) return cache.get(start); 가장 간단해 보이는 이 부분은 캐시에 저장된 부분이 있다면, 그 부분을 가져오겠다는 의미가 된다.\npublic int lis2(List\u0026lt;Integer\u0026gt; list, List\u0026lt;Integer\u0026gt; cache, int start) 그 다음으로 눈에 띄는 부분은, 함수가 받고자 하는 파라미터가 조금 변화하였다. 이 부분이 가벼워 보이지만 신중하게 바라봐야 하는 이유는, 바로 start 변수에 있다. 우리가 cache를 사용하려면, index를 기반으로 접근해야 한다. 그리고 이 index를 사용하기 위해서는, 항상 리스트의 길이는 고정되어야 한다. 말인 즉슨, sub 배열을 만들어줘서는 안된다는 뜻이다.\nsub 배열을 만들게 될 경우, 우리가 for-loop에서 사용할 index가 뒤틀리는 문제가 발생하게 된다. 반대로, sub 배열을 만들지 않고 원본 list를 사용하지 않더라도 전혀 문제가 되지 않는다. 왜냐하면, 우리가 사용하는 index 는 \u0026ldquo;앞의 내용을 전혀 신경쓰지 않아도\u0026rdquo; 되기 때문이다.\n위에서 작성한 내용을 다시 살펴보자.\n  이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다.\n  for(int next = start+1; next \u0026lt; list.size(); next++) {  if (list.get(start) \u0026lt; list.get(next)) {  ret = Math.max(ret, lis2(list, cache, next) + 1);  }  } 이에 맞춰서 for-loop 도 변화하였다. 우리는 리스트를 인덱스를 기준으로 살펴볼 것이므로, next 는 start + 1 부터 시작한다. 그리고 와중에 \u0026ldquo;나보다 큰 녀석\u0026quot;을 발견하면, 그 녀석을 대상으로 다시 재귀함수를 호출하게 된다. 재귀함수의 결과에 더하는 1 은 앞에서 설명했으니 생략하겠다.\n또한, 만약 cache에서 답을 구하지 못하고, LIS 가 마지막으로 가더라도 상관없다. 자연스럽게 for-loop 의 조건에 성립하지 않으므로, 0 이 return 된다. 즉, 이전 코드의 if (list.isEmpty()) return 0; 와 같은 base case를 특별히 명시해둘 필요가 없는 것이다.\ncache.set(start, ret);  return ret; 처음 문제를 마주한 경우에는 당연히 cache를 저장하고, 그 값을 돌려주면 된다.\n그런데, 단순히 이렇게만 봤을때에 문제가 하나 있다. 바로 0 번째 인덱스가 가장 큰 값인 경우를 해결하지 못한다는 것이다. 그 이유는, 재귀함수를 처음 호출했을 때, if 문에 걸리지 않기 때문이다. 이를 위해 list.add(0, Integer.MIN_VALUE); 를 넣었던 것이다.\n다른 방법으로는,\n애초에 lis2() 함수 자체를 한번 더 묶어서,\nint max = 0; for (int i = 0; i \u0026lt; n; i++) {  max = Math.max(max, lis2(...)); } 처럼 사용하는 방법이 있다. 이 방식은 lis2() 의 반복을 밖에서 하느냐, 안에서 하느냐의 차이이지, 본질적으로는 같다. 다만, ret = 0 을 ret = 1로 바꾸어 주어야 한다. 또한, cache의 내용은 달라진다\n 0번 index에 값을 넣어주는 방법-\u0026gt; [4 3 2 1 0 2 2 1 0] 바깥쪽에서 loop를 돌려주는 방법 -\u0026gt; [4 3 2 1 3 3 2 1]  3-C 시간복잡도 : 아까 2-C 에서 보았던 꼬리란 꼬리는 다 끊어놓았기 때문에, 해당 코드는 결국 까보면 2중의 for-loop를 반복하게 된다. 따라서 시간복잡도는 O(n^2) 이 된다.\n4. 세 번째 방법 - 동적계획법 2 : 엥? 두 번째도 동적 계획법이었는데, 세 번쨰도 동적 계획법이라니 약간 당황스럽다. 하지만 읽어보면, 둘 다 동적계획법의 정신을 계승하는 알고리즘이란 것을 알 수 있다.\n4-A 이론 : 이번에는 조금 관점을 달리하자. 재귀함수를 호출하기 보다는, 두 개의 for-loop 로 해결할 것이다. 어떻게 할 것이냐?\n이는 배열의 요소를 하나씩 살펴보면서, \u0026ldquo;내가 될 수 있는 증가부분수열의 최대값은 몇이냐?\u0026rdquo; 를 보는 것이다. 아까는, cache에서, LIS 의 시초가 되는 녀석이 부분증가수열의 최대값이 되었다면, 지금은 LIS 의 유종의 미를 거두어주는 녀석이 부분증가수열의 최대값이 된다.\n즉,\n 전자의 경우 -\u0026gt; [4 3 2 1 3 3 2 1] 후자의 경우 -\u0026gt; [1 2 3 4 1 1 2 4]  가 된다.\n이를 어떻게 만드는고 하니, 아주 간단하게 다음과 같은 아이디어를 적용하면 된다\n 현재 내 값 X 를 기준으로 앞쪽을 봤을 때 나보다 작은 녀석들 중 (즉, 내가 뒤에 붙을 수 있는 후보들) , 증가 부분수열의 길이가 가장 긴 녀석 + 1 이 나의 증가부분수열의 길이.  글재주가 없어 말로 쓰니 헷갈린다. 얼른 예시를 보자.\n편의상 값(Value)를 담았다는 의미로 V 를, 증가부분수열의 길이(Length) 를 담았다는 의미로 L 테이블이라 칭하겠다.\n처음에는 이렇게 가장 앞에 0을 붙인채로 초기화한다.\nx 를 3으로 두었을 때, 내 앞에 있으면서, 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1을 더한게, 나의 length가 된다.\n마찬가지의 과정을 반복한다. 즉, x 를 9로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석들은 [0 3 5 7] 이다. 그리고 그 중에서, 가장 긴 증가부분수열의 길이를 갖고 있는 3 에 1 을 더한 4 가 나의 length가 된다.\nvalue 가 2 일 때도 마찬가지이다. x를 2로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1 을 더한게 나의 length, 즉 1이 된다.\n마지막의 경우를 살펴보자. X를 8로 두었을 때, 나보다 작은 녀석은 [3 5 7 2 1 4] 이다. 그리고 그 중, 가장 긴 증가부분수열의 길이를 갖고 있는 녀석은 3(7이 갖고있는) 이고, 여기에 1을 더한 4 가 답이 된다.\n이렇게 해서, 4 라는 최종 답을 구할 수 있다.\n4-B 구현 public int lis3(List\u0026lt;Integer\u0026gt; V) {  List\u0026lt;Integer\u0026gt; L = new ArrayList\u0026lt;\u0026gt;();   V.add(0, 0);  L.add(0);   int ret = 0;  for (int i = 1; i \u0026lt; V.size(); i++) {  int maxLen = 0;  for (int j = 0; j \u0026lt; i; j++) {  if (V.get(j) \u0026lt; V.get(i)) {  maxLen = Math.max(maxLen, L.get(j) + 1);  }  }  L.add(maxLen);  ret = Math.max(ret, maxLen);  }   return ret; } 코드는 그닥 어렵지 않다.\nList\u0026lt;Integer\u0026gt; L = new ArrayList\u0026lt;\u0026gt;();  V.add(0, 0); L.add(0); int ret = 0; 이 내용은 우리가 앞서 봤듯이, 미리 세팅을 해놓는 단계이다.\nfor (int i = 1; i \u0026lt; V.size(); i++) {  int maxLen = 0;  for (int j = 0; j \u0026lt; i; j++) {  if (V.get(j) \u0026lt; V.get(i)) {  maxLen = Math.max(maxLen, L.get(j) + 1);  }  }  L.add(maxLen);  ret = Math.max(ret, maxLen); } 그리고, for-loop 를 돌면서 한 놈씩 잡는다. 그리고 앞쪽을 살펴보면서, 나보다 작은 녀석 중 최대의 길이를 구한 뒤에, 나는 거기에 1 을 더한 값을 갖는다.\n정확히 위의 과정과 일치하는 내용이다. 코드가 워낙 간단해서, 뭐라고 내가 몇 마디 떠드는 것보다 코드를 읽는 편이 더 이해하기 수월할 것이다.\n4-C 시간복잡도. : 간단하게 2중 for-loop로 이루어져 있으니, 시간복잡도는 O(n^2) 라는 사실을 쉽게 유추할 수 있다.\n5. 네 번째 방법 - 이진탐색 : 그런데 O(n^2) 방법도 맘에 들지 않는다. 우리는 조금 더 최적화를 하고 싶다. 아마 이 글을 읽는 사람들도 위 세 방법을 이해하지 못해서 여기까지 오진 않았을 것 같다. 글을 읽느라 식어버린 커피를 원샷 때리고, 담배도 한 대 피워본 뒤, 차분하게 읽어보자.\n5-A 이론 이 알고리즘은 세 번째 방법을 개선한다. 세 번째 방법은, 우리가 뒤쪽으로 가면서 앞쪽에 있는 녀석들을 모두 살펴봐야 했었다. 앞쪽에 있는 녀석들은 하나씩 추가되기도 하고, 나보다 작을수도, 클 수도 있기 때문이다. 그런데, 관점을 살짝 뒤틀어보자.\n내가 선택한 X 라는 녀석이 더욱 긴 녀석이 되기 위해서는, 앞에 있는 녀석이 작은 편이 좋다. 가령, [5 6 1 2 X] 라는 배열이 있다고 해보자. 이 녀석들의 L 테이블은 {1 2 1 2} 로 구성되어있을 것은 자명하다. 여기서, X 가 999 라면, [5 6] 과 [1 2] 둘 다 이어갈 수 있지만, X 가 3 이라면 [1 2] 는 이어갈 수 있지만 [5 6] 은 이어갈 수 없다.\n즉, 값이 작으면 작을수록, X 가 들어왔을 때 이어나갈 수 있는 가능성이 높아진다!\n이러한 정보를 담는 테이블 C 를 만들어놓으면, 위 예시는 다음과 같이 된다.\n 5가 들어왔을 때 -\u0026gt; [5] 6이 들어왔을 때 -\u0026gt; [5 6] 1이 들어왔을 때 -\u0026gt; [1 6] 2가 들어왔을 때 -\u0026gt; [1 2] 3(X)이 들어왔을 때 -\u0026gt; [1 2 3]  즉, C[i] 는 \u0026ldquo;길이가 i일때 최소인 값\u0026rdquo; 이 되고, 이를 계속 갱신해나가면 된다. 그리고 이 갱신 과정속에서, C 테이블은 항상 정렬이 되어있다!\n정렬이 되어있다는 말은, 곧 내가 위로 가야할지, 아래로 가야할지 판단이 가능하다는 뜻이고, 이는 이진탐색이 가능하다는 것을 의미한다.\n5-B 구현 public int lis4(List\u0026lt;Integer\u0026gt; V) {  List\u0026lt;Integer\u0026gt; C = new ArrayList\u0026lt;\u0026gt;();  C.add(0);   int ret = 0;  for (int i = 0; i \u0026lt; V.size(); i++) {  if (V.get(i) \u0026gt; C.get(ret)) {  ret += 1;  C.add(V.get(i));  } else {  int loc = binarySearch(C, 0, ret, V.get(i));  C.set(loc, V.get(i));  }  }   return ret; }  public int binarySearch(List\u0026lt;Integer\u0026gt; C, int low, int high, int value) {  if (low == high) return low;   int mid = (low + high) / 2;  if (C.get(mid) == value) return mid;  else if (C.get(mid) \u0026lt; value) return binarySearch(C, mid+1, high, value);  else return binarySearch(C, low, mid, value); } : 함수를 두개로 나눠, 하나는 순수한 이진탐색, 하나는 위에서 설명한 과정을 구현하였다. 여기서 이진탐색까지 설명하는건 범위에서 벗어나므로, 따로 찾아보도록 하자.\nList\u0026lt;Integer\u0026gt; C = new ArrayList\u0026lt;\u0026gt;(); C.add(0); int ret = 0; 역시 구현에 앞서, 몇 가지 세팅이 필요하다.\n먼저, C 가 첫 번째 입력에도 이진탐색에 대응할 수 있도록, 0 을 넣어주자. 또한, ret이 최장증가부분수열의 길이를 나타내기도 하면서, 동시에 C 테이블의 가장 마지막 녀석의 index를 나타내기도 한다 (결국은 같은 말이다.)\n즉, 앞의 이론에서 이야기한 내용을 가슴속에 품은채로 생각해보면, C 테이블의 가장 마지막에 있는 녀석은, \u0026ldquo;가장 유리하면서\u0026rdquo;, 동시에 \u0026ldquo;가장 큰 값\u0026quot;인데, 그것보다 더 큰 녀석이 나타났다는 것은 새로운 기록을 가진 녀석이 나타난다는 뜻이 된다.\n그러나, 위 조건에 성립하지 않는 녀석은 우리가 교체해야할 녀석이다. C 테이블에서 교체할 자리를 찾아서, 신규 데이터로 갱신해준다.C.set(loc, V.get(i));\n5-C 시간복잡도. : 꽤나 어려운 알고리즘이지만, 시간복잡도는 아주 깔끔하다. 각 원소를 반복하는데 N, 그리고 이분탐색하는데 logN이 더해져 최종적으로는 O(NlogN)이 된다.\n6. 마치며 : 이 글을 읽는 분들이 기나긴 터널의 끝을 떠나 한줄기 빛을 맞이하는 기분이었으면 좋겠다. 다만, 내가 방금 공부한 내용을 글로 옮기는 것은 공부하는데에는 효과적일지 모르겠으나, 남에게 정확한 정보를 전달한다는 점에서는 아무래도 완성도가 떨어지기 마련이다. 더욱이 이렇게 장문의 글을 쓰기가 쉽지 않아, 중간중간 어디 틀렸을까 걱정되기도 한다. 잘못된 부분이 있으면 언제든 지적 바란다.\n이상으로 포스팅을 마칩니다.\nReference  LIS의 길이를 구하는 3가지 알고리즘 나무위키 - 최장 증가 부분 수열  ","permalink":"http://cjlee38.github.io/post/algorithm/algorithm/2020-12-15-ways_to_get_lis_length/","summary":"0. 들어가며 : 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.\n아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다.\n1. 해결할 문제 : LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 \u0026ldquo;최대 증가 부분 수열\u0026rdquo; 정도가 된다.","title":"# 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )"},{"content":"문제 링크\nProblem 문제\n안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다. 원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다. 그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 항상 서로 친구인 학생들끼리만 짝을 지어 줘야 합니다.\n각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝지어줄 수 있는 방법의 수를 계산하는 프로그램을 작성하세요. 짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다. 예를 들어 다음 두 가지 방법은 서로 다른 방법입니다.\n(태연,제시카) (써니,티파니) (효연,유리)\n(태연,제시카) (써니,유리) (효연,티파니)\n입력\n입력의 첫 줄에는 테스트 케이스의 수 C (C \u0026lt;= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 학생의 수 n (2 \u0026lt;= n \u0026lt;= 10) 과 친구 쌍의 수 m (0 \u0026lt;= m \u0026lt;= n*(n-1)/2) 이 주어집니다. 그 다음 줄에 m 개의 정수 쌍으로 서로 친구인 두 학생의 번호가 주어집니다. 번호는 모두 0 부터 n-1 사이의 정수이고, 같은 쌍은 입력에 두 번 주어지지 않습니다. 학생들의 수는 짝수입니다.\n출력\n각 테스트 케이스마다 한 줄에 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력합니다.\n예제 입력\n3\n2 1\n0 1\n4 6\n0 1 1 2 2 3 3 0 0 2 1 3\n6 10\n0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5\n예제 출력\n1 3 4\nSolve : 책의 카테고리도 그렇지만, 문제 자체의 내용도 읽어보면, 완전탐색을 통해서 구할 수 있음을 알 수 있다.\n즉, 아직 짝이 맺어지지 않은 학생을 두 명 (A, B) 고른 다음에, 그 둘이 친구인지 확인해보고, 맞다면 짝을 맺어주는 방식을 계속 반복하면 된다.\n따라서, 자연스럽게 재귀함수와, 짝이 맺어졌는지 확인하는 boolean 배열(대개 visited 배열로 표현되는) 이 필요하단 것을 머릿속에 떠올릴 수 있다.\nprivate int countPairings(boolean[] paired) {   int target = findTarget(paired);  if (target == -1) return 1;   int ret = 0;  for (int i = target + 1; i \u0026lt; n; i++) {  if (!paired[i] \u0026amp;\u0026amp; areFriends[target][i]) {  paired[target] = paired[i] = true;  ret += countPairings(paired);  paired[target] = paired[i] = false;  }  }   return ret; } 위 함수는 paried 라는 boolean 배열을 받아서, 짝을 찾아서 맺어주는 역할을 하는 재귀함수이다. 그런데 여기서 눈여겨보아야 할 것이, 바로 target 변수다. target 변수는 1. 아직 짝을 구하지 못한 학생 A 를 나타내기도 하지만, 2. 동시에 재귀 함수의 호출을 종료하는 Base case이기도 하며, 3. 또한 짝의 쌍을 중복으로 찾지 않도록 해주는 역할 까지 해준다.\n이게 무슨 말일까? 우선, target 변수를 할당해주는 findTarget() 함수를 살펴보자.\npublic int findTarget(boolean[] paired) {  int target = -1;  for (int i = 0; i \u0026lt; n; ++i) {  if (!paired[i]) {  target = i;  break;  }   }   return target; } 특별할 것 없이, target을 -1로 설정해놓은 뒤에 for 문을 돌면서, false인, 즉 다시 말해 아직 짝이 맺어지지 않은 학생을 발견하면, 해당 학생을 target으로 return 해주는 함수이다. 따라서, 1번에서 언급한 아직 짝을 구하지 못한 학생 A를 나타낸다.\n만약 짝이 맺어지지 않은 학생을 발견하지 못한다면, 이는 모든 학생이 짝이 맺어졌다는 뜻이므로 target은 -1 로 return 될 것이고, 따라서 if (target == -1) return 1; 라는 Base case의 조건에 부합하게 된다.\n다시 countPairings() 로 돌아가서, for 문을 살펴보자.\nfor (int i = target + 1; i \u0026lt; n; i++)\n짝이 맺어지지 않은 학생 B(코드 상 i)를 찾는 for문이, target + 1 부터 시작한다. 0부터 시작하지 않은 이유가 바로 3번의 짝의 쌍을 중복으로 찾지 않기 위함 이다.\n잠깐 다른 이야기를 하자면, 수학의 순열과 조합을 떠올려보자.\n순열은 \u0026ldquo;서로 다른 n 개의 원소를 가진 집합에서, r 개를 순서를 따져서 나열\u0026rdquo; 한다.\n반면 조합은 \u0026ldquo;서로 다른 n 개의 원소를 가진 집합에서, r 개를 순서를 따지지 않고 나열\u0026rdquo; 한다.\n[1, 2, 3] 이라는 배열에서,\n3P2 는 (1, 2), (2, 1), (1, 3), (3, 1), (2, 3), (3, 2) 이 되고,\n3C2 는 (1, 2), (1, 3), (2, 3) 이 된다.\n이쯤되면 아마 눈치를 챘을텐데, 우리가 구하고자 하는 것은 조합 이지, 순열이 아니다. 즉, (1, 2)와 (2, 1)은 같은 취급을 한다.\n다시 코드로 돌아가서, 만약 for 문이 target + 1 이 아닌, 0 부터 시작했다고 해보자.\n0번 학생과 5번 학생이 짝이라고 하고, 재귀 함수를 호출하는 과정 속에서 5번이 짝이 맺어지지 않아 A 로 선정되었다고 할 때, 0 번 학생은 B로 선정되어 그 둘을 짝으로 맺어줄 것이다. 이는 우리가 원하는 결과가 아니다. 왜냐면, 그 전에 이미 A 가 0 이었을 때 B 가 5 임을 발견해서, 짝을 맺어주었을 것이기 때문이다.\n즉, 정리하자면, (5, 0) 이라는 쌍을 생성하게 되는 꼴이고, 이는 조합으로 고려하겠다는 의미가 아닌, 순열로 고려하겠다는 의미이므로, 중복된 쌍을 만들게 된다. 이는 우리가 원하는 것이 아니다.\n 핵심이 되는 target 을 이해하고 나면, 나머지 코드는 쉽게 따라갈 수 있다. 전체 코드는 다음과 같다.\npackage algospot;  /* 3 2 1 0 1 4 6 0 1 1 2 2 3 3 0 0 2 1 3 6 10 0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5 */  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.*;  // 소풍 public class Picnic {  public static void main(String[] args) throws IOException {  List\u0026lt;Solution\u0026gt; problems = new ArrayList\u0026lt;\u0026gt;();  BufferedReader br = new BufferedReader(new InputStreamReader((System.in)));  StringTokenizer st = new StringTokenizer(br.readLine());  int c = Integer.parseInt(st.nextToken());   for (int i = 0; i \u0026lt; c; ++i) {  st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());  int m = Integer.parseInt(st.nextToken());   st = new StringTokenizer(br.readLine());  boolean[][] areFriends = new boolean[n][n];   for (int j = 0; j \u0026lt; m; j++) {  int a = Integer.parseInt(st.nextToken());  int b = Integer.parseInt(st.nextToken());   areFriends[a][b] = true;  areFriends[b][a] = true;  }    problems.add(new Solution(n, m, areFriends));   }    for (Solution problem : problems) {  int answer = problem.run();  System.out.println(answer);  }  }   static class Solution {  private int n;  private int m;  private boolean[][] areFriends;   public Solution(int n, int m, boolean[][] areFriends) {  this.n = n;  this.m = m;  this.areFriends = areFriends;  }   public int run() {   boolean[] paired = new boolean[n];   int ret = countPairings(paired);   return ret;  }   private int countPairings(boolean[] paired) {   int target = findTarget(paired);  if (target == -1) return 1;   int ret = 0;  for (int i = target + 1; i \u0026lt; n; i++) {  if (!paired[i] \u0026amp;\u0026amp; areFriends[target][i]) {  paired[target] = paired[i] = true;  ret += countPairings(paired);  paired[target] = paired[i] = false;  }  }   return ret;  }   public int findTarget(boolean[] paired) {  int target = -1;  for (int i = 0; i \u0026lt; n; ++i) {  if (!paired[i]) {  target = i;  break;  }   }   return target;  }  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-12-10-problem_solving_21/","summary":"문제 링크\nProblem 문제\n안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다. 원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다. 그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 항상 서로 친구인 학생들끼리만 짝을 지어 줘야 합니다.\n각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝지어줄 수 있는 방법의 수를 계산하는 프로그램을 작성하세요. 짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다.","title":"# 알고스팟 [ID:PICNIC] 소풍 ( Java )"},{"content":"문제 링크\nProblem 문제 설명\n그렙시에는 0으로 된 도로에 숫자 블록을 설치하기로 하였습니다. 숫자 블록의 규칙은 다음과 같습니다.\n블록의 번호가 n 일 때, 가장 처음 블록은 n * 2번째 위치에 설치합니다. 그다음은 n * 3, 그다음은 n * 4, \u0026hellip;로 진행합니다.만약 기존에 블록이 깔려있는 자리라면 그 블록을빼고 새로운 블록으로 집어넣습니다.\n예를 들어 1번 블록은 2,3,4,5, \u0026hellip; 인 위치에 우선 설치합니다. 그다음 2번 블록은 4,6,8,10, \u0026hellip; 인 위치에 설치하고, 3번 블록은 6,9,12\u0026hellip; 인 위치에 설치합니다.\n이렇게 3번 블록까지 설치하고 나면 첫 10개의 블록은 0, 1, 1, 2, 1, 3, 1, 2, 3, 2이됩니다.\n그렙시는 길이가 1,000,000,000인 도로에 1번 블록부터 시작하여 10,000,000번 블록까지 위의 규칙으로 모두 놓았습니다.\n그렙시의 시장님은 특정 구간의 어떤 블록이 깔려 있는지 알고 싶습니다.\n구간을 나타내는 두 수 begin, end 가 매개변수로 주어 질 때, 그 구간에 깔려 있는 블록의 숫자 배열(리스트)을 return하는 solution 함수를 완성해 주세요.\n제한 사항\n begin, end 는 1 이상 1,000,000,000이하의 자연수 이고, begin는 항상 end보다 작습니다. end - begin 의 값은 항상 10,000을 넘지 않습니다.  입출력 예\n   begin end result     1 10 [0, 1, 1, 2, 1, 3, 1, 4, 3, 5]    입출력 예 설명\n입출력 예 #1\n다음과 같이 블럭이 깔리게 됩니다.\nSolve 접근 방법. : LV.4 문제를 푸는 정도의 사람이라면, 당연히 위에서 설명하는 흐름대로 시뮬레이션해서 구현하지는 않을 것이다.\n길게 볼 것도 없이, 문제의 예시를 보면, 각각 최종적으로 깔리게 되는 블록의 값은 해당 숫자가 가질 수 있는 약수 중, 자기 자신을 제외한 최대 값이다.\n즉, 10 이라는 숫자를 보면, 10 이 가질 수 있는 약수는 [1, 2, 5, 10] 이며, 이 중 자기 자신을 제외한 최대 값은 5 이므로, 5 가 채워지게 된다.\n그런데 이 때, 주의할 점이 있는데, 길이가 10억 인 도로에, 1000만 번 블록까지 이러한 규칙으로 놓았다고 하였으므로, 해당 숫자의 블록은 1000만을 넘어설 수 없다.\n따라서, 자기 자신을 제외하면서, 동시에 1000만 이하인 약수 중 최대값 이 올바른 숫자가 되겠다.\n별로 어렵지 않다 싶어, 곧바로 코드를 작성했다.\npublic int[] solution(long begin, long end) {  int n = (int) (end - begin + 1);  int[] road = new int[n];   for (int i = 0; i \u0026lt; n; i++) {  long cur = begin + i;  road[i] = getGD(cur);  }   // begin이 1인 경우, 1 번째는 0으로 채워야 한다. 문제 예시 참고  if (begin == 1) road[0] = 0;   return road; }  private int getGD(long cur) {  for (long i = 2; i \u0026lt;= Math.sqrt(cur); i++) {  if (cur % i == 0 \u0026amp;\u0026amp; (cur / i) \u0026lt; 10000000) {  return (int) (cur / i);  }  }   return 1; } 지난 번에 소수를 찾는 방법 에서 다뤘듯이, square_root 까지만 살펴보면 되기 때문에, 시간 복잡도도 그리 높지 않을 것이라 예상했다.\n???\n효율성 테스트에서 떨어졌다.\n다른 방법으로, 약수를 구할 때 2 를 먼저 검사하고, 이후 for loop에서 3을 시작점으로 잡은 뒤, i += 2 씩 더하는 방법으로 for 문의 수행을 절반으로 토막내더라도, 답을 구할 수 없다. 가령, 9억 9000만 2 라는 숫자는, 2로 약분되지만, 1000만으로는 약분될 수 없다. 대신, 142로 나누었을 때 나머지가 0 이 되면서, 동시에 몫이 1000만 이하인 6971831 이 답이 된다.\n(틀린 코드)\nprivate int getGD(long cur) {  if (cur % 2 == 0) {  return cur / 2 \u0026lt; 10000000L ? (int) cur / 2 : 10000000;  }   for (long i = 3; i \u0026lt;= Math.sqrt(cur); i += 2) {  if (cur % i == 0 \u0026amp;\u0026amp; (cur / i) \u0026lt; 10000000) {  return (int) (cur / i);  }  }   return 1; } 바꿔 말하면, 2로 한번 검사 했더라도, 4, 6, 8 \u0026hellip; 또한 검사해줘야 한다는 의미가 된다.\n그렇다면, 이렇게 고친 코드가 아닌, 기존의 코드에서 답을 구해야 한다는 이야기가 된다. 이것저것 시도해보다가, 다음과 같이 long 이 아닌 int로 비교해줘야 한다 는 답을 얻어내었다.\nprivate int getGD(int cur) {  for (int i = 2; i \u0026lt;= Math.sqrt(cur); i++) {  if (cur % i == 0 \u0026amp;\u0026amp; (cur / i) \u0026lt; 10000000) {  return cur / i;  }  }   return 1; } 어차피 문제에서 제시하는 최대 값은 10억이고, int 형은 약 21억까지 표현할 수 있으므로, long 변수를 int 로 캐스팅해주어도 문제가 되지 않는다.\n전체 코드는 다음과 같다.\npackage programmers.lv4;  public class p12923 {  public static void main(String[] args) {  long begin = 990000000;  long end = 990010000;   p12923 p = new p12923();  int[] answer = p.solution(begin, end);  }   public int[] solution(long begin, long end) {  int n = (int) (end - begin + 1);  int[] road = new int[n];   for (int i = 0; i \u0026lt; n; i++) {  int cur = (int) begin + i;  road[i] = getGD(cur);  }   if (begin == 1) road[0] = 0;  return road;  }   private int getGD(int cur) {  for (int i = 2; i \u0026lt;= Math.sqrt(cur); i++) {  if (cur % i == 0 \u0026amp;\u0026amp; (cur / i) \u0026lt; 10000000) {  return cur / i;  }  }   return 1;  }  } 호기심에 차이가 얼마나 나는지 궁금해서 시간을 측정해보았다.\nbegin은 990,000,000 으로, end 는 990,010,000 으로 설정한 뒤,\n10번을 실행해서 평균을 내본 결과는 다음과 같다.\n long 으로 비교한 경우 : 1021.5 ms int 로 비교한 경우 : 364.0 ms  약 3 배에 가까운 차이를 보였다.\n링크를 참고하면, 이는 내 착각이 아니라 실제로 long이 int형보다 느리게 동작함을 보여주고 있다.\n따라서, 간단한 프로그램이라면 괜찮지만, 위와 같이 무거운 작업을 수행해야 할 때에는 해당 값의 최대 범위를 잘 고려해서 int 형으로 캐스팅 하는 것을 고려해봐야 한다.\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-11-18-problem_solving_20/","summary":"문제 링크\nProblem 문제 설명\n그렙시에는 0으로 된 도로에 숫자 블록을 설치하기로 하였습니다. 숫자 블록의 규칙은 다음과 같습니다.\n블록의 번호가 n 일 때, 가장 처음 블록은 n * 2번째 위치에 설치합니다. 그다음은 n * 3, 그다음은 n * 4, \u0026hellip;로 진행합니다.만약 기존에 블록이 깔려있는 자리라면 그 블록을빼고 새로운 블록으로 집어넣습니다.\n예를 들어 1번 블록은 2,3,4,5, \u0026hellip; 인 위치에 우선 설치합니다. 그다음 2번 블록은 4,6,8,10, \u0026hellip; 인 위치에 설치하고, 3번 블록은 6,9,12\u0026hellip; 인 위치에 설치합니다.","title":"# 프로그래머스[Lv.4] - 숫자 블록 ( Java )"},{"content":"문제 링크\nProblem 문제 설명\nn명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.\n선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.\n제한사항\n 선수의 수는 1명 이상 100명 이하입니다. 경기 결과는 1개 이상 4,500개 이하입니다. results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다. 모든 경기 결과에는 모순이 없습니다.  입출력 예\n   n results return     5 [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] 2    입출력 예 설명\n 2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다. 5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.  Solve 문제에 대한 이해. : 나만 그렇게 느끼는 건진 모르겠는데, 코딩 테스트의 문제가 어려워질수록 문제 설명도 굉장히 불친절해진다. 이게 단순히 문제의 난이도를 높이기 위해서 말을 아끼는 것이라면 그러려니 하겠는데, 애초에 설명 자체가 부족하니 참 이해하기가 어렵다.\n잠깐 잡소리를 하자면, 대학 교수님들 중에 간혹 그런 분이 있다. 본질적으로 강의라는 것은 학생들에게 지식을 전파하기 위함이고, 시험은 이를 검증하는 것이 목표이다. 따라서, 학생들이 이해할 만한 선에서, 최대한의 깊고 다양한 지식을 학생들에게 전수하면서, 동시에 시험을 변별력 있게 내는 것은 타당하다. 그러나, 거꾸로 시험을 변별력 있게 내기 위해서, 강의를 하면서 일부러 말을 아끼고, 설명해야 할 것도 설명하지 않는 교수님을 몇 번 본적이 있다.\n잡소리는 이만하면 됐고, 어쨌든 이번 순위 문제도 이러한 문제에 해당하는 것 같은데, 문제 내용 중 \u0026ldquo;만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다.\u0026rdquo; 라는 명제는, 만약 A 선수가 B 선수를 이겼다면, A 선수는 B 선수에 비해 항상 실력이 좋다는 것을 의미합니다. 정도로 바꿔줬으면 좀 잘 와닿지 않았을까 싶다.\n또한, 이 문제에는 실제로 일어난 경기가 몇 번 일어났는지에 대해서 설명하고 있지 않다.\n무슨말인가 하면, 문제에서는 몇몇 경기 결과를 분실하였다. 라고 이야기 하였는데, 이는 곧 주어진 배열보다 더 많은 경기가 있었음을 의미한다. 그리고 이 경기가 몇 번 일어났는지, 매치 방식은 어떻게 되는지에 대한 정보가 전혀 없다. 밑에서 설명할 방법이 아니라, 토너먼트 방식일 수도 있지 않은가?\n차라리 이런 식의 문제 설명보다는, 서바이벌 방식의 권투 대회가 아직 진행중인데, 현재까지의 경기 결과를 가지고 순서가 이미 확정된 선수의 수를 구하려고 합니다. 정도의 설명이었다면 더욱 명료했을 것 같다.\n아무튼 정리하자면, 각 선수는 다른 선수들과 경기를 하는데, 그 대상은 자기 자신을 제외한 나머지 모두가 될 수 있고, A 가 B 를 이겼다는 것은, B 가 이긴 C, D 또한 A가 항상 이긴다. 그리고 이러한 가정은, 한 선수가 모든 선수와 게임을 직접 해 봐야 그 선수의 순위가 결정되는 것이 아니라, 대충 몇 번 싸워만 봐도 그 선수에 대한 순위를 알 수 있다는 결론으로 이어진다.\n접근 방법 : 문제의 유형이 그래프로 명시되어 있다 보니, 각 선수를 그래프의 Node 로 생각하고, 각 경기의 결과를 방향이 있는 간선으로 생각할 수 있다. 문제의 예시를 그림으로 그리면 다음과 같다.\n또한, 문제 설명을 기반으로 다음과 같이 정리할 수 있다.\n 경기 결과에 모순이 없다는 말은, 곧 방향 그래프의 Cycle이 없다는 의미가 된다. 따라서, 특정 Node가 가리킬 수 있는 다른 Node들의 리스트를 만든다.  그런데, 이렇게만 하면 정보가 부족하다. 가령, 2번 Node의 경우, 5번 Node로부터 승리했기 때문에 4위라는 순위를 얻을 수 있는데, 위 그래프만으로는 이를 설명할 수 없다. 따라서, 방향을 뒤집어서도, 특정 Node를 가리킬 수 있는 Node들의 리스트 또한 만들어 줘야 한다.\n즉, 바꿔 말하면, 정방향과 역방향의 그래프 두 개를 바탕으로, 내가(Node가) 직, 간접적으로 나갈 수 있는 Node 리스트의 합집합을 만들어 줘야 한다.\n위 그림을 바탕으로, 하나씩 살펴보자.\nNode 1\n 첫 번째 그림에서, Node 1 이 갈 수 있는 Node는 없다. 두 번째 그림에서, Node 1 이 갈 수 있는 Node는 2, 5 이다.  -\u0026gt; count = 2\nNode 2\n 첫 번째 그림에서, Node 2 가 갈 수 있는 Node는 1, 3, 4 이다. 두 번째 그림에서, Node 2 가 갈 수 있는 Node는 5 이다.  -\u0026gt; count = 4\nNode 3\n 첫 번째 그림에서, Node 3 가 갈 수 있는 Node는 4 이다. 두 번째 그림에서, Node 3 가 갈 수 있는 Node는 2, 5 이다.  -\u0026gt; count = 3\nNode 4\n 첫 번째 그림에서, Node 4 가 갈 수 있는 Node는 없다 두 번째 그림에서, Node 4 가 갈 수 있는 Node는 2, 3, 5 이다.  -\u0026gt; count = 3\nNode 5\n 첫 번째 그림에서, Node 5 가 갈 수 있는 Node는 1, 2, 3, 4 이다. 두 번째 그림에서, Node 5 가 갈 수 있는 Node는 없다.  -\u0026gt; count = 4\n이렇게 정리했을 때, 노드의 개수 n 에서, 자기 자신을 제외한 나머지의 개수는 n-1 이므로, 4가 되는 Node 2, Node 5 의 개수 = 2 가 정답이 된다.\n구현. : 우선, 문제를 쉽게 하기 위해 Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; 를 만들어 주었다. 그리고 위에서 이야기했던 것 처럼, 역방향도 고려해줘야 하기 때문에, winnerMap 과 loserMap 이라는 이름으로 두 개를 만들어 주었다.\nMap\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; winnerMap = initGames(n, results, true); Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; loserMap = initGames(n, results, false); // winnerMap = {1=[2], 2=[5], 3=[2], 4=[3, 2], 5=[]} // loserMap = {1=[], 2=[4, 3, 1], 3=[4], 4=[], 5=[2]} private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; initGames(int n, int[][] results, boolean isWin) {  int WINNER = isWin ? 0 : 1;  int LOSER = isWin ? 1 : 0;  Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;();   // 한 번의 for문으로 해결하려 하면, 비어 있는 List를 표현할 수 없다.  for (int i = 1; i \u0026lt;= n; i++) {  map.put(i, new ArrayList\u0026lt;\u0026gt;());  }   for (int[] result : results) {  int winner = result[WINNER];  int loser = result[LOSER];  map.get(winner).add(loser);  }   return map; } 그리고 나서, 각 Node (1 ~ n이하) 의 iteration을 돌면서, 합집합을 구하기 위해 boolean[] visited = new boolean[n]; 를 만들고, 재귀함수를 통해 visited 를 채워나갔다.\n배열을 채우고 나서는, 해당 배열에 true 값이 몇개가 들어있는지 파악한 후, n-1 개 이면 int형 변수 answer를 1 증가시켰다.\nint answer = 0;  for (int i = 1; i \u0026lt;= n; i++) {  boolean[] visited = new boolean[n];  recursive(winnerMap, visited, i);  recursive(loserMap, visited, i);  // 배열 채우기.   int battleCount = countBattle(visited);  if (battleCount == (n - 1)) answer++; } 재귀 함수 내부는, 내가 더이상 나갈 수 없을 때 까지, 즉 List가 비어있을 때까지 를 종료 조건으로 주었다.\nprivate void recursive(Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map, boolean[] visited, int enemy) {  if (map.get(enemy).isEmpty()) return;   for (Integer val : map.get(enemy)) {  if (!visited[val - 1]) { // 이를 확인하지 않으면, 너무 깊게 들어갈 수 있다.  visited[val - 1] = true;  recursive(map, visited, val);  }  } } 이렇게 구한 answer 를 return 해주면 된다. 전체 코드는 다음과 같다.\npackage programmers.lv3;  import java.util.*;  public class p49191 {  public static void main(String[] args) {  int n = 5;  int[][] results = {  {4, 3},  {4, 2},  {3, 2},  {1, 2},  {2, 5}  };   p49191 p = new p49191();  int result = p.solution(n, results);  System.out.println(\u0026#34;result = \u0026#34; + result);  }   public int solution(int n, int[][] results) {  Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; winnerMap = initGames(n, results, true);  Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; loserMap = initGames(n, results, false);   int answer = 0;   for (int i = 1; i \u0026lt;= n; i++) {  boolean[] visited = new boolean[n];  recursive(winnerMap, visited, i);  recursive(loserMap, visited, i);   int battleCount = countBattle(visited);  if (battleCount == (n - 1)) answer++;  }     return answer;  }   private void recursive(Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map, boolean[] visited, int enemy) {  if (map.get(enemy).isEmpty()) return;   for (Integer val : map.get(enemy)) {  if (!visited[val - 1]) {  visited[val - 1] = true;  recursive(map, visited, val);  }  }  }   private int countBattle(boolean[] visited) {  int count = 0;   for (int i = 0; i \u0026lt; visited.length; i++)  if (visited[i]) count++;   return count;  }   private Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; initGames(int n, int[][] results, boolean isWin) {  int WINNER = isWin ? 0 : 1;  int LOSER = isWin ? 1 : 0;   Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;();   for (int i = 1; i \u0026lt;= n; i++) {  map.put(i, new ArrayList\u0026lt;\u0026gt;());  }   for (int[] result : results) {  int winner = result[WINNER];  int loser = result[LOSER];  map.get(winner).add(loser);  }   return map;  }   } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-11-18-problem_solving_19/","summary":"문제 링크\nProblem 문제 설명\nn명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.\n선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.","title":"# 프로그래머스[Lv.3] - 순위 ( Java )"},{"content":"What ? : 스프링, 정확히는 스프링 프레임워크란, 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크이다. 기존의 Java EE(Enterprise Edition)의 스펙을 구현한 EJB는 기술의 복잡도가 높아, 성능도 느리고 러닝커브도 높았다. 이를 \u0026lsquo;겨울\u0026rsquo;로 빗대서, 개발자들의 \u0026lsquo;봄\u0026rsquo;이 도래했다는 의미로 스프링이라는 명칭을 갖게 되었다.\n그러나, 이렇게만 이야기하면, 겨우 특정 언어의 문법 정도나 갓 뗀 사람들에게는 어렵고 생소하게만 다가온다. 오픈소스? 애플리케이션? 프레임워크? 무슨 뜻일까? 하나씩 살펴보자.\n1) 오픈 소스    오픈 소스란, 어떤 소프트웨어 프로그램을 개발하는 과정에 있어서 필요한 소스 코드를 누구나 볼 수 있도록 공개하는 것을 의미한다. 즉, 내가 어떤 기가 막힌 프로그램을 개발했다고 해보자. 그 프로그램은 결국 내가 소스코드로 정성스럽게 한줄한줄 타이핑했을 것이다. 그리고 그 소스코드를, 다른 사람들이 누구나 볼 수 있도록 공개하면, 이는 해당 프로그램(소프트웨어) 는 곧 오픈 소스 소프트웨어가 된다.\n  2) 애플리케이션    애플리케이션(이하, 앱) 이란, 흔히 모바일 앱을 생각해볼 수 있다. 우리가 사용하는 모바일 앱은, 안드로이드, 혹은 iOS 라는 모바일 운영체제 위에서 동작하며, 카카오톡과 같이 특정 목적을 위해 제작되었고, 또 사용된다. 그러나, 이는 모바일에만 국한되는 이야기는 아니다. 우리가 당장에 컴퓨터 사용하는 크롬과 같은 웹 브라우저, 코딩을 위해 사용하는 Intellij, Eclipse와 같은 IDE 들도 모두 앱이다. 웹 브라우저는 네트워크 통신을 이용한 웹이라는 것을 이용하기 위함이며, IDE는 한층 더 편리하고, 실수 없이 코딩을 할 수 있도록 제작된 응용 프로그램이다. 참고로, Windows, Linux와 같은 운영체제들은 응용 프로그램(앱)이 아닌, 시스템 프로그램에 속한다.\n  3) 프레임워크    프레임워크란 개념은 라이브러리와 비교했을 때 자주 헷갈리는 개념이다.\n  먼저 라이브러리부터 이야기하자면, 가령 C언어에서 #include \u0026lt;stdio.h\u0026gt;, 혹은 파이썬에서 import pandas , 혹은 자바에서 import java.util.*; 이러한 코드를 작성해본 적이 있을 것이다. 이는 우리가 모두 어떤 라이브러리를 사용하겠다고 명시함을 의미한다.\n생각해보자. 라이브러리란, 이름 그대로 도서관이라는 의미를 갖는다. 우리가 도서관에 가서 어떤 책을 읽는다는 것은, 누군가가 특정 지식에 대해서 잘 정리해놓은 것을 배우는것이다. 마찬가지로, 프로그래밍에서도 특정 분야에 대해서 누군가가 잘 만들어서 정리해놓은 것을, 쉽게 이용할 수 있도록 만들어 놓은 것이다. 즉, 한마디로 라이브러리는 \u0026ldquo;도구\u0026rdquo; 이다.\n반대로, 프레임워크란, 뼈대를 의미한다. 즉, 기본적인 구조는 다 구성이 되어 있고, 그 안에서 내가 작업을 하는 것을 말한다. 이 또한, 안드로이드 프레임워크를 생각해볼 수 있다. 안드로이드 프로그래밍을 할 때에는 주로 자바, 혹은 코틀린이라는 언어를 사용한다. 이 언어를 가지고, 내가 안드로이드 앱을 만든다고 생각해보자. 만약 안드로이드 프레임워크 라는 개념이 없더라면, 앱을 만드는 과정이 얼마나 힘들까? 자그마한 버튼 하나를 만들기 위해서, 위치, 크기, 색깔 등을 직접 만들어줘야 할 것이고, 또 이 버튼이 클릭되었을 때 어떻게 동작할 것인지, 그리고 이것이 다른 요소들과 통신했을 때 모두 정상적으로 작동하는지에 대한 아~주 많은 노력이 필요할 것이다. 그러나, 안드로이드 프레임워크 안에서는, 누군가가 이미 잘 만들어서, 문제 없이 잘 동작하는 버튼이라는 개념이 있고, 우리는 이것이 클릭되었을 때 어떤 동작을 할 것인지에 대한, 특수 케이스만 고려하면 된다.\n이 두가지 개념을 다음과 같이 비교할 수 있다.\n가령, 우리가 나무의자를 만든다고 해보자.\n라이브러리와 프레임워크가 둘 다 없다면, 마치 어렸을 적 마인크래프트 게임을 하듯이, 처음부터 모든 것을 다 만들어야 한다. 나무의자를 만들 것이므로, 나무를 베어야 하는데, 그 나무를 베기 위해선 도끼라는 것이 필요하고, 도끼는 철로 만들어져있으니 철도 구해야하고, 철을 구하기 위해서 불도 필요하고 \u0026hellip; 상상만해도, 얼마나 힘들지 눈에 선히 보인다.\n그러나, \u0026ldquo;도끼\u0026rdquo; 라는 라이브러리가 주어진다면 어떨까? 나무를 베는 정도는, 그리 어렵지 않을 것이다. 그리고 이를 잘 다듬기 위한, \u0026ldquo;톱\u0026rdquo; 이라는 라이브러리, 이렇게 조각 낸 나무를 잘 조립시키기 위한, \u0026ldquo;못과 망치\u0026rdquo; 라는 라이브러리 등을 활용하면, 비교적 수월하게 나무의자를 만들어낼 수 있을 것이다.\n프레임워크는, 마치 공방과 같다. 공방에 가면, 우리가 원하는 것들이 다 구비되어 있다. 입맛에 따라 나무를 가져와서, 필요하면 잘라내고, 조립함으로써 손쉽게 나무의자를 만들어낼 수 있다.\n 즉, 스프링 프레임워크란, 우리가 자바로 어떤 소프트웨어를 제작하는데 있어서 편리하게 만들어낼 수 있도록 도움을 주는 무료 공방인 셈이다.\nWhy ? : 그렇다면, 기존의 EJB 를 밀어내고 Spring이 대세로 자리잡게 된 이유는 무엇일까? 이는 스프링을 지탱하는 몇 가지 기술을 기반으로 한다.\n스프링은, Dependency Injecton, Aspect Oriented Programming , 그리고 Portable service Abstraction을 뒷받침으로 개발자가 빠르고, 간단하면서도 생산성까지 잡아낼 수 있는 앱을 개발할 수 있도록 지원한다. 각 요소에 대해서는 나중에 자세히 다룰 예정이지만, 다음과 같이 간단하게 정리할 수 있겠다.\nDependency Injection (DI) : 흔히 IoC, Inversion of Control 이라고 표현되기도 한다. 객체지향 프로그래밍에서 중요시하는 요소 중 하나는, 느슨한 결합력이다. 객체끼리 강한 결합이 아닌 느슨한 결합 관계를 맺음으로써, 부품의 교체가 용이하도록 만드는 것이다. 그리고 이를 위해 Dependency Injection 이라는 방법이 사용되는데, 스프링에서는 이 DI 를 몇 가지 설정을 통해 알아서 지원해준다. 즉, 개발자들이 자연스럽게 객체지향적인 개발을 할 수 있도록, 다시 말해 비즈니스 로직에 집중할 수 있도록 도와준다.\nAspect Oriented Programming : 가령, 우리가 어떤 프로그램을 개발하는데 성공했는데, 이 프로그램의 성능을 측정하기 위해 모든 메소드의 속도를 측정해야 한다고 가정해보자. 메소드가 한 두개라면 괜찮겠지만, 100개, 1000개 라면 어떨까? 각 메소드마다 System.CurrentTimeMillis();를 작성할 수는 없는 노릇이다.\n즉, 여러 곳에서 사용되는 공통적인 코드를 모듈화함으로써, cross-concern(공통 관심사)를 비즈니스 로직과 분리해내고, 각 사항별로 따로 집중할 수 있도록 하는 기능을 스프링이 제공해준다.\nPortable Service Abstraction : 스프링은 다른 여러 모듈을 사용함에 있어서, 별도의 추상화 레이어를 사용한다. 대표적인 예시로는 JDBC가 있다. Java에서 DB로 곧바로 접근하는 것이 아닌, JDBC 라는 추상화를 이용함으로써, 그 뒤에서 DBMS가 오라클이던, MySQL이던 관계 없이, 공통된 방식으로 코드를 작성할 수 있다. 그리고 이를 일관성있게 제어할 수 있도록 한 것이 PSA 인 것이다.\n현실로 비유하자면, 중국집에 가서 \u0026ldquo;짜장면 하나 주세요\u0026rdquo; 라고 했다고 해보자. 이 때, 주방장이 춘장을 얼마나 사용했든, 면을 직접 뽑았든 수타를 쳤든, 관계없이 짜장면이라는 결과를 얻을 수 있는 것과 같다.\n 스프링이 웹개발을 기반으로 발전되어 오긴 했지만, 현재는 Java 라는 언어 위에서, 다양한 분야에서 지원하고 있으므로, 디 팩토인 스프링은 자바를 공부하는 사람이라면 반드시 공부해야 한다고 생각한다.\nReference  [스프링] 스프링이란 무엇인가? wikipedia - 스프링 프레임워크  ","permalink":"http://cjlee38.github.io/post/tech/spring/2020-11-11-what_is_spring/","summary":"What ? : 스프링, 정확히는 스프링 프레임워크란, 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크이다. 기존의 Java EE(Enterprise Edition)의 스펙을 구현한 EJB는 기술의 복잡도가 높아, 성능도 느리고 러닝커브도 높았다. 이를 \u0026lsquo;겨울\u0026rsquo;로 빗대서, 개발자들의 \u0026lsquo;봄\u0026rsquo;이 도래했다는 의미로 스프링이라는 명칭을 갖게 되었다.\n그러나, 이렇게만 이야기하면, 겨우 특정 언어의 문법 정도나 갓 뗀 사람들에게는 어렵고 생소하게만 다가온다. 오픈소스? 애플리케이션? 프레임워크? 무슨 뜻일까? 하나씩 살펴보자.\n1) 오픈 소스    오픈 소스란, 어떤 소프트웨어 프로그램을 개발하는 과정에 있어서 필요한 소스 코드를 누구나 볼 수 있도록 공개하는 것을 의미한다.","title":"# [Spring 학습 정리] Spring Framework 란?"},{"content":"0. 들어가며 : 우아한 테크코스 코딩테스트를 준비하며, 이전에 풀었던 PS 문제들을 하나씩 둘러보던 중, 소수 문제를 발견했다. 소수를 구하는 방법에 여러 가지가 있는 것은 알았는데, 막상 쓰려니까 손가락이 잘 움직이지 않았다.\n해서 생각난 김에, 이번 포스팅에서 주어진 숫자가 소수인지 확인하는 방법에 대해서 알아보고자 한다.\n1. 소수(Prime Number) : 소수를 모르는 사람은 없을 것이다. 그래도 굳이 한번 적어보자면, 소수의 정의는 다음과 같다.\n 1과 자기자신 이외의 수로 나누어 떨어지지 않는, 즉 약수를 갖지 않는 자연수\n 2. Methods to find Prime Number 1) Method 1 : 소수의 정의에 충실하게, n 부터 2까지 하나씩 약분해봄으로써 구할 수 있을 것이다.\npublic static boolean isPrime(int num) {  for (int i = 2; i \u0026lt; num; i++) {  if (num % i == 0) return false;  }   return true; } num을 num와 2 사이의 값으로 나누었을 때 나머지 값이 0이 된다는 것은, 나누어 떨어진다는 것을 의미하고, 이는 곧 약수가 존재함을 의미하니, 소수인지 아닌지 여부를 간단하게 판별해낼 수 있다.\n2) Method 2 : 그런데, 여기서 한 걸음 더 나아가보자. 어떤 주어진 수 X 에 대해서, X/2초과, X미만까지의 값을 Y라고 했을 때, X / Y 는 반드시 1 초과, 2 미만의 값을 가진다.\n정말일까? 예시를 갖고 살펴보자. X를 12로 두었을 때, Y가 될 수 있는 값들은 (7, 8, 9, 10, 11)이 된다. (7, 8, 9, 10, 11) 을 분모로 두는, X / Y 는 (1.714, 1.5, \u0026hellip; , 1.090)인 실수가 되므로, 나누어 떨어지지 않는다.\n이를 바꿔말하면, X/2 초과의 값은 살펴볼 필요가 없다는 말이 된다.\n따라서 우리는 주어진 num 까지가 아닌, num/2까지만 살펴보면 된다.\npublic static boolean isPrime(int num) {  for (int i = 2; i \u0026lt;= num/2; i++) {  if (num % i == 0) return false;  }   return true; } 이 때 주의할 점은, num/2 를 포함해서 살펴봐야 하므로, \u0026lt; 기호가 아닌 \u0026lt;= 기호를 사용해야 한다.\n3) Method 3 : 마지막 한걸음만 더 내딛어 보자. 사실, num/2 까지 갈 필요도 없고, sqrt(num) 까지만 살펴보면 된다. 다음의 예시를 보자.\n num이 12인 경우, sqrt(12) 는 약 3.464 이다. 이 때, 후보 (2, 3) 중 2(또는 3)를 넣는 경우 0으로 나누어 떨어진다. num이 13인 경우, sqrt(13) 은 약 3.606 이다. 이 때, 후보 (2, 3) 중 어느 값을 넣어도 0으로 나누어 떨어지지 않는다.  이것이 어떻게 가능한 것일까? 원리는 간단하다.\n어떤 수의 약수를 쭉 나열하면, 다음과 같은 규칙을 발견할 수 있다.\n 약수의 개수는 반드시 짝수이다. index(i) , index(n-i-1) (n은 약수의 길이, i는 n보다 작은 임의의 수) 를 곱하면 원래의 수가 나온다.  즉, 가령 40 이라는 숫자의 약수는 [1, 2, 4, 5, 8, 10, 20, 40] 으로, 총 **8개(짝수)**의 약수를 갖는다. 그리고, index(0)과 index(8-0-1, 7)은 1과 40이고, 이 둘을 곱하면 원래의 수 40이 나온다. index(1)과 index(8-1-1, 6)은 2와 20이고, 이 둘을 곱하면 원래의 수 40이 나온다. 즉, pair로 묶으면, 이 약수의 리스트 중에서 index(n/2)까지만(앞 절반만) 살펴보면 된다.\n그런데 범위를 정수가 아닌 실수로 확장시켜보면, sqrt(n) * sqrt(n) 이라는 실수의 약수도 있다. 즉, 억지를 부려서, 다음과 같이 약수의 리스트를 만들 수도 있는 것이다.\n[1, 2, 4, 5, 6.325, 6.325, 8, 10, 20, 40]\n* sqrt(40) = 6.325\n즉 바꿔말하면, sqrt(n)은 약수 pair의 중앙값이 되고, 2 이상 sqrt(n) 미만의 값에 정수의 약수가 존재한다면, 이는 곧 합성수라는 의미가 된다.\n잘 이해가 되지 않는다면, 다음의 예시를 보자.\n num이 65 인 경우 -\u0026gt; 약수는 (1, 5, 13, 65) 이고 sqrt(65)는 약 8.062 이다. 따라서, 8.062 는 5와 13 사이에 끼어들어 갈 수 있다. 그리고, 2 이상 8.062 이하의 값 중에, 5 라는 약수가 존재하므로, 합성수다. num이 67 인 경우 -\u0026gt; 약수는 (1, 67) 이다. sqrt(67) 약 8.185 는 1 과 67 사이에 끼어들어 갈 수 있다. 그리고, 2 이상 8.185 이하의 약수가 존재하지 않으므로, 소수다.  따라서, 코드로는 다음과 같이 작성할 수 있다.\npublic static boolean isPrime(int num) {  for (int i = 2; i \u0026lt;= Math.sqrt(num); i++) {  if (num % i == 0) return false;  }   return true; }  위 방법들은, 숫자가 주어졌을 때, 이것이 소수인가요? 에 대답할 수 있는 방법들이다. 거꾸로, 소수의 목록을 주세요. 라고 하면 어떻게 해야할까? 가령 100 까지의 소수를 달라고 하면, 2 부터 100 까지 위 isPrime()을 반복할까? 그것보다는, 소수를 한 번에 생성해놓는 것이 나을것이다.\n(2020.11.16 수정)\n미리 소수를 다 생성을 해놓는 방식을 대개 체(체에 거른다 할 때의 그 체가 맞다.) 라고 부르는데, 여기에는 여러가지 방법이 있다.\n에라토스테네스, 오일러, 순다람, 앳킨\u0026hellip; 의 체가 있는데, 에라토스테네스의 체를 제외한 나머지 방법들은 방법도 어려울뿐더러, 수학자가 아닌데 이것까지 알아야 하나 싶어서 작성을 포기하였다. 여기서는 에라토스테네스의 체만 알아보고, 나머지가 궁금한 사람은 다음의 링크를 참고하자.\n sieve of euler sieve of sundaram sieve of atkin  에라토스테네스의 체 : 에라토스테네스의 체라는, 고대의 수학자가 발견해낸 방법이 있다. 이 또한 원리는 어렵지 않은데, X 가 소수일 때, X를 제외한 나머지 X의 배수는 모두 합성수일 것은 자명하다. 따라서, 2부터 시작해서, 합성수라고 mark 되지 않은 모든 (X가 아닌) X의 배수를 합성수라고 mark 하면 된다.\n이 흐름은 다음의 애니메이션으로 쉽게 이해할 수 있다.\n코드로는 다음과 같이 작성할 수 있다.\npublic static boolean isPrime(int num) {  boolean[] prime = new boolean[num + 1]; //  Arrays.fill(prime, true); // 모든 숫자가 소수라고 가정  prime[0] = prime[1] = false; // 0과 1은 소수의 정의에서 벗어남.   for (int i = 2; i * i \u0026lt;= num; i++) {  if (prime[i]) {  for (int j = i * i; j \u0026lt;= num; j += i) {  prime[j] = false;  }  }  }   return prime[num]; } 잡다한 부분은 쳐내고, for loop만 보자.\n첫 번째 for문의 Math.sqrt(num) 부분은, 위에서 설명했던 부분과 같다. 그 뒷부분은 살펴볼 필요가 없다.\n그리고 이 for문을 반복하면서, 어떤 숫자가 소수라고 mark 되어 있다면, 해당 숫자의 i * i 부터, num 까지. 즉 i의 배수를 합성수로 mark 한다. 이 때, j가 왜 i * i 부터 시작하는지 의문을 가질 수 있는데, i * 2 이상 i * (i - 1) 이하 에서, 2와 i - 1 에 해당하는 값 k 는 이미 검사되었으므로(즉, k 는 이전에 i 였있다.) i * i 부터 시작할 수 있다.\n","permalink":"http://cjlee38.github.io/post/tech/btb/2020-11-08-ways_to_find_prime_number/","summary":"0. 들어가며 : 우아한 테크코스 코딩테스트를 준비하며, 이전에 풀었던 PS 문제들을 하나씩 둘러보던 중, 소수 문제를 발견했다. 소수를 구하는 방법에 여러 가지가 있는 것은 알았는데, 막상 쓰려니까 손가락이 잘 움직이지 않았다.\n해서 생각난 김에, 이번 포스팅에서 주어진 숫자가 소수인지 확인하는 방법에 대해서 알아보고자 한다.\n1. 소수(Prime Number) : 소수를 모르는 사람은 없을 것이다. 그래도 굳이 한번 적어보자면, 소수의 정의는 다음과 같다.\n 1과 자기자신 이외의 수로 나누어 떨어지지 않는, 즉 약수를 갖지 않는 자연수","title":"# 소수(Prime Number)를 찾는 방법 ( feat. Java )"},{"content":"문제 링크\nProblem Solve : 처음에는 한 5분 정도는 문제가 무슨 뜻인지 잘 이해가 되지 않았다.\n문제의 예제를 기준으로 설명하자면,\n R * C 크기의 2차원 배열에서, 각 배열의 요소는 1 ~ R * C 까지의 중복되지 않는 값을 가진다. H * W (H와 W는 홀수) 의 크기만큼의 영역이 여러 개 존재하는데, 그 중 중앙값이 가장 낮은 값을 골라야 한다.  즉, 문제의 예제를 기준으로 설명하자면,\n5 11 12\n17 18 2\n4 23 20\n이 하나의 sub-area 이고, 여기서\n2 4 5 11 12 17 18 20 23\n의 중앙값은 12 이다.\n이런식으로 계속 반복해서, 모든 sub-area의 중앙값을 구한 뒤,\n그 중 최소가 되는 값(즉, Quality rank가 가장 좋은)을 출력하면 된다.\n문제를 이해하고 나니 간단해보였지만, 시간복잡도로 인해 전혀 간단하지 않았던 문제였다.\n한참을 고민하다 안되서, 결국 구글링을 통해 답지를 보고 어떻게 풀어야할지 이해했다.\n첫 번째 시도(실패) : 처음에는, 문제에서 요구하는 그대로 시뮬레이션 했다.\nsub-area를 구하고, 이를 array로 만들고, 중앙값을 찾아서, 최소값인지 비교했다.\npackage BOJ;  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.StringTokenizer;  public class bj10227 {   static Solution10227 init() throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int r = Integer.parseInt(st.nextToken());  int c = Integer.parseInt(st.nextToken());  int h = Integer.parseInt(st.nextToken());  int w = Integer.parseInt(st.nextToken());   int[][] map = new int[r][c];  for (int i = 0; i \u0026lt; r; i++) {  st = new StringTokenizer(br.readLine());  for (int j = 0; j \u0026lt; c; j++) {  map[i][j] = Integer.parseInt(st.nextToken());  }  }   return new Solution10227(r, c, h, w, map);  }   public static void main(String[] args) throws IOException {  Solution10227 s = init();  int answer = s.run();  System.out.println(answer);  } }  class Solution10227 {  private int r;  private int c;  private int h;  private int w;  private int[][] map;   public Solution10227(int r, int c, int h, int w, int[][] map) {  this.r = r;  this.c = c;  this.h = h;  this.w = w;  this.map = map;  }   public int run() {  int min = Integer.MAX_VALUE;   for (int i = 0; i \u0026lt;= r - h; i++) {  for (int j = 0; j \u0026lt;= c - w; j++) {  int[] subArray = createSubArray(i, j);  min = Math.min(min, getMedian(subArray));  }  }   return min;  }    public int[] createSubArray(int i, int j) {  int[] sublist = new int[h*w];  for (int k = 0; k \u0026lt; h; k++) {  for (int l = 0; l \u0026lt; w; l++) {  sublist[(k*h)+l] = map[k+i][l+j];  }  }  return sublist;  }   public int getMedian(int[] sublist) {  Arrays.sort(sublist);  return sublist[(h*w) / 2];  } } 시간초과가 떴으니 답이 맞았는지도 잘 모르겠다.\n아무튼, 코드가 그리 길지 않으니 이해하는데에는 큰 어려움이 없을 것이라 생각한다.\n이렇게 제출하고 나니까 곧바로 시간초과가 떴다.\n문제의 조건을 다시 보니, R과 C는 최대 3000 까지 간다는 것을 볼 수 있었다.\n만약 H와 W가 1500 이라면, 한 번의 Array를 만드는데 1500 * 1500 이 소요될 것이고,\n이를 정렬하는데에 또 N*logN 이 걸릴 것이고,\n또 이 Array를 만들고 정렬하는 총 횟수는 1500 * 1500 번이 필요하다.\n대충 생각만해도 끔찍하다.\n두 번째 방법 : 다른 사람의 풀이 를 보고 이해했다.\n해당 풀이는, 두 단계의 접근법으로 문제를 풀었다.\n 이분 탐색 누적 합  1) 이분 탐색 : 이분 탐색은 여기서 설명할 내용은 아니니, 뭔지 잘 모른다면 다른 글을 참고하자. 이분 탐색을 이용하는 방법은 기존의 방법과 궤를 달리한다.\n간단한 Array에 대한 이분 탐색을 하려면 정렬이 되어 있어야 하는데, 이는 이 문제에 적용해 바꿔 말하면, 내가 갖고 있는 값을 기준으로, 위로 가야 하는가 아래로 가야 하는가에 대한 판단이 가능해야 한다.\n다음의 내용을 차분히 따라가보자.\n우리가 찾고자 하는 값은 \u0026ldquo;중앙값\u0026rdquo; 중 \u0026ldquo;최소값\u0026rdquo; 이다.\n만약 어떤 숫자(m)를 기준으로 삼고,\n m 보다 크면 -\u0026gt; 1 m 보다 작으면 -\u0026gt; -1 m 이면 -\u0026gt; 0  으로 sub-area 를 만들어준다고 가정해보자.\n문제의 예시를 기준으로 설명하자면,\n이 상태에서, m을 (임의로) 12로 둔다고 해보자. 그러면,\n이와 같은 그림이 될 것이다. 그리고 이중에서, 임의의 sub-area를 고른 뒤, sub-area의 합계를 구한다.\n이 때,\n sub-area의 합이 0인 경우 -\u0026gt; m 이 해당 sub-area의 중앙값임. sub-area의 합이 음수인 경우 -\u0026gt; m 이 중앙값보다 큼. sub-area의 합이 양수인 경우 -\u0026gt; m 이 중앙값보다 작음.  을 의미한다. 정말일까?\n위에서 했던 내용이다. 빨간 박스 부분의 합은 0이 된다.\n그리고, 원본의 Array인 2 4 5 11 12 17 18 20 23 의 중앙값은 12이다.\n따라서, sub-area의 합이 0이라면, m 이 중앙값이 맞다.\n하지만 빨간 박스를 위 그림과 같이 옮기게 되면, 합은 -2 가 된다.\n원본 Array를 오름차순 정렬을 해보면 1 2 3 7 10 12 16 20 25 이므로,\nm(12)은 중앙값(10)보다 크다.\n어찌보면 되게 당연해보인다. 그런데 이걸로 무엇을 할 수 있을까?\n사실 이 부분이 이해하기 너무 어려웠다.\n문제에서 요구하는 내용과, 이러한 접근법이 머릿속에서 mapping 되지 않았기 때문이다.\nm을 바꿔서, 1로 설정했다고 가정해보자.\n그러면 다음 그림과 같이, 값 1에 해당하는 부분은 0이 되고, 나머지는 1이 된다.\n이는 어떠한 sub-area를 그려도 m이 중앙값이 될 수 없다는 의미이기도 하지만,\n동시에 sub-area가 모두 양수이므로, m이 너무 작다는 것을 의미한다.\n반대로, m을 25로 설정했다고 가정해보자.\n역시, 값 25에 해당하는 부분은 0 이 되고, 나머지는 -1이 된다.\n이 또한, 어떠한 sub-area를 그려도 m이 중앙값이 될 수 없다는 의미 이면서,\n동시에 sub-area가 모두 음수이므로, m이 너무 크다는 것을 의미한다.\n이 쯤되면, 어떠한 규칙을 발견할 수 있지 않은가?\n즉, 우리가 설정한 m이 중앙값이 되면서, 다시 말해 sub-area의 합이 0이면서,\n동시에 이외의 모든 sub-area들은 양수의 값을 가져야 한다는 것을 의미한다!\n따라서, 위 문제의 정답인 9를 넣은 경우의 모습은 다음과 같다.\n위 빨간 박스의 영역을 제외하고는, 어떠한 sub-area를 계산해봐도 그 합은 모두 양수가 나온다.(아직도 의심이 된다면, 위에서 m이 12일 때, 그리고 빨간 박스가 우측 상단에 있었을 때 합이 -2의 음수가 나왔다는 것을 떠올려보자.)\n이에 더불어, 우리가 원하는 9 라는 정답은, 1 ~ 25 의 중앙값(13) 에서 그리 멀지 않을 것이므로, 13에서 출발해서 위/아래로 이분탐색 하듯이 계산해나가면 된다.\n이렇게 계산했을 때의 장점은, \u0026ldquo;내가 구한 Median이 좋은 Median인가?\u0026rdquo; 에 대한 판단이 가능해져서, Median을 증가시킬 것인지, 감소 시킬 것인지에 대한 구분이 가능해지고, 이에 따라 이분 탐색을 사용할 수 있어진다는 것이다.\n2) 누적 합. 누적 합은 위 이분 탐색 처럼 어렵지는 않다.\n단순하게, \u0026ldquo;계산을 미리 해놓는 것\u0026rdquo; 이라고 생각하면 편하다.\nm이 9일때의 모습을 다시 가져와보자.\n해당 빨간 박스 부분을, 행 단위로 합을 미리 구해놓으면 순서대로\n3\n-1\n-1\n2\n1\n이 된다.\n처음 [3, -1, -1] 부분을 가져와서 합쳐보면(즉, 3*3 sub-area의 합) 1이 된다.\n3을 빼고, 2를 집어넣어서 만든 [-1, -1, 2] 를 합치면, 0이 된다.\n즉, 해당 sub-area 에서, m은 중앙값이다.\n기존의 방식이었다면, -1(-1 - 1 + 1), -1(1 - 1 - 1) 의 두 개를, 중복해서 계산(3이 있을 때 한번, 2가 있을 때 한번) 해야 했지만, 누적 합을 이용할 경우 그럴 필요가 없다. 가로 연산은 한번만 해놓고, 세로 연산할 때 가져와서 쓰기만 하면 되기 때문이다.\n 자, 이제 이론적인 부분은 다 끝났다. 이를 코드로 구현해보자.\npackage BOJ;  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  public class bj10227 {   static Solution10227 init() throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int r = Integer.parseInt(st.nextToken());  int c = Integer.parseInt(st.nextToken());  int h = Integer.parseInt(st.nextToken());  int w = Integer.parseInt(st.nextToken());   int[][] map = new int[r][c];  for (int i = 0; i \u0026lt; r; i++) {  st = new StringTokenizer(br.readLine());  for (int j = 0; j \u0026lt; c; j++) {  map[i][j] = Integer.parseInt(st.nextToken());  }  }   return new Solution10227(r, c, h, w, map);  }   public static void main(String[] args) throws IOException {  Solution10227 s = init();  int answer = s.run();  System.out.println(answer);  } }  class Solution10227 {  private int R;  private int C;  private int H;  private int W;  private int[][] map;   public Solution10227(int r, int c, int h, int w, int[][] map) {  R = r;  C = c;  H = h;  W = w;  this.map = map;  }   public int run() {  int min = 1;  int max = R * C;  int mid;   while (true) {  mid = (max + min) / 2;  int result = tryMedian(mid);   if (result == 0) break;  else if (result == 1) min = mid + 1;  else max = mid - 1;  }  return mid;  }   private int tryMedian(int mid) {  boolean exists = false;   int[] rowSum = new int[R];  for (int i = 0; i \u0026lt;= C - W; i++) {  getRowSumOfTernary(rowSum, mid, i);  int mapSum = 0;  for (int j = 0; j \u0026lt;= R - H; j++) {  mapSum += getMapSum(rowSum, j);   if (mapSum == 0) exists = true;  else if (mapSum \u0026lt; 0) return -1;  }  }   if (exists) return 0;  return 1;  }    private void getRowSumOfTernary(int[] rowSum, int mid, int x) {  if (x == 0) {  for (int i = 0; i \u0026lt; R; i++) {  int sum = 0;  for (int j = x; j \u0026lt; x + W; j++) {  sum += getTernary(mid, map[i][j]);  }  rowSum[i] = sum;  }  } else {  for (int i = 0; i \u0026lt; R; i++) {  rowSum[i] += getTernary(mid, map[i][x+W-1])- getTernary(mid, map[i][x-1]);  }  }  }   private int getTernary(int mid, int value) {  if (value == mid) return 0;  else if (value \u0026gt; mid) return 1;  else return -1;  }   private int getMapSum(int[] rowSum, int x) {  int mapSum = 0;  if (x == 0) {  for (int i = 0; i \u0026lt; H; i++) {  mapSum += rowSum[i];  }  } else {  mapSum += rowSum[x+H-1] - rowSum[x-1];  }   return mapSum;  } } 정답 코드는 위에서 설명한 내용과 조금 다른 부분이 있는데,\nrowSum 과 mapSum 변수를 매 번 새로 구하니 여전히 시간초과가 났다.\n가령, mapSum의 경우, rowSum이 다음과 같이 있다고 할 때\n3 -1 -1 2 1\n3 - 1 - 1 를 계산해서 1 이라는 결과를 내놓고,\n그 다음에 다시 -1 - 1 + 2 를 계산해서 0 이라는 결과를 내놓는 방식을 사용했었다.\n그런데, 이렇게 할 경우 -1, -1 의 중복 연산(위에서 언급했던, \u0026ldquo;-1을 구하기 위한\u0026rdquo; (-1 - 1 + 1) 과 (1 - 1 - 1) 연산과는 다르다. 이 연산의 결과물인 -1의 연산이다.) 이 발생하므로, 이를 제거하기 위해 Sliding window 기법을 이용해서,\n 첫 rowSum (혹은 mapSum)을 구하는 경우 -\u0026gt; 순수하게 계산 첫 번째가 아닌 경우 -\u0026gt; 가장 첫 번째 열(또는 값)을 빼고, 새로운 열(또는 값)을 추가  하는 방식으로 수정했다.(그 덕에 코드가 조금 난잡해졌다.)\n마치며 다른 문제들과 다르게, 진짜 너무너무 어려웠다..\nInternatinal Olympiad in Informatics(처음 들어봤다.) 문제라는데, 이게 어떻게 40% 의 정답률인지 이해가 안될 정도였다.\n그러다보니 기존 PS 들은 그냥, 내가 어떻게 풀었는지 설명하고 코드를 보여주는 식으로 끝났는데, 이 문제는 어쩌다보니 각잡고 쓰게 되었다..\n풀고나서, 다른 사람의 풀이를 보니 Dynamic Programming을 이용하는 방법도 있었다.\n더 이상 머리아프기 싫어서 쳐다보기를 그만두었는데, 혹시 궁금한 사람은\n이 동영상을 참고하면 될 것 같다.\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-11-06-problem_solving_18/","summary":"문제 링크\nProblem Solve : 처음에는 한 5분 정도는 문제가 무슨 뜻인지 잘 이해가 되지 않았다.\n문제의 예제를 기준으로 설명하자면,\n R * C 크기의 2차원 배열에서, 각 배열의 요소는 1 ~ R * C 까지의 중복되지 않는 값을 가진다. H * W (H와 W는 홀수) 의 크기만큼의 영역이 여러 개 존재하는데, 그 중 중앙값이 가장 낮은 값을 골라야 한다.  즉, 문제의 예제를 기준으로 설명하자면,\n5 11 12\n17 18 2","title":"# 백준[No.10227] - 삶의 질 ( Java )"},{"content":"문제 링크\nProblem 문제 설명\n뉴스 클러스터링\n여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.\n개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 카카오 신입 개발자 공채 관련 기사를 검색해보았다.\n카카오 첫 공채..\u0026lsquo;블라인드\u0026rsquo; 방식 채용\n카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용\n카카오, 블라인드 전형으로 신입 개발자 공채\n카카오 공채, 신입 개발자 코딩 능력만 본다\n카카오, 신입 공채.. 코딩 실력만 본다\n카카오 코딩 능력만으로 2018 신입 개발자 뽑는다\n기사의 제목을 기준으로 블라인드 전형에 주목하는 기사와 코딩 테스트에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.\n유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 자카드 유사도라는 방법을 찾아냈다.\n자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.\n예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다.\n자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 1을 3개 가지고 있고, 다중집합 B는 원소 1을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 1을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 1을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다.\n이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 FRANCE와 FRENCH가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(\u0026ldquo;FRANCE\u0026rdquo;, \u0026ldquo;FRENCH\u0026rdquo;) = 2/8 = 0.25가 된다.\n입력 형식\n입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다. 입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 ab+가 입력으로 들어오면, ab만 다중집합의 원소로 삼고, b+는 버린다. 다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. AB와 Ab, ab는 같은 원소로 취급한다.\n출력 형식\n입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.\n예제 입출력\n   str1 str2 answer     FRANCE french 16384   handshake shake hands 65536   aa1+aa2 AAAA12 43690   E=M*C^2 e=m*c^2 65536    Solve : 이해한대로, 그대로 시뮬레이션 하면 되는 문제이다.\n문제를 풀고 나서 보니 대부분의 사람들이 ArrayList로 풀었는데, 나는 HashMap을 이용했다.\n접근방법 : 해결해야 하는 부분은 크게 두가지다.\n 문제에서 요구하는 다중집합 만들기 다중집합을 기반으로, 자카드 유사도 구하기  1. 다중집합 : 다중집합을 만들기는 크게 어렵지 않다. 다음의 순서를 따라가면 된다.\n 문자열 전체를 대문자, 혹은 소문자로 만들어준다.(나는 소문자로 만들었다.) 1씩 증가하면서, 2칸 단위의 temp String(=key)을 만든다.(e.g. ABC -\u0026gt; AB, BC) 해당 temp String이 영문자로만 구성되어 있으면, HashMap에 추가한다. 이 때, HashMap에 key가 이미 존재한다면, value를 1 증가시킨다.  즉, ABCBC 라는 문자열이 들어온다면,\n abcbc로 만듦. ab, bc, cb, bc 로 나눔 위 3, 4번에 따라서, map은 {bc=2, ab=1, cb=1}이 된다.  이렇게 map을 str1, str2 에 대해서 각각 만들어주면 된다.\n2. 자카드 유사도 구하기 : 자카드 유사도를 구할 때에는, 교집합과 합집합을 각각 구해서,\n해당 집합들의 개수를 세면 된다.\n교집합 : 일반적인 집합에 대해서 교집합을 구하는 방법은 간단하지만,\n이 문제는 다중집합 이라는 것을 기억해야 한다.\n따라서, 두 map의 같은 원소의 최소값 이, 내가 세야 할 숫자이다.\n위 입출력 예시에서, aa1+aa2 와 AAAA12 를 가져와보자.\n첫 번째 녀석의 map1은 {aa=2} 가 될 것이고,\n두 번째 녀석의 map2는 {aa=3} 이 될 것이다.\n여기서 다중집합의 교집합의 개수는 2가 되어야 한다.\n만약 여기서 {bb=1} 과 {bb=2} 가 추가로 각각 있었다면,\n1을 골라서, 2+1의 3이 최종 결과값이 된다.\n여전히 이해가 되지 않는다면, 문제 설명의 내용을 다시 읽어보자.\n  다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다.\n  합집합 : 합집합의 경우에는, 교집합의 반대가 된다. 위 aa1+aa2 와 AAAA12 예시를 다시 끌고오자면,\n내가 세야 할 녀석은 2가 아닌 3이 된다.\n역시, 추가로 {bb=1} 과 {bb=2} 가 있었다면,\n세야 할 녀석은 2 이므로, 3+2의 5가 된다.\n 그리고 위에서 구한 교집합의 개수와 합집합의 개수를 기반으로 자카드 유사도는 다음과 같다.\n{aa=2}와 {aa=3} 인 경우 -\u0026gt; 2/3 {aa=2, bb=1}와 {aa=3, bb=2} 인 경우 -\u0026gt; 3/5\n이 자카드 유사도에, 65536을 곱한 뒤 Math.floor() 함수를 통해 소수부를 날려주었다.\n구현 다중집합 다중집합을 구하는 코드는 간단하다.\npublic Map\u0026lt;String, Integer\u0026gt; createMap(String str) {  Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  str = str.toLowerCase();   for (int i = 2; i \u0026lt;= str.length(); i++) {  String temp = str.substring(i - 2, i);  if (isAlpha(temp)) map.compute(temp, (k, v) -\u0026gt; v == null ? 1 : v + 1);  }   return map; }  public boolean isAlpha(String str) {  return str.matches(\u0026#34;^[a-z]*$\u0026#34;); } 적절히 for문을 돌면서, temp String을 만들어 주고,\n이 temp가 영문자로 구성된 경우에 한해서,\n첫 삽입이면 1 을, 아니라면 기존값+1 을 넣어주었다.\n교집합 : 다음과 같이, stream을 이용하였다.\npublic static int getIntersectionCount(Map\u0026lt;String, Integer\u0026gt; map1, Map\u0026lt;String, Integer\u0026gt; map2) {  return map1.entrySet()  .stream()  .filter(x -\u0026gt; map2.containsKey(x.getKey()))  .mapToInt(x -\u0026gt; Math.min(x.getValue(), map2.get(x.getKey())))  .sum(); } key가 공통인 경우에만 한해서 filtering 하고,\n각 value의 값을 구해서, 최소 값이 되는 녀석을 int로 mapping한 다음,\n이 intstream을 summation 해주었다.\n합집합 : 합집합은, 진짜 합집합의 map을 만들어 주었다.\n public static int getUnionCount(Map\u0026lt;String, Integer\u0026gt; map1, Map\u0026lt;String, Integer\u0026gt; map2) {  Map\u0026lt;String, Integer\u0026gt; union = new HashMap\u0026lt;\u0026gt;(map1);  map2.forEach((k, v) -\u0026gt; union.merge(k, v, (v1, v2) -\u0026gt; v1 \u0026gt; v2 ? v1 : v2));   return union.values().stream().mapToInt(Integer::intValue).sum();  } 합집합을 만들고 나서, stream을 통해 summation 해주었다.\n만약 교집합을 구할때 처럼 곧바로 stream을 쓸 경우,\nmap1 에는 없으나 map2 에는 있는 원소에는 접근할 수 없다는 문제가 있다.\n 이렇게 두 개의 Count를 구하고 나서,\n위에서 언급한대로 적절히 값을 수정해서 return 하면 된다.\n전체 코드는 다음과 같다.\npackage programmers.lv2;  import java.util.HashMap; import java.util.Map;  // 프로그래머스 - [1차] 뉴스 클러스터링 public class p17677 {  public static void main(String[] args) {  String str1 = \u0026#34;FRANCE\u0026#34;;  String str2 = \u0026#34;french\u0026#34;;   int result = solution(str1, str2);  System.out.println(result);  }   public static int solution(String str1, String str2) {   Map\u0026lt;String, Integer\u0026gt; map1 = createMap(str1);  Map\u0026lt;String, Integer\u0026gt; map2 = createMap(str2);   System.out.println(\u0026#34;map1 = \u0026#34; + map1);  System.out.println(\u0026#34;map2 = \u0026#34; + map2);   // 두 다중집합이 공집합인 경우, 자카드 유사도는 1로 판단.  if (map1.isEmpty() \u0026amp;\u0026amp; map2.isEmpty()) return 65536;   int intersection = getIntersectionCount(map1, map2);  int union = getUnionCount(map1, map2);   System.out.println(\u0026#34;intersection = \u0026#34; + intersection);  System.out.println(\u0026#34;union = \u0026#34; + union);   return (int) Math.floor(((double) intersection / union) * 65536);  }   public static Map\u0026lt;String, Integer\u0026gt; createMap(String str) {  Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  str = str.toLowerCase();   for (int i = 2; i \u0026lt;= str.length(); i++) {  String temp = str.substring(i - 2, i);  if (isAlpha(temp)) map.compute(temp, (k, v) -\u0026gt; v == null ? 1 : v + 1);  }   return map;  }   public static boolean isAlpha(String str) {  return str.matches(\u0026#34;^[a-z]*$\u0026#34;);  }   public static int getUnionCount(Map\u0026lt;String, Integer\u0026gt; map1, Map\u0026lt;String, Integer\u0026gt; map2) {  Map\u0026lt;String, Integer\u0026gt; union = new HashMap\u0026lt;\u0026gt;(map1);  map2.forEach((k, v) -\u0026gt; union.merge(k, v, (v1, v2) -\u0026gt; v1 \u0026gt; v2 ? v1 : v2));   return union.values().stream().mapToInt(Integer::intValue).sum();  }   public static int getIntersectionCount(Map\u0026lt;String, Integer\u0026gt; map1, Map\u0026lt;String, Integer\u0026gt; map2) {  return map1.entrySet()  .stream()  .filter(x -\u0026gt; map2.containsKey(x.getKey()))  .mapToInt(x -\u0026gt; Math.min(x.getValue(), map2.get(x.getKey())))  .sum();  }  } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-11-03-problem_solving_17/","summary":"문제 링크\nProblem 문제 설명\n뉴스 클러스터링\n여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.\n개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 카카오 신입 개발자 공채 관련 기사를 검색해보았다.\n카카오 첫 공채..\u0026lsquo;블라인드\u0026rsquo; 방식 채용\n카카오, 합병 후 첫 공채.","title":"# 프로그래머스[Lv.2] [1차] 뉴스 클러스터링 ( Java )"},{"content":"문제 링크\nProblem. 문제 설명\n매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.\n섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)\nLeo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\nLeo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.\n제한 사항\n scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.  입출력 예\n   scoville K return     [1, 2, 3, 9, 10, 12] 7 2    입출력 예 설명\n  스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\n가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]\n  스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다. 새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\n가진 음식의 스코빌 지수 = [13, 9, 10, 12]\n  모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.\nSolve : 지난 번에 풀었던 야근 지수 문제와 살짝 흡사하다.\n접근방법. 문제의 핵심은, 가장 작은 수(음식)을 두 개 꺼내서, 이를 계산 후 다시 집어넣는 것이다.\n음식이 들어있는 array를 내림차순 정렬해서,\n가장 뒤에서 두개를 꺼냈다가 다시 집어넣는 방법도 있지만,\n우선순위 큐라는, 여기에 아주 걸맞는 자료구조가 있으므로,\n이용하지 않을 이유가 없다.\n구현. 연습도 할 겸, 겉멋으로 스트림을 이용했다.\nPriorityQueue\u0026lt;Integer\u0026gt; foods  = Arrays.stream(scoville)  .boxed()  .collect(Collectors.toCollection(PriorityQueue::new)); 현재 foods 라는 우선순위 큐는 오름차순 정렬되어있으므로,\n하나씩 꺼낼때에는, 가장 낮은 숫자가 튀어나오게 된다.\n첫 번째 꺼내는 녀석은 그대로,\n두 번째 꺼내는 녀석은 2를 곱한 뒤,\n다시 집어넣어주면 되는데\n이 때 주의할 점은, 매 반복마다 2개의 음식을 꺼내므로,\nfoods의 크기가 2 이상이어야 한다는 것이다.\nwhile (foods.size() \u0026gt; 1 \u0026amp;\u0026amp; foods.peek() \u0026lt; K) {  foods.offer(foods.poll() + foods.poll() * 2);  count++; } 그리고 마지막으로,\n모두 잘 섞여서 반복이 중단된건지,\n아니면 K 이상으로 만들 수 없어서 중단된건지,\n를 확인하기 위해, peek()한 값이 K보다 큰지 확인하고,\n맞으면 count를, 아니라면 -1을 return하면 된다.\nreturn foods.peek() \u0026gt;= K ? count : -1; 전체 코드는 다음과 같다.\npackage programmers.lv2;  import java.util.Arrays; import java.util.PriorityQueue; import java.util.stream.Collectors;  //프로그래머스 - 더 맵게 public class p42626 {  public static void main(String[] args) {  int[] socville = {1, 5};  int K = 7;  int result = solution(socville, K);  System.out.println(result);  }   public static int solution(int[] scoville, int K) {  int count = 0;   PriorityQueue\u0026lt;Integer\u0026gt; foods = Arrays.stream(scoville)  .boxed()  .collect(Collectors.toCollection(PriorityQueue::new));   while (foods.size() \u0026gt; 1 \u0026amp;\u0026amp; foods.peek() \u0026lt; K) {  foods.offer(foods.poll() + foods.poll() * 2);  count++;  }   return foods.peek() \u0026gt;= K ? count : -1;  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-10-30-problem_solving_16/","summary":"문제 링크\nProblem. 문제 설명\n매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.\n섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)\nLeo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.","title":"# 프로그래머스[Lv.2] 더 맵게 ( Java )"},{"content":"varargs : varargs 는 variable arguments의 약자로, 한국어로는 \u0026ldquo;가변인자\u0026rdquo; 로 해석된다.\n이는 지난번에 포스팅했던 파이썬의 Asterisk(*) 다루기 와 비슷한데,\narguments를 몇 개를 받을지 지정하지 않고, 호출하는 쪽에서 정해주겠다는 의미가 된다.\n다음의 예시를 보자.\n구현하고자 하는 코드는, 입력받은 여러 개의 문자열을 하나씩 출력하고자 한다.\n가변인자를 사용하지 않는 방식\npublic class Main {  public static void main(String[] args) {  Main main = new Main();  String[] strs = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;};  main.foo1(strs);  }   public void foo1(String[] strs) {  for (String str : strs) {  System.out.println(\u0026#34;str = \u0026#34; + str);  }  } }  // 결과 // str = hello // str = world // str = java 정상적으로 잘 동작하는 모습을 볼 수 있다.\n그러나, 이렇게 작성하지 않고, 가변인자를 사용하면 다음과 같다.\n가변인자를 사용하는 방식\npublic class Main {  public static void main(String[] args) {  Main main = new Main();  main.foo2(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;);  }   public void foo2(String ... strs) {  for (String str : strs) {  System.out.println(\u0026#34;str = \u0026#34; + str);  }  } } // 결과 // str = hello // str = world // str = java foo2() 라는 메소드를 호출할 때, Array가 아닌 3개의 문자열을 따로 전달해주었다.\n그리고 이를 받는 메소드 foo2()는 ... 표시를 통해 배열이 아닌 varargs를 받도록 했다.\n코드는 변하였지만, 결과는 기존의 방식과 차이가 없다.\n그렇다면 어떤 효용성이 있을까?\n첫 번째로는, formatting에 있다. System.out.printf() 혹은, String.format() 이 이러한 방식으로 동작한다.\nString[] strs = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;}; String sout = String.format(\u0026#34;numOfStrings = %d, first String = %s \u0026#34;, strs.length, strs[0]); System.out.println(sout); 위 코드에서, sout의 인자 전달을 보면,\n첫 번째로는 \u0026ldquo;\u0026ldquo;로 작성된 String literal을,\n두 번째로는 strs.length 라는 숫자를,\n세 번째로는 strs[0], 즉 \u0026quot;hello\u0026quot; 를 넘겨주었다.\n뒤에 몇 개를 전달하더라도,\n앞 literal의 이스케이프 시퀀스와 짝을 맞춰주면 정상적으로 동작한다.\n내부는 다음과 같이 작성되어 있다.\npublic static String format(String format, Object... args) {  return new Formatter().format(format, args).toString(); } 두 번째로는, Arrays.asList()가 있다. 배열을 List로 전환하는 가장 쉬운 방법은,\n루프를 돌면서 하나씩 더하는 것이다.\nString[] strs = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;}; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();  for(String str : strs) {  list.add(str); } 그러나, 좀 더 심플하게 넣는 방법은 Arrays.asList() 메소드를 활용하는 것이다.\nString[] strs = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;}; List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(strs)); 한 발 더 나가서,\n이 Arrays.asList() 메소드 또한, varargs를 받기 때문에,\n다음과 같이 작성해도 무리가 없다.\nList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;)); 이 때, 눈치가 빠르면 알겠지만,\nArrays.asList()를 첫 번째 방식과, 두 번째 방식으로 사용할 때,\n넘겨준 인자가 서로 다르다.\n첫 번째 녀석은 strs 라는 배열을 넘겨줬지만, 두 번째는 3개의 문자열을 넘겨주었다.\n이것이 가능한 이유는, 자바 컴파일러가 ... 라는 syntax를 보고,\n이를 array로 바꾸어주기 때문이다.\n    원본 컴파일 이후     메소드 public void method(String \u0026hellip; args) public void method(String[] args)   호출 method(\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;world\u0026rdquo;); method(new String[]{\u0026ldquo;hello\u0026rdquo;, world\u0026rdquo;});    varargs 를 사용할 때 주의할 점은,\n이를 파라미터의 가장 마지막에 넣어야 한다는 것이다.\n다음과 같은 메소드가 있다고 생각해보자.\npublic void method(String ... args, String specific) {  // do something } 이 메소드를 호출할 때, specific 이라는 곳에 값을 넣어줄 수 있는 방법이 없다.\n따라서, IDE는 곧바로 에러를 띄워준다.\nVararg parameter must be the last in the list\nkeyword-arguments : keyword-argument, keyword-parameter, named-argument, named-parameter\u0026hellip;\n모두 같은 이야기이다.\n이는, 함수를 호출 할 때에, 값만 넘겨주는 것이 아니라,\n명시적으로 이름까지 지정하는 것이다.\n가령, 파이썬에서의 예시는 다음과 같다.\ndef introduce(name, age):  print(\u0026#34;안녕하세요, 제 이름은\u0026#34;, name, \u0026#34;이고, 나이는\u0026#34;, age, \u0026#34;입니다.\u0026#34;)  introduce(\u0026#34;홍길동\u0026#34;, 25) # without keyword introduce(name = \u0026#34;홍길동\u0026#34;, age = 25) # with keyword 어느 파라미터에 어떤 변수를 집어넣을 것인지 명확하게 볼 수 있다.\n이러한 기능의 장점은, 파라미터의 변수가 많아질 때 극명하게 드러난다.\n아쉽게도, 자바는 이러한 기능을 지원하지 않는다.\n그러나, 이를 유사하게 흉내낼 수 있는 방법을 몇 가지 소개한다.\n  Note. named parameter를 지원하지 않는 이유는, 여기를 읽어보자.\n  위 파이썬 같은 코드를, 자바로 구현했다고 가정해보자.\nclass Foo {  public void introduce(String name, int age) {  System.out.println(\u0026#34;안녕하세요, 제 이름은 \u0026#34; + name + \u0026#34; 이고, 나이는 \u0026#34; + age + \u0026#34; 입니다.\u0026#34; );  } } 기본적으로 사용할 때에는, 다음과 같이 사용한다.\npublic class Main {  public static void main(String[] args) {  Foo foo = new Foo();  foo.introduce(\u0026#34;홍길동\u0026#34;, 25);  } }  첫 번째로는, 변수를 lazy 하게 정의하는 방법이 있다.\npublic class Main {  public static void main(String[] args) {  Foo foo = new Foo();  String name;  int age;   foo.introduce(name = \u0026#34;홍길동\u0026#34;, age = 25);  } } 두 번째 방법은, 받은 값을 그대로 돌려주는 static method를 이용하는 방법이다.\nimport static com.company.Foo.*;  public class Main {  public static void main(String[] args) {  Foo foo = new Foo();   foo.introduce(name(\u0026#34;홍길동\u0026#34;), age(25));  } }  class Foo {  public void introduce(String name, int age) {  System.out.println(\u0026#34;안녕하세요, 제 이름은 \u0026#34; + name + \u0026#34; 이고, 나이는 \u0026#34; + age + \u0026#34; 입니다.\u0026#34; );  }   public static String name(String name) {  return name;  }   public static int age(String age) {  return age;  } } 마지막 세 번째는 다른 방법들과 약간 궤를 달리하지만,\n마치 stream을 사용하듯이, Builder pattern을 사용하는 것이다.\npublic class Main {  public static void main(String[] args) {  Foo foo = Foo.builder()  .setName(\u0026#34;홍길동\u0026#34;)  .setAge(25)  .build();   foo.introduce();  } }  class Foo {  private final int age;  private final String name;   private Foo(Builder builder) {  age = builder.age;  name = builder.name;  }   public static Builder builder() {  return new Builder();  }   public void introduce() {  System.out.println(\u0026#34;안녕하세요, 제 이름은 \u0026#34; + name + \u0026#34; 이고, 나이는 \u0026#34; + age + \u0026#34; 입니다.\u0026#34; );  }   public static class Builder {  private int age;  private String name;   public Foo build() {  return new Foo(this);  }   public Builder setAge(int age) {  this.age = age;  return this;  }    public Builder setName(String name) {  this.name = name;  return this;  }  }   } 클래스의 instance를 직접 생성하지 않고,\nBuilder 라는 static class 를 통해서 만든다.\n이 Builder는 setter method 가 void가 아니고,\n자기 자신(instnace)를 return 해서,\n계속 set, set, set.. 을 할 수 있도록 한다.\n최종적으로 build() 메소드를 호출하면,\nFoo 클래스의 생성자로 지금까지 만든 Builder를 넘겨주어,\nFoo 의 instance를 만들도록 하는 방법이다.\n약간 난해하게 생겼는데, 차분히 코드를 따라가면 이해할 수 있을 것이다.\nReference  Java Varargs Named Parameters in Java Stackoverflow - Named Parameter idiom in Java  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-25-java_parameters/","summary":"varargs : varargs 는 variable arguments의 약자로, 한국어로는 \u0026ldquo;가변인자\u0026rdquo; 로 해석된다.\n이는 지난번에 포스팅했던 파이썬의 Asterisk(*) 다루기 와 비슷한데,\narguments를 몇 개를 받을지 지정하지 않고, 호출하는 쪽에서 정해주겠다는 의미가 된다.\n다음의 예시를 보자.\n구현하고자 하는 코드는, 입력받은 여러 개의 문자열을 하나씩 출력하고자 한다.\n가변인자를 사용하지 않는 방식\npublic class Main {  public static void main(String[] args) {  Main main = new Main();  String[] strs = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;};  main.","title":"# (Java) Parameter를 활용하는 방법 ( feat. varargs, kwargs )"},{"content":"0. 들어가며 : 첫 처음 자바를 배웠을 당시가 떠오른다.\n아무것도 모른채, \u0026ldquo;약속\u0026quot;이라는 말과 함께\npublic static void main(String][] args) 를 기계적으로 입력했었는데,\n이게 무슨 뜻인지, 왜 이렇게 썼는지에 대해서 그닥 신경을 안썼던 것 같다.\n그런데, 최근 스프링을 공부하면서, 난생 처음으로 내손으로 테스트를 작성해보다,\nmain method가 없는데 어떻게 실행되지? 라는 의문에 봉착했다.\n생각의 꼬리를 물고 올라가다 보니, main method 자체에 대한 의문이 생겼다.\n파이썬을 생각해보면, 이러한 main method 하나 없이도,\nprint(\u0026quot;hello world\u0026quot;) 라는 명령어 하나만으로 실행이 가능했다.\n그런데 Java는 다르다. 그 근본을 하나씩 파헤쳐보자.\n1. public static void main(Strign[] args) main : 가장 먼저 의문이 들었던 부분은, \u0026ldquo;메소드 이름이 정말 main이어야 하는가?\u0026rdquo; 이다.\n백문이 불여일견. main 의 이름을 init으로 바꿔보고, 실행해보았다.\n코드\npublic class Main {   public static void init(String[] args) {  System.out.println(\u0026#34;hello world\u0026#34;);  }  } 실행결과\njava Main.java error: can\u0026#39;t find main(String[]) method in class: com.company.Main 보다시피, 반드시 이름은 main 이어야 하는 것 같다.\n그렇다면, 각각의 keyword가 필요한 이유는 무엇일까?\npublic : public은 알다시피, 접근 제어자다.\npublic으로 선언하게 되면, 외부로 공개되어 이 메소드는 다른 클래스에서 사용될 수 있다.\n따라서 main method가 public으로 선언되어야 하는 이유는 당연해보이지만,\n그 좀만 더 자세하게 살펴보자.\nJava 프로그램이 실행되는 절차는 다음과 같다.\n Java classloader가 Class들을 JVM으로 load한다.(≒ 등록한다.) class 내에 작성된 static block을 실행한다. main method를 찾은 뒤, 이를 invoke 한다.    Note. 위 흐름과 같이, 우리가 작성한 코드가 그 자체로써 동작하는 것이 아니라, JRE 라는 환경 안에 편입(?) 되므로, 파이썬 처럼 곧바로 메소드를 수행할 수 없는 것이다.\n  테스트를 위해, 다음과 같은 코드를 작성해서 실행해보자.\n코드\npublic class Main {   static {  System.out.println(\u0026#34;hello world\u0026#34;);  }  } 실행결과\njava Main.java hello world error: can\u0026#39;t find main(String[]) method in class: com.company.Main 보는 바와 같이, static block을 실행했으나,\nmain method를 찾지 못해서 에러가 발생한다.\n  Note. 위와 같은 에러를 발생시키지 않으려면, System.exit(0); 를 통해\nmain method() invokation을 일으키지 않고 프로그램을 종료할 수 있다.\n  다음으로, static block을 실행 한 이후에, main method가 실행 되는지 확인해보자.\n코드\npublic class Main {  static int value = 10;  static {  System.out.println(\u0026#34;1 : \u0026#34; + value);  value++;  System.out.println(\u0026#34;2 : \u0026#34; + value);  }   public static void main(String[] args) {  System.out.println(\u0026#34;3 : \u0026#34; + value);  value++;  System.out.println(\u0026#34;4 : \u0026#34; + value);  }  } 실행결과\n1 : 10 2 : 11 3 : 11 4 : 12 예상한 순서대로 프로그램이 진행된 것을 확인할 수 있다.\n즉 정리하자면, 이 JVM이 위와 같은 흐름을 진행하면서\nmain method를 호출하는데, JVM은 Main 이라는 class가 아니므로,\npublic으로 선언해줘야 한다.\nstatic : static 또한 마찬가지다.\nMain 이라는 클래스의 instance를 만들지 않고 호출할 수 있도록, static keyword 를 붙여야 한다.\n다시 말해, non-static 이라면, main method를 호출하기 위해서 instance를 만들어야 한다.\n또한, main method는 어찌 되었든, 프로그램의 가장 첫 스택에 쌓이는 메소드다.\n말인 즉슨, 프로그램의 시작과 끝(Stack이므로)을 함께하는 메소드이고,\n따라서 프로그램이 종료될 때 까지 유지되어야 하기 때문에, static으로 선언된다.\nvoid : void는 딱히 특별할 것이 없는 것 같다.\nvoid가 아니라면, 우리가 프로그램을 종료할 때에, 어떤 값을 반환하겠다는 의미인데,\n이 값을 받는 JVM이 무슨 역할을 할까?\nJava의 개발자가 아닌 사용자는, 이에 대해서 쉽게 답변할 수 없을 것 같다.\n  Note. 사실 의문점이 남는 부분이 하나 있는데, 가장 처음 배웠던 C언어를 생각해보면, main() 함수를 void main() 이 아닌 int main()으로 사용했고, void main()을 사용하더라도 컴파일러에 의해 int main()으로 변환된다는 이야기를 들었다. 그리고, 이 때 return 되는 값은 기본적으로 0 인데, 이는 \u0026ldquo;정상적으로 종료되었다\u0026rdquo; 를 의미한다. 그리고 이 결과값을 받는 것은 Shell 프로그램이고, 이 Shell 이 받는 결과값에 따라서 또 행동이 달라질 수 있다.\n그러나, Java에서는 그저 void로, 아무것도 return하지 않는다. 즉, 결과에 관계 없이, JVM은 언제나 같은 동작만을 수행한다고 예측할 수 있다. 이러한 차이에 대해서, Java 개발자인 제임스 고슬링의 철학을 알 수 있는 도리가 없으니, 아쉽지만 여기서 멈춰야한다.\n  String[] args : args는 arguments의 약자로, 프로그램 외부에서 전달하는 인자를 받아내는 역할을 한다.\n역시, 코드로 살펴보자.\n코드\npublic class Main {  public static void main(String[] args) {  for (String arg : args) {  System.out.println(arg);  }  }  } 실행결과\njava Main.java hello world hello world 두 개의 숫자를 사칙연산을 하는 계산기 프로그램을 만들었다고 생각해보자.\n그렇다면, 숫자를 어디서 구할 것인가?\n코드 안에서 input을 받을 수도 있지만, 위와 같은 방식으로 곧바로 넣어줄 수도 있는 것이다.\n2. Where is main method in Junit test? : Junit의 main method 를 이야기 하는데,\n위와 같이 main method의 근본에 대한 잡설을 한 이유는,\n우리가 작성한 Java program이 어떻게 동작하는가? 에 대해서 이해하기 위함이었다.\n즉, 3. main method를 찾은 뒤, 이를 invoke 한다. 라는 것이 핵심이다.\n그렇다면, main method가 없다면 프로그램이 실행되지 않을까?\nstatic block을 사용하지 않는다면, 그렇다.\n결국, main method는 있어야 한다.\n다시 돌아와서, Intellij와 같은 개발환경에서 테스트 코드를 보면,\nmain method는 전혀 존재하지 않는다.\n그런데도, 옆에 ▶ 의 run 버튼이 생긴다. 어떻게..?\nMain 클래스와 테스트 클래스를 각각 돌려서,\n터미널을 확인해보면 그 이유를 알 수 있다.\nMain\n\u0026#34;C:\\Program Files\\Java\\jdk1.8.0_261\\bin\\java.exe\u0026#34; \u0026#34;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.1\\lib\\idea_rt.jar=7495:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.1\\bin\u0026#34; -Dfile.encoding=UTF-8 -classpath \u0026#34;어어엄청나게 많은 라이브러리들\u0026#34; com.company.Main Test\n\u0026#34;C:\\Program Files\\Java\\jdk-11.0.8\\bin\\java.exe\u0026#34; -ea -Didea.test.cyclic.buffer.size=1048576 \u0026#34;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.1\\lib\\idea_rt.jar=2288:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.1\\bin\u0026#34; -Dfile.encoding=UTF-8 -classpath \u0026#34;어어엄청나게 많은 라이브러리들\u0026#34; com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.company.myTest (테스트를 사용하는 프로젝트와, Java 연습용으로 사용하는 프로젝트의 JDK 버전을 다르게 설정해놓았는데, 여기서는 특별한 의미는 없다.)\n우리가 cmd 창을 열어서, java Main.java라는 명령어를 입력하듯이,\nIDE의 run 버튼은 위와 같은 정말 길고도 긴 명령어를 한방에 딱 입력해준다.\n이 중에서 주목해야할 부분은, com.intellij.rt.junit.JUnitStarter 라는 부분이다.\n저녀석과 JDK 버전, 그리고 실행하는 java 파일 이름을 제외하면 거의 비슷하다는 것을 확인할 수 있다.\n즉, 우리가 테스트를 실행하면,\n본질적으로는 com.intellij.rt.junit.JUnitStarter 이 녀석이 실행되는 것이다.\nC:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.1\\plugins\\junit\\lib\\junit-rt.jar\n를 까보면, (경로는 사용자마다 다를 수 있다.)\ncom.intellij.rt.junit.JUnitStarter.class 가 있는 것을 확인할 수 있다.\n엥? 위에서 테스를 실행했던 명령어에서,\ncom.intellij.rt.junit.JUnitStarter 랑 같은 위치다.\n와우, 그렇다면 우리가 이 녀석을 실행한다는 것을 알 수 있다.\nIntellij를 이용해서, 디컴파일 해보면\npublic static void main(String[] args) {  List\u0026lt;String\u0026gt; argList = new ArrayList(Arrays.asList(args));  ArrayList\u0026lt;String\u0026gt; listeners = new ArrayList();  String[] name = new String[1];  String agentName = processParameters(argList, listeners, name);  if (!\u0026#34;com.intellij.junit5.JUnit5IdeaTestRunner\u0026#34;.equals(agentName) \u0026amp;\u0026amp; !canWorkWithJUnitVersion(System.err, agentName)) {  System.exit(-3);  }   if (!checkVersion(args, System.err)) {  System.exit(-3);  }   String[] array = (String[])argList.toArray(new String[0]);  int exitCode = prepareStreamsAndStart(array, agentName, listeners, name[0]);  System.exit(exitCode); } 드디어 메인 메소드를 찾았다.\n그리고, 이 뒤에 붙은 -ideVersion5 -junit5 com.company.myTest 녀석들을 인자로 넘겨주면서,\n적절한 프로세싱과, 테스트의 실행이 동작한다.\n3. 마치며 Junit이 동작하는 방식에 대해서도 코드로 살짝 훑어봤는데,\n어렵기도 하고, 여기에 또 쓰기에는 양이 정말 많아질 것 같아서, 이쯤 해야 할 것 같다.\n이상으로 포스팅을 마칩니다. 틀린 부분이 있으면 지적 바랍니다.\nReference  Stackoverflow - Can we execute a program without main() method? main 함수의 반환 값 활용하기 Stackoverflow - java junit has no main function Stackoverflow - Why is main() in java void? wikipedia - 자바 클래스로더  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-23-how-junit_works_without_main/","summary":"0. 들어가며 : 첫 처음 자바를 배웠을 당시가 떠오른다.\n아무것도 모른채, \u0026ldquo;약속\u0026quot;이라는 말과 함께\npublic static void main(String][] args) 를 기계적으로 입력했었는데,\n이게 무슨 뜻인지, 왜 이렇게 썼는지에 대해서 그닥 신경을 안썼던 것 같다.\n그런데, 최근 스프링을 공부하면서, 난생 처음으로 내손으로 테스트를 작성해보다,\nmain method가 없는데 어떻게 실행되지? 라는 의문에 봉착했다.\n생각의 꼬리를 물고 올라가다 보니, main method 자체에 대한 의문이 생겼다.\n파이썬을 생각해보면, 이러한 main method 하나 없이도,\nprint(\u0026quot;hello world\u0026quot;) 라는 명령어 하나만으로 실행이 가능했다.","title":"# (Java) Junit은 어떻게 Main method 없이 실행될까? "},{"content":"0. 들어가며 : Java 는 Call by Value일까, Call by Reference 일까?\n지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,\n객체를 넘겨줄 때에는 call by reference로 알고 있었다.\n그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.\n1. Call in Java : Java 에서는 언제나 Call by Value 라고 한다.\n약 12년 된 스택오버플로우의 한 질문글에 달린 답변은 다음과 같다.\n  자바는 예외 없이, 항상 pass by value 입니다.\n그렇다면, 왜 사람들이 이것을 혼란스러워 하고, Java는 pass by reference라고 믿고 있을까요? 키 포인트는, Java가 어떠한 상황에서도, 객체의 값에 직접적인 접근을 제공하지 않기 때문입니다. 객체에 접근하는 유일한 방법은 그 객체의 참조를 통하는 것뿐입니다. Java 객체가 직접 접근되지 않고 참조에 의해 접근되기 때문에, 현학적으로 필드, 변수, 그리고 메소드 인자를 객체인 것처럼 이야기 되는데, 이것들은 객체에 대한 참조일 뿐입니다. 이러한 혼란은 (엄밀히 말하면, 틀린) 명명(命名)의 변화에서 기인합니다.\n따라서, 메소드를 호출할 때,\n Primitive인 경우 : pass-by-value 는 primitive의 실제 값의 전달입니다. 객체인 경우 : pass-by-value는 객체에 대한 참조 \u0026ldquo;값\u0026quot;의 전달입니다.\n\u0026hellip; 하략    또 다른 답변의 경우, 친절하게 예시도 같이 달아주었다.\npublic static void main(String[] args) {  Dog aDog = new Dog(\u0026#34;Max\u0026#34;);  Dog oldDog = aDog;   // we pass the object to foo  foo(aDog);  // aDog variable is still pointing to the \u0026#34;Max\u0026#34; dog when foo(...) returns  aDog.getName().equals(\u0026#34;Max\u0026#34;); // true  aDog.getName().equals(\u0026#34;Fifi\u0026#34;); // false  aDog == oldDog; // true }  public static void foo(Dog d) {  d.getName().equals(\u0026#34;Max\u0026#34;); // true  // change d inside of foo() to point to a new Dog instance \u0026#34;Fifi\u0026#34;  d = new Dog(\u0026#34;Fifi\u0026#34;);  d.getName().equals(\u0026#34;Fifi\u0026#34;); // true } 이 예제를 보고 나니, 위 답변이 무슨 말을 하는지 이해할 수 있었다.\n코드를 보면, aDog 라는 변수를 foo() 메소드로 넘겨주었다.\nfoo() 메소드 안에서, getName() 을 찍어보면 \u0026quot;Max\u0026quot;로 찍히는 것은 당연하다.\n그러나, 주의깊게 봐야 할 부분은 d = new Dog(\u0026quot;Fifi\u0026quot;) 다.\n만약 참조에 의한 호출이었다면, d 라는 참조는 본래 aDog가 가리키는 객체를 가리킬 것이다.\n따라서, aDog는 Fifi로 바뀌어야 한다.\n그러나 메소드를 실행하고 나서 다시 aDog의 getName()을 찍어보면,\n여전히 \u0026quot;Max\u0026quot;로 남아있다.\n왜냐하면, aDog 라는 참조 를 넘겨준 것이 아니라, 복사본 을 넘겨주었기 때문이다.\n여전히 이해하기 힘들다면, 다음의 그림을 보자.\nDog aDog = new Dog(\u0026#34;Max\u0026#34;); Dog oldDog = aDog; 위 코드를 실행하면, 그림과 같이 aDog과 oldDog는 Max라는 녀석을 가리키고 있다.\n여기서, foo() 메소드를 실행하면 어떻게 될까?\n위 그림과 같이, d는 aDog의 복사본(call-by-value)이 된다.\n만약, 참조에 의한 호출이었다면 다음과 같은 모양새였을 것이다.\n그러나, 실제로 d는 복사본이므로, new Dog(\u0026quot;Fifi\u0026quot;)를 수행하면 다음과 같이 된다.\n따라서, foo() 메소드 안에서 getName() 을 찍어보면 \u0026quot;Fifi\u0026quot;로 나오지만,\n메소드가 끝난 이후, 메인 메소드에서 다시 getName()을 찍어보면 \u0026quot;Max\u0026quot;로 나오게 된다.\n반면, foo() 메소드 안에서, d.setName(\u0026quot;Fifi\u0026quot;) 라고 사용한다면,\n다음 그림과 같이 메소드 종료 이후에 aDog의 Name은 \u0026quot;Fifi\u0026quot;가 될 것이다.\n결국 Java는 Call-by-value 이지만, 우리가 사용할 때에는 대부분 Call-by-Reference 처럼 인식하게 된다.\nCall-by-value라고 해서, 특별하게 걱정할 내용은 없다는 얘기다.\n2. How about Wrapper classes? : 하지만, Integer 와 같은 Wrapper class는 어떨까?\n다음 코드의 결과를 예상해보자.\npublic class Main {   public static void main(String[] args) {  int intValue = 10;  Integer integerValue = new Integer(10);  MyInteger myIntegerValue = new MyInteger(10);   System.out.println(\u0026#34;before intValue = \u0026#34; + intValue);  System.out.println(\u0026#34;before integerValue = \u0026#34; + integerValue);  System.out.println(\u0026#34;before myIntegerValue = \u0026#34; + myIntegerValue.getValue());   intMethod(10);  integerMethod(integerValue);  myIntegerMethod(myIntegerValue);   System.out.println(\u0026#34;after intValue = \u0026#34; + intValue);  System.out.println(\u0026#34;after integerValue = \u0026#34; + integerValue);  System.out.println(\u0026#34;after myIntegerValue = \u0026#34; + myIntegerValue.getValue());   }   public static void intMethod(int value) {  value = value + 1;  }   public static void integerMethod(Integer value) {  value = value + 1;  }   public static void myIntegerMethod(MyInteger value) {  value.increase();  }  }  class MyInteger {  private int value;   public MyInteger(int value) {  this.value = value;  }   public int getValue() {  return value;  }   public void increase() {  value = value + 1;  } } 결과는 다음과 같다.\nbefore intValue = 10 before integerValue = 10 before myIntegerValue = 10 after intValue = 10 after integerValue = 10 after myIntegerValue = 11 int 값의 경우, 위에서 이야기한 것처럼 call-by-value 이므로,\n10이 그대로 유지되는 것은 당연하다.\nMyInteger의 경우 또한, myIntegerValue 라는 참조값을 복사해서 전달했으므로,\n11로 늘어나는 것 또한 타당하다.\n이는 앞서 이야기한 코드 예시에서, setName(\u0026quot;Fifi\u0026quot;) 를 실행한 것과 비슷하다.\n주목할 부분은, integerValue 다.\nInteger는 primitive가 아닌 class이고,\n따라서 integerValue 는 new Integer(10) 을 가리키고 있던 것이 아닐까?\n그렇다면, value = value + 1 을 실행하면 11이 나와야 할 것 같은데,\n10으로 그냥 유지되어 버렸다.\n왜 이렇게 되었을까?\n3. Secret in Wrapper class : 그 비밀을 파헤치기 위해, Integer 클래스를 살짝 뜯어보자.\nInteger 클래스의 (int 형을 넘겨주는 경우의) 생성자는 다음과 같이 생겼다.\npublic Integer(int value) {  this.value = value; } 이 this.value 를 찾아가보면, 다음과 같이 final 로 선언된 것을 볼 수 있다.\nprivate final int value; 말인 즉슨, Integer 클래스는 Immutable(불변) 이라는 뜻이 된다.\n그렇다면, 아까 작성했던 value = value + 1 은 어떻게 동작했을까?\nWrapper class에 대해서 배웠다면, autoboxing, unboxing 이라는 용어에 대해서 들어봤을 것이다.\n이 boxing이 어떻게 일어나는지, 바이트 코드를 들여다보자.\npublic static void main(String[] args) {  Integer integerValue = 10; } public static void main(java.lang.String[]); Code: 0: bipush 10 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: return 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n이라는 부분을 보면, valueOf() 라는 static 메소드를 호출하고 있음을 볼 수 있다.\nvalueOf() 메소드는 다음과 같이 생겼다.\npublic static Integer valueOf(int i) {  if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high)  return IntegerCache.cache[i + (-IntegerCache.low)];  return new Integer(i); } 따라서, autoboxing은 내부적으로 컴파일러가 valueOf() 메소드를 호출했고,\n이에 따라 새로운 Integer 객체를 생성해서, 이를 return 하고 있음을 볼 수 있다.\n그렇다면, 덧셈은 어떻게 동작할까?\npublic static void main(String[] args) {  Integer integerValue = 10;  integerValue = integerValue + 1; }  public static void main(java.lang.String[]); Code: 0: bipush 10 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: aload_1 7: invokevirtual #3 // Method java/lang/Integer.intValue:()I 10: iconst_1 11: iadd 12: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 15: astore_1 16: return 0, 2, 5 번호의 byte code는 위의 내용과 같다.\nvalueOf() 메소드를 실행한 뒤에,\n그 결과인 Integer 객체를 지역변수 Array의 1번에 할당했다.\n6 번에서, 만들었던 이 Integer 객체를 꺼내왔고,\n7 번에서, intValue()라는 메소드를 호출했다. 참고로 intValue()는 다음과 같이 생겼다.\npublic int intValue() {  return value; } 다음으로 10번에서, 1 이라는 상수 값을 가져왔다.\n(iconst_1은 integerValue = interValue + 1 에서, 1을 담당한다.\n만약, 1 대신 3을 더했다면, 바이트 코드는 iconst_3이 된다.)\n이렇게 까지 하면,\n아까 Integer 객체에서 꺼낸 int 값과,\n상수 1이 Stack에 쌓여 있다.\n11번에서 이 두개를 더한다(iadd)\n그리고, 다시 Integer.valueOf() 의 static method를 실행해서,\n다시 Integer 객체로 만들고, 이를 다시 지역변수 Array의 1번에 저장한다.\n와우, 긴 여정이 끝났다. 정리하면 다음과 같다.\n(Integer 덧셈코드)\nInteger integerValue = 10; integerValue = integerValue + 1;  int 값(10)을 boxing(Integer 객체로 만듦)하고, 저장한다. 저장한 Integer 값을 unboxing 한다. unboxing 된 int 값에, 1을 더한다. 더한 결과(11)를 다시 boxing 하고, 저장한다.    Note. 이런 동작방식을 증명하는 또 다른 방법은,\n다음과 같은 코드를 실행해보는 것이다.\nInteger value = 10; System.out.println(\u0026#34;value.getClass() = \u0026#34; + value.getClass()); System.out.println(\u0026#34;(value+1).getClass() = \u0026#34; + (value+1).getClass()); 당연하게도, (value+1)은 unboxing된 int형이므로,\ngetClass()라는 메소드가 없다는 에러를 뱉는다.\n  이 과정을, 아까 수행한 integerMethod()에 대입해서 생각해보자.\n다시 스크롤해서 올려보기 귀찮을테니, 코드를 여기에 다시 적겠다.\npublic static void integerMethod(Integer value) {  value = value + 1; } 아직 덧셈 연산을 하기 전에는, 다음과 같은 형태를 갖고 있을 것이다.\n그러나, 방금 정리했듯이,\n더한 결과를 다시 Boxing하므로\n다시 말해, 새로운 new Integer() 객체를 생성하므로,\n덧셈을 하고나면, 다음의 그림과 같이 된다.\nvalue 라는 변수는 위와 같이 11 이라는 새로운 객체를 가리키고 있으므로,\nintegerMethod() 를 수행하더라도, 메소드의 종료 이후 결과값은 변하지 않는다.\n4. 마치며 : 길고도 험난한 여정이었다.\nC언어는 포인터라는 개념이 있기에,\n메소드를 호출해서 그 내부의 값을 변경하려면 무조건 이를 이용해야 하는데,\nJava에서는 primitives 와 object 의 동작방식이 다르고,\n이에 더해 Wrapper class는 클래스임에도 불구하고 primitives 처럼 동작해서 자주 헷갈렸다.\n이번 포스팅을 통해 확실하게 개념을 잡을 수 있었던 것 같다.\n이상으로 포스팅을 마칩니다.\nReference  Is Java “pass-by-reference” or “pass-by-value”? Wrapper classes and call by reference in java [duplicate] Java bytecode instruction listings  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-21-java_wrapper_class/","summary":"0. 들어가며 : Java 는 Call by Value일까, Call by Reference 일까?\n지금까지는, 함수의 parameter로 primitive type을 넘겨줄 때에는 call by value,\n객체를 넘겨줄 때에는 call by reference로 알고 있었다.\n그런데, 구선생님의 말씀에 따르면, 그렇지는 않은 것 같다.\n1. Call in Java : Java 에서는 언제나 Call by Value 라고 한다.\n약 12년 된 스택오버플로우의 한 질문글에 달린 답변은 다음과 같다.\n  자바는 예외 없이, 항상 pass by value 입니다.","title":"# (Java) Wrapper Class는 Call by Value 일까?"},{"content":"  본 포스팅은 마틴 파울러가 Value Object 에 대해 작성한 글을 의역했습니다.\n정확한 이해를 위해, 가능하시면 원문을 보시는 것을 추천드립니다.\n  프로그래밍을 할 때, 종종 사물(things)을 복합적으로 표현하는게 유용할 때가 있습니다. 2차원의 좌표는 x 값과 y 값을 가집니다. 돈은 숫자와 통화를 가집니다. 기간은 시작 날짜와 끝 날짜를 가지고, 이것들은 연, 월, 일을 가집니다.\n이럴 때, 두 복합 객체가 같은지에 대해서 궁금할 때가 있습니다. (2,3)의 직교 좌표계를 갖는 두 개의 Point 객체가 서로 같다는 것은 말이 됩니다. 어떠한 객체가, 갖고 있는 속성으로 인해, (이 경우에는 x와 y 좌표) 같다고 여겨지면, Value Object 라고 불립니다.\n하지만 내가 신중하게 프로그래밍 하지 않는다면, 내 프로그램에서 다음과 같은 행위를 이해하지 못할 것입니다.\nJavascript에서, 점(Point) 을 표시한다고 해봅시다.\nconst p1 = {x: 2, y: 3}; const p2 = {x: 2, y: 3}; assert(p1 !== p2); // NOT what I want 슬프게도 이 테스트는 통과합니다. 이는 자바스크립트가 객체를 참조에 의해 동일한지 비교하고, 그것들이 갖고 있는 값은 무시하기 때문입니다.\n대부분의 상황에서는, 값 보다 참조를 이용하는 것이 타당합니다. 가령 여러 개의 판매 주문을 가져와서 다룰 때에는, 각 주문을 한 곳에 모아야 합니다. 그리고 Alice의 가장 최근 주문이 배송예정 목록에 있는지 확인해야 한다면, 메모리 참조 혹은 Alice의 주문 ID를 이용해서 확인할 수 있습니다. 이러한 테스트를 할 때에는, 주문에 어떤 요소가 있는지 신경 쓸 필요가 없습니다. 비슷하게, 고유한 주문 번호를 이용해서 Alice의 주문 번호가 배송 목록에 있는지 확인할 수 있습니다.\n따라서, 내가 객체를 어떻게 구분하느냐에 따라, Value Object와 Reference Object의 두 종류의 객체로 생각하는 것이 유용합니다. 각 객체가 어떻게 동일성을 다룰지에 대해서 본인이 확실히 알아야 하고, 그 기대에 따라 동작할 수 있도록 프로그래밍 해야합니다. 이를 어떻게 구현할 지는, 내가 사용하는 프로그래밍 언어에 따라 달라집니다.\n일부 언어는 모든 복합 데이터를 값으로 다룹니다. Clojure에서 간단한 복합물을 만들면, 다음과 같습니다\n\u0026gt; (= {:x 2, :y 3} {:x 2, :y 3}) true 이는 모든 것들을 immutable(불변) 값으로 다루는 함수형 스타일입니다.\n하지만 함수형 언어를 사용하지 않아도, Value Object를 만들 수 있습니다. 예를 들어, Java에서는 기본적인 Point 클래스는 내가 원하는 방식으로 동작합니다.\nassertEquals(new Point(2, 3), new Point(2, 3)); // Java Point class 가 원래의 equals 메소드를, 값에 대한 검사로 override 하는 방법입니다.\nJavascript에서도 비슷하게 할 수 있습니다.\nclass Point {  constructor(x, y) {  this.x = x;  this.y = y;  }  equals (other) {  return this.x === other.x \u0026amp;\u0026amp; this.y === other.y;  } } const p1 = new Point(2,3); const p2 = new Point(2,3); assert(p1.equals(p2)); 여기서 Javascript의 문제점은, 내가 정의한 equals 메소드를 다른 Javascript 라이브러리가 모른다는 것 입니다.\nconst somePoints = [new Point(2,3)]; const p = new Point(2,3); assert.isFalse(somePoints.includes(p)); // not what I want  //so I have to do this assert(somePoints.some(i =\u0026gt; i.equals(p))); 이는 Java의 문제가 아닙니다. 왜냐하면, Object 클래스의 equals 메소드는 core 라이브러리에 정의되어 있고, 모든 다른 라이브러리들은 객체를 비교할 때 이 메소드를 사용하기 때문입니다( == 연산자는 주로 원시(primitive) 타입에만 사용됩니다.)\nValue Object의 좋은 결과중 하나는, 메모리의 같은 값을 갖고 있는 객체에 대해서 하나의 참조를 갖고 있는지, 다른 객체를 갖고 있는지 신경 쓸 필요가 없다는 것입니다. 하지만, 내가 조심하지 않는다면, 행복한 무지(ignorance)가 문제로 이어질 수 있습니다. Java로 예시를 보여드리겠습니다.\nDate retirementDate = new Date(Date.parse(\u0026#34;Tue 1 Nov 2016\u0026#34;));  // this means we need a retirement party Date partyDate = retirementDate;  // but that date is a Tuesday, let\u0026#39;s party on the weekend partyDate.setDate(5);  assertEquals(new Date(Date.parse(\u0026#34;Sat 5 Nov 2016\u0026#34;)), retirementDate); // oops, now I have to work three more days :-( 이것은 Aliasing Bug 의 예시중 하나입니다. 한 곳의 날짜를 바꾸었는데(partyDate.setDate(5)), 내가 기대한 것과 다른 결과를 가져옵니다. Aliasing Bug를 피하기 위해, 간단하지만 중요한 규칙을 따라야 합니다 : Value Object는 immutable 이어야 한다.(변하지 않아야 한다.) 만약 내가 파티 날짜를 바꾸고 싶다면, 새로운 객체를 만들어야 합니다.\nDate retirementDate = new Date(Date.parse(\u0026#34;Tue 1 Nov 2016\u0026#34;)); Date partyDate = retirementDate;  // treat date as immutable partyDate = new Date(Date.parse(\u0026#34;Sat 5 Nov 2016\u0026#34;));  // and I still retire on Tuesday assertEquals(new Date(Date.parse(\u0026#34;Tue 1 Nov 2016\u0026#34;)), retirementDate); 물론, Value Object가 정말 불변 이라면, 불변으로 Value Object를 다루는 것이 훨씬 쉽습니다. 객체를 가지고, 어떠한 setting method도 제공하지 않음으로써 이를 쉽게 구현할 수 있습니다. 따라서, 예전 나의 Javascript 코드는 다음과 같이 생겼습니다.\nclass Point {  constructor(x, y) {  this._data = {x: x, y: y};  }  get x() {return this._data.x;}  get y() {return this._data.y;}  equals (other) {  return this.x === other.x \u0026amp;\u0026amp; this.y === other.y;  } } 불변은 Aliasing Bug를 피하기 위한, 제가 가장 좋아하는 테크닉 중 하나이지만, 변수를 할당할 때, 언제나 객체의 복사본을 만들게 함으로써 버그를 피할수도 있습니다. C# 의 구조체와 같은 언어들은 이러한 기능을 제공합니다.\nValue Object로 다룰지, Reference Object로 다룰지는 상황에 따라 달라집니다. 대부분의 경우, 우편 주소는 간단한 텍스트 구조를 가진 Value Object로 다룰 수 있습니다. 하지만 좀 더 정교한 지도 시스템은 우편 주소를 정교한 계층 모델로 연결할 수 있고, 이 때는 Reference 가 타당합니다. 대부분의 모델링 문제와 마찬가지로, 다른 상황에는 다른 해결책이 필요합니다.\n일반적으로, 문자열과 같은 일반적인 Primitive 요소를 적절한 Value Object로 만드는 것은 좋은 생각입니다. 전화번호는 문자열로 나타낼 수 있지만, \u0026ldquo;전화번호 객체\u0026quot;로 만드는 것은 변수와 파라미터를 좀 더 명시적이게 하고(언어가 지원한다면, 데이터 타입 확인), 자연스럽게 검증에 초점을 맞출 수 있게 하며, 적용이 불가능한 동작(예를 들면, 정수 ID 숫자에 대한 연산)을 피하게 해줍니다.\n좌표, 돈, 기간과 같은 작은 객체들은 Value Object의 좋은 예시입니다. 그러나, 더 큰 객체도, 개념적인 정체성(ID)을 갖고 있지 않거나, 프로그램 내에서 참조를 공유할 필요가 없는 경우, Value Object로 프로그래밍 될 수 있습니다. 이는 불변성이 기본인 함수형 언어에 좀 더 자연스럽습니다.\nValue Object는, 특히 작은 경우에, 경시되는 경향이 있습니다 - 너무 사소해서 생각할 가치도 없는 것으로 보이곤 합니다. 하지만, 좋은 Value Object를 발견하고 나면, 객체들에 더욱 다양한 행위를 만들어 낼 수 있습니다. 이를 맛보려면, Range class를 통해, 다양한 행위를 활용해서 start 와 end 속성을 조작하고, 이를 통해 모든 종류의 중복을 어떻게 막는지 확인해보세요. 이렇게 Domain-specific한 Value Object는 리팩토링의 초점 역할을 하고, 시스템을 급격한 간소화로 이끕니다. 이러한 단순화를 몇번 보면, 깜짝 놀랄 것입니다 - 그리고, 그때 쯤이면, Value Object는 좋은 친구가 되어 있을 것입니다.\n","permalink":"http://cjlee38.github.io/post/tech/btb/2020-10-20-value_object/","summary":"본 포스팅은 마틴 파울러가 Value Object 에 대해 작성한 글을 의역했습니다.\n정확한 이해를 위해, 가능하시면 원문을 보시는 것을 추천드립니다.\n  프로그래밍을 할 때, 종종 사물(things)을 복합적으로 표현하는게 유용할 때가 있습니다. 2차원의 좌표는 x 값과 y 값을 가집니다. 돈은 숫자와 통화를 가집니다. 기간은 시작 날짜와 끝 날짜를 가지고, 이것들은 연, 월, 일을 가집니다.\n이럴 때, 두 복합 객체가 같은지에 대해서 궁금할 때가 있습니다. (2,3)의 직교 좌표계를 갖는 두 개의 Point 객체가 서로 같다는 것은 말이 됩니다.","title":"# (번역) Value Object of Martin Fowler"},{"content":"문제 링크\nProblem 문제 설명\nFinn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.\n 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15  자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.\n제한사항\nn은 10,000 이하의 자연수 입니다.\n입출력 예\n   n result     15 4    Solve : 이런 문제를 푸는 방법은 두 가지 중 하나인 것 같다.\n수학을 엄청 잘해서, 머릿속에 수식을 만들어 낸 뒤 이를 코드로 풀어내거나,\n혹은 깊은 고민 끝에 패턴을 찾아내거나.\n당연히 나는 후자에 속해서, 어떻게 하면 패턴을 찾아낼 수 있을까 고민 끝에,\n다음과 같은 방법을 찾아냈다.\n흐름을 설명하면, 다음과 같다.\n 숫자가 가감되는 sum, 1,2번에서 설명할 head, tail, 그리고 정답의 count를 정의한다. 목표 숫자 n이 될 때까지, factorial을 계산하듯이 head를 1씩 늘려가며 sum에 더한다. sum이 n보다 같거나 크면, n보다 작아질 때까지 1씩 증가하는 tail을 뺀다. 와중에, n과 같으면, count를 증가시킨다. 1~3번의 과정을 n까지 반복한다.  역시나, 말로 설명하면 이해하기 힘들다. 예시를 보자.\n1부터 5까지 head를 늘려나가면서, sum 에 더하면, 다음과 같이 된다.\n1 + 2 + 3 + 4 + 5(head = 5, tail = 1, count = 0)\n이 때, sum이 n보다 크거나 같으므로, n보다 작아질때까지 tail을 뺀다. 와중에, n과 sum이 같으므로 count를 1 증가시킨다.\n2 + 3 + 4 + 5(head = 5, tail = 2, count = 1)\nsum이 n보다 작아졌으므로, 다시 2번의 더하기를 시작한다.\n2 + 3 + 4 + 5 + 6(head = 6, tail = 2, count = 1)\nsum이 n보다 크거나 같으므로, 다시 3번의 빼기를 시작한다.\n3 + 4 + 5 + 6(head = 7, tail = 3, count = 1) 4 + 5 + 6(head = 7, tail = 4, count = 1)\n5 + 6(head = 7, tail = 5, count = 2)\n중간에 4+5+6 에서, sum이 n과 같으므로, count가 하나 증가한 모습을 볼 수 있다.\n이러한 과정을 반복하면, 답을 손쉽게 구할 수 있다.\n전체 코드는 다음과 같다.\npackage programmers.lv2;  public class p12924 {  public static void main(String[] args) {  int n = 15;  int result = solution(n);  System.out.println(result);  }   public static int solution(int n) {  int sum = 0, count = 0, tail = 1, head = 1;   for ( ; head \u0026lt;= n; head++) {  sum += head;  while(sum \u0026gt;= n) {  if (sum == n) count++;  sum -= tail;  tail++;  }  }   return count;  } } 다른 사람의 풀이 : 다른 분들의 풀이를 보니, 대개 두가지로 나뉘는 것 같았다.\n  \u0026ldquo;주어진 자연수를 연속된 자연수의 합으로 표현하는 방법의 수는 주어진 수의 홀수 약수의 개수와 같다라는 정수론 정리가 있습니다\u0026rdquo; 라는 멘트가 달려있는, 문제 풀이와 전혀 연관이 없어 보이는\u0026hellip; 놀라운 코드\n  i를 num까지 반복하면서, 각 i마다 i부터 시작하는 j변수가 num까지 달려가면서 정답여부를 확인하는 (아마 시간복잡도로 O(NlogN)이었던 것 같은데) 코드\n  잠시 구글링을 해봤더니, 효율성이 2번의 코드는 약 1.5ms ~ 2 ms 인 반면,\n내 코드는 0.4ms ~ 0.5ms 정도가 나왔다.\n1번코드의 효율성은\u0026hellip; 따질 필요도 없지않을까 싶다.\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-10-19-problem_solving_15/","summary":"문제 링크\nProblem 문제 설명\nFinn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.\n 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15  자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.","title":"# 프로그래머스[Lv.2] 숫자의 표현 ( Java )"},{"content":"0. 들어가며 : 혹시, 여러 개로 겹쳐있는 for문을 반복하다가, 어느 조건을 만족했을 때,\n**전체 반복문을 중단시키려면 어떻게 해야 할까?**에 대해서 고민해본 적이 있는가?\n아마 지금까지는 두가지 방법 중 하나를 사용했을 것 같다.\nA 방법\nboolean flag = false; for (int i = 0; i \u0026lt; 10; i++) {  for (int j = 0; j \u0026lt; 10; j++) {  if ( /*some_condition*/ ) {  flag = true;  break;  }  }  if (flag) {  break;  } } B 방법\nfor (int i = 0; i \u0026lt; 10; i++) {  for (int j = 0; j \u0026lt; 10; j++) {  if ( /*some_condition*/ ) return;  } } 아마 후자의 방식을 많이 사용했을 것 같은데,\n만약 return을 하기 전에 추가적으로 해줘야 하는 어떤 작업이 있었다면,\n코드가 약간 더러워보이더라도 전자의 방식을 어쩔 수 없이 사용했을 것이다.\n그러나, label을 이용하면, 아주 간단하게 해결할 수 있다.\n1. 형태 : for-loop, 혹은 while-loop 앞에, 이름 그대로 \u0026ldquo;Label\u0026rdquo; 을 붙이는 것을 의미한다.\n다음과 같이 사용할 수 있다.\nfoo: for(int i = 0; i \u0026lt; 10; i++) {  // do something  if (i == 5) break foo; } 결과\n0 1 2 3 4 별 거 없어보이고, 기존 for-loop 랑 별반 차이도 없어보이지만,\nlabel의 힘은 아까와 같이, 반복문이 겹쳐 있을 때 비로소 발휘된다.\nfoo: for (int i = 0; i \u0026lt; 10; i++) {  bar:  for (int j = 0; j \u0026lt; 10; j++) {  System.out.println(i + \u0026#34; \u0026#34; + j);  if (j == 6) break foo;  } } 결과\n0 0 0 1 0 2 0 3 0 4 0 5 0 6 break는 한번만 사용되었는데, 가장 바깥쪽 foo 라고 labeling 된 loop가 중단되었다.\n처음에는 보고 \u0026lsquo;이거 코틀린 코드인가?\u0026rsquo; 싶어 눈을 비벼보아도, 자바코드였다.\n나중에 공부를 하고 나서야 label 이라는 것을 알게 되었다.\n2. 써도 될까? : 언뜻 보면, C 계열 언어에서 거의 죄악시 하는 goto 문이랑 비슷해서,\n쓰면 안될것 같기도 한데, 찾아보니 써도 괜찮다고 한다.\n말인 즉슨, \u0026ldquo;Control Flow를 전이 시키는 것이 아니므로, 괜찮다\u0026rdquo; 고 한다. 자세한 내용은 여기 를 참고하자.\n3. How about Python ? 여담으로, Python에서는 이러한 기능이 없는데,\n파이썬의 창시자인 귀도 반 로섬이 이러한 이유로 거절했다고 한다.\n대신, 예외처리를 발생시키는 raise StopIteration 을 응용해 활용할 수 있다.\n4. 의문점 : label statement 라면, if-statement에도 붙을 수 있다는 뜻이고,\n실제로 코드를 작성해보아도 어떠한 에러도 나지 않고, 결과에도 영향이 없다.\n그런데, 이를 어떻게 응용할 수 있을지에 대해서는 도저히 떠오르지 않는다.\n이 부분에 대해서는 조금 더 공부를 해봐야 알 것 같다.\nReference  Labeled Statements in Java Naming Loops in Python - StackOverflow Is using a labeled break a good practice in Java?  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-18-label_statement/","summary":"0. 들어가며 : 혹시, 여러 개로 겹쳐있는 for문을 반복하다가, 어느 조건을 만족했을 때,\n**전체 반복문을 중단시키려면 어떻게 해야 할까?**에 대해서 고민해본 적이 있는가?\n아마 지금까지는 두가지 방법 중 하나를 사용했을 것 같다.\nA 방법\nboolean flag = false; for (int i = 0; i \u0026lt; 10; i++) {  for (int j = 0; j \u0026lt; 10; j++) {  if ( /*some_condition*/ ) {  flag = true;  break;  }  }  if (flag) {  break;  } } B 방법","title":"# (Java) 효율적인 반복문 탈출을 위한 Label"},{"content":"0. 들어가며 : 나는 재귀함수를 좋아하지 않는다.\n재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.\n그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.\n이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,\n재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.\n1. 재귀함수의 사전적 정의 : 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.\n이를 프로그래밍에 적용하면, 함수가 자기 자신으로 되돌아옴 정도로 표현할 수 있겠다.\n다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다.\n2. 해결할 문제. 이러한 재귀함수를 활용하는 가장 대표적인 문제는, 역시 피보나치 수열이다.\n잡다한 이야기는 쫙 빼고, 피보나치 수열이 무엇인가 하면,\nN번째 항의 값은, 그 전항(N-1) 과, 그 전전항(N-2)의 값의 합이다.\n라는 것으로 정의되는 수열이다.\n즉, 만약 N이 3이라면, 다시 말해 fibonacci(3)을 구하고자 한다면,\n전항인 fibonacci(2)와, fibonacci(1)의 값을 더해서 구할 수 있다.(이하 F() 로 통일)\n그렇다면 F(0)과 F(1)을 구하기 위해 F(-1)과 같은 음수로 가느냐?\n그렇지는 않고, 0과 1의 값은 각각 0과 1로 정의되어 있다.\n간단하게, F(4)를 구해보자. 이를 구하기 위해서는, F(3)과 F(2)를 알아야 한다.\nF(3)과 F(2)를 구하기 위해서는, F(2)와 F(1)을, 그리고 F(1)과 F(0)을 구해야 한다.\nF(1)과 F(0)은 1과 0으로 정의되어 있으니, 다시 거꾸로 타고 올라가면 된다.\nF(2) = F(1) + F(0) = 1 + 0 = 1\nF(3) = F(2) + F(1) = 1 + 1 = 2\nF(4) = F(3) + F(2) = 2 + 1 = 3\n답이 나왔다. F(4)의 답은 3 이다.\n3. 해결법 : 여러 가지 해결 방법이 있지만, 반복문과 오늘의 핵심인 재귀함수 두가지 방법을 이용해보자.\n1) 반복문 : 반복문을 이용하는 방법은 간단하다.\n배열을 만들어놓고, 전항의 값, 그리고 전전항의 값을 더해서 넣으면 된다.\npublic static int fibonacci(int n) {  int[] fibo = new int[n+1];  fibo[0] = 0;  fibo[1] = 1;   for (int i = 2; i \u0026lt; fibo.length; i++) {  fibo[i] = fibo[i-1] + fibo[i-2];  }   return fibo[n]; } 보는 바와 같이, 0번째 항과 1번째 항은 0과 1로 값을 미리 채워두고,\n반복문을 통해 더해가면서 구할 수 있다.\n2) 재귀함수 : 그렇다면, 재귀함수는 어떨까?\npublic static int fibonacci(int n) {  if (n == 0) return 0;  else if (n == 1) return 1;   return fibonacci(n-1) + fibonacci(n-2); } 삼항연산자로도 풀어낼 수 있지만,\n가장 기본에 충실하게 작성하면 위와 같이 작성할 수 있다.\nn에 3이 들어오는 경우, fibonacci(2)와 fibonacci(1) 이 각각 호출되고,\nfibonacci(2)는 fibonacci(1)과 fibonacci(0)을 호출한다.\nfibonacci(1)은 1을, fibonacci(0)은 0을 return하므로, 이 둘을 더해 fibonacci(2)는 1이 된다.\n따라서, fibonacci(2) + fibonacci(1)은 1+1이 되어,\n최종적으로 2가 return된다.\n여기까지 모두가 행복하게 잘 살았습니다의 해피엔딩으로 끝나면 좋겠지만,\n문제가 남아있다.\n4. 문제점 : 만약, 피보나치에 100을 요구하면 어떻게 될까?\n결과가 나타나지 않는다. 너무 오래 걸리는 탓이다.\n반토막을 내서 50을 넣어봐도, 약 65초가 걸렸다.\n(여담으로 값은 약 120억으로, int형의 최대값인 21억을 훨씬 넘어선다.)\n왜 이렇게 오래 걸릴까?\n그 이유는, 재귀함수를 돌면서, Call Stack이 쌓이기 때문이다.\n위 코드를 다시 보자.\nfibonacci(n)을 구하기 위해, fibonacci(n-1), fibonacci(n-2)를 수행해야 한다.\n당연하게 보이지만, fibonacci(n-1)과 fibonacci(n-2)를 구하기 전까지는,\nfibonacci(n)은 대기하고 있는 상태이다.\n즉, n이 0 또는 1이 되기 전까지는 계속해서 대기, 대기, 대기 하는 함수들이 쌓이고,\n0 또는 1이 되어서야 다시 돌아와서 값을 구하고, 더해야 하기 때문이다.\n5. 해결 방법 : 이는 다음의 두 가지 방법으로 해결할 수 있다.\n1) Tail Recursion : 먼저 활용할 수 있는 방법은 꼬리재귀를 이용하는 방법이다.\n꼬리재귀는, 재귀함수의 탈을 쓴 while문과 같다.\n앞서, 위와 같이 계속해서 Stack이 쌓였던 이유는,\nfibonacci(n-1)과 fibonacci(n-2)를 구하고 나서,\n이를 더하는 연산이 필요했기 때문이다.\n즉, 아직 할 일이 남아있었다.\n그런데, 할 일이 없다면 어떨까?\n그냥 곧바로, 가장 최초로 함수를 실행한 지점으로 return을 쏴버리면 안될까?\n안될 것 없다.\n코드를 다음과 같이 수정해보자.\npublic static int fibonacci(int n) {  return fibonacciTail(n, 0, 1); }  public static int fibonacciTail(int n, int prev, int next) {  if (n == 0) return prev;  return fibonacciTail(n-1, next, prev+next); } 앞서 코드는, fibonacci(n)을 구하기 위해서\n계산을 최대한 뒤로 미루는 듯한 느낌을 받았는데,\n새로운 코드는 계산을 한다음에 그 값을 넘겨준다.\n그리고, 직접 디버깅으로 하나하나 실행해보면 알겠지만,\nn이 되는 순간 곧바로 fibonacciTail()이 아닌 fibonacci() 로 쏴버린다.\n반복 횟수는 어떨까?\nFibonacci(10)을 기준으로,\n기존의 방식은 177번,\n새로운 방식은 11번 반복했다.\nN이 늘어나면 늘어날수록, 이 차이는 더더욱 극명하게 드러날 것이다.\n Note. 좀 더 자세히 찾아보았는데, 진정한 꼬리재귀는 Stack Frame 자체를 쌓지 않는다. 즉, 꼬리재귀함수를 지원하지 않는다는 Python 에서도, 위와 같은 코드는 구현할 수 있고, 실제로 잘 동작하기도 한다. 그러나, 꼬리재귀함수를 지원하는 컴파일러인 경우, 애초에 Stack Frame을 쌓지 않도록 이를 while문으로 애초에 \u0026ldquo;바꾸어버린다\u0026rdquo; 는 것이다. 따라서, 다음과 같이 정리할 수 있겠다.\n  꼬리재귀를 지원하는 경우 : 애초에 while문으로 바뀌기 때문에, Stack Frame 자체가 쌓이지 않음. 즉, StackOverflow 의 에러가 절대 발생하지 않는다. -\u0026gt; Tail Call Optimization\n꼬리재귀를 지원하지 않는 경우 : 위와 같은 로직으로 최적화는 되더라도, Stack은 쌓이기 때문에, StackOverflow가 발생할 수 있다.\n 2) 동적계획법(cache)을 이용 : 문제가 발생했던 코드의 경우, 같은 연산을 반복하는 코드가 존재한다.\n즉, F(4)를 구하기 위해서, F(3)과 F(2)를 구해야 했는데,\nF(3)을 구하기 위해서, 또 다시 F(2) 에 대한 연산을 해야하는 것이다.\n그러므로, 재귀함수를 반복하면서,\n구하고자 하는 값이, 처음 구하는 경우에는 직접 연산,\n한번 구한적 있는 값이라면, 꺼내오기\n를 이용하면, 좀 더 똑똑하게 가져올 수 있다.\n다음과 같이 코드를 작성해보자.\nstatic int[] fibo;  public static void main(String[] args) {  int n = 10;  fibo = new int[n+1];  int result = fibonacci(n);  System.out.println(result); }  public static int fibonacci(int n) {  if (fibo[n] != 0) return fibo[n];  if (n == 0) return 0;  else if (n == 1) return 1;   fibo[n] = fibonacci(n-1) + fibonacci(n-2);  return fibo[n]; } int[] 배열 fibo를 선언한 뒤, main method에서 n+1 만큼의 길이로 정의해주었다.\n다음으로, fibonacci() 함수가 실행될 때마다,\n값이 있는지 확인하고,\n없는 경우에는 기존의 로직을, 있는 경우에는 그 값을 곧바로 return하도록 만들었다.\n그리고 최종적으로, 원하는 fibonacci 값인 fibo[n]을 return했다.\n반복 횟수는, 10을 기준으로 19번을 반복했다.\n6. 마치며 : 하나의 문제를 푸는데에 여러 가지 방법을 아는 것은 큰 도움이 된다.\n모든것을 한방에 해결해주는 만능 알고리즘은 없으니,\n상황에 맞게 적절하게 사용하는 것이 중요한데,\n이 때 내가 어떤 무기, Tool을 갖고 있느냐에 따라\n선택의 폭도 달라지고, 생각의 틀도 격변하기 때문인 것 같다.\n위 피보나치를 구하는 방법에도,\n일반항을 이용하는 방법이나, 행렬을 이용하는 방법이 있다고 하는데,\n본 포스팅의 목적은 피보나치가 아닌 재귀함수 이므로 이에 대해서 따로 찾아보지는 않았다.\n궁금한 사람은 이하의 Reference를 참고하면 좋겠다.\n이상으로 포스팅을 마칩니다.\nReference  피보나치 수열 알고리즘을 해결하는 5가지 방법 Tail Recursion in Python StackOverflow - What is tail-recursion elimination? Wikipedia - Tail call  ","permalink":"http://cjlee38.github.io/post/tech/btb/2020-10-16-recursive_function/","summary":"0. 들어가며 : 나는 재귀함수를 좋아하지 않는다.\n재귀함수는 몇 번을 써도 어렵고, 몇 번을 봐도 쉽사리 파악하기 어렵다.\n그럼에도 불구하고, 재귀함수는 유용하고, 신기하다.\n이번 포스팅을 통해, 재귀함수가 어떻게 동작하는지 간단하게 살펴보고,\n재귀함수를 최적화하기 위한 두 가지 방법에 대해서 알아보자.\n1. 재귀함수의 사전적 정의 : 재귀(再歸) 라는 말을 국어사전에 쳐보면, 다음과 같이 설명한다.\n이를 프로그래밍에 적용하면, 함수가 자기 자신으로 되돌아옴 정도로 표현할 수 있겠다.\n다시 말해, 호출한 함수가 자기 자신을 호출하는 행위를 의미한다.","title":"# 재귀함수 주무르기 with 피보나치 수열 ( feat. Java )"},{"content":"0. 들어가며 : 스프링 공부를 하던 중, 자주 사용되는 Annotation에 대해서 살펴보았다.\n다양한 글을 읽었는데도, Java의 Annotation은 뭐라 딱 찝어서 설명하기 어려운 것 같다.\n더욱이, 나는 \u0026rsquo;@\u0026rsquo; 표시에 대해서, Python의 Decorator로 먼저 이해했기 때문에 더욱 어려웠던 것 같다.\nPython의 Decorator는 마치 함수를 감싸는 함수의 역할과 같은 모습을 볼 수 있지만,\nJava의 Annotation은 그냥 Meta data 로 퉁쳐버리기 때문에,\n\u0026ldquo;정말 그게 다야? 뭐 더 없어? 아닐 것 같은데?\u0026rdquo; 싶은 생각이 계속 들어서 이해하기 어려웠다.\n1. Java Annotation : Java의 Annotation은, 곧 메타 데이터다.\nJDK 5에서 추가된 어노테이션은 소스코드가 동작하는 데에는 영향을 미치지 않는다.\n그저 Class, Interface, method, field 등에 붙어서,\nJava Compiler와 JVM에게 추가적인 정보를 제공한다.\n그냥 이게 전부다. 여기서 더 설명할 것이 없다.\nPython decorator와 헷갈리는 사람은 스킵하고 쭉 내려가서 4번을 읽어보자.\n Meta data 란, 데이터에 대한 데이터, 혹은 데이터를 설명하기 위한 데이터를 의미한다.\n 이에 더해, 배포 or 런타임 시에도 사용될 수 있다.\n2. Built-in Annotations in Java 1) Override : 자주 보는 예시 중 하나가, @Override 이다.\n사실, 이러한 Override가 없어도, 실행은 잘 된다(위에서 언급했듯이, 소스코드의 동작에는 영향을 미치지 않는다.)\n그런데 이를 사용하는 이유는 무엇일까?\n다음과 같은 상황에서, 컴파일러가 미리 알려준다.\n Super class(interface)에서, 그러한 method가 없는 경우, 즉 이름을 잘못 적은 경우  @Override public String toStrring() {  return \u0026#34;something\u0026#34;; } 모든 클래스의 최상위 클래스인 Object 클래스에 정의된\ntoString method를 Override 하려고 했는데, 실수로 toStrring 으로 적었다.\n이러한 경우에 컴파일러가 에러를 뱉어준다.\n2) Deprecated : Deprecated 는, 마킹된 요소(클래스, 메소드, 필드)를 더이상 사용하지 않을 것을 권장할 때 사용된다.\n다음의 코드를 보자.\npublic class Main {  public static void main(String[] args) {  MyClass myClass = new MyClass();  myClass.myMethod();  } }  class MyClass {  @Deprecated  void myMethod() {  System.out.println(\u0026#34;hello world\u0026#34;);  } } 실행은 정상적으로 이루어지지만, IDE가 myMethod()에 줄을 쫙 그어준다.\n또한, myMethod()는 Deprecated 되었다고 Warning도 띄워준다.\n3) SupperssWarnings : 이름에서 나타내듯이, 컴파일러가 특정 warning을 무시하도록 해준다.\n2)에서 사용했던 코드에서, main method에 @SupressWarnings(\u0026quot;deprecation\u0026quot;)을 추가해보자.\n경고가 사라진 것을 볼 수 있다.\n3. 살짝 뜯어보기 : Annotation이 어떻게 정의되어 있는지, 살짝만 뜯어보자.\n@Override 를 살펴보면, 다음과 같이 정의되어 있다.\n/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: * * \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt; * The method does override or implement a method declared in a * supertype. * \u0026lt;/li\u0026gt;\u0026lt;li\u0026gt; * The method has a signature that is override-equivalent to that of * any public method declared in {@linkplain Object}. * \u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; * * @author Peter von der Ah\u0026amp;eacute; * @author Joshua Bloch * @jls 8.4.8 Inheritance, Overriding, and Hiding * @jls 9.4.1 Inheritance and Overriding * @jls 9.6.4.4 @Override * @since 1.5 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } @Target Annotation은 \u0026ldquo;Annotation이 적용될 수 있는 요소\u0026rdquo; 를,\n@Retention Annotation은, \u0026ldquo;이 Annotation이 언제까지 살아있는지?\u0026rdquo; 를,\n@interface는 이 인터페이스가 Annotation으로 사용될 것을 의미한다.\n@Target의 값에 포함되는, enum ElementType은 다음과 같다.\n(주석이 너무 길어서, 주석을 제외하고 가져왔다.)\npublic enum ElementType {  TYPE,  FIELD,  METHOD,  PARAMETER,  CONSTRUCTOR,  LOCAL_VARIABLE,  ANNOTATION_TYPE,  PACKAGE,  TYPE_PARAMETER,  TYPE_USE,  MODULE,  @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS, essentialAPI=true)  RECORD_COMPONENT; } 몇 가지 눈에 보이는 점은,\n필드, 메소드, 생성자.. 를 넘어서, 파라미터, 패키지 등에 붙일수도 있음을 볼 수 있다.\n@Retention 의 값에 포함되는, enum RetentionPolicy는 다음과 같다.\npublic enum RetentionPolicy {  /** * Annotations are to be discarded by the compiler. */  SOURCE,   /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */  CLASS,   /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */  RUNTIME }  Source : 컴파일러에 의해 버려진다. Class : 컴파일러에 의해 클래스파일에 남아있지만, 런타임시에는 유지되지 않는다. RUNTIME : 컴파일러에 의해 클래스파일에 남아있고, 런타임 시에도 남아있다.  4. 가볍게 Custom Annotation 만들어보기. : 위에서 본 내용을 바탕으로, Custom Annotation을 만들어보자.\npublic class Main {  public static void main(String[] args) throws NoSuchFieldException {  MyClass myClass = new MyClass(\u0026#34;foo\u0026#34;);   MyAnnotation myClassAnnotation = myClass.getClass()  .getAnnotation(MyAnnotation.class);  System.out.println(\u0026#34;myClassAnnotation value = \u0026#34; + myClassAnnotation.value());   MyAnnotation myFieldAnnotation = myClass.getClass()  .getDeclaredField(\u0026#34;myField\u0026#34;)  .getAnnotation(MyAnnotation.class);  System.out.println(\u0026#34;myFieldAnnotation value = \u0026#34; + myFieldAnnotation.value());  } }  @MyAnnotation(value = 1) class MyClass {   @MyAnnotation(value = 10)  private String myField;    public MyClass(String myField) {  this.myField = myField;  } }  @Target({ElementType.TYPE, ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation {  int value() default 0; } MyAnnotation 이라는 Annotation을 만들었다.\n이 때, Retention은 RUNTIME, Target은 클래스와 Field에 붙일 수 있도록 했다.\n그리고 MyClass 클래스에 1이라는 value를, MyField는 10을 붙였다.\n여기서 주의할 것은, value 라는 것은 meta data의 일부이지,\nvalue를 가져야만 meta data를 가질 수 있는 것은 아니다.\n다시 말해, value가 없어도 된다.\n만약, Constructor에 MyAnnotation을 붙이려고 하면\nTarget이 Class와 Field에만 붙일 수 있도록 했기 때문에\n'@MyAnnotation' not applicable to constructor 라고 에러를 뱉는다.\n위와 같이 코드를 작성하고 main method를 실행하면, 결과는 다음과 같다.\nmyClassAnnotation value = 1 myFieldAnnotation value = 10 예상한대로 결과가 잘 나타났다.\n만약 RetentionPolicy.RUNTIME을 CLASS, 혹은 SOURCE로 변경할 경우,\nrun 하면 NullPointerException이 발생한다.\n4. Python의 decorator와의 차이(번역) 스택오버플로우의 한 질문글에서, 나의 혼란을 정확히 짚어주는 한 답변을 보았다.\n간략하게 번역하면 다음과 같다.\n 이는 두 언어를 동시에 사용하는 사람이라면 가질 수 있는 아주 타당한 질문입니다. 나는 파이썬을 잠시 사용했고, 최근에는 자바를 사용하고 있습니다. 두 차이에 대한 비교의 제 생각은 다음과 같습니다.\nJava의 Annotation은 그저, 말 그대로 Annotation(주석) 입니다. 이는 마커로, 객체에 대한 추가적인 Meta data의 컨테이너입니다. 이것들이 단순히 존재한다고 해서, 실행흐름을 바꾸거나 어떠한 캡슐화를 추가하지 않습니다. 그렇다면 어떤 쓸모가 있을까요? Annotation Processor라는 것이 Annotation을 읽고, 처리합니다. Annotation이 갖고 있는 메타데이터는 사용자가 정의한 Annotation processor에 의해 사용되어, 삶을(코딩을) 좀 더 편하게 하는 보조적인 역할을 합니다. 하지만, 다시 말씀드리겠습니다. 이것들은 기본적인 실행의 흐름을 바꾸거나, 감싸지 않습니다.\nPython decorator를 사용해본 사람은, 실행 흐름을 바꾸지 않는 것에 대한 강조를 명확히 이해할 것입니다. Python의 decorator는 Java의 annotation과 비슷하게 보이고 느껴지지만, 그 내면은 상당히 다릅니다. decorator는 사용자가 원하는대로 감쌀 수 있고, 원한다면 실행하는것 자체를 막을수도 있습니다. 내부요소를 가져다 감싸고, 그 감싼 것으로 원래의 것과 교체합니다. decoraor는 효과적으로 요소를 \u0026ldquo;proxying\u0026rdquo; 할 수 있습니다.\n\u0026hellip; 하략\n 기존에 Annotation에 대해 너무 어렵게 생각했나 싶기도 하다.\n이상으로 포스팅을 마칩니다.\n","permalink":"http://cjlee38.github.io/post/language/java/2020-10-14-java_annotation/","summary":"0. 들어가며 : 스프링 공부를 하던 중, 자주 사용되는 Annotation에 대해서 살펴보았다.\n다양한 글을 읽었는데도, Java의 Annotation은 뭐라 딱 찝어서 설명하기 어려운 것 같다.\n더욱이, 나는 \u0026rsquo;@\u0026rsquo; 표시에 대해서, Python의 Decorator로 먼저 이해했기 때문에 더욱 어려웠던 것 같다.\nPython의 Decorator는 마치 함수를 감싸는 함수의 역할과 같은 모습을 볼 수 있지만,\nJava의 Annotation은 그냥 Meta data 로 퉁쳐버리기 때문에,\n\u0026ldquo;정말 그게 다야? 뭐 더 없어? 아닐 것 같은데?\u0026rdquo; 싶은 생각이 계속 들어서 이해하기 어려웠다.","title":"# (Java) Annotation에 대한 이해"},{"content":"문제 링크\nProblem 문제 설명\n자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 집합으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.\n 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합  예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다.\n{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 }\n그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다.\n집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요.\n제한사항\n 최고의 집합은 오름차순으로 정렬된 1차원 배열(list, vector) 로 return 해주세요. 만약 최고의 집합이 존재하지 않는 경우에 크기가 1인 1차원 배열(list, vector) 에 -1 을 채워서 return 해주세요. 자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다. 모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다.  입출력 예\n   n s return     2 9 [4, 5]   2 1 [-1]   2 8 [4, 4]    입출력 예 설명\n입출력 예#1\n문제의 예시와 같습니다.\n입출력 예#2\n자연수 2개를 가지고는 합이 1인 집합을 만들 수 없습니다. 따라서 -1이 들어있는 배열을 반환합니다.\n입출력 예#3\n자연수 2개로 이루어진 집합 중 원소의 합이 8인 집합은 다음과 같습니다.\n{ 1, 7 }, { 2, 6 }, { 3, 5 }, { 4, 4 }\n그중 각 원소의 곱이 최대인 { 4, 4 }가 최고의 집합입니다.\nSolve 접근 방법 : 직관적으로도 알 수 있는 내용인데,\n중복집합 중에서, 곱이 최대인 집합을 구하려면\n**\u0026ldquo;가장 중앙에 가까운 값들\u0026rdquo;**로 구성되어 있어야 한다.\n문제 예시(1)에서 보다시피,\n1 * 8 = 8\n2 * 7 = 14\n3 * 6 = 18\n4 * 5 = 20\n인데, 4*5가 9의 중앙값에 가장 가까운 자연수 집합이다.\n(친구의 도움을 받아)\n수학적으로 증명하자면,\nn=2, s=8 이고, 원하는 값이 x일때,\nmax( x * (8-x) )\n를 구해야 한다.\n이때, -x^2 + -8x 은 위로 볼록한 함수이므로,\n미분했을 때의 기울기가 0인 지점,\n다시 말해 함수의 최상단인 지점이 답이 된다.\n-x^2 + -8x 를 미분하면 -2x + 8 이고,\n이때 0이 되는 x는 4다.\n따라서, 답은 **[4, 4]**가 된다.\n만약 s가 9라면,\n우리가 원하는 답은 자연수여야 하므로, 실수 4.5에서 가장 가까운 자연수 [4, 5]가 된다.\n구현 : 따라서, 배열을 s/n 의 값으로 모두 채운뒤,\n만약 나머지 s%n 이 존재한다면,\n뒤쪽부터 1씩 추가시켜주면 된다.\n즉, 가령 n=4, s=15 라면,\n[3, 3, 3, 3] 으로 우선 채워질 것이고,\n나머지가 3이므로,\n3개의 요소에 뒤쪽부터 1씩 더해줘서\n[3, 4, 4, 4]를 만들면 된다.\n전체 코드는 다음과 같다.\nimport java.util.Arrays;  class Solution {  public int[] solution(int n, int s) {  if (n \u0026gt; s) return new int[]{-1};   int[] answer = new int[n];  Arrays.fill(answer, s/n);   int mod = s%n;  int idx = answer.length-1;  while(mod != 0) {  answer[idx] += 1;  idx--;  mod--;  }   return answer;  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-10-12-problem_solving_14/","summary":"문제 링크\nProblem 문제 설명\n자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 집합으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.\n 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합  예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다.\n{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 }","title":"# 프로그래머스[Lv.3] 최고의 집합 ( Java )"},{"content":"문제 링크\nProblem 문제 설명\n회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.\n제한 사항\nworks는 길이 1 이상, 20,000 이하인 배열입니다.\nworks의 원소는 50000 이하인 자연수입니다.\nn은 1,000,000 이하인 자연수입니다.\n입출력 예\n   works n result     [4, 3, 3] 4 12   [2, 1, 2] 1 6   [1,1] 3 0    입출력 예 설명\n입출력 예 #1\nn=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 4시간동안 일을 한 결과는 [2, 2, 2]입니다. 이 때 야근 지수는 22 + 22 + 22 = 12 입니다.\n입출력 예 #2\nn=1일 때, 남은 일의 작업량이 [2,1,2]라면 야근 지수를 최소화하기 위해 1시간동안 일을 한 결과는 [1,1,2]입니다. 야근지수는 12 + 12 + 22 = 6입니다.\nSolve 접근방법 : 문제를 푸는 시간보다 문제를 이해하는데 더 오래 걸렸던 문제.\n문제 설명을 조금 더 친절하게 해줬으면 어떨까 싶은 생각이 들었다.\n결국, 여기서 이야기하는 야근 피로도의 최소화란,\n야근이 아닌 근무시간 중에, 미리 어떤 일거리를 얼마나 해결해 놓아야,\n야근을 시작했을 때 피로도가 최소화 되는가?(이 때, 피로도는 각 작업 별 수치의 제곱) 가 핵심이다.\n중학교 정규교육과정을 이수한 사람이라면, 제곱의 밑 수가 커지면 커질수록,\n그 결과값이 점점 더 큰 폭으로 상승하는 것을 알고 있을 것이다.\n다시 말해, 밑 수가 2-\u0026gt;3 으로 갈 때에는 **5(3^2 - 2^2)**만큼 차이나지만,\n3-\u0026gt;4로 갈 때에는 **7(4^2 - 3^2)**만큼 차이가 난다.\n따라서, 최대한 숫자를 평평하게(?) 만들어 주는것이 핵심이다.\n구현 위에서 언급한 내용을 구현하기 위해서, 큰 수를 우선으로 하는PriorityQueue를 사용했다.\nPriorityQueue\u0026lt;Integer\u0026gt; PQ = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); 1시간 당 가능한 작업량이 1이니,\n가장 큰 수를 먼저 꺼내고,\n1을 감소시키고,\n다시 집어넣는다.\n이 과정을 n 만큼 반복하면 된다.\nfor (int i = 0; i \u0026lt; n; i++) {  PQ.offer(PQ.poll()-1); } 그리고, 답을 구할 때에는, PQ 안에 들어있는 모든 값을 다 꺼내서 제곱해서 모으면 된다.\n이 때, 음수인 경우에는 0이어야 한다는 것을 주의하자.\nwhile(!PQ.isEmpty()) {  long p = PQ.poll();  answer += p \u0026gt; 0 ? Math.pow(p, 2) : 0; } 전체 코드는 다음과 같다.\npackage programmers.lv3;  import java.util.Collections; import java.util.PriorityQueue;  // 프로그래머스 - 야근 지수 public class p12927 {   public static void main(String[] args) {  int n = 4;  int[] works = {4, 3, 3};  long result = solution(n, works);  System.out.println(result);  }   public static long solution(int n, int[] works) {  long answer = 0;  PriorityQueue\u0026lt;Integer\u0026gt; PQ = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder());   for (int i = 0; i \u0026lt; works.length; i++) {  PQ.offer(works[i]);  }   for (int i = 0; i \u0026lt; n; i++) {  PQ.offer(PQ.poll()-1);  }   while(!PQ.isEmpty()) {  long p = PQ.poll();  answer += p \u0026gt; 0 ? Math.pow(p, 2) : 0;  }   return answer;    } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-10-11-problem_solving_13/","summary":"문제 링크\nProblem 문제 설명\n회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.\n제한 사항\nworks는 길이 1 이상, 20,000 이하인 배열입니다.","title":"# 프로그래머스[Lv.3] 야근지수 ( Java )"},{"content":"Concept of Static : static을 한글로 해석하면 정적이라는 뜻인데, 크게 와닿지는 않는 해석이다.\n흔히, 객체지향에서 자주 하는 비유 중 하나가 붕어빵 틀과 붕어빵이다.\n클래스는 붕어빵 틀로, 붕어빵을 찍어낼 수 있고, 인스턴스는 찍혀진 붕어빵이다.\n따라서, 찍힌 붕어빵은 서로 다른 객체로 인식해야한다.\n그러나, 붕어빵을 만들기 위해 사용하는 반죽은 어떨까?\n붕어빵 장사를 하는 사람이, 아주 기가막힌 비율의 반죽을 만들어내서,\n(말은 안되지만) 이미 만들어진, 그리고 앞으로 만들 모든 붕어빵의 반죽을\nnew 반죽으로 바꾸고 싶다고 해보자.\n모든 instance의 반죽을 하나하나 전부 변경해야할까?\n이를 instance로는 해결하려 하기 보다는, 모든 객체가 바라보는 class 자체에 박아넣고,\n이를 수정하는 것이 나을 것이다.\n다른 비유를 들자면 Class계의 공지사항 정도가 될 수 있을 것 같다.\nStatic Field : 붕어빵 예시를 코드로 한번 작성해보자.\nclass 붕어빵 {  private String 반죽;  private String 속재료;  private String 크기;   public 붕어빵(String 반죽, String 속재료, String 크기) {  this.반죽 = 반죽;  this.속재료 = 속재료;  this.크기 = 크기;  }  // Getter, Setter, toString 메소드 생략 }  public class Main {  public static void main(String[] args) {  붕어빵 b1 = new 붕어빵(\u0026#34;기본\u0026#34;, \u0026#34;팥\u0026#34;, \u0026#34;중간\u0026#34;);  붕어빵 b2 = new 붕어빵(\u0026#34;기본\u0026#34;, \u0026#34;슈프림\u0026#34;, \u0026#34;중간\u0026#34;);   System.out.println(b1);  // 붕어빵{반죽=\u0026#39;기본\u0026#39;, 속재료=\u0026#39;팥\u0026#39;, 크기=\u0026#39;중간\u0026#39;}  System.out.println(b2);  // 붕어빵{반죽=\u0026#39;기본\u0026#39;, 속재료=\u0026#39;슈프림\u0026#39;, 크기=\u0026#39;중간\u0026#39;}  } } 여기서 \u0026quot;기본\u0026quot; 이라는 반죽이 \u0026quot;혁신\u0026quot; 이라는 혁신적인 반죽으로 바뀌어야 한다면 어떨까?\nb1.set반죽(\u0026#34;혁신\u0026#34;); b2.set반죽(\u0026#34;혁신\u0026#34;); ... 벌써부터 끔찍하다.\n하지만, 반죽 앞에 static 이라는 키워드를 붙일 수 있다.\n(private String 반죽 -\u0026gt; static String 반죽)\n이 때, 생성자와 Setter에 다음과 같은 Warning이 나온다.\nStatic member 'com.company.붕어빵.반죽' accessed via instance reference \n따라서, 생성자와 Setter를 다음과 같이 수정하면 된다.\npublic 붕어빵(String 반죽, String 속재료, String 크기) {  붕어빵.반죽 = 반죽; // 혹은  this.속재료 = 속재료;  this.크기 = 크기; }  public void set반죽(String 반죽) {  붕어빵.반죽 = 반죽; } 다시 Main Method로 돌아가서, 한줄만 추가해서 실행해보자.\npublic class Main {  public static void main(String[] args) {  붕어빵 b1 = new 붕어빵(\u0026#34;기본\u0026#34;, \u0026#34;팥\u0026#34;, \u0026#34;중간\u0026#34;);  붕어빵 b2 = new 붕어빵(\u0026#34;기본\u0026#34;, \u0026#34;슈프림\u0026#34;, \u0026#34;중간\u0026#34;);   b2.set반죽(\u0026#34;혁신\u0026#34;);   System.out.println(b1);  // 붕어빵{반죽=\u0026#39;혁신\u0026#39;, 속재료=\u0026#39;팥\u0026#39;, 크기=\u0026#39;중간\u0026#39;}  System.out.println(b2);  // 붕어빵{반죽=\u0026#39;혁신\u0026#39;, 속재료=\u0026#39;슈프림\u0026#39;, 크기=\u0026#39;중간\u0026#39;}  } } b2를 통해서 실행했을 뿐인데, b1또한 혁신으로 바뀌는 것을 볼 수 있다.\nStatic Method : 그런데, 코드를 다시 보면 이상한 점이 느껴진다.\n모두 \u0026quot;혁신\u0026quot; 으로 잘 바뀌기는 했는데,\nb2를 통해서 set반죽() 메소드를 호출하는 것이 어울릴까? 그렇지는 않아보인다.\n잠깐 다른 이야기를 하자면, 우리가 출력을 위해 사용하는 System.out.println() 이라는 메소드는,\n우리가 instance를 만들어서 실행하지 않는다.\n그저 곧바로 System.out.println() 을 실행할 수 있다.\n이렇게 사용할 수 있는 이유는, println() 이라는 메소드가 static method 이었기 때문이다.\n따라서, set반죽() 메소드 또한 static으로 바꾸어서,\n(public void set반죽() -\u0026gt; public static void set반죽())\n클래스로 접근해 사용할 수 있도록 만들면 좋겠다는 생각이 든다.\nb2.set반죽(\u0026quot;혁신\u0026quot;); 을 붕어빵.set반죽(\u0026quot;혁신\u0026quot;); 로 바꿔서 실행해보자.\npublic class Main {  public static void main(String[] args) {  붕어빵 b1 = new 붕어빵(\u0026#34;기본\u0026#34;, \u0026#34;팥\u0026#34;, \u0026#34;중간\u0026#34;);  붕어빵 b2 = new 붕어빵(\u0026#34;기본\u0026#34;, \u0026#34;슈프림\u0026#34;, \u0026#34;중간\u0026#34;);   // b2.set반죽(\u0026#34;혁신\u0026#34;);  붕어빵.set반죽(\u0026#34;혁신\u0026#34;);   System.out.println(b1);  // 붕어빵{반죽=\u0026#39;혁신\u0026#39;, 속재료=\u0026#39;팥\u0026#39;, 크기=\u0026#39;중간\u0026#39;}  System.out.println(b2);  // 붕어빵{반죽=\u0026#39;혁신\u0026#39;, 속재료=\u0026#39;슈프림\u0026#39;, 크기=\u0026#39;중간\u0026#39;}  } } 똑같은 결과가 나타나는 것을 볼 수 있다.\nStatic Block : C++과 다르게,\n자바는 클래스의 static 초기화에 사용될 수 있는 static block,\n혹은 static clause 라고 불리는 특별한 block을 지원한다.\n지금껏 우리는 생성자, 혹은 set반죽() 메소드를 통해서,\n반죽을 결정할 수 있었다.\n하지만, 붕어빵의 반죽이라는 것은, 붕어빵을 만들 때 결정되는 것이 아니고,\n붕어빵 장사를 하는 사람이 집에서부터 만들어서 준비를 해놓는다.\n다시 말해, 반죽은 붕어빵에 종속되지 않는다.\n그러나, 지금 코드는 붕어빵이 있어야, 그제서야 붕어빵의 반죽이 결정되는 꼴과 다름없다.\n잠깐의 테스트를 위해, 반죽 변수의 접근제어자를 public으로 바꾸고,\nSystem.out.println(붕어빵.반죽)을 가장 먼저 호출해보면,\nnull이 return 되는 것을 볼 수 있다.\n이를, \u0026quot;기본\u0026quot; 이라는 문자열로 초기화 될 수 있도록 해보자.\n붕어빵의 생성과 관계 없이 반죽은 미리 결정되어야 하므로, 생성자에서도 빼버리자.\n그리고 나면, 붕어빵의 반죽을 초기화 할 수 있는 방법은 총 세가지가 된다.\n 처음 변수를 선언할 때, 정의하기 처음 변수를 선언할 때, private static method를 콜 해서, 그 결과값을 받기 선언해놓고, Static Block 이용하기  1번의 방법은, 초기화가 복잡한 경우에는 쓰고싶어도 쓸 수 없는 방법이다.\n(e.g. 1부터 100까지의 숫자가 담긴 ArrayList를 받아야 한다면?)\n2번과 3번은 거의 유사하다. 다음의 예제를 보자.\nCase. 2\nclass 붕어빵 {  static public String 반죽 = 반죽만들기();  // 중간 생략  private static String 반죽만들기() {  System.out.println(\u0026#34;static method called\u0026#34;);  return \u0026#34;기본\u0026#34;;  } } Case. 3\nclass 붕어빵 {  static public String 반죽;  // 중간 생략  static {  System.out.println(\u0026#34;static block called\u0026#34;);  반죽 = \u0026#34;기본\u0026#34;;  } } Main\npublic class Main {  public static void main(String[] args) {  System.out.println(붕어빵.반죽);  // static method called 또는 static block called  // 기본  } } 이렇게 단순한 경우에는 거의 차이가 없지만,\n여러 개의 static 변수를 초기화해야하고, 이 변수들이 의존적이라면,\nstatic block을 쓰는것이 훨씬 편할 것이다.\n가령, 위 예시에서, String 반죽2 는 기본 반죽이 두개,\n즉 기본기본을 만들고 싶다고 해보자.\nCase. 2\nclass 붕어빵 {  static public String 반죽 = 반죽만들기();  static public String 반죽2 = 반죽만들기2(반죽);   private static String 반죽만들기() {  System.out.println(\u0026#34;static method called\u0026#34;);  return \u0026#34;기본\u0026#34;;  }   private static String 반죽만들기2(String 반죽) {  System.out.println(\u0026#34;static method 2 called\u0026#34;);  return 반죽 + 반죽;  } } Case. 3\nclass 붕어빵 {  static public String 반죽;  static public String 반죽2;   static {  System.out.println(\u0026#34;static block called\u0026#34;);  반죽 = \u0026#34;기본\u0026#34;;  반죽2 = 반죽 + 반죽;  } } Main\npublic class Main {  public static void main(String[] args) {  System.out.println(붕어빵.반죽2);  // static method called , static method2 called  // 또는 static block called  // 기본기본  } } 2번의 방법을 사용하나, 3번의 방법을 사용하나 차이는 거의 없지만,\n상황에 따라 편리한 방법을 골라서 사용하는 것이 좋다고 본다.\n사용 시 주의점 : static의 붙은 변수는, 메모리의 static 영역에 할당되어서, 프로그램이 끝날 때 까지 생존한다.\n다시 말해, Garbage Collection의 대상이 되지 않는다.\n그렇기에, static 변수를 남발하는 것은 좋은 선택은 아니다.\n 이에 더해, 스택오버플로우의 한 질문글 에서는, static 키워드를 사용하는 것 자체를 금기시 하고 있다.\n한줄 요약하면, static 사용은 객체지향적이지 않다. 라는 것이 요지이다.\n Reference  static block vs private static method for static member initialization Why are static variables considered evil? Static blocks in Java [Java] static method, static block  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-10-java_static/","summary":"Concept of Static : static을 한글로 해석하면 정적이라는 뜻인데, 크게 와닿지는 않는 해석이다.\n흔히, 객체지향에서 자주 하는 비유 중 하나가 붕어빵 틀과 붕어빵이다.\n클래스는 붕어빵 틀로, 붕어빵을 찍어낼 수 있고, 인스턴스는 찍혀진 붕어빵이다.\n따라서, 찍힌 붕어빵은 서로 다른 객체로 인식해야한다.\n그러나, 붕어빵을 만들기 위해 사용하는 반죽은 어떨까?\n붕어빵 장사를 하는 사람이, 아주 기가막힌 비율의 반죽을 만들어내서,\n(말은 안되지만) 이미 만들어진, 그리고 앞으로 만들 모든 붕어빵의 반죽을\nnew 반죽으로 바꾸고 싶다고 해보자.","title":"# (Java) Static Field, Method, 그리고 Block"},{"content":"Enum in Java : C언어에서의 Enum은, 단순하게 연속된 숫자의 Magic Number를 표현하는 것을\n막기 위해 사용되어서, 그 내부의 값은 int 값을 갖고 있다.\nEnumerate, 열거하다 라는 표현에, 걸맞다는 생각이 들기도 한다.\n그러나, Java에서의 Enum은 클래스다.\n따라서, C와는 다르게 여러가지 기능을 지원한다.\n사용법 기본 형태 : 먼저, 가장 단순하게 기존의 C에서 쓰던 것처럼 enum을 활용할 수 있다.\nSize.java\npublic enum Size {  SMALL, MEDIUM, LARGE } Main.java\npublic class Main {  public static void main(String[] args) {  System.out.println(Size.SMALL);  // SMALL 출력  } } enum method 활용 : 위 예제에서, 명시되어 있지는 않지만, Size 클래스의 static method 또한 존재한다.\npublic class Main {  public static void main(String[] args) {  for(Size size : Size.values()) {  System.out.println(size);  // SMALL, MEDIUM, LARGE 순서대로 출력  }  } } values() 함수를 호출하면, Size에 들어있는 값들의 배열이 return 된다.\n또한, 다음과 같이 valueOf() 함수를 통해서, 이름을 이용해 값을 생성할 수도 있다.\npublic class Main {  public static void main(String[] args) {  Size size_1 = Size.SMALL;  Size size_2 = Size.valueOf(\u0026#34;SMALL\u0026#34;);  System.out.println(size_1 == size_2); // true  System.out.println(size_1.equals(size_2)); // true  } } 호기심에 두 객체가 같은지 비교해보았는데,\nvalueOf() 함수를 통해 String을 넣어 만든 size_2은,\nsize_1과 같은 값을 가지는 것을 볼 수 있었다.\n다른 값과 연결하기 : Java의 enum의 또 다른 특징은,\n여러 값을 하나의 값처럼 연결해서 사용할 수 있다는 것이다.\nSize enum을 살짝 업그레이드 시켜보자.\npublic enum Size {  SMALL(\u0026#34;스몰\u0026#34;),  MEDIUM(\u0026#34;미디엄\u0026#34;),  LARGE(\u0026#34;라지\u0026#34;);   private final String kor;   Size(String kor) {  this.kor = kor;  }   public String getKor() {  return kor;  } } 위와 같이, SMALL은 String \u0026quot;스몰\u0026quot;과 같다고 명시해줄 수 있는데,\n이 때 이 String을 받아내는 kor 변수를 선언하였고,\n이에 걸맞은 생성자와 Getter 메소드를 만들어두었다.\npublic class Main {  public static void main(String[] args) {  String size = Size.SMALL.getKor();  System.out.println(size); // 스몰  } } 보는 바와 같이 사용할 수 있다.\n간단한 사용법은 이정도로 마무리하고,\n그렇다면, 어떻게 enum이 class화 되는지에 대해서 살펴보자.\n구조 : StackOverflow에서 아주 좋은 예제 코드가 있길래, 가져왔다.\n다음의 코드는, 위에서 작성한 Size 와 차이가 없는 코드이다.\npublic enum Ordinals {  FIRST(\u0026#34;st\u0026#34;),  SECOND(\u0026#34;nd\u0026#34;),  THIRD(\u0026#34;rd\u0026#34;);   private String notation;   private Ordinals(String notation) {  this.notation = notation;  }   public String getNotation() {  return notation;  } } 이 코드를 한번 컴파일 시킨 뒤, 디컴파일해서 보면 다음과 같이 생겼다고 한다.\n(IDE의 차이인지는 모르겠지만, 내가 디컴파일 했을 때에는 enum 그대로 튀어나왔다.\n아마 실제로 보려면 다른 방법을 이용해야 하는 듯 하다.)\npublic final class Ordinals extends java.lang.Enum\u0026lt;Ordinals\u0026gt; {  public static final Ordinals FIRST;   public static final Ordinals SECOND;   public static final Ordinals THIRD;   private String notation;   private static final Ordinals[] $VALUES;   public static Ordinals[] values() {  return $VALUES.clone();  }   public static Ordinals valueOf(String name) {  return (Ordinals) Enum.valueOf(Ordinals.class, name);  }   private Ordinals(String name, int ordinal, String notation) {  super(name, ordinal);  this.notation = notation;  }   static {  FIRST = new Ordinals(\u0026#34;FIRST\u0026#34;, 0, \u0026#34;st\u0026#34;);  SECOND = new Ordinals(\u0026#34;SECOND\u0026#34;, 1, \u0026#34;nd\u0026#34;);  THIRD = new Ordinals(\u0026#34;THIRD\u0026#34;, 2, \u0026#34;rd\u0026#34;);  Ordinals[] $VALUES = new Ordinals[3];  $VALUES[0] = FIRST;  $VALUES[1] = SECOND;  $VALUES[2] = THIRD;  Ordinals.$VALUES = $VALUES;  } } Singleton 패턴으로 Enum이 생성됨을 알 수 있다.\n그렇기에 다음의 코드를 보면,\nSystem.out.println(Size.LARGE.getClass().getName()); // com.example.Size, com.example은 패키지명 Size.LARGE의 클래스 이름을 찍어봤을 때,\nint 값이 아닌 size 클래스로 찍히는 것을 볼 수 있다.\n이러한 enum의 활용법은 우아한 형제들 기술 블로그에서,\n입이 떡 벌어질 정도로 놀라운 예제를 볼 수 있다.\nReference  How are enums internally represented in Java? enum 클래스의 사용과 이해 Java Enum 활용기 ENUM CONVERTED TO CLASS  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-09-java_enum/","summary":"Enum in Java : C언어에서의 Enum은, 단순하게 연속된 숫자의 Magic Number를 표현하는 것을\n막기 위해 사용되어서, 그 내부의 값은 int 값을 갖고 있다.\nEnumerate, 열거하다 라는 표현에, 걸맞다는 생각이 들기도 한다.\n그러나, Java에서의 Enum은 클래스다.\n따라서, C와는 다르게 여러가지 기능을 지원한다.\n사용법 기본 형태 : 먼저, 가장 단순하게 기존의 C에서 쓰던 것처럼 enum을 활용할 수 있다.\nSize.java\npublic enum Size {  SMALL, MEDIUM, LARGE } Main.java\npublic class Main {  public static void main(String[] args) {  System.","title":"# (Java) [짧] Enum 뜯어보기"},{"content":"SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,\n짧은 영어 실력으로 번역 및 정리해보았다.\n수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,\n영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,\n이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.\n사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면\n차라리 영어 원문을 보는것을 추천한다.\n원문\nSOLID 원칙이란 무엇입니까?  Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다.\n  SRP : Single Responsibility Principle. 단일 책임 원칙 OCP : Open-Closed Principle. 개방 폐쇄 원칙 LSP : Liskov Substitution Principle. 리스코프 치환(교체) 원칙 ISP : Interface Segregation Principle. 인터페이스 분리 원칙 DIP : Dependeny Inversion Principle. 의존관계 역전 원칙  SOLID 원칙은 다양한 테스트 제품군과 함께, 코드가 부패(\u0026hellip;) 하는것을 방지하는데 도움을 주는 클래스 레벨의 객체지향 설계 컨셉입니다. 자바에서, SOLID 원칙은 소프트웨어의 주요 가치를 높게 유지하는데 도움을 줍니다.\n왜 SOLID 설계 원칙을 사용해야 합니까? 개발자들이 SOLID와 같은 구조화된 설계 원칙 없이 설계를 하면, 그들은 이 프로젝트를 진행할 미래의 개발자들에게 오랫동안 지속될 문제를 만들 수 있고, 그들이 개발하는 어플리케이션의 잠재적인 성공을 제한할 수 있습니다. 이러한 이슈는 흔히 \u0026ldquo;코드 부패\u0026rdquo; 라고 부릅니다.\n  그렇다면, 어떻게 미래의 코드 부패를 알아낼 수 있을까요? 아래와 같은 신호(징후)는 코드가 부패한다는 것을 암시합니다.\n Rigidity(경직성) : 작은 변화가 전체 시스템의 rebuild를 야기하는 것 Fragility(취약성) : 한 모듈의 변화가 다른 관련 없는 모듈이 오작동하도록 야기하는 것.\n(e.g. 라디오 주파수 변경이 창문에 영향을 미치는 자동차 시스템) Immobility(부동성) : 모듈의 내부 구성요소가 새로운 환경에서 재사용 될 수 없는 것 (e.g. 한 어플리케이션의 로그인 모듈이 다른 모듈들 간의 coupling과 의존성으로 인해 완전히 다른 시스템에서 재사용 될 수 없는 경우, 부동적이다.) Viscosity(점성) : 빌드와 테스트가 어렵고 실행하는 데 오래 걸리는 경우. 사소한 변화도 비용이 많이 들고, 여러 위치/수준 에서 변경이 필요한 경우.  사용자들은 사용하는 소프트웨어에서 어떠한 가치를 얻을 것이라고 기대합니다.\n어플리케이션의 가치는, 생산성, 시간, 돈 등을 증대시키고 낭비를 절약함으로써, 사용자들이 무언가를 하는데에 도움을 주는지의 여부에 따라 결정됩니다.\n사람들은 높은 가치를 가친 소프트웨어에 돈을 지불합니다.\n하지만, 사용자들이 훌륭한 소프트웨어로부터 얻는 2차 가치가 있는데, 나는 그 가치에 대해서 먼저 이야기하려고 합니다. 왜냐하면, 사람들이 소프트웨어의 가치에 대해 이야기 할 때 이것을 가장 먼저 생각하기 때문입니다 : Behaviour(행동)\n어플리케이션에서 2차 가치를 만드는 것 : 만약 소프트웨어가 버그, 충돌, 딜레이 없이 사용자가 필요로 하는 것을 수행한다면, 소프트웨어의 2차 가치는 높습니다. 2차 가치는 소프트웨어가 사용자의 현재 요구를 만족시킬 때 달성됩니다. 하지만 사용자의 변화는 자주 변합니다; 소프트웨어가 제공하는 행동(behaviour)와, 사용자가 필요로 하는 것은 불일치하기 쉽고, 이는 가치를 낮추게 됩니다. 당신의 소프트웨어는 사용자의 변화하는 요구에 따라갈 수 있어야 합니다. 그래야 우리는 지속적인 변화를 용인하고, 촉진할 수 있는 소프트웨어의 주요 가치에 도달하게 됩니다.\n현재 소프트웨어가 사용자의 요구를 만족시키지만, 수정하기에 아주 어렵고 비싸다고 상상해보세요. 여기서, 앱의 inflexibility(경직성)으로 인해, 사용자들은 좋아하지 않고, 수익률도 떨어질 것입니다.\n처음에는 2차 가치가 낮지만, 수정하기에 싸고 간단한 소프트웨어가 있다고 상상해보세요. 수익성은 올라가고, 사용자들은 점점 더 좋아할 것입니다.\nSOLID 5원칙에는 무엇이 있습니까? : 위에서 얘기했듯이, SOLID 원칙은 5가지 객체지향 설계 원칙으로 구성되어 있습니다; 단일책임 원칙, 개방폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존관계 역전 원칙. 이 원칙들은 개발자들이 \u0026ldquo;코드 부패\u0026quot;에서 벗어나, 고객들에게 지속적인 가치와 이 프로젝트에 참여할 미래의 개발자들에게 건전성을 제공하는 어플리케이션을 만들 수 있도록 하는 가치있는 기준을 제공해줍니다.\n          SRP Single Responsibility Principle 클래스를 변경하는 이유는 오직 하나여야 한다.   OCP Open-Closed Principle 클래스를 수정하지 않으면서, 행동을 확장할 수 있어야 한다.   LSP Liskov Substitution Principle 상위 클래스는 하위 클래스로 대체할 수 있어야 한다.   ISP Interface Segregation Principle 클라이언트별로 세분화된 인터페이스를 만들어라.   DIP Dependeny Inversion Principle 구체 클래스가 아닌 추상 클래스에 의존해라.    1.Single Responsibility Principle(SRP) 단일 책임 원칙은 클래스가 변경되어야 하는 이유가 하나보다 많으면 안된다고 명시하고 있습니다. 즉, 코드의 모든 클래스(혹은 유사한 구조)는 하나의 작업만 수행해야 합니다.\n클래스의 모든 것은 하나의 목적과 관련이 있어야 합니다.(즉, 응집되어야 합니다.) 이것은 클래스가 하나의 메소드나 속성만을 가져야 한다는 것을 의미하지는 않습니다.\n단일책임에 관련되는 한, 많은 구성원이 있을 수 있습니다. 한 가지 변경의 이유가 생길 경우, 클래스의 여러 개의 멤버가 변경되어야 할 수 있기 때문입니다. 또는 많은 클래스에 업데이트가 필요할 수 있습니다.\n다음의 코드는 얼마나 많은 책임을 갖고 있을까요?\nclass Employee {  public Pay calculatePay() {...}  public void save() {...}  public String describeEmployee() {...} } 정답은 세 개 입니다.\n하나의 클래스 안에 1) 계산하는 로직, 2) 데이터베이스 로직, 3) 보고 로직이 섞여 있습니다. 만약 당신이 여러개의 책임을 하나의 클래스로 합친다면, 다른 것들을 깨뜨리지 않으면서 하나를 바꾸는 것은 어려울 것입니다. 책임을 섞는것은 또한, 이해하기도, 테스트하기에도 어렵게 만들면서, 응집도를 낮춥니다. 이를 해결하는 가장 간단한 방법은 클래스를 세 개의 서로 다른 클래스로 나누고, 각각이 하나의 책임을 갖도록 하는 것입니다 : 데이터베이스 접근, 계산, 보고\n2. Open-Closed Principle(OCP) 개방폐쇄원칙은 클래스가 확장에는 개방되어 있으나, 변경에는 닫혀있어야 함을 말합니다.\u0026ldquo;확장에 개방되어 있다\u0026quot;는 것은, 새로운 요구사항이 생겼을 때 새로운 기능을 쉽게 추가할 수 있도록 클래스를 작성해야 함을 의미합니다. \u0026ldquo;변경에 닫혀 있어야 한다\u0026quot;는 것은, 한번 만들어진 클래스는 버그를 잡는 것이 아니라면 변경해서는 안된다는 것을 의미합니다.\n이 원칙의 두가지 부분은 모순되는 것 처럼 보입니다. 하지만, 올바르게 클래스와 의존성을 구조화 하면, 기존의 코드를 변경하지 않고 기능을 추가할 수 있습니다.\n일반적으로 concrete(구체) class가 아닌, interface나 abstract class와 같은 추상적인 것들에 의존적이게 참조함으로써 이를 달성할 수 있습니다. 인터페이스를 구현하는 새로운 클래스를 만들어서, 기능을 추가할 수 있습니다.\nOCP를 당신의 프로젝트에 적용하는 것은 소스코드가 한번 작성되고, 테스트되고, 디버깅 되었다면, 변경할 필요를 제한합니다. 이는 기존의 코드에 새로운 버그를 발생시킬 위험을 줄임으로써, 더욱 robust(강력한) 한 소프트웨어로 이어집니다.\n Open-Closed Principle Example 의존성을 위해 인터페이스를 사용하는 것의 side-effect는 결합력을 낮추고, 기능성을 증가시키는 것 입니다.  void checkOut(Receipt receipt) {  Money total = Money.zero;  for (item : items) {  total += item.getPrice();  receipt.addItem(item);  }  Payment p = acceptCash(total);  receipt.addPayment(p); } 신용카드 결제를 어떻게 추가할 수 있을까요? 아래와 같이 if-문을 추가할 수 있지만, 이는 OCP의 위반입니다.\nPayment p; if (credit)  p = acceptCredit(total); else  p = acceptCash(total); receipt.addPayment(p); 다음의 방식이 더 낫습니다.\npublic interface PaymentMethod {void acceptPayment(Money total);}  void checkOut(Receipt receipt, PaymentMethod pm) {  Money total = Money.zero;  for (item : items) {  total += item.getPrice();  receipt.addItem(item);  }  Payment p = pm.acceptPayment(total);  receipt.addPayment(p); } 그리고, 여기 더러운(?) 작은 비밀이 하나 있습니다 : OCP는 발생할 것이라고 예측 가능한 경우에만 도움을 줍니다. 따라서, 비슷한 변화가 이미 일어난 경우에만 적용해야 합니다. 따라서, 가장 간단한 것을 먼저 하고, 어떤 변화가 요구되는지 확인해야, 미래의 변화를 좀 더 정확하게 예측할 수 있습니다.\n이는 고객이 변화를 만들고 나서야, (미래의 비슷한 변화로부터 당신을 보호하기 위해) 추상적인 것을 개발하는 것을 의미합니다.\n3. Liskov Substitution Principle (LSP) LSP는 상속 계층에 적용되며, 클라이언트가 알지 못하게 클라이언트 종속성이 하위 클래스로 대체될 수 있도록 설계해야 함을 말합니다.\n따라서, 모든 하위클래스는 상위클래스와 같은 방식으로 동작해야 합니다. 하위 클래스의 특정 기능은 다를 수 있지만, 상위 클래스의 기대되는 동작에 부합해야 합니다. 진정한 행동적 subtype 이 되기 위해서, 하위클래스는 상위 클래스의 메소드와 속성을 구현할 뿐만 아니라, 암시적 행동 또한 부합해야 합니다.\n일반적으로, supertype의 subtype이 supertype의 클라이언트가 기대하지 않은 행동을 한다면, 이는 LSP의 위반입니다. 상위 클래스가 던지지 않는 예외를 던지는 하위클래스를 상상해보세요. 기본적으로, 하위클래스의 기능은 상위클래스보다 적어서는 안됩니다.\nLSP를 위반하는 전형적인 예로는, 직사각형 클래스에서 파생되는 정사각형 클래스 입니다. 정사각형 클래스는 언제나 높이와 너비가 같습니다. 만약 직사각형이 기대되는 곳에서 정사각형 객체가 사용된다면, 정사각형의 치수는 독립적으로 변할 수 없기 때문에, 예기치 않은 동작이 발생할 수 있습니다.\n Liskov Substitution Principle Example 이 문제는 쉽게 해결할 수 없습니다 : 정사각형이 불변(즉, 치수가 같도록 유지)하기 위해서 정사각형의 setter 메소드를 수정할 수 있다면, 이 method는 직사각형 setter의 치수가 독립적으로 수정될 수 있다는 직사각형의 사후 조건을 위반합니다.  public class Rectangle {  private double height;  private double width;   public double area();   public void setHeight(double height);  public void setWidth(double width); } 위 코드는 LSP를 위반합니다.\npublic class Square extends Rectangle {  public void setHeight(double height) {  super.setHeight(height);  super.setWidth(height);  }   public void setWidth(double width) {  setHeight(width);  } } LSP 위반은 정의되지 않은 행동을 야기합니다. 정의되지 않은 행동이란, 개발과정에서는 잘 동작하지만, 생산 단계에서 blows up(터지거나), 하루에 한번 일어날 수 있는 것을 디버깅 하는데 몇주를 쓰거나, 무엇이 잘못되었는지 알아내기 위해 몇백 MB의 로그파일을 뒤져봐야 하는 것을 의미합니다.\n4. Interface Segregation Principle (ISP) ISP는 고객이 사용하지 않는 인터페이스에 의존하도록 강요하지 않아야 하는 것을 의미합니다. 우리가 응집되지 않은 인터페이스를 가지고 있을 때, ISP는 더 작고, 다양하고, 응집된 인터페이스를 만들도록 안내합니다.\nISP를 적용하면, 클래스와 클래스의 의존성은 타이트하게 초점을 맞춘 인터페이스를 이용해 통신함으로써, 사용되지 않는 멤버에 대한 의존성을 최소화하고, 이에 따라 결합력도 낮춥니다. 작아진 인터페이스는 구현하기 쉽고, 유연성과 재사용성을 높여줍니다. 더 적은 클래스가 이러한 인터페이스를 공유함에 따라, 인터페이스 변경에 따라 필요한 변화의 수가 적어지고, robustness(건전성)을 향상시킵니다.\n기본적으로, 여기서의 교훈은 \u0026ldquo;필요하지 않은 것에 의존하지 말라\u0026rdquo; 입니다. 예를 들자면 다음과 같습니다.\n다른 메시지를 표시하고자 하는 화면이 있는 ATM기기를 상상해보세요. 다른 메시지를 표시하는 문제를 어떻게 해결할 수 있을까요? SRP, OCP, LSP를 적용해서 해결책을 제시하지만, 여전히 시스템은 유지보수하기 어렵습니다. 왜일까요?\nATM의 주인이 인출기능만을 위해 나타나는 메시지를 추가하고 싶다고 상상해보세요. 즉, \u0026ldquo;이 ATM은 인출 시 약간의 수수료를 부과합니다, 동의하십니까?\u0026rdquo; 라는 메시지를 표현하려고 합니다. 어떻게 해결할까요?\n아마, 메신저 인터페이스에 메소드를 추가함으로써 해결할 수 있을 것입니다. 하지만 이로 인해, 인터페이스의 모든 사용자가 다시 컴파일하고, 거의 모든 시스템이 재배포되더야 하는데, 이는 OCP를 직접적으로 위반하고, 코드를 부패시키는 것입니다.\n여기서, 인출 기능의 변경이 다른 관련없는 기능들에 변화를 만들었고, 이는 우리가 원하는 것이 아닙니다. 왜 이런 일이 일어났을까요?\nInterface Segregation Principle Example\n사실, 각각의 기능들이 필요로 하지는 않지만, 다른 기능에 의해 필요한 메소드에 의존하는, 거꾸로된 의존성이 있습니다. 이는 우리가 피하고 싶은 것입니다.\npublic interface Messenger {  askForCard();  tellInvalidCard();  askForPin();  tellInvalidPin();  tellCardWasSiezed();  askForAccount();  tellNotEnoughMoneyInAccount();  tellAmountDeposited();  tellBalance(); } 대신, 메신저 인터페이스를 나눔으로써, 다른 ATM 기능들이 분리된 메신저에 의존하도록 해야 합니다.\npublic interface LoginMessenger {  askForCard();  tellInvalidCard();  askForPin();  tellInvalidPin();\t}  public interface WithdrawalMessenger {  tellNotEnoughMoneyInAccount();  askForFeeConfirmation(); }  public class EnglishMessenger implements LoginMessenger, WithdrawalMessenger {  ...\t} 5. Dependency Inversion Principle (DIP) DIP는, 높은 수준의 모듈은 낮은 수준의 모듈이 아닌 추상화에 의존해야 하는 것을 의미합니다. 둘 째로, 추상화는 세부적인 것에 의존하지 않아야 하고, 세부적인 것들은 추상화에 의존해야 합니다. 핵심은 클래스를 추상화에 의해 형성된 경계선 뒤에 클래스를 고립시키는 것입니다. 추상화 뒤에 있는 모든 세부사항들이 변경되더라도, 클래스는 여전히 안전합니다. 이는 결합력을 낮추고, 설계를 쉽게 바꿀 수 있도록 해줍니다. DIP는 things(아마 코드를 의미하는듯) 독립적으로 테스트할 수 있도록 해줍니다.\nDependency Inversion Principle Example\n예시는 다음과 같습니다 : 프로그램은 추상화인 Reader와 Writer 인터페이스에 의존하고, 키보드와 프린터는 이 인터페이스를 구현하는, 추상화에 의존하는 세부사항 입니다. 다음의 예에서, CharCopier는 Reader와 Writer의 세부적인 구현을 알지 못하므로, Reader와 Writer 인터페이스를 구현한다면 어느 Device든 넘길 수 있습니다.\npublic interface Reader { char getchar(); } public interface Writer { void putchar(char c)}  class CharCopier {   void copy(Reader reader, Writer writer) {  int c;  while ((c = reader.getchar()) != EOF) {  writer.putchar();  }  } }  public Keyboard implements Reader {...} public Printer implements Writer {…} ","permalink":"http://cjlee38.github.io/post/tech/btb/2020-10-08-solid_principles/","summary":"SOLID 원칙에 대해서 공부하던 중, 적절한 예시와 함께 작성된 글이 있어,\n짧은 영어 실력으로 번역 및 정리해보았다.\n수능을 마치고나서, 영어를 볼 떄마다 종종 드는 생각은,\n영어가 머릿속에 꽂히는, 맥락의 파악은 쉬워지는데,\n이를 한글로 다시 뱉어내기가 어려워졌다는 점 인것 같다.\n사실상 구글번역기를 돌린 것과 큰 차이가 없으니, 읽다가 정 안읽히면\n차라리 영어 원문을 보는것을 추천한다.\n원문\nSOLID 원칙이란 무엇입니까?  Robert C.Martin(Uncle Bob)에 의해 만들어진 SOLID 설계 원칙은 5가지 원칙의 조합을 의미합니다.","title":"# 객체지향 설계원칙 - SOLID(번역)"},{"content":"0. 들어가며 : 최근, 여러 알고리즘 문제들을 풀면서,\n가끔 심심할때마다 프로그래머스 Lv.1 문제들도 푸는데,\nLv.1 문제들은 단순하게 제출하는 것이 뭔가 좀 껄끄러웠다.\n개인적으로는, 1차원의 for loop를 쓰더라도 이게 여러 개 있으면 꽤 마음이 불편해진다.\n뭔가, 깔끔하고 멋있게 써야 할 것 같았다.\n개인적으로, 이러한 상황에 가장 베스트인 선택지는\n바로 Stream API 라고 생각한다.\n아직 익숙치 않은 Stream API를 공부해보자.\n양이 꽤 많기 때문에 아마 모두 적기에는 어려울 것 같다.\n  Note. Stream API는 일반적으로 컴퓨터 공학에서 사용하는 용어인 Stream 과는 다르다.\n본 포스팅은 Stream API(이하, Stream) 에 대해서 다룬다.\n  1. Stream 이란? : Oracle에서 Stream package의 document에서는 다음과 같이 설명하고 있다.\n요소들의 stream에 대해서, (컬렉션의 map-reduce 변환과 같은) 함수형 연산을 지원하는 클래스 \u0026hellip; ?\n무슨 말인지 이해하기 어렵다.\n이전 HashMap 편에서도 이야기했듯이 나는 Naming이 중요하다고 생각하기 때문에,\n가장 먼저 네이버 사전에 stream을 검색한 결과는 다음과 같다.\nstream\n 개울, 시내 (액체기체의) 줄기 줄줄 흐르다  이걸 보고나니, 영화 전우치에서 전우치가 화담과 마지막 전투를 할 때에\n벽에서 물을 끌어다가 화담에게 쏘는 장면이 생각났다.\n아무튼, \u0026ldquo;어떠한 흐름\u0026rdquo; 을 다루는 것이 stream 이라고 생각하면 될 것같다.\n(이 부분은 컴퓨터공학의 Stream과 비슷한 맥락을 갖는다.)\n이 흐름은 그대로 흘러가는구나.. 하는 것이 아니라,\n우리가 주도적으로 이리저리 다룰 수 있어야 한다.\n수도꼭지를 돌렸을 때 물이 어떻게 나오는지 상상해보면 이해하기 쉽다.\n수도꼭지는 수도관과 연결되어 있을테고,\n수도관의 물은 단순히 전달되는것이 아니라, 그 과정에서 filtering도 하고, 정화도 하고..\n등등의 여러가지 절차가 있을 것이다.\n마찬가지로, 우리가 원하는 데이터를 얻기 위해,\nStream을 이용해서 요리조리 흐름을 제어하고, 필터링을 하는 등의 작업을 거치면 된다.\n간단한 예시 ( 1 ) : Stream을 썼을 때의 장점이라면, 가독성이 좋아진다는 것이다.\n숫자가 1부터 10까지 있는 array에서, 짝수인 숫자만 골라내고 싶다면 어떻게 해야할까?\n아마 stream을 쓰지 않는다면, 이렇게 작성할 수 있을 것이다.\nint[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // 짝수를 구하는 부분 int[] evens = new int[array.length/2]; for (int i=0; i\u0026lt;array.length; i++) {  if (array[i] % 2 == 0) {  evens[i/2] = array[i];  } } // 짝수를 구하는 부분  for(int i=0; i\u0026lt;evens.length; i++) {  System.out.print(evens[i] + \u0026#34; \u0026#34;); } // 2 4 6 8 10 그러나, 이 방법은 꽤 우아해보이진 않는다.\n만약, array가 랜덤인 정수라면 어떨까?\n조금 더 극단적으로, array가 짝수로만 이루어져있다면 어떨까?\n물론, ArrayList 나 LinkedList 같이 편리한 Collection을 사용하는 방법도 있지만,\n근본적인 해결책을 제시했다고 보기는 어렵다.\nstream을 이용한다면 어떨까?\nint[] evens = Arrays.stream(array)  .filter(x -\u0026gt; x % 2 == 0)  .toArray(); \u0026hellip;???\n이게 전부다.\narray를 stream으로 감싸서 Instream 이라는 객체로 만든뒤에,\nx % 2 == 0, 즉 짝수인 애들만 남기고,\n이를 다시 Array로 만들었다.\n이렇게 작성하면, array에 무슨 값이 들어와도 두렵지 않다.\nint[] array = {2, 4, 1, 3, 4, 4, 4}; int[] evens = Arrays.stream(array)  .filter(x -\u0026gt; x % 2 == 0)  .toArray(); // 2 4 4 4 4 하나만 더 보자.\n간단한 예시 ( 2 ) : 프로그래머스에서 풀었던 문제 중 하나다.\n자연수 뒤집어 배열로 만들기 라는 문제인데,\n숫자형 값이 들어왔을 때, 이를 뒤집은 뒤, 배열로 만들면 된다.\n가령, 12345가 들어오면, [5, 4, 3, 2, 1] 로 만들어서 돌려주면 된다.\nstream을 쓰지 않는다면, 이렇게 썼을 것 같다.\n(일부러 조금 귀찮게 썼다.)\nStringBuilder sb = new StringBuilder(String.valueOf(n)).reverse(); String[] strArray = sb.toString().split(\u0026#34;\u0026#34;);  int[] answer = new int[strArray.length]; for (int i=0; i\u0026lt;strArray.length; i++) {  answer[i] = Integer.parseInt(strArray[i]); } return answer; StringBuilder로 만들어서 뒤집고, 이를 빈 문자열로 split한다.\n\u0026ndash;\u0026gt; [\u0026ldquo;5\u0026rdquo;, \u0026ldquo;4\u0026rdquo;, \u0026ldquo;3\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;1\u0026rdquo;]\n그리고, int형의 빈 배열을 만든 뒤 하나씩 int형으로 parsing해서 집어넣고, 돌려준다.\n꽤 괜찮아보인다.\nstream을 쓰면 어떨까?\nreturn new StringBuilder(String.valueOf(n))  .reverse()  .toString()  .chars() // 여기서 Intstream이 생성된다  .map(x -\u0026gt; Character.getNumericValue(x))  .toArray(); // chars()를 만들면 각 char 값이 아스키코드값이 되기 때문에 // 이를 다시 원래 숫자값으로 해석해줘야 한다. 같은 기능을 하는 코드지만, 좀 더 간결해졌다.\n이런 코드를 보고있으면 왠지모르게 심적으로 편안해진다.\n2. 사용법 : stream은 대개 다음과 같은 절차를 거친다.\n 생성 가공 소비  위 3단계 절차에 대해서, 아주 \u0026ldquo;간략하게\u0026rdquo; 다룰 것이며, 자세한 사용법을 모두 서술하는 것은 포스팅이 너무 길어지므로\n다른 분들의 포스팅을 참고하길 바란다.\n1) 생성 배열 : 배열은 클래스가 아니므로 Arrays라는 클래스를 통해 스트림으로 만들어줘야 한다.\nint[] intArr = new int[10]; IntStream stream = Arrays.stream(array);  String[] strArr = {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; Stream\u0026lt;String\u0026gt; strStream = Arrays.stream(strArr); Collection : Collection (e.g. List, stream)의 경우,\nCollection interface에 추가된 method인 .stream()을 통해 만들 수 있다.\nList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(1, 2, 3)); Stream\u0026lt;Integer\u0026gt; stream = list.stream(); 자체 생성 : Stream.of() method를 이용하는 방법도 있다.\n이는 입력받은 값을 stream으로 변환해주는 기능을 한다.\nStream\u0026lt;Integer\u0026gt; stream = Stream.of(1, 2, 3); 2) 가공 : 다음과 같은 String의 stream을 기준으로 가공하는 예시를 들어보겠다.\nList\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;, \u0026#34;stream\u0026#34;); 이 떄 주의해야할 것은,\n첫 째로, **\u0026ldquo;각각의 요소\u0026rdquo;**에 접근해서 사용한다는 것을,\n둘 째로, 가공하는 method가 return하는 객체는 또 다시 stream이라는 것을\n기억해야 한다.\n.filter() : 이름 그대로, 조건에 부합하는 요소들만 남기는 작업을 한다.\nStream\u0026lt;String\u0026gt; stream = list.stream()  .filter(x -\u0026gt; x.contains(\u0026#34;o\u0026#34;)); // {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;} \u0026ldquo;o\u0026rdquo; 라는 문자열이 포함된 요소만 남기겠다는 의미이므로,\no를 포함하고 있는 hello, world 가 남게 된다.\n이때, x 라는 녀석은 임의로 붙이는 \u0026ldquo;임시변수\u0026rdquo; 이다.\n파이썬의 for loop, java의 for-each 에서 각 요소를 접근하는 법을 생각하면 된다.\n.map() : map 또한 이름과 마찬가지로, 각각의 요소를 mapping 하는 역할을 한다.\nStream\u0026lt;String\u0026gt; stream = list.stream()  .map(x -\u0026gt; x.substring(0, 2)); // {\u0026#34;he\u0026#34;, \u0026#34;wo\u0026#34;, \u0026#34;ja\u0026#34;, \u0026#34;st\u0026#34;} 각각의 요소에 접근하면서, x 라고 붙인 임시변수를 substring, 즉 index 기준으로 잘라내겠다는 의미가 된다.\n.sorted() : 정렬을 하는 기능을 해준다.\n내부 객체(요소)가 스스로 Compartor를 갖고 있다면 이에 기반해서 default 정렬을 할 것이고,\n없거나, 커스텀 정렬을 할 경우 Compartor를 넘겨줄 수도 있다.\nStream\u0026lt;String\u0026gt; stream = list.stream().sorted(); // {\u0026#34;hello\u0026#34;, \u0026#34;java\u0026#34;, \u0026#34;stream\u0026#34;, \u0026#34;world\u0026#34;} Stream\u0026lt;String\u0026gt; stream = list.stream().sorted(Collections.reverseOrder()); // {\u0026#34;world\u0026#34;, \u0026#34;stream\u0026#34;, \u0026#34;java\u0026#34;, \u0026#34;hello\u0026#34;} .peek() : 자료구조에서 사용하는 peek()과 비슷하다.\nstream을 소비하지 않고, 각각의 요소를 한번 \u0026ldquo;확인\u0026rdquo; 하는 정도의 역할만 하고,\nreturn 되는 결과에는 영향을 미치지 않는다.\nStream\u0026lt;String\u0026gt; stream = list.stream().peek(x -\u0026gt; x.substring(0,2)); // 아무런 영향을 미치지 않으므로, {\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;, \u0026#34;stream\u0026#34;}을 유지  Stream\u0026lt;String\u0026gt; stream = list.stream().peek(x -\u0026gt; System.out.println(x)); // hello, world, java, steram 순서대로 출력 3) 소비 .min(), .max(), .sum() 숫자형일 때 최소, 최대, 합의 값을 구해주는 연산이다.\nString은 계산이 불가능하므로 잠깐 다른 예시를 활용한다.\nint[] arr = {1, 2, 3, 4}; OptionalInt oMax = Arrays.stream(arr).max(); // OptionalInt[4] OptionalInt oMin = Arrays.stream(arr).min(); // OptionalInt[1] int sum = Arrays.stream(arr).sum(); // 10 이 때, max()와 min()으로 나온 값은 Optional 객체이므로,\n이를 getAsInt()를 뒤에 붙여줘야 한다.\nint max = oMax.getAsInt(); int min = oMin.getAsInt(); .toArray() : stream을 배열로 변환해주는 작업이다.\nString[] strArr = list.stream()  .map(x -\u0026gt; x.substring(0,2))  .toArray(x -\u0026gt; new String[x]); // {\u0026#34;he\u0026#34;, \u0026#34;wo\u0026#34;, \u0026#34;ja\u0026#34;, \u0026#34;st\u0026#34;} parameter를 넘기지 않으면 Object 객체의 배열로 넘어가게 된다.\n.collect() : Collection 객체로 모으는 역할을 한다.\n이 때, Collector 객체를 파라미터로 넘겨줘야 한다.\nSet\u0026lt;String\u0026gt; set = list.stream()  .map(x -\u0026gt; x.substring(0,2))  .collect(Collectors.toSet()); // Set = {\u0026#34;he\u0026#34;, \u0026#34;wo\u0026#34;, \u0026#34;ja\u0026#34;, \u0026#34;st\u0026#34;} .forEach() : 각 요소에 대해서, \u0026ldquo;어떤 작업\u0026quot;을 하고 그대로 실행하는 Consumer를 받는다.\n대표적으로, System.out.println() 이 있다.\nlist.stream()  .map(x -\u0026gt; x.substring(0,2))  .forEach(x -\u0026gt; System.out.println(x)); // 순서대로, he, wo, ja, st 가 출력 3. 주의점 : 이렇듯 막강한 stream에도, 주의해야할 점이 있다.\n 너무 복잡한 경우, stream 보다 그냥 일반적인 for-loop를 쓰는 것이 낫다. stream은 한번 **\u0026ldquo;소비\u0026rdquo;**하면, 그대로 사라진다.  2번의 경우, 여기를 참고하자.\n앞서도 언급했듯이 위 예시 이외에도 여러 메소드들이 있고,\n응용에 따라 사용법은 무궁무진해지므로,\n이를 적절히 활용하면 정말 편리함을 느낄 수 있을 것이다.\nReference  JAVA 8 스트림 튜토리얼 Oracle - Package java.util.stream for-loop 를 Stream.forEach() 로 바꾸지 말아야 할 3가지 이유 자바8 Streams API 를 다룰때 실수하기 쉬운것 10가지  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-07-java_stream/","summary":"0. 들어가며 : 최근, 여러 알고리즘 문제들을 풀면서,\n가끔 심심할때마다 프로그래머스 Lv.1 문제들도 푸는데,\nLv.1 문제들은 단순하게 제출하는 것이 뭔가 좀 껄끄러웠다.\n개인적으로는, 1차원의 for loop를 쓰더라도 이게 여러 개 있으면 꽤 마음이 불편해진다.\n뭔가, 깔끔하고 멋있게 써야 할 것 같았다.\n개인적으로, 이러한 상황에 가장 베스트인 선택지는\n바로 Stream API 라고 생각한다.\n아직 익숙치 않은 Stream API를 공부해보자.\n양이 꽤 많기 때문에 아마 모두 적기에는 어려울 것 같다.\n  Note.","title":"# (Java) Stream API 첫걸음"},{"content":"들어가며 : 지난 포스팅에서, Jasper 라는 도구를 이용하여 HTML Code에 직접 자바코드를 때려박는 방법을,\n그리고 이렇게 생성되는 파일을 JSP 라고 부른다는 것을 배웠다.\n그렇다면, 기존의 Java Code는 다 그대로 JSP로 옮겨버려도 될까?\n흠.. 뭔가 그렇지는 않을 것 같은데, 명확히 이유를 짚어내기는 어렵다.\n이번 포스팅에서는 그 \u0026ldquo;이유\u0026quot;에 대해서 알아보자.\n코드 구분의 필요성 : 우선, 다음과 같이, 기본적인 덧셈, 뺄셈을 계산해주는 코드를 만들어보자.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;calculator\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;form action=\u0026#34;Adder.jsp\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; first_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n1\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; second_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n2\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;add\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;minus\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;% int num1 = 0; int num2 = 0; String num1_ = request.getParameter(\u0026#34;n1\u0026#34;); String num2_ = request.getParameter(\u0026#34;n2\u0026#34;); if(num1_ != null \u0026amp;\u0026amp; !num1_.equals(\u0026#34;\u0026#34;)) { num1 = Integer.parseInt(num1_); } if(num2_ != null \u0026amp;\u0026amp; !num2_.equals(\u0026#34;\u0026#34;)) { num2 = Integer.parseInt(num2_); } String op = request.getParameter(\u0026#34;calc\u0026#34;); if (op == null || op.equals(\u0026#34;\u0026#34;)) { // do nothing } else if (op.equals(\u0026#34;add\u0026#34;)) { %\u0026gt; result of add is \u0026lt;%= num1+num2 %\u0026gt; \u0026lt;% } else { %\u0026gt; result of minus is \u0026lt;%= num1-num2 %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 테스트 해보면, 다음과 같다.\n{: .caption} 초기 화면\n{: .caption} 덧셈 결과\n{: .caption} 뺄셈 결과\n  Note. 실수로 이름을 Adder.jsp 라고 지었는데, 이후 Calculator.jsp 로 수정하였다.\n  두개의 입력을 받기 전에는 0으로 두고,\n하나 혹은 두개의 값을 입력받으면, 두, 세 번째와 같이 결과를 출력한다.\n그러나, 이 정도로 간단한 코드는 괜찮지만,\n만약 내가 실제로 어떤 서비스를 제공하고자 한다면,\n그 코드의 길이는 얼마나 될까?\n당장 이 글을 쓰고 있는 Jekyll 의 Layout만 보더라도,\nLiquid를 몇번 사용하고나면, 굉장히 가독성이 떨어진다.\n또한, JSP의 뼈대가 되는 HTML 의 길이 또한 꽤 되는데,\n여기에 Java Code까지 추가하면 얼마나 길어질까?\n이를 해결하기 위한, 다시 말해 코드를 구분하기 위한 방법론은 크게 두 가지가 있으며,\n이를 각각 Model 1, Model 2 라고 부른다.\nMVC 패턴이 무엇인지에 대해서 먼저 잠깐 짚고, 그리고 Model 1, 2에 대해서 알아보자.\nMVC Pattern    MVC pattern이란, 소프트웨어 공학에서 제시하는 소프트웨어 개발 방법론 중 하나이다.\n즉, \u0026ldquo;이런 식으로 개발하면, 알차고 우아하게 짤 수 있습니다\u0026rdquo; 라고 제시하는 방법론 중 하나이다.\nMVC 에서 각각의 M, V, C가 의미하는 바는 다음과 같다.\n   M : Model - Controller에 의해 제어되어, View로 전달되는 객체 V : View - 사용자에게 보여지는 UI, 결과물. C : Controller - 사용자의 요청을 적절히 제어해서, View로 명령을 보냄.  이러한 식으로 프로젝트를 구성하면, UI와 비즈니스 로직을 분리해서,\n서로의 변경에 의한 영향을 최소화하면서 수정할 수 있다는 장점이 있다.\nModel 1    Model 1은, 쉽게 말해서 단순히 코드만을 구분짓는 것을 의미한다. JSP page로 들어온 요청에 대해서, 요청 및 로직을 처리하는 행위를 해당 JSP가 책임지고 핸들링한다.\n  그러나, \u0026ldquo;가독성\u0026rdquo; 을 위해서,(다시말해 유지보수를 위해서)\n요청을 받은 부분과, 로직을 처리하는 부분만을 구분해서 흐름을 제어하는 것이 Model 1의 특징이다.\n역시, 말로 하면 잘 이해가 안된다. 위에서 보여줬던 예시를 수정하면 다음과 같다.\n\u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;% int num1 = 0; int num2 = 0; String num1_ = request.getParameter(\u0026#34;n1\u0026#34;); String num2_ = request.getParameter(\u0026#34;n2\u0026#34;); if(num1_ != null \u0026amp;\u0026amp; !num1_.equals(\u0026#34;\u0026#34;)) { num1 = Integer.parseInt(num1_); } if(num2_ != null \u0026amp;\u0026amp; !num2_.equals(\u0026#34;\u0026#34;)) { num2 = Integer.parseInt(num2_); } String op = request.getParameter(\u0026#34;calc\u0026#34;); String outString = \u0026#34; \u0026#34;; if (op == null || op.equals(\u0026#34;\u0026#34;)) { // do nothing } else if (op.equals(\u0026#34;add\u0026#34;)) { outString = \u0026#34;result of \u0026#34; + op + \u0026#34; is \u0026#34; + (num1+num2); } else { outString = \u0026#34;result of \u0026#34; + op + \u0026#34; is \u0026#34; + (num1-num2); } %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;calculator\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;form action=\u0026#34;Adder.jsp\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; first_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n1\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; second_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n2\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;add\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;minus\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;%= outString %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 바뀐 점은 다음과 같다.\n parameter를 int형으로 변환하는 과정을, 위쪽으로 옮겼다. if else문을 위쪽에서 처리하고, HTML 태그에서는 곧바로 출력만 하도록 했다.  이렇게 함으로서, 3개의 코드블럭을 2개로 줄일 수 있었다.\n또한, 곱셈, 나눗셈에 대해서 처리할 때에도 크게 귀찮지는 않을 것이다.\n또한, MVC 패턴을 따랐다고 볼 수도 있다.\n위쪽의 Code Block이 Controller\n아래쪽의 HTML 코드가 View\noutString이 Model\n이 된다.\n그러나, 여전히 문제점은 남아 있다.\n 파일이 하나이기 때문에, 다른 사람과 협업을 하려고 한다면, 어려움을 크게 겪을 것이다. 만약 한 page에 대해서 처리하는 양이 많다면, page에 대한 요청이 들어올 때마다, 무거운 servlet으로 변환하고, 컴파일하는 행위를 반복해야 한다.  Model 2    Model 2의 형태로 구성하기 위해서는 우선, Model 1에서\n**\u0026ldquo;코드를 물리적으로 구분하는 것\u0026rdquo;**이 첫번째다.\n  @WebServlet(\u0026#34;/calculator\u0026#34;) public class Adder extends HttpServlet {  @Override  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  int num1 = 0;  int num2 = 0;   String num1_ = req.getParameter(\u0026#34;n1\u0026#34;);  String num2_ = req.getParameter(\u0026#34;n2\u0026#34;);   if(num1_ != null \u0026amp;\u0026amp; !num1_.equals(\u0026#34;\u0026#34;)) {  num1 = Integer.parseInt(num1_);  }  if(num2_ != null \u0026amp;\u0026amp; !num2_.equals(\u0026#34;\u0026#34;)) {  num2 = Integer.parseInt(num2_);  }   String op = req.getParameter(\u0026#34;calc\u0026#34;);  String outString = \u0026#34;\u0026#34;;  if (op == null || op.equals(\u0026#34;\u0026#34;)) {  // do nothing  } else if (op.equals(\u0026#34;add\u0026#34;)) {  outString = \u0026#34;result of \u0026#34; + op + \u0026#34; is \u0026#34; + (num1+num2);  } else {  outString = \u0026#34;result of \u0026#34; + op + \u0026#34; is \u0026#34; + (num1-num2);  }  } } 그러므로 기존의 코드블럭을 모두 잘라내서, calculator.java에 집어넣자. 그런데, 이렇게만 하면 아무것도 할 수 없다.\ncalculator.jsp 에서 calculator.java 로 넘어왔으면,\n여기서 받은 값을 다시 calculator.jsp 에서 \u0026ldquo;지속\u0026rdquo; 할 수 있어야 하지 않을까?\n이 때 사용할 수 있는 것이 dispatcher 라는 녀석의 forward 다.\n// request라는 저장소에 outString을 \u0026#34;outString\u0026#34; 이라는 이름으로 저장. req.setAttribute(\u0026#34;outString\u0026#34;, outString);   RequestDispatcher dispatcher = req.getRequestDispatcher(\u0026#34;calculator.jsp\u0026#34;); dispatcher.forward(req, resp);   Note. 다른 페이지로 넘겨주는 방식에는, redirect와, forward가 있다.\nredirect를 통해 calculator.jsp 로 넘겨주면, \u0026ldquo;새로운\u0026rdquo; calculator servlet이 생성된다. 따라서, 유지한 상태를 넘겨주기 위해서는 forward를 통해서 값을 넘겨줘야 한다.\n  이렇게 forward로 넘겨받은 값을, jsp 에서 활용하면 된다.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;calculator\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- calculator.jsp에서 calculator로 바꿔줘야 한다 --\u0026gt; \u0026lt;form action=\u0026#34;calculator\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; first_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n1\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; second_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n2\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;add\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;minus\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;%= request.getAttribute(\u0026#34;outString\u0026#34;) %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 여기서 잠깐,\n\u0026lt;%= request.getAttribute(\u0026quot;outString\u0026quot;) %\u0026gt;\n이 녀석을, 지난 시간에 배웠던 EL 이라는 녀석으로 대체하자.\n${outString}\n이렇게 하면, jsp에 있던 모든 코드블럭을 없앰으로써,\n여전히 JSP, 즉 동적 페이지로서의 기능은 하면서\nMVC 패턴을 지켰기 때문에 유지보수에도 용이한\n코드를 작성할 수 있다.\n이와 더불어, Model 1 에서 겪었던 단점도 해결하였다.\n 파일이 하나이기 때문에, 다른 사람과 협업을 하려고 한다면, 어려움을 크게 겪을 것이다.\n==\u0026gt; 파일 자체를 구분하였기 때문에, 협업에 용이하다 만약 한 page에 대해서 처리하는 양이 많다면, page에 대한 요청이 들어올 때마다, 무거운 servlet을 만들고, 컴파일하는 행위를 반복해야 한다.\n==\u0026gt; Controller, Dispatcher는 미리 Compile되어있고, JSP만 Servlet으로 변환하면 된다.  정리 : 기존의 Code Block이 있던 JSP, Model 1, Model 2 로 옮겼을때를 짧게 정리하면 다음과 같다.\n    기존 Model 1 Model 2     개발편의성(러닝커브) 좋음 보통 나쁨   유지보수(가독성) 나쁨 보통 좋음   적합한규모 소 소 대    ","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-10-06-jsp_learning_07/","summary":"들어가며 : 지난 포스팅에서, Jasper 라는 도구를 이용하여 HTML Code에 직접 자바코드를 때려박는 방법을,\n그리고 이렇게 생성되는 파일을 JSP 라고 부른다는 것을 배웠다.\n그렇다면, 기존의 Java Code는 다 그대로 JSP로 옮겨버려도 될까?\n흠.. 뭔가 그렇지는 않을 것 같은데, 명확히 이유를 짚어내기는 어렵다.\n이번 포스팅에서는 그 \u0026ldquo;이유\u0026quot;에 대해서 알아보자.\n코드 구분의 필요성 : 우선, 다음과 같이, 기본적인 덧셈, 뺄셈을 계산해주는 코드를 만들어보자.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;calculator\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;form action=\u0026#34;Adder.jsp\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; first_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n1\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; second_number \u0026lt;/label\u0026gt; \u0026lt;input name=\u0026#34;n2\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;add\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;calc\u0026#34; value=\u0026#34;minus\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;% int num1 = 0; int num2 = 0; String num1_ = request.","title":"# 7. JSP 학습기록 - MVC 패턴과 JSP Model 1, Model 2"},{"content":"0. 들어가며 : 예외처리는, 그 이름만 들어도 두려움이 생긴다.\n간단하게 생각하자면 if else문의 연장선인 것 같으면서도,\n또 뭔가 시스템의 장애를 덕지덕지 막아내는 것 같은 찝찝함도 동시에 든다.\n예외처리문을 쓸때면 항상\n\u0026ldquo;애초에 코드를 잘 짜면 되지 않나?\u0026rdquo; 라는\n바보같은 의문이 남기도 한다.\n아무튼, 오늘 다루고자 하는 내용은\n\u0026ldquo;예외 처리는 이렇게 해야한다!\u0026rdquo; 하는 거창한 내용은 못되고(쓸 실력도 안되고),\n기본적으로 알고 있었던, 그리고 글을 쓰면서 새로 배운,\n이러이러한 것들이 존재한다~ 정도의 Introduction 느낌만 가져가려고 한다.\n1. 예외란 무엇인가? : Error와 Exception은 다르다.\n- Error : 시스템 레벨에서 발생하는 심각한 수준의 오류. 프로그램 내에서 처리할 수 없음.\ne.g. OutOfMemoryError, StackOverflowError\n- Exception : 개발자의 설계 미숙 등으로 인해, 로직 상의 문제. 미리 예측하고, 처리할 수 있다.\ne.g. NullPointerException, IndexOutOfBoundException\n1. try - catch - finally : 아마 try-catch 문을 배웠다면,\n가장 먼저 배우는 기본적인 형태는 다음과 같을 것이다.\npublic class Main {   public static void main(String[] args) {  myException();  }   public static void myException() {  try {  System.out.println(\u0026#34;try here\u0026#34;); // throw new IllegalStateException(\u0026#34;exception here\u0026#34;);  } catch(Exception e) {  System.out.println(\u0026#34;catch here\u0026#34;);  System.out.println(\u0026#34;e : \u0026#34; + e.getMessage());  } finally {  System.out.println(\u0026#34;finally here\u0026#34;);  }  }  } 중간에 주석처리된 throw new \u0026hellip; 는 예외를 발생시키는 코드다.\n저 키워드에 대해서는 후술하겠다.\n어쨌든, myException() 이라는 함수가 실행되면,\ntry 구문에서 try here를 출력하고,\n에러가 발생한다면(주석이 해제된다면) catch here 와 e : exception here 를,\n그리고 마지막으로 finally의 finally here를 출력하고 함수가 종료된다.\n만약 이러한 exception에 대한 처리를 해주지 않았더라면,\nNullPointerException, ArrayIndexOutOfBoundsException 등이 발생했을 때\n프로그램이 개복치처럼 죽어버렸을 것이다.\n  Note. 적절한 예외처리에 대한 내용은 잘 모르기도 하고, 이 포스팅의 취지에 맞지 않아\n최대한 빼려고 했는데, 그래도 이 부분은 중요한 것 같아서 꼭 넣어야 할 것 같다.\n무엇이냐 하면, 모든 예외를 Handling 해버리는, 상위 클래스인 Exception으로 예외처리하지 않는 것을 권장한다.\n다시 말해, 특정 예외만을 받아내는 Exception으로 처리해야 한다.\n  또한, finally가 **언제까지 살아있느냐?**를 주의깊게 봐야한다.\n다음의 코드를 보자.\npublic class Main {   public static void main(String[] args) {  myException();  }   public static int myException() {  try {  System.out.println(\u0026#34;try here\u0026#34;);  throw new IllegalStateException(\u0026#34;exception here\u0026#34;);  } catch(Exception e) {  System.out.println(\u0026#34;catch here\u0026#34;);  System.out.println(\u0026#34;e : \u0026#34; + e.getMessage());  return -1;  } finally {  System.out.println(\u0026#34;finally here\u0026#34;);  }  }  } 위에서 작성한 코드와의 차이는 딱 두 가지다.\n try문에서, throw keyword의 주석을 해제했다. myException() 함수의 return을 int로 바꾼 뒤, -1 (임의의 값) 을 return하도록 해서, 이를 출력하도록 했다.  try-catch가 익숙치 않은 사람이라면, finally가 있다 하더라도 return이 있기 때문에\nfinally here는 출력되지 않을 것으로 생각할 수 있지만,\n실제로는 finally here까지 출력이 되고, return 이 이루어진다.\n따라서, 실제 출력은 다음과 같이 이루어진다.\ntry here catch here e : exception here finally here -1 함수를 바로 종료시켜버리는 막강한 return조차 기다리게 만드는 finally라니, 도대체 어떻게 가능한 것일까?\n이를 알아보기 위해, 위 코드를 컴파일 시킨뒤, IDE를 이용하여 다시 디컴파일 시켜보자.\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // public class Main {  public Main() {  }   public static void main(String[] var0) {  int var1 = myException();  System.out.println(var1);  }   public static int myException() {  byte var1;  try {  System.out.println(\u0026#34;try here\u0026#34;);  throw new IllegalStateException(\u0026#34;exception here\u0026#34;);  } catch (Exception var5) {  System.out.println(\u0026#34;catch here\u0026#34;);  System.out.println(\u0026#34;e : \u0026#34; + var5.getMessage());  var1 = -1;  } finally {  System.out.println(\u0026#34;finally here\u0026#34;);  }   return var1;  } } 디컴파일 시킨 코드를 보니, 우리가 작성했던 return 문이 catch 안에서 실행되는 것이 아니고,\nvar1 이라는 byte 변수에 담아 놓은 뒤에, finally 이후에 return 되는 것을 볼 수 있다.\n즉, 우리가 catch안에 return을 작성하더라도, 컴파일러에 의해 뒤로 미뤄진다.\n2. Exception class : 예외 클래스는 다음과 같은 구조를 가진다.\n(인터페이스의 네이밍을 가진) Throwable이라는 클래스 하위에,\n아까 보았던 Exception과 Error가 구분되고,\n그 하위에 Exception을 직접 상속하는 클래스들,\n그리고 Exception을 상속하는 RunTimeException을 상속하는 클래스들로 이루어진다.\n이 때, Checked와 Unchecked는 다음과 같은 차이가 있다.\n- Checked Exception : 컴파일시에 \u0026ldquo;에러를 처리하는지\u0026quot;의 여부를 확인한다.\n예외 발생 시 transaction을 roll-back 하지 않는다.\n- Unchecked Exception : 예외가 런타임시에 발생할수도, 발생하지 않을수도 있으므로,\n컴파일할 때에는 에러 처리 여부를 확인하지 않는다.\n예외 발생 시 transaction을 roll-back 한다.\n3. throw와 throws : 이 두가지 키워드가 수행하는 역할은 다르지만, 비슷하게 생겨서 묶었다.\n- throw : 위에서 적어놓았던 throw new IllegalStateException(); 은,\nIllegalStateException 이라는 예외를 \u0026ldquo;발생\u0026quot;시킨다.\n즉, throw는 예외를 발생시키는 역할을 한다.\n- throws : 반면, throws는 예외를 던진다. 무슨말인가 하면, 예외가 발생했을 때 이를 메소드 자기 자신이 처리하지 않고,\n자기 자신을 호출한 메소드에게 \u0026ldquo;이거 처리해주세요\u0026rdquo; 하고 던진다.\n계속해서 stack을 타고 가다보면, 최종적으로는 main 메소드를 실행한 JVM 에게 던진다.\n다음의 코드의 흐름을 잘 살펴보면, 위 두 키워드의 차이에 대해서 알 수 있으리라 생각한다.\npublic class Main {  public static void main(String[] args) {  try {  myException();  } catch(IllegalStateException e) {  System.out.println(e.getMessage());  }   }   public static int myException() throws IllegalStateException {  throw new IllegalStateException(\u0026#34;exception\u0026#34;);  } } 4. try-with-resources : 버퍼 입출력을 지원하는 클래스인 BufferedWriter는 Checked Exception중 하나이다.\nPath file = Paths.get(\u0026#34; ... \u0026#34;); BufferedWriter writer = null;  writer = Files.newBufferedWriter(file); // IOException writer.write(\u0026#34; ... \u0026#34;); // IOException writer.close(); // IOException 위 세 곳에서 IOException이 발생하므로,\nIDE에서 Unhandled Exception이 있다면서 빨간 줄을 쭉 그어준다.\n그러나, close()의 경우 반드시 실행되어야 하기 때문에,\ntry가 아닌 finally block에 들어가야 하는데, 이 또한 IOException이 발생할 수 있다.\n따라서, finally에 try-catch를 한번 더 써야하는데, 이는 꽤 귀찮은 일이다.\n이를 위해, try-with-resources 라는 것이 생겼다.\n형태는 다음과 같다.\ntry(BufferedWriter writer = Files.newBufferedWriter(file)) {  writer.write(\u0026#34; ... \u0026#34;); } catach(IOException e) {  // do something } 마치, 파이썬에서 Context Manager라고 불리는 with 과 비슷하다.\n파이썬의 Context Manager는 close() 함수를 호출하지 않아도,\nwith 구문이 끝나면 알아서 호출해준다.\nwith open(\u0026#34;foo.txt\u0026#34;, \u0026#34;r\u0026#34;) as f:  file = f.read() 아무튼, 이러한 try-with-resources 의 resources가 되기 위해서는\njava.lang.AutoCloseable 인터페이스를 구현해야 한다.\n","permalink":"http://cjlee38.github.io/post/language/java/2020-10-05-exception_in_java/","summary":"0. 들어가며 : 예외처리는, 그 이름만 들어도 두려움이 생긴다.\n간단하게 생각하자면 if else문의 연장선인 것 같으면서도,\n또 뭔가 시스템의 장애를 덕지덕지 막아내는 것 같은 찝찝함도 동시에 든다.\n예외처리문을 쓸때면 항상\n\u0026ldquo;애초에 코드를 잘 짜면 되지 않나?\u0026rdquo; 라는\n바보같은 의문이 남기도 한다.\n아무튼, 오늘 다루고자 하는 내용은\n\u0026ldquo;예외 처리는 이렇게 해야한다!\u0026rdquo; 하는 거창한 내용은 못되고(쓸 실력도 안되고),\n기본적으로 알고 있었던, 그리고 글을 쓰면서 새로 배운,\n이러이러한 것들이 존재한다~ 정도의 Introduction 느낌만 가져가려고 한다.","title":"# (Java) 예외처리를 위한 Try-Catch"},{"content":"Problem 문제 설명\n고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.\n고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.\n제한사항\n 차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다. 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다. 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.  입출력 예\n   routes return     [[-20,15], [-14,-5], [-18,-13], [-5,-3]] 2    입출력 예 설명\n-5 지점에 카메라를 설치하면 두 번째, 네 번째 차량이 카메라를 만납니다.\n-15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다.\nAnswer : 입출력 예에서, 15가 아니라 -15다. 오타인 듯 싶다.\n문제 예시를 대충 그려보면 다음과 같다.\n지난번에 풀었던 공주님의 정원 문제와 흡사하다.\n핵심 키포인트는, 모든 차량이 한번이라도 단속카메라를 만나야 한다는 것,\n그리고 최소한의 카메라를 구해야 한다는 것이다.\n가장 먼저, 진입지점을 우선순위로, 진출지점을 차순위로 하여 차량을 내림차순 정렬했다. (이 방법이 답을 구하는 유일한 방법은 아니다.)\n다음으로, 진입지점이 가장 큰 차량을 우선 기준으로 삼은 뒤,\nindex 1번부터 loop를 돌면서 \u0026ldquo;진출지점이 기준에 해당하지 않는\u0026rdquo; 차량을 발견한다면,\n그 차량의 진입지점을 다음 기준으로 삼는다.\n문제 예시로 설명하면 다음과 같다.\n우선, 정렬을 하고 나면 배열은 다음과 같이 구성된다.\n-5 -3\n-14 -5\n-18 -13\n-20 -15\n이후, 먼저 -5를 기준으로 삼고, loop를 시작한다.\n-14 -5 는 진출지점인 -5가 기준에 해당한다(즉, 카메라에 찍힌다.)\n-18 -13 은, 진출지점인 -13이 기준에 해당하지 않으므로, 이 차량의 진입지점인 -18을 기준으로 삼는다(즉, 카메라를 설치한다.)\n-20 -15 는 진출지점인 -15가 -18인 기준에 해당한다.(즉, 카메라에 찍힌다.)\n카메라는 첫 기준인 -5와, 두번째 기준인 -18 의 두개로, 2를 return한다.\n코드는 다음과 같다.\npackage programmers;  import java.util.Arrays;  // 프로그래머스 - 단속카메라 public class p42884 {  public static void main(String[] args) {  int[][] routes = {  {-20, 15},  {-14, -5},  {-18, -13},  {-5, -3}  };   int answer = solution(routes);  System.out.println(answer);  }   public static int solution(int[][] routes) {  Arrays.sort(routes, (o1, o2) -\u0026gt; {  if (o1[0] == o2[0]) return o1[1] \u0026lt; o2[1] ? 1 : -1;  else return o1[0] \u0026lt; o2[0] ? 1 : -1;  });   int std = routes[0][0];  int answer = 1;  for (int i=1; i\u0026lt;routes.length; i++) {  System.out.println(\u0026#34;std : \u0026#34; + std);  if (routes[i][1] \u0026lt; std) {  std = routes[i][0];  answer++;  }  }     return answer;  }  } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-10-04-problem_solving_12/","summary":"Problem 문제 설명\n고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.\n고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.\n제한사항\n 차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다.","title":"# 프로그래머스[Lv.3] 단속카메라 ( Java )"},{"content":"0. 들어가며 : String은 언제 다뤄도 어렵다.\nJava 에서의 String은 조금 특별한 존재이기 때문에, Python처럼 생각없이 다루면 안된다.\nString에 연산이 많이 들어가는 경우, StringBuilder를 쓰는 경우가 많은데,\n도대체 어떤 차이가 있는지, String은 어떻게 변환되는지에 대해\n이번 포스팅을 통해 짚어보고자 한다.\n1. String String Constant Pool : 기본적으로, String은 Primitive Type이 아닌, Reference Type이다.\n즉, 우리가 바라보고 있는 특정 String은 그 자체로서 값을 갖고 있는 것이 아니고,\n그 값에 대한 \u0026ldquo;포인터\u0026rdquo; 인 셈이다.\n이 포인터는 Stack 영역에서 관리된다.\n그렇다면, 그 실제적인 값을 갖고 있는 녀석은 어디에 있을까?\n바로 Heap 영역의 String Constant Pool에 있다.\n다음을 보자.\npublic class Main {   public static void main(String[] args) {  String s1 = \u0026#34;hello\u0026#34;;  String s2 = \u0026#34;hello\u0026#34;;  String s3 = new String(\u0026#34;hello\u0026#34;);  String s4 = new String(\u0026#34;hello\u0026#34;);   System.out.println(s1 == s2); // true  System.out.println(s1 == s3); // false  System.out.println(s3 == s4); // false   } } 다 같은 \u0026ldquo;hello\u0026rdquo; 라는 string을 담고 있는데,\ns1과 s2는 같은 반면, s1과 s3는 다르다. 이에 더해, s3와 s4 또한 다르다.\n왜 이런 차이를 보이는 것일까? 이는 다음의 그림을 보면 알 수 있다.\n{: .alignCenter}\n{: .caption} 사진 출처\n기본적으로, 우리가 String str = \u0026quot;hello\u0026quot;; 와 같이 String을 만들면,\n이는 String literal 이라고 부르고, 다음과 같이 동작한다.\n String (constant) Pool 에서, 동일한 String이 있는지 찾는다. 동일한 String을 발견하면, 해당 객체를 가리키도록 한다. 동일한 String을 발견하지 못하면, String Pool에 새로운 String을 만들고 이를 가리킨다.  하지만, String str = new String(\u0026quot;hello\u0026quot;); 와 같이 작성하면,\n우리가 일반적으로 관리하는 클래스처럼, Heap 영역에 해당 String을 만들어버린다.\n위 코드의 s3와 s4는 같지 않다고 나온 이유가 이 때문이다.\n따라서, 사람의 입장에서 \u0026ldquo;String이 같은가요?\u0026rdquo; 라고 물어보려면, equals() 함수를 사용해야 한다.\nequals() 함수를 따라가보면 다음과 같이 작성되어 있다.\n@HotSpotIntrinsicCandidate  public static boolean equals(byte[] value, byte[] other) {  if (value.length == other.length) {  for (int i = 0; i \u0026lt; value.length; i++) {  if (value[i] != other[i]) {  return false;  }  }  return true;  }  return false;  } String을 initialize 하면, String은 byte[] 라는 배열로 값이 들어가므로,\n비교하고자 하는 value 라는 byte 배열과, 그 대상인 byte[] other 를 하나씩 비교해가면서\n하나라도 다를 경우 false를 return한다.\n어찌되었든, Heap 영역과, 그 안의 String Pool에 String이 저장된다는 것은 알았다.\nString as Immutable : Java에서의 String은 immutable(불변) 이라고 한다. 이게 도대체 무슨 뜻일까?\n바꿔 말해서, String에 값을 변경하면 어떻게 될까?\n다음의 코드를 보자.\npublic class Main {   public static void main(String[] args) {  String s1 = new String(\u0026#34;hello\u0026#34;);  String s2 = s1;  String s3 = new String(\u0026#34;helloworld\u0026#34;);  String s4 = \u0026#34;helloworld\u0026#34;;   System.out.println(s1 == s2); // true   s1 += \u0026#34;world\u0026#34;;  System.out.println(s1); // helloworld  System.out.println(s2); // hello   System.out.println(s1 == s2); // false  System.out.println(s2 == s3); // false  System.out.println(s1 == s4); // false   } } 만약, String이 mutable, 즉 변경가능한 객체였다면,\ns1 += \u0026quot;world\u0026quot;; 라는 덧셈을 하고 나면,\ns2 가 s1 의 값을 가리키고 있으므로,\ns2 또한 \u0026ldquo;helloworld\u0026rdquo; 가 되었을 것이다.\n그러나, 실제로는 기존의 s1이 가리키던 객체를 놔버리고,\nworld가 추가된 \u0026ldquo;helloworld\u0026rdquo; 객체를 새로 만들어서, 그곳을 가리키게 된다.\n그렇기 때문에, 두 번째 s1 == s2 에서 false를 return 했다.\n또한, s3는 new String으로 String pool 이 아닌 heap 영역에 할당되었기 때문에, 예상한대로 s1과 같지 않았다.\n마지막으로, world가 추가된 s1은 기존의 String pool에 있던 s4와 다르므로,\n덧셈 연산자가 더해진 s1은 heap 영역(not String pool) 에 객체로서 저장된다는 사실을 알 수 있다.\n바꿔 말하면, String은 Immutable 객체이기 때문에, 기존 객체의 값이 변경되지 않고\n새로 만들어서 할당된다는 것을 알 수 있다.\n  Note. 찾다보니, int 같은 primitive type도 immutable인지에 대해서 찾아보았다.\n잠깐 C에서의 예시를 가져와보면, C에서의 primitive data는 mutable 이다.\n#include \u0026lt;stdio.h\u0026gt;int main() {  int i = 1;  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;i); // 0x7ffd1111f95c   i += 1;  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;i); // 0x7ffd1111f95c } 그런데, Java에서의 primitive는 immutable 이라고 한다.\n자세한 내용은 여기를 참고하자.\n누군가는 \u0026ldquo;Primitive는 mutable, immutable 자체를 따질 수 없다\u0026quot;고도 한다.\n이 내용은 조금 더 찾아봐야 할 듯 싶다.\n  Heap ↔ String pool : 이렇게 보면 String pool은 무슨 신성불가침의 영역처럼 여겨질 수도 있는데,\n다음과 같이 활용하면, 두 영역을 손쉽게 넘나들 수 있다.\npublic class Main {   public static void main(String[] args) {  String s1 = \u0026#34;hello\u0026#34;;  String s2 = new String(s1);  String s3 = s2.intern();   System.out.println(s1 == s2); // false  System.out.println(s2 == s3); // false  System.out.println(s1 == s3); // true   } } s1 은 평소처럼 String pool에 등록해서 사용하는 것이다.\ns2 또한, new String으로 만들어주는 방법으로, heap 영역에 할당할 수 있다.\ns3 에서 나타나는 intern()의 역할은,\nheap 영역에 있는 String을 String pool로 등록시켜준다.\n이는 필요에 따라, 적절히 사용하면 된다.\nString, StringBuilder, StringBuffer History : 이제 String이 대충 어떻게 노는 녀석인지는 배웠다.\n근데, StringBuilder, StringBuffer는 왜 생겼을까?\nBefore JDK 1.5, String에 덧셈을 한다는 것은 굉장히 비효율적인 일이었다.\n생각해보자. 앞서서, \u0026ldquo;hello\u0026quot;에다가 \u0026ldquo;world\u0026quot;를 더해주려면,\n\u0026ldquo;hello\u0026quot;를 놔버리고, 새로 만든 \u0026ldquo;helloworld\u0026quot;를 가리키도록 하는 일이었다.\n근데 만약, for loop 안에서, 100번을 반복하는 일이 생긴다면 어떻게 될까?\n100번을 놓고, 다시 100번을 가리키도록 하는 불상사가 생길 것이다.\n따라서, 그 전까지는 StringBuffer가 String의 manipulation을 위한 유일한 선택지였다.\n그런데, StringBuffer는 모든 Public method가 동기화 되어야 한다는 단점을 안고 있었다.\n즉, multi-thread가 아닐 때에도, 울며겨자먹기로 StringBuffer를 쓸 수 밖에 없었다.\n효율적인 String의 연산을 위해서, StringBuiler가 JDK 1.5부터 등장하였다.\n이 StringBuilder와 StringBuffer는 Mutable이다.\n역시, 다음의 코드를 보자.\npublic class Main {   public static void main(String[] args) {  StringBuilder sb1 = new StringBuilder();  StringBuilder sb2 = sb1;   sb1.append(\u0026#34;hello\u0026#34;);  System.out.println(sb1); // hello  System.out.println(sb2); // hello   System.out.println(sb1 == sb2); // true  } } String이었다면 서로 다른 객체라고 false를 던졌을텐데,\nStringBuilder는 mutable이기 때문에 서로 같다는 결과가 나타나는 것을 볼 수 있다.\n그렇다면, String 연산 시에는 String을 무조건 쓰면 안되는 것일까? 그렇지는 않다.\nJDK 1.5 이후로, String의 + 연산도 StringBuilder를 사용하도록 변경되었다.\nComparing : 백문이 불여일견. 정말 StringBuilder를 사용하는지 직접 코드로 속도 비교 테스트를 해보자.\npublic class Main {   public static void main(String[] args) {  int repeat = 100000;  long resultString = testString(repeat);  long resultStringBuilder = testStringBuilder(repeat);  long resultStringBuffer = testStringBuffer(repeat);   System.out.println(\u0026#34;string : \u0026#34; + resultString);  System.out.println(\u0026#34;stringBuilder : \u0026#34; + resultStringBuilder);  System.out.println(\u0026#34;stringBuffer : \u0026#34; + resultStringBuffer);   }   public static long testString(int repeat) {  long start = System.currentTimeMillis();  String str = \u0026#34;\u0026#34;;  for (int i=0; i\u0026lt;repeat; i++) {  str += \u0026#34;string\u0026#34;;  }  long end = System.currentTimeMillis();  System.out.println(str.length());  return end-start;  }  public static long testStringBuilder(int repeat) {  long start = System.currentTimeMillis();  StringBuilder sbd = new StringBuilder();  for (int i=0; i\u0026lt;repeat; i++) {  sbd.append(\u0026#34;string\u0026#34;);  }  long end = System.currentTimeMillis();  System.out.println(sbd.length());  return end-start;  }   public static long testStringBuffer(int repeat) {  long start = System.currentTimeMillis();  StringBuffer sbf = new StringBuffer();  for (int i=0; i\u0026lt;repeat; i++) {  sbf.append(\u0026#34;string\u0026#34;);  }  long end = System.currentTimeMillis();  System.out.println(sbf.length());  return end-start;  } } 약 10만번의 반복을 테스트해봤는데, 결과는 다음과 같다.\nstring : 10886 stringBuilder : 6 stringBuffer : 8 ???. 뭔가 이상하다.\n검색해보니 StackOverflow에 다음과 같은 답변이 있었다.\nString one = \u0026#34;abc\u0026#34;; String two = \u0026#34;xyz\u0026#34;; String three = one + two; // 이렇게 쓰면,   String three = new StringBuilder().append(one).append(two).toString(); // 이렇게 컴파일 됩니다. 그러나,   String out = \u0026#34;\u0026#34;; for( int i = 0; i \u0026lt; 10000 ; i++ ) {  out = out + i; } return out; // 이렇게 작성하면,   String out = \u0026#34;\u0026#34;; for( int i = 0; i \u0026lt; 10000; i++ ) {  out = new StringBuilder().append(out).append(i).toString(); } return out; // 이렇게 쓰는거랑 똑같습니다. 그러므로, 그냥 StringBuilder를 쓰세요.   StringBuilder out = new StringBuilder(); for( int i = 0 ; i \u0026lt; 10000; i++ ) {  out.append(i); } return out.toString(); // 이렇게 결국 StringBuilder를 계속해서 만드는 꼴이므로,\n꼼수 부리지 말고 그냥 StringBuilder를 쓰자.\n대충 정리하면, String, StringBuilder, StringBuffer의 차이점은 다음과 같다.\n    String StringBuilder StringBuffer     Storage String Pool Heap Heap   Modifiable No(immutable) Yes(mutable) Yes(mutable)   Thread safe Yes(immutable이므로) No Yes   Performance Fast(compiled as StringBuilder) Fast (Relatively)Slow    즉,\n String : 연산이 많지 않은 경우, thread-safe 를 원하는 경우. StringBuilder : 연산이 많은 경우, thread 는 상관 없는 경우. StringBuffer : 연산이 많은 경우, thread-safe 를 원하는 경우.  가 되겠다.\nReference  Guide to Java String Constant Pool java String 풀(Pool) String, StringBuffer, StringBuilder의 차이점과 장단점은 뭔가요? Java: String concat vs StringBuilder - optimised, so what should I do?  ","permalink":"http://cjlee38.github.io/post/language/java/2020-10-01-all_of_string_in_java/","summary":"0. 들어가며 : String은 언제 다뤄도 어렵다.\nJava 에서의 String은 조금 특별한 존재이기 때문에, Python처럼 생각없이 다루면 안된다.\nString에 연산이 많이 들어가는 경우, StringBuilder를 쓰는 경우가 많은데,\n도대체 어떤 차이가 있는지, String은 어떻게 변환되는지에 대해\n이번 포스팅을 통해 짚어보고자 한다.\n1. String String Constant Pool : 기본적으로, String은 Primitive Type이 아닌, Reference Type이다.\n즉, 우리가 바라보고 있는 특정 String은 그 자체로서 값을 갖고 있는 것이 아니고,\n그 값에 대한 \u0026ldquo;포인터\u0026rdquo; 인 셈이다.","title":"# (Java) 추석맞이 String 종합선물세트"},{"content":"Problem {: .alignCenter}\nAnswer : 문제가 좀 복잡한데, 어쨌든 시뮬레이션으로 풀었다.\n이 문제에서 신경써야 할 부분은, 보다시피 딱 두 가지다.\n 미세먼지의 확산 공기청정기의 작동  처음에는 공기청정기가 로봇청소기처럼 돌아다니면서 청소하는 개념인줄 알았더니,\n그게 아니고 제자리 Fix된 상태에서 공기를 순환시키는 방식으로 동작하는 것이었다.\n아무튼, 하나씩 풀어보자.\n미세먼지의 확산 : 미세먼지는 인접한 네 방향으로만 확산하고,\n벽 혹은 공기청정기에 가로막혀 있으면 확산되지 않는다.\n또한, 본래 자리에 있던 미세먼지는 빠져나간 미세먼지 만큼만\n감소하므로, 이를 유의해야 한다.\n이에 더해, 미세먼지의 확산은 동시에 일어나므로,\n확산되는 숫자를 모아놨다가 한번에 더해줘야 한다.\n{: .alignCenter}\n예를 들자면, 그림의 (1, 8) 에 위치한 9 에서 확산이 벌어지면,\n두 방향으로 1씩 나눠주므로, 본래 위치의 값은 7이 된다.\n바꿔말하면, -2 라는 값을 받아야 한다.\n그림의 (2, 8) 에 위치한 8 에서 확산이 벌어지면,\n세 방향으로 1씩 나눠주므로, 본래 위치의 값은 5가 된다.\n그러나, (원래 9에서 원래 8)로 1 만큼, (원래 8에서 원래 9로) 1 만큼\n주기 때문에, 확산이 일어난 후 값은 7과 5가 아닌 8과 6이 된다.\n{: .alignCenter}\n기존의 board 에다가 그리면 이러한 동시다발적인 효과를 구현하기 어려우므로,\nemptyMap을 하나 만들어서, 해당 Map에다가 증감의 값을 기록해놓은 뒤,\n한번에 더해주는 방식으로 작성하였다.\n private void dustSpread() {  int[][] newMap = createEmptyMap(); // empty Map  for (int i=0; i\u0026lt;R; i++) {  for (int j=0; j\u0026lt;C; j++) {  if (map[i][j] != 0 \u0026amp;\u0026amp; map[i][j] != -1) { // 원래의 map에서 미세먼지를 발견한다면  spread(newMap, i, j, map[i][j]); // 미세먼지 확산  }  }  }   addMap(newMap); // 기록해놓은 값을 한번에 더함 }  private void spread(int[][] newMap, int i, int j, int target) {  int spreadCount = 0;  if (i != 0 \u0026amp;\u0026amp; !isCleaner(i-1, j)) {  newMap[i-1][j] += target / 5;  spreadCount++;  }  if (i != R-1 \u0026amp;\u0026amp; !isCleaner(i+1, j)) {  newMap[i+1][j] += target / 5;  spreadCount++;  }  if (j != 0 \u0026amp;\u0026amp; !isCleaner(i, j-1)) {  newMap[i][j-1] += target / 5;  spreadCount++;  }  if (j != C-1 \u0026amp;\u0026amp; !isCleaner(i, j+1)) {  newMap[i][j+1] += target / 5;  spreadCount++;  }   newMap[i][j] -= ((target / 5) * spreadCount); } 공기청정기의 동작 : 미세먼지의 확산보다, 좀 더 어려웠던 부분이 공기청정기였던 것 같다.\n공기청정기는 두 칸을 차지하고, 또 동작하는 방향도 다르므로,\n마치 1x1의 공기청정기가 두 개 있는 것 처럼 생각해서 작성하였다.\n그리고, 시계방향 혹은 반시계방향으로 회전할 때에는,\n마치 배열을 한칸씩 뒤로 미룬뒤 삽입할 때 처럼,\nprev와 cur를 사용해서 동작하면 된다.\np.s.1 코드를 다시 보니까 리팩토링할 부분이 한두군데가 아닌 것 같다.\np.s.2 문제를 풀 때 뭔 생각이었는진 모르겠는데, x와 y가 바뀌어 있다.\n전체 코드\npackage BOJ;  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  // 백준 - 미세먼지 안녕! public class bj17144 {   static Solution17144 init() throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int R = Integer.parseInt(st.nextToken());  int C = Integer.parseInt(st.nextToken());  int T = Integer.parseInt(st.nextToken());   int[][] map = new int[R][C];   for (int i = 0; i \u0026lt; R; i++) {  st = new StringTokenizer(br.readLine());  for (int j = 0; j \u0026lt; C; j++) {  map[i][j] = Integer.parseInt(st.nextToken());  }  }   return new Solution17144(R, C, T, map);  }   public static void main(String[] args) throws IOException {  Solution17144 s = init();  int answer = s.run();  System.out.println(answer);  } }  class Solution17144 {  final private int R;  final private int C;  final private int T;   private int[][] map;   public Solution17144(int R, int C, int T, int[][] map) {  this.R = R;  this.C = C;  this.T = T;  this.map = map;  }   public int run() {  int answer = 0;  AirCleaner posA = findClenaerPos(0);  AirCleaner posB = findClenaerPos(1);   for (int i=0; i\u0026lt;T; i++) {  dustSpread();  posA.clean(map);  posB.clean(map);  }   answer = getResult();   return answer;  }   private AirCleaner findClenaerPos(int number) {  AirCleaner AC = null;  for (int i=0; i\u0026lt;R; i++) {  for (int j=0; j\u0026lt;C; j++) {  if (map[i][j] == -1) {  if (number == 0) {  AC = new AirCleaner(i, j, AirCleaner.CLOCKWISE);  } else {  AC = new AirCleaner(i+1, j, AirCleaner.COUNTER_CLOCKWISE);  }  return AC;  }  }  }   return AC;  }   private void dustSpread() {  int[][] newMap = createEmptyMap();  for (int i=0; i\u0026lt;R; i++) {  for (int j=0; j\u0026lt;C; j++) {  if (map[i][j] != 0 \u0026amp;\u0026amp; map[i][j] != -1) {  spread(newMap, i, j, map[i][j]);  }  }  }   addMap(newMap);  }   private void spread(int[][] newMap, int i, int j, int target) {  int spreadCount = 0;  if (i != 0 \u0026amp;\u0026amp; !isCleaner(i-1, j)) {  newMap[i-1][j] += target / 5;  spreadCount++;  }  if (i != R-1 \u0026amp;\u0026amp; !isCleaner(i+1, j)) {  newMap[i+1][j] += target / 5;  spreadCount++;  }  if (j != 0 \u0026amp;\u0026amp; !isCleaner(i, j-1)) {  newMap[i][j-1] += target / 5;  spreadCount++;  }  if (j != C-1 \u0026amp;\u0026amp; !isCleaner(i, j+1)) {  newMap[i][j+1] += target / 5;  spreadCount++;  }   newMap[i][j] -= ((target / 5) * spreadCount);  }   private int[][] createEmptyMap() {  int[][] newMap = new int[R][C];  for (int i=0; i\u0026lt;R; i++) {  for (int j=0; j\u0026lt;C; j++) {  newMap[i][j] = 0;  }  }   return newMap;  }   private boolean isCleaner(int i, int j) {  if (map[i][j] == -1) {  return true;  } else {  return false;  }  }   private void addMap(int[][] newMap) {  for (int i=0; i\u0026lt;R; i++) {  for (int j=0; j\u0026lt;C; j++) {  map[i][j] += newMap[i][j];  }  }  }   public int getResult() {  int result = 0;  for (int i=0; i\u0026lt;R; i++) {  for (int j=0; j\u0026lt;C; j++) {  if (map[i][j] ==-1) {  continue;  } else {  result += map[i][j];  }  }  }   return result;  }  }  class AirCleaner {  final static int CLOCKWISE = 0;  final static int COUNTER_CLOCKWISE = 1;    final private int X;  final private int Y;  final private int clockwise;  public AirCleaner(int x, int y, int clockwise) {  X = x;  Y = y;  this.clockwise = clockwise;  }   public void clean(int[][] map) {  int x = X;  int y = Y+1;  int R = map.length;  int C = map[0].length;  int cur;  int prev = map[x][y-1];   // go right  for ( ; y\u0026lt;C-1; y++) {  cur = map[x][y];  map[x][y] = map[x][y-1] == -1 ? 0 : prev;  prev = cur;  }   // go up or down  if (clockwise == CLOCKWISE) {  for ( ; x\u0026lt;R-1; x++) {  cur = map[x][y];  map[x][y] = prev;  prev = cur;  }  } else {  for ( ; x\u0026gt;0; x--) {  cur = map[x][y];  map[x][y] = prev;  prev = cur;  }  }   // go left  for ( ; y\u0026gt;0; y--) {  cur = map[x][y];  map[x][y] = prev;  prev =cur;  }   // go up or down  if (clockwise == CLOCKWISE) {  for ( ; x\u0026gt;X ; x--) {  cur = map[x][y];  map[x][y] = prev;  prev = cur;  }  } else {  for ( ; x\u0026lt;X ; x++) {  cur = map[x][y];  map[x][y] = prev;  prev = cur;  }  }  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-28-problem_solving_10/","summary":"Problem {: .alignCenter}\nAnswer : 문제가 좀 복잡한데, 어쨌든 시뮬레이션으로 풀었다.\n이 문제에서 신경써야 할 부분은, 보다시피 딱 두 가지다.\n 미세먼지의 확산 공기청정기의 작동  처음에는 공기청정기가 로봇청소기처럼 돌아다니면서 청소하는 개념인줄 알았더니,\n그게 아니고 제자리 Fix된 상태에서 공기를 순환시키는 방식으로 동작하는 것이었다.\n아무튼, 하나씩 풀어보자.\n미세먼지의 확산 : 미세먼지는 인접한 네 방향으로만 확산하고,\n벽 혹은 공기청정기에 가로막혀 있으면 확산되지 않는다.\n또한, 본래 자리에 있던 미세먼지는 빠져나간 미세먼지 만큼만\n감소하므로, 이를 유의해야 한다.","title":"# 백준[No.17144] - 미세먼지 안녕! ( Java )"},{"content":"문제 링크\nProblem N진수 게임\n튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다.\n이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.\n 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.  이렇게 게임을 진행할 경우,\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …\n순으로 숫자를 말하면 된다.\n한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는\n0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …\n순으로 숫자를 말하면 된다.\n이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해\n이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다.\n숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해,\n자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다.\n튜브의 프로그램을 구현하라.\n입력 형식\n진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 가 주어진다.\n 2 ≦ n ≦ 16 0 ＜ t ≦ 1000 2 ≦ m ≦ 100 1 ≦ p ≦ m  출력 형식 튜브가 말해야 하는 숫자 t개를 공백 없이 차례대로 나타낸 문자열. 단, 10~15는 각각 대문자 A~F로 출력한다.\n입출력 예제\n   n t m p result     2 4 2 1 \u0026ldquo;0111\u0026rdquo;   16 16 2 1 \u0026ldquo;02468ACE11111111\u0026rdquo;   16 16 2 2 \u0026ldquo;13579BDF01234567\u0026rdquo;    Answer : N 진수를 구하는것만 해결한다면, 어렵지 않게 해결할 수 있는 문제다.\n처음에는 2,8,10,16 의 기본적인 진수만 고려했는데,\n문제를 다시 읽어보니 2부터 16까지의 진수가 나올 수 있다는 것을 알았다.\n즉, 9진수, 13진수 등과 같은 경우도 생길 수 있다는 뜻이다.\n직접 구하기 위해서, 다음과 같이 작성하였다.\nfinal static private String[] BASE = {\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;F\u0026#34;};  public static String getNumberString(int n, int num) {  StringBuilder sb = new StringBuilder();   do {  sb.append(BASE[num%n]);  num /= n;  } while (num != 0);   return sb.reverse().toString(); } 0부터 F까지의 숫자를 구해놓고, num이 0 이 아닐때까지 해당 진수의 값을 구하는 방법이다.\n즉, 가령 16진수가 조건으로 들어왔고, 10진수로 10 이라는 숫자가 들어왔다면,\n10%16 = 10 이므로, \u0026ldquo;A\u0026quot;가 StringBuilder에 append 된다.\n만약 31 이라는 숫자가 들어왔다면,\n31 % 16 = \u0026ldquo;F\u0026rdquo; (append)\n31 / 16 = 1\n1 % 16 = \u0026ldquo;1\u0026rdquo; (append)\n1 / 16 = 0 (break)\nStringBuilder(\u0026ldquo;F1\u0026rdquo;).reverse().toString = \u0026ldquo;1F\u0026rdquo;\n가 된다.\n이 때, num이 0부터 시작하므로\nwhile loop 가 아닌 do while loop 를 사용하였다.\n2~16 진수에 대한 값을 구할 수 있다면, 나머지는 간단하다.\npackage programmers;  public class p17687 {  final static private String[] BASE = {\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;F\u0026#34;};  public static void main(String[] args) {  int n = 16;  int t = 16;  int m = 2;  int p = 1;  String result = solution(n, t, m, p);  System.out.println(result);  }   public static String solution(int n, int t, int m, int p) {  StringBuilder sb = new StringBuilder();   // T*M = 튜브가 말해야 하는 숫자 T 개 * 게임에 참가하는 인원 M 명  // 자릿수가 두 개 이상 넘어가면 사용하지 않는 영역이 생기지만,  // 어쨌든 부족할 일은 없다.  for (int i=0; i\u0026lt;t*m; i++) {  sb.append(getNumberString(n, i));  }     StringBuilder tube = new StringBuilder();  for (int i=0; i\u0026lt;sb.length(); i++) {  if (tube.length() == t) {  break;  } else if (i % m == (p-1)) { // p가 1부터 시작하므로 p-1로 0으로 맞춰줌.  tube.append(sb.charAt(i));  }  }   return tube.toString();  }   public static String getNumberString(int n, int num) {  StringBuilder sb = new StringBuilder();   do {  sb.append(BASE[num%n]);  num /= n;  } while (num != 0);   return sb.reverse().toString();  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-28-problem_solving_11/","summary":"문제 링크\nProblem N진수 게임\n튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다.\n이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.\n 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.  이렇게 게임을 진행할 경우,","title":"# 프로그래머스[Lv.2] N진수 게임( Java )"},{"content":"  본 포스팅은 자바지기 박재성님의 강의를 듣고 정리하면서 작성한 글입니다.\n발표 동영상과 슬라이드는 하단의 Reference를 참고해주세요.\n  의식적인 연습 : 단순히 반복적인 연습을 함으로써 실력 향상을 기대하기는 어렵다.\n\u0026ldquo;의식적인\u0026rdquo; 연습이 필요하다.\n의식적인 연습의 7가지 원칙.  효과적인 훈련 기법이 수립되어 있는 기술 연마 개인의 \u0026ldquo;컴포트 존\u0026quot;을 벗어난 지점에서 진행, 자신의 현재 능력을 살짝 넘어가는 작업을 지속적으로 시도 명확하고 구체적인 목표를 가지고 진행 신중하고 계획적이다. 즉, 개인이 온전히 집중하고 \u0026lsquo;의식적\u0026rsquo;으로 행동할 것을 요구 피드백과 피드백에 따른 행동 변경을 수반 효과적인 심적 표상을 만들어내는 한편으로 심적 표상에 의존 기존에 습득한 기술의 특정 부분을 집중적으로 개선함으로써 발전시키고 수정하는 과정을 수반.  연습 방법 1단계 : 단위 테스트 연습 : (TDD와 단위테스트를 만드는 것은 다르다.)내가 사용하는 API 사용법을 익히기 위한 학습 테스트에서 시작해라.\n 자바 String 클래스의 다양한 메소드 사용법 자바 ArrayList에 데이터를 추가,수정,삭제하는 방법  Example\nimport static org.assertj.core.api.Assertion.asserThat;  public class StringTest {  @Test  public void split() {  String[] values = \u0026#34;1\u0026#34;.split(\u0026#34;,\u0026#34;);  assertThat(values).contains(\u0026#34;1\u0026#34;);   values = \u0026#34;1,2\u0026#34;;  assertThat(values).containsExactly(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;);  }   @Test  public void substring() {  String input = \u0026#34;(1,2)\u0026#34;;  String result = input.substring(1, input.length() -1);  assertThat(result).isEqualsTo(\u0026#34;1,2\u0026#34;);  } } API 이외에는?\n 내가 구현하는 메소드 중,\nInput과 Output이 명확한 클래스 메소드(보통 Util 성격의 메소드)\n에 대한 단위 테스트 연습  효과\n 단위테스트 방법을 학습할 수 있다. 단위테스트 도구(jUnit)의 사용법을 익힐 수 있다. 사용하는 API에 대한 학습 효과가 있다.  2단계 : TDD 연습 지켜야 할 원칙  회사 프로젝트가 아닌, 토이 프로젝트에 연습하자. 웹, 모바일UI 혹은 DB에 의존관계를 가지지 않은 요구사항으로 연습한다.  Example : 쉼표(,) 또는 콜론(:)을 구분자로 가지는 문자열을 전달하는 경우,\n구분자를 기준으로 분리한 각 숫자의 합을 반환\n   입력(Input) 출력(Output)     null 또는 \u0026quot;\u0026rdquo; 0   \u0026ldquo;1\u0026rdquo; 1   \u0026ldquo;1,2\u0026rdquo; 3   \u0026ldquo;1,2:3\u0026rdquo; 6      Note. TDD LifeCycle\n{: .alignCenter} 실패하는 테스트를 먼저 만들고, 컴파일을 성공시키고, 테스트를 패스하기 위해 Production Code(실제 동작하는 코드)를 만들고, 마지막에 Refactoring.\n한번에 다 연습하지 말고, Test Fails와 Test Passes까지만 해보자.\n  Test Code Example\npublic class StringCalculatorTest {  @Test  public void nullOrEmpty() {  assertThat(StringCalculator.splitAndSum(null).isEqualTo(0));  assertThat(StringCalculator.splitAndSum(\u0026#34;\u0026#34;).isEqualTo(0));  }   @Test  public void singleValue() {  assertThat(StringCalculator.splitAndSum(\u0026#34;1\u0026#34;).isEqualTo(1));  }   @Test  public void delimiter_comma() {  assertThat(StringCalculator.splitAndSum(\u0026#34;1,2\u0026#34;).isEqualTo(3));  }   @Test  public void delimiter_comma_colon() {  assertThat(StringCalculator.splitAndSum(\u0026#34;1,2:3\u0026#34;).isEqualTo(6));  } } Production Code Example\npublic class StringCalculator {  public static int splitAndSum(String text) {  int result = 0;  if (text == null || text.isEmpty()) {  result = 0;  } else {  String[] values = text.split(\u0026#34;,|:\u0026#34;);  for (String value : values) {  result += Integer.parseInt(value);  }  }   return result;  } } 3단계 : Refactoring 연습 : 위 코드를, 어떻게 Refactoring 할 수 있을까?\nTest Code는 변경하지 말고, Production Code를 개선하는 연습을 한다.\n이를 Refactoring 하려고 하면, 막막하지만, 앞서 언급한\n\u0026ldquo;의식적인 연습 7가지 원칙\u0026rdquo; 을 떠올리자\n 명확하고 구체적인 목표를 가지고 진행 피드백과 피드백에 따른 행동 변경을 수반  Plus, 정성적인 기준보다는 정량적이고 측정 가능한 방법으로 연습하자. How?\nA. 메소드 분리 Method Point. 1 : 한 메소드에 오직 한 단계의 들여쓰기(indent)만 한다. 위 Production Code에서 두 단계의 indent가 있는 곳은\nfor (String value : values) {  result += Integer.parseInt(value); } 이 부분의 result += 부분임.\n따라서, for loop 부분을 result = sum(values) 로 대체하고,\n이에 걸맞는 메소드 작성!\nprivate static int sum(String[] values) {  int result = 0;  for (String value : values) {  result += Integer.parseInt(value);  }  return result; } Method Point. 2 : else Keyword를 쓰지 않는다. : if statement 안에, result = 0; 을 return 0; 로 대체함.\nresult = 0;이 남아 있다면, return이 나올때까지 코드를 직접 눈으로 봐야함. 그렇다면 다음과 같은 모습이 됨.\npublic static int splitAndSum(String text) {  if (text == null || text.isEmpty()) {  return 0;  }   String[] values = text.split(\u0026#34;,|:\u0026#34;);  return sum(values); } Method Point. 3 : 메소드가 한 가지 일만 하도록 구현하기. : 현재 sum() 메소드는 두 가지 일을 하고 있음\n 문자열을 숫자로 변환하기 숫자의 합을 계산하기  따라서, toInts() 라는 이름의 메소드를 만든다\nprivate static int[] toInts(String[] values) {  int[] numbers = new int[values.length];  for (int i = 0; i \u0026lt; values.length; j++) {  numbers[i] = Integer.parseInt(values[i]);  }   return numbers; } 따라서, sum() 함수도 parameter를 String[] 이 아닌 int[] 로 받게 한다.\nprivate static int sum(int[] numbers) {  int result = 0;  for (int number : numbers) {  result += number;  }   return result; } 이렇게 하고 나면, splitAndSum() 함수는 다음과 같다.\npublic static int splitAndSum(String text) {  if (text == null || text.isEmpty()) {  return 0;  }   String[] values = text.split(\u0026#34;,|:\u0026#34;);  int[] numbers = toInts(values);  return sum(numbers); } Method Point. 4 : 필요없는 로컬변수 제거 이때, values와 numbers 라는 로컬 변수가 정말 필요한가?\n필요하지 않다면, 다음과 같이 한 줄에 작성한다.\nreturn sum(toInts(text.split(\u0026#34;,|:\u0026#34;))); Method Point. 5 : Compose Method 패턴 적용 : 메소드의 의도가 잘 드러나도록 동등한 수준의 작업을 하는 여러 단계로 나눈다.\nLike This.\npublic class StringCalculator {  public static int add(String text) {  if (isBlank(test)) {  return 0;  }   return sum(toInts(split(text)));  }   private static boolean isBlank(String text) { ... }  private static String[] split(String text) { ... }  private static int[] toInts(String[] values) { ... }  private static int sum(int[] numbers) { ... } }  이전 코드와 비교해보자.  ```java public class StringCalculator {  public static int splitAndSum(String text) {  int result = 0;  if (text == null || text.isEmpty()) {  result = 0;  } else {  String[] values = text.split(\u0026#34;,|:\u0026#34;);  for (String value : values) {  result += Integer.parseInt(value);  }  }   return result;  } } 처음 읽는 사람에겐, add() 메소드는(이전 코드에서는 splitAndSum()) Refactoring 된 경우가 더 보기 좋다.\n이러한 Refactoring을, 한번에 하나씩 하자.\n이 외에도 다른 연습 방법? : 15 Line의 코드를 10 Line으로 줄여보자.\n이러한 극단적인 연습을 하면, \u0026ldquo;설계에 대한 Insight가 보인다.\u0026rdquo;\n또한, 이러한 연습이 가능한 이유는? 테스트가 뒷받침해주기 때문에.\nB. 클래스 분리 (조건 추가) : 위 로직에서, 만약 음수를 전달하는 경우\nRuntimeException을 Throw 한다.\nTest Code Example(Plus)\npublic class StringCalculatorText {   ...   @Test(expected = RuntimeExcept)  public void negative() {  StringCalculator.splitAndSum(\u0026#34;-1,2:3\u0026#34;);  } } Production Code Example(Plus)\npublic class StringCalculator {   ...   private static int[] toInts(String[] values) {  int[] numbers = new int[value.length];  for (int i = 0; i \u0026lt; values.length; i++) {  numbers[i] = toInt(values[i]);  }   return numbers;  }  private static int toInt(String value) {  int number = Integer.parseInt(value);  if (number \u0026lt; 0) {  throw new RuntimeException();  }  return number;  } } Class Point. 1 : 모든 Primitive Type과 String을 포장(Wrap)한다. 즉, 새로운 Class를 만든다.\npublic class Positive {  private int number;   public Positive(String value) {  this(Integer.parseInt(value));  }  public Positive(int number) {  if (number \u0026lt; 0) {  throw new RuntimeException();  }  this.number = number;  } } 이에 맞춰서, 다른 코드들도 Production Code도 수정하면 된다.\nprivate static Positive[] toInts(String[] values) {  Positive[] numbers = new Positive[values.length];  for (int i = 0; i\u0026lt; values.length; i+) {  numbers[i] = new Positive(values[i]);  }  return numbers; }  private static int sum(Positive[] numbers) {  Positive result = new Positive(0);  for (Positive number : numbers) {  result = result.add(number);  }   return result.getNumber(); } 이에 더해, Positive Class의 add와 getNumber를 구현한다.\npublic class Positive {   ...   public Positive add(Positive other) {  return new Positive(this.number + other.number);  }   public int getNumber() {  return number;  } } Class Point. 2 : 1급 Collection을 쓴다 : 1급 컬렉션이란?\n 하나의 Collection을 유일한 Field로 갖고 있는 클래스. Collection의 불변성을 보장(내부의 값도 변경 불가능) 상태와 행위를 한 곳에서 관리.  Class Point. 3 : 3개 이상의 instance 변수를 가진 class를 쓰지 않는다.  즉, Class의 Field가 3개 이상을 넘어가면 안된다.    Note. 위 Class point 2, 3에 대한 내용은 다음의 링크 참조\n일급 컬렉션 (First Class Collection)의 소개와 써야할 이유\n  4단계 : 토이 프로젝트 난이도 높이기 : 연습하기 좋은 프로그램의 요구사항들\n 게임과 같이 요구사항이 명확한 프로그램으로 연습 의존관계(모바일 UI, 웹 UI, 데이터베이스, 외부 API와 같은 의존관계)가 없이 연습 약간은 복잡한 로직이 있는 프로그램  example\n 로또 사다리 타기 볼링 게임 점수 판 체스 게임 지뢰 찾기 게임 (단, UI는 콘솔)  앞에서 지켰던 기준을 지키면서 프로그래밍 연습을 하자.\n5단계 : 의존관계 추가를 통한 난이도 높이기 : 웹, 모바일 UI, 데이터베이스와 같은 의존관계를 추가\n이 때 필요한 역량\n 테스트하기 쉬운 코드와 어려운 코드를 보는 눈 테스트하기 어려운 코드를, 테스트 하기 쉬운 코드로 설계하는 감각(sense)  Plus Alpha : 한 단계 더 나아간 연습을 하고 싶다면?\n 컴파일 에러를 최소화하면서 리팩토링하기 ATDD 기반으로 응용 애플리케이션 개발하기 레거시 애플리케이션에 테스트 코드 추가해 리팩토링하기  : TDD, 리팩토링 연습을 위해 필요한 것은?\n 조급합 대신 마음의 여유 나만의 토이 프로젝트 같은 과제를 반복적으로 구현할 수 있는 인내력  마무리 : 하드웨어 비용보다 사람이 더 비싸기 때문에,\n사람이 읽기 좋은 코드를 만드는 것이 중요하다.\n질의응답 Q1. Comfort Zone을 극복하는 노하우는 무엇일까요?\nA1. 시간, 에너지가 있어야 한다. 이를 만들어야 한다.\n(농담) 친구와 여자친구를 만나는 빈도수를 줄여라.\n1-2년은 과도기가 필요하다.\nQ2. 요구사항이 변경되었을 때, 기존의 테스트 코드가 발목을 잡는 경우에 어떻게 해야 할까요?\nA2. 본인도 그런 경험을 많이 해봤다. 이는 요구사항의 변경이 문제가 아니라,\n테스트코드를 잘못 작성했을 경우, 설계가 잘못되었을 경우 발생하는 문제다.\n시간이 없으면, 할 수 있는 만큼만 하거나, 혹은 데드라인의 연장을 요구하자.\nReference 유튜브 링크\nSlide\n","permalink":"http://cjlee38.github.io/post/tech/btb/2020-09-27-tdd-by-jaesung_park/","summary":"본 포스팅은 자바지기 박재성님의 강의를 듣고 정리하면서 작성한 글입니다.\n발표 동영상과 슬라이드는 하단의 Reference를 참고해주세요.\n  의식적인 연습 : 단순히 반복적인 연습을 함으로써 실력 향상을 기대하기는 어렵다.\n\u0026ldquo;의식적인\u0026rdquo; 연습이 필요하다.\n의식적인 연습의 7가지 원칙.  효과적인 훈련 기법이 수립되어 있는 기술 연마 개인의 \u0026ldquo;컴포트 존\u0026quot;을 벗어난 지점에서 진행, 자신의 현재 능력을 살짝 넘어가는 작업을 지속적으로 시도 명확하고 구체적인 목표를 가지고 진행 신중하고 계획적이다. 즉, 개인이 온전히 집중하고 \u0026lsquo;의식적\u0026rsquo;으로 행동할 것을 요구 피드백과 피드백에 따른 행동 변경을 수반 효과적인 심적 표상을 만들어내는 한편으로 심적 표상에 의존 기존에 습득한 기술의 특정 부분을 집중적으로 개선함으로써 발전시키고 수정하는 과정을 수반.","title":"# 박재성 - 의식적인 연습으로 TDD, 리팩토링 연습하기"},{"content":"0. 들어가며 : Hash 라는 용어는 주로 암호학에서 많이 사용되지만,\n개발자라면 오며가며 한 번쯤은 주워 듣는 용어이기도 하다.\n특히, 블록체인을 한 번이라도 공부해봤다면,\nHash 라는 것이 이 블록체인의 핵심 기술 중 하나라는 것을 배웠을 것이다.\n동작 원리를 안다고 해도 복호화(Decryption)가 불가능하므로,\n암호학을 전공하지 않는 한 깊게 파고들 이유는 없다고 생각하지만,\n그렇다고 아예 모르는 것은 개발자에겐 죄악에 가까우므로,\n이번 포스팅을 통해 가볍게 혓바닥 한 번 대서 맛이라도 보자는 느낌으로 건드려보자.\n1. Hash 에 대한 이론 1) What is Hash? : Hash란, Hash 함수를 이용하여, \u0026ldquo;어떤 값을 넣더라도\u0026rdquo; 고정된 길이의 문자열로 바꿔버리는 것을 의미한다.\nWikipedia에서 설명하는 Hash 함수는 다음과 같이 설명하고 있다.\n  A hash function is any function that can be used to map data of arbitrary size to fixed-size values.\n  즉, 임의의 크기의 데이터가 고정된 크기의 값으로 mapping 시켜버리는 함수를 의미한다.\n극단적으로 쉬운 Hash function은, 짝홀수를 만드는 함수다.\n다음을 보자.\npublic int myHash(int value) {  int hashValue;  if (value % 2 == 0) {  hashValue = 0;  } else {  hashvalue = 1;  }  return hashValue; } 사실, 한 줄로도 작성할 수 있는 코드지만, 일부러 위와 같이 작성했다.\n각설하고, 위와 같은 코드가 하는 일은,\n입력된 숫자가 짝수면 0을, 홀수면 1을 return하는 것이다.이 myHash() 라는 hash 함수에,\n1을 집어넣든, 1억을 집어넣든, 1조를 집어넣든,\n결국 0 혹은 1의 고정된 값이 나온다.\n고정된 길이의 값을 출력하므로, 이 함수는 일단은 Hash 함수라고 이야기 할 수 있다.\n2) Hash 함수의 특징 : 이러한 Hash 함수는, 다음과 같은 특성을 가진다.\n 어떠한 값을 입력하더라도, **\u0026ldquo;고정된 길이\u0026rdquo;**의 값을 출력한다. 입력값이 조금이라도 바뀌면, 출력값은 달라진다. 복호화가 불가능하다.  여기서 핵심이라고 볼 수 있는 부분은 2번인데,\n주로 암호화 Hash의 경우, Hash 값만 같으면 본래의 값도\n동일하다고 취급하는 것이 주 목적이기 때문에,\n최대한 Hash 충돌이 일어나지 않도록 해야 한다.\n일례로, 강의를 들었을 때 교수님께서 재미난 비유를 하나 해주셨는데,\n책이 100만 권이 있는 도서관에서, 책의 내용이 단 한 글자라도\n바뀌었는지 알기 위해서는, 모든 책을 다 조사할 필요 없이\n책들의 내용을 Hash 값으로 보관해서 그것만 들고 있기만 한다면 된다는 이야기를 하셨다.\n물론, 바뀌었을 때 \u0026ldquo;어디가 바뀌었는지?\u0026rdquo; 에 대해서는 절대 알 수 없다.\n3) Hash 함수의 성질 : 또한, Hash 함수는 다음을 만족해야 한다.\n(정확히는, Cryptographic Hash. 즉 암호화 Hash는 다음을 만족해야 한다.)\n　1. 원상 회피(Pre-image resistance)\n 주어진 해시 값 h에 대해, 다음을 만족하는 메시지 m을 찾는 것은 불가능하다.  $$h = H(m)$$\n　2. 두 번째 원상 회피(Pre-image resistance)\n 주어진 메시지 m에 대해, 다음을 만족하는 또 다른 메시지 m\u0026rsquo;을 찾는 것은 불가능하다.  $$m \\neq m\u0026rsquo; 이면서 H(m) = H(m\u0026rsquo;)$$\n　3. 충돌 회피(Collision resistance)\n 다음을 만족하는 두 메시지 m과 m\u0026rsquo;를 찾는 것은 불가능하다.  $$m \\neq m\u0026rsquo; 이면서 H(m) = H(m\u0026rsquo;)$$\n말이 좀 어려우므로, 바꿔서 설명하면 다음과 같다\n Hash의 결과값을 보고, 본래의 값을 찾는 것은 어렵다. 입력값을 보고, 이 입력과 같은 해쉬값을 출력하는 다른 입력값을 찾는 것이 어렵다. Hash의 결과값이 같은 두 입력값을 찾는 것이 어려워야 한다. 즉, Hash 충돌에 안전해야 한다.  이 세 가지를 만족시켜야, 비로소 \u0026ldquo;진정한\u0026rdquo; 암호화 Hash 함수라고 일컬을 수 있다.\n아까 작성했던 짝홀수로 만든 Hash 함수를 보자.\n우리는 0 혹은 1이라는 값을 보고, 본래의 값이 무엇이었는지 알 수 없다. 따라서, 원상회피의 조건을 만족한다.\n두 번째로, 우리가 3이라는 값이 주어졌을 때, 5라는 값으로 바꿔 넣으면\n같은 Hash 값인 1이 출력된다는 것을 쉽게 알 수 있다.\n따라서, 짝홀수 Hash 함수는 두 번째 원상회피를 만족하지 못한다고 볼 수 있다.\n마찬가지로, 0 혹은 1이라는 결과값을 내뱉는 본래의 값은 1,3,5\u0026hellip; 임을 쉽게 알 수 있다.\n이는 충돌회피 또한 만족하지 못한다고 볼 수 있다.\n4) Hash 충돌 : 위 짝홀수 Hash 함수가 가장 대표적인 Hash 충돌의 예시가 된다.\n세상 모든 정수는 짝홀수로 구분할 수 있고, 따라서 Hash 값은 무조건 0 혹은 1이 된다.\n1과 3은 1이라는 같은 값을 출력하므로 충돌이고,\n1과 5 또한 1이라는 같은 값을 출력하므로 충돌이다.\n암호화 Hash 에서는 이 충돌을 막기 위해 다양하고 복잡한 방법을 사용한다.\n2. Hash에 기반한 공격과 수비 1) SHA-256 : 위 Hash 함수의 성질을 지키기 위해, 여러 Hash 알고리즘들이 고안되었다.\n당장, 해쉬 생성기 사이트로 이동해서,\n아무런 값이나 입력해보면\nF03B8A4D721D828D8C972CC84C023EA67022CE5D0F8E650FB59D22E4B187DA6E\n이러한 알 수 없는 숫자가 튀어나오는 것을 볼 수 있다.\n지금 예시로 보여준 Hash 값은 SHA-256의 결과인데, 이름처럼\n256 bit(64글자 * 16진수(4 bit)) 로 생성된 결과임을 알 수 있다.\n단순히 생각해보더라도, 256 bit 라면, 2256 이고,\n이는 지수표기법으로는\n1.1579208923731619542357098500869e+77\n이라는 말도안되게 거대한 숫자가 나온다.\n즉, 단순하게 생각하면 위 숫자의 개수만큼 데이터를 집어넣지 않는 이상, 충돌이 나지 않는다는 이야기다.\n(물론 비둘기집의 원리를 고려하면, 실제로는 그렇지 않겠지만)\n  여담으로, Firefox를 이용해서 학교 홈페이지에 로그인 해보니, Firefox의 비밀번호를 저장하겠냐는 질문과 함께 원본 데이터를 볼 수 있었다.\n숫자가 뭔가 낯이 익다 싶어서 보니 16진수인 것을 확인할 수 있었고,\n위 Hash 생성기에 내 비밀번호를 SHA-512에 넣어보니 같은 값임을 확인할 수 있었다.\n이 때, 정말 신기하면서도 \u0026ldquo;Hash \u0026hellip; 라서 괜찮겠지?\u0026rdquo; 하고 넘겼던 기억이 난다.\n  2) Rainbow Table : 결국, 이 Hash 함수는 복호화가 불가능하므로,\n있는대로 때려 맞춰보는 brute force 가 Hash 를 뚫는 기본적인 방법이 되시겠다.\n어떤 해커가, 철수라는 사람의 비밀번호의 Hash 값을 알아냈는데,\n이 원본 값을 찾기 위해 가능한 모든 입력값들을 다 때려박아서 비밀번호를 찾아냈다.\n그렇다면, 이 철수라는 사람과 같은 Hash 값을 갖고 있는\n다른 모~든 사람들의 원본 값도 다 똑같은 값일 것임은 자명하다.\n그렇다면, 모든 입력값과 모든 Hash 값을 다 저장해놓는다면 어떨까?\nHash 함수가 취약하다면, 어지간한 Hash의 원본 값은 다 찾을 수 있을 것이다.\n그리고, 매 번 찾을 필요가 없이, 그냥 새로운 해킹 대상이 들어올 때마다\n미리 저장해놓은 곳에서 Hash 값을 보고 원본 값을 찾아내서 입력하기만 하면 된다.\n이렇게 저장해놓은 Table을 Rainbow Table이라 한다.\n(실제로는 이보다 좀 더 복잡한 방식으로 저장한다고 한다.)\n3) Salting : Salting. 말 그대로 소금을 치는 것이다.\nRainbow Table에 맞서 나온 대응책이다.\n원리는 간단하다.\n만약 김철수가 \u0026ldquo;hello\u0026rdquo; 라는 값을 비밀번호로 저장하려고 했다면,\n거기에 \u0026ldquo;Kim\u0026rdquo; 이라는 값을 추가해서 Hash 함수를 적용한다.\n다음으로, 홍길동이 똑같이 \u0026ldquo;hello\u0026rdquo; 라는 값을 비밀번호로 저장하려고 했다면,\n거기에 \u0026ldquo;Hong\u0026rdquo; 이라는 값을 추가해서 Hash 함수를 적용한다.\n즉, \u0026ldquo;Kim\u0026rdquo; 혹은 \u0026ldquo;Hong\u0026rdquo; 이라는 소금을 치는 것이다.\n이렇게 하면, 같은 비밀번호를 사용하더라도 다른 Hash 값이 저장되고,\n\u0026ldquo;값이 조금이라도 달라지면 출력값은 완전히 달라지므로\u0026rdquo; Rainbow Table에 대응할 수 있게 된다.\n3. 마치며 : Hash에 대한 개념은, 암호학, 컴퓨터공학을 넘어서 IT에 발가락 하나라도 담그고 있는 사람이라면 반드시 알아야 하는 개념이라고 생각한다.\n나중에 정말 여유가 되면, 교수님께 배웠던 블록체인 시리즈도 꼭 다뤄보고 싶다.\nReference  한국외대 이병욱 교수님, 정보보안 강의교안. Hash function  ","permalink":"http://cjlee38.github.io/post/tech/btb/2020-09-25-what_is_hash/","summary":"0. 들어가며 : Hash 라는 용어는 주로 암호학에서 많이 사용되지만,\n개발자라면 오며가며 한 번쯤은 주워 듣는 용어이기도 하다.\n특히, 블록체인을 한 번이라도 공부해봤다면,\nHash 라는 것이 이 블록체인의 핵심 기술 중 하나라는 것을 배웠을 것이다.\n동작 원리를 안다고 해도 복호화(Decryption)가 불가능하므로,\n암호학을 전공하지 않는 한 깊게 파고들 이유는 없다고 생각하지만,\n그렇다고 아예 모르는 것은 개발자에겐 죄악에 가까우므로,\n이번 포스팅을 통해 가볍게 혓바닥 한 번 대서 맛이라도 보자는 느낌으로 건드려보자.\n1. Hash 에 대한 이론 1) What is Hash?","title":"# Hash 맛보기"},{"content":"doGet, doPost : 기존에는 Servlet에 코드를 작성할 때, service()만 사용하고,\nget과 post를 구분하지 않았었다. 당연히, get과 post를 구분하는 방법이 있을텐데, 우선적으로 생각할 수 있는 방법은\nif else 문으로 분기하는 것이다. 또한, 이에 걸맞은 method 도 존재한다.\nif (req.getMethod().equals(\u0026#34;GET\u0026#34;)) {  // do something for get } else if (req.getMethod().equals(\u0026#34;POST\u0026#34;)) {  // do something for post } 그러나, 이렇게 작성하는 것은 당연하게도 우아해보이지 않는다.\n이에 걸맞은 method가 있는데, 바로 doGet(), doPost() method 다.\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  //do something for get }  @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  // do something for post } 그렇다면, service() 함수와 어떤 관계를 가질까?\n우리가 작성한 Servlet이 상속받은 HttpServlet 클래스를 찾아가보면, 다음과 같은 코드를 볼 수 있다.\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  String method = req.getMethod();  long lastModified;  if (method.equals(\u0026#34;GET\u0026#34;)) {  lastModified = this.getLastModified(req);  if (lastModified == -1L) {  this.doGet(req, resp);  } else {  long ifModifiedSince = req.getDateHeader(\u0026#34;If-Modified-Since\u0026#34;);  if (ifModifiedSince \u0026lt; lastModified) {  this.maybeSetLastModified(resp, lastModified);  this.doGet(req, resp);  } else {  resp.setStatus(304);  }  }  } else if (method.equals(\u0026#34;HEAD\u0026#34;)) {  lastModified = this.getLastModified(req);  this.maybeSetLastModified(resp, lastModified);  this.doHead(req, resp);  } else if (method.equals(\u0026#34;POST\u0026#34;)) {  this.doPost(req, resp);  } else if (method.equals(\u0026#34;PUT\u0026#34;)) {  this.doPut(req, resp);  } else if (method.equals(\u0026#34;DELETE\u0026#34;)) {  this.doDelete(req, resp);  } else if (method.equals(\u0026#34;OPTIONS\u0026#34;)) {  this.doOptions(req, resp);  } else if (method.equals(\u0026#34;TRACE\u0026#34;)) {  this.doTrace(req, resp);  } else {  String errMsg = lStrings.getString(\u0026#34;http.method_not_implemented\u0026#34;);  Object[] errArgs = new Object[]{method};  errMsg = MessageFormat.format(errMsg, errArgs);  resp.sendError(501, errMsg);  }   } 자세한건 잘 알아보지 못하더라도,\n대충 각 http 방식에 걸맞는 do method를 실행하는 것을 볼 수 있다.\n따라서, 우리가 service() 함수를 작성하고,\n그 안에 **super.service(req, resp)**로\n부모 클래스인 HttpServlet의 service() 함수를 실행하면,\nservice() 함수가 일종의 \u0026ldquo;Filter\u0026rdquo; 역할을 해줄 수 있는 것이다.\n앞서 우리가 봤던 Servlet Filter는 특정 Path에 대해서 걸 수도 있지만,\n그보다 조금 더 좁은 개념으로 service() 함수를 활용할 수 있다.\nJSP with Jasper : 지금까지 학습했던 내용들은, JSP 가 아니라 단순히 Servlet을 만드는 과정이었다.\n따라서, HTML 문서는 나름대로 웹페이지로서의 기능을 할 수 있었지만, 대신 정적인 페이지일 뿐이었고,\nServlet으로 작성한 코드는 out.println() 과 같은, 소위 텍스트와 비슷한 결과물만을 볼 수 있었다.\n우리가 원하는 것은 이것이 아니다. WAS 를 사용하는 목적은, **\u0026ldquo;동적인 페이지\u0026rdquo;**를 만드는 것이다.\nout.println() 을 통해서도, 그 안에 태그를 붙여줌으로써 동적인 HTML 문서를 만들 수 있다.\n그러나, 그 모습은 다음과 같이 정말 괴랄하기 짝이 없다.\n@WebServlet(\u0026#34;/firstServlet\u0026#34;) public class firstServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  PrintWriter out = resp.getWriter();   out.write(\u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\u0026#34;);  out.write(\u0026#34;\u0026lt;html lang=\\\u0026#34;en\\\u0026#34;\u0026gt;\u0026#34;);  out.write(\u0026#34;\u0026lt;head\u0026gt;\u0026#34;);  out.write(\u0026#34;\u0026lt;meta charset=\\\u0026#34;UTF-8\\\u0026#34;\u0026gt;\u0026#34;);  out.write(\u0026#34;\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\u0026#34;);   // 중략   out.write(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;);  out.write(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;);  } } 이런 단순 반복 행위에 불과한 코드를 작성하는 행위는, 사람이 아니라 기계에게 맡기는 것이 어떨까?\n애초에 기계라는 것이 이러한 단순반복을 대신 수행하기 위해 등장한 것이니 말이다.\n이 때 바로 JSP 라는 것이 등장한다.\nJSP는 Java Server Page의 약자로서,\n이 JSP의 형태는 HTML에 Java Code를 작성할 수 있는 모습이다.\nJekyll 기반의 블로그를 운영하면서 배웠던, Liquid라는 문법이 하는 일과 굉장히 흡사한데,\n대신 Liquid는 Programming Language가 아니었지만, JSP는 Jasper라는 도구를 이용해\nJava 코드를 해석하고, 위 괴상한 코드를 자동으로 생성해줌으로써 최종적으로 Servlet의 구색을 갖출 수 있게 해준다.\n일례로, 다음과 같은 모습을 볼 수 있다.\n\u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;% for (int i=0; i\u0026lt;15; i++) { %\u0026gt; \u0026lt;body\u0026gt; hello world! \u0026lt;br/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;/html\u0026gt; {: .alignCenter}\n\u0026lt;% %\u0026gt; 이런식으로 생긴 녀석 (=코드블럭) 으로 코드를 감쌀 수 있다.\n이렇게 \u0026ldquo;이 문장은 HTML이 아닌 Java 코드다\u0026rdquo; 라는 것을 알려줌으로서,\nfor문을 15번을 반복시켜서 Hello world! 를 15번을 출력할 수 있다.\n이러한 JSP 코드의 문법은 다음과 같다.\n   이름 작성법 목적 예시     스크립트릿(Scriptlet) \u0026lt;% %\u0026gt; 일반적인 변수 할당 등의 script \u0026lt;% String name = \u0026ldquo;홍길동\u0026rdquo;; %\u0026gt;   선언문(Declarations) \u0026lt;%! %\u0026gt; 함수 선언 \u0026lt;%! public void someFunction() { \u0026hellip; } %\u0026gt;   지시자(Directivs) \u0026lt;%@ %\u0026gt; 라이브러리 임포트, 혹은 페이지 메타데이터 설정 \u0026lt;%@ page pageEncoding=\u0026ldquo;UTF-8\u0026rdquo; \u0026hellip; %\u0026gt;   표현식(Expressions) \u0026lt;%= %\u0026gt; Expression 출력 \u0026lt;%= someFunction() %\u0026gt; 입니다.(태그 내)    위에서 실행한 JSP 파일이, 어떻게 Jasper에 의해 .java 파일로 변환되었는지 살펴보자.\n(설정이 꼬였는지, 정확히 위 파일이 존재하지는 않고, 이전 포스팅에서 작성했던 index.jsp를 살펴볼 수 있었다.)\n// 윗부분 생략 try {  response.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;);  pageContext = _jspxFactory.getPageContext(this, request, response,  null, true, 8192, true);  _jspx_page_context = pageContext;  application = pageContext.getServletContext();  config = pageContext.getServletConfig();  session = pageContext.getSession();  out = pageContext.getOut();  _jspx_out = out;   out.write(\u0026#34;\\r\\n\u0026#34;);  out.write(\u0026#34;\\r\\n\u0026#34;);  out.write(\u0026#34;\u0026lt;html\u0026gt;\\r\\n\u0026#34;);  out.write(\u0026#34;\u0026lt;head\u0026gt;\\r\\n\u0026#34;);  out.write(\u0026#34; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\\r\\n\u0026#34;);  out.write(\u0026#34;\u0026lt;/head\u0026gt;\\r\\n\u0026#34;);  out.write(\u0026#34;\u0026lt;body\u0026gt;\\r\\n\u0026#34;);  out.write(\u0026#34;\\r\\n\u0026#34;);  out.write(\u0026#34; This is index!\\r\\n\u0026#34;);  out.write(\u0026#34;\u0026lt;/body\u0026gt;\\r\\n\u0026#34;);  out.write(\u0026#34;\u0026lt;/html\u0026gt;\\r\\n\u0026#34;);  } catch (java.lang.Throwable t) {  if (!(t instanceof javax.servlet.jsp.SkipPageException)){  out = _jspx_out;  if (out != null \u0026amp;\u0026amp; out.getBufferSize() != 0)  try {  if (response.isCommitted()) {  out.flush();  } else {  out.clearBuffer();  }  } catch (java.io.IOException e) {}  if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);  else throw new ServletException(t);  }  } finally {  _jspxFactory.releasePageContext(_jspx_page_context);  } 그러나, 이렇게 JSP 파일에 몰아서 작성했을 경우 발생할 수 있는 단점은, JSP 코드 자체가 급격하게 보기에 나빠진다는 것이다.\n작성된 JSP 또한 결국 jasper에 의해 Servlet으로 변환되므로,\n기존에 Servlet에서 사용하던 여러 변수 (e.g. Parameter로 넘겨받은 HttpServletRequest req) 들을 사용할 수 있는데,\nloop 문이라던지, 각 변수마다 \u0026lt;%= request.getAttribute(\u0026quot;something\u0026quot;) %\u0026gt; 를 작성하게 되면\n보기도 좋지 않고, 유지보수하기도 힘들 것이 분명하다.\n따라서, 다음 포스팅에 이야기할 MVC model 1, 그리고 model 2가 등장하게 되는데,\n일단 거기에 앞서 EL, Expression Langauge에 대해서 잠깐 짚고 가자.\nEL (Expression Language) : 다음 포스팅에서 작성할 MVC model에 대해서 이해하고 나면, 이 EL이 왜 쓰이는지 더더욱 명확하게 알 수 있다.\nEL은, 흡사 Javascript의 Template Literal과 비슷하게 생겼는데,\n이런식으로 작성한다.\n${something} 그냥 저렇게 작성하는 것만으로, \u0026lt;%= request.getAttribute(\u0026quot;something\u0026quot;) %\u0026gt; 를 대체할 수 있다.\nEL 문법을 정리하면, 다음과 같다.\n사용법    Data Type JSP EL     Primitive request.getAttribute(\u0026ldquo;value\u0026rdquo;); ${value}   Array(or list) request.getAttribute(\u0026ldquo;list\u0026rdquo;).get(0); ${list[0]}   Map request.getAttribute(\u0026ldquo;map\u0026rdquo;).get(\u0026ldquo;key\u0026rdquo;) ${map.key} 혹은 ${map[\u0026ldquo;key\u0026rdquo;]}    변수 탐색 범위 : pageContext Scope -\u0026gt; request Scope -\u0026gt; session Scope -\u0026gt; application Scope (다음 포스팅에서 설명)\n연산자 : 파이썬과 겹치는 부분이 좀 있다.\n   연산자 구분 기호 EL     비교연산자 \u0026gt; gt(greater than)   비교연산자 \u0026lt; lt(less than)   비교연산자 \u0026gt;= ge(greater or equal)   비교연산자 \u0026lt;= le(less or equal)   산술연산자 / div(divide)   산술연산자 % mod(modulo)   관계연산자 == eq(equal)   관계연산자 != ne(not equal)   논리연산자 \u0026amp;\u0026amp; and   논리연산자 ││ or   부호연산자 ! not   - - empty (isEmpty())    반드시 EL 연산자로 작성할 필요는 없지만,\n문제가 생길 것을 대비해(e.g. \u0026lsquo;\u0026lt;\u0026rsquo;,\u0026rsquo;\u0026gt;\u0026rsquo; 기호가 Tag로 인식된다던지),\nEL 연산자로 작성하는 것을 권장한다.\n","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-09-25-jsp_learning_06/","summary":"doGet, doPost : 기존에는 Servlet에 코드를 작성할 때, service()만 사용하고,\nget과 post를 구분하지 않았었다. 당연히, get과 post를 구분하는 방법이 있을텐데, 우선적으로 생각할 수 있는 방법은\nif else 문으로 분기하는 것이다. 또한, 이에 걸맞은 method 도 존재한다.\nif (req.getMethod().equals(\u0026#34;GET\u0026#34;)) {  // do something for get } else if (req.getMethod().equals(\u0026#34;POST\u0026#34;)) {  // do something for post } 그러나, 이렇게 작성하는 것은 당연하게도 우아해보이지 않는다.\n이에 걸맞은 method가 있는데, 바로 doGet(), doPost() method 다.","title":"# 6. JSP 학습기록 - doGet, doPost와 JSP, 그리고 EL(Expression Language) "},{"content":"0. 들어가며 : 코드를 작성하다보면 한번쯤은, 그런 생각을 해본다.\n물론, Key-Value 를 갖는 Java의 Hashmap, Python의 Dictionary가 있지만,\n때로는 편의성 때문에 변수명 자체가 그 값에 의해서 자동으로 선언될 수 있으면 좋겠다는 생각을 해본다.\n이럴때, Python에서는 eval() 혹은 exec() 이라는 내장함수를 이용해볼 수 있는데,\n쓰다보면 expression과 statement 라는 용어가 등장한다.\n생각해보니, expression 이라는 단어도, statement라는 단어도, 둘 다 한 번쯤은\n어디선가 들어본 용어인데, 갑자기 두 개의 차이가 있다고 하니 당혹스러울 수 밖에 없다.\n오늘은 이 두 용어의 차이에 대해서 알아보고자 한다.\n1. eval()과 exec() eval() : 먼저, 다음의 코드를 보자.\na = 1 print(\u0026#34;eval\u0026#34;) print(eval(\u0026#34;a\u0026#34;)) # -\u0026gt; eval # -\u0026gt; 1 eval() 함수 안에, \u0026ldquo;a\u0026quot;라는 string을 넣었더니 변수 a에 해당하는 값이 튀어나오고,\nprint() 함수는 이를 받아서 1이라는 값을 실행하는 모습을 볼 수 있다.\n그렇다면, a=2로 바꿀수도 있을까?\na = 1 print(\u0026#34;eval\u0026#34;) print(eval(\u0026#34;a=2\u0026#34;)) # -\u0026gt; eval # -\u0026gt; SyntaxError : invalid synatx 문법이 잘못 작성되었다고, SyntaxError가 튀어나오는 모습을 볼 수 있다.\n즉, 우리는 print(a=1) 이라고 작성한 셈이다.\nexec() : 그렇다면, exec()은 어떨까?\na = 1 print(\u0026#34;exec\u0026#34;) print(exec(\u0026#34;a\u0026#34;)) # -\u0026gt; exec # -\u0026gt; None 보는바와 같이, exec(\u0026ldquo;a\u0026rdquo;) 의 결과로는 아무것도 반환되지 않는다.\n그렇다면, 마찬가지로 a=2 는 어떨까?\na = 1 print(\u0026#34;exec\u0026#34;) print(exec(\u0026#34;a=2\u0026#34;)) print(a) # -\u0026gt; exec # -\u0026gt; None # -\u0026gt; 2 이번에는 다르다. 역시 exec()의 return값은 존재하지 않았지만,\na가 2로 변경된 것을 볼 수 있다.\nWhat\u0026rsquo;s the difference? : 왜 이런 차이가 발생하는 것일까? help()함수를 통해 두 함수를 확인해보자.\n  eval()\nHelp on built-in function eval in module builtins:\neval(source, globals=None, locals=None, /)\nEvaluate the given source in the context of globals and locals.\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.\n   exec() Help on built-in function exec in module builtins:\nexec(source, globals=None, locals=None, /)\nExecute the given source in the context of globals and locals.\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.\n  두 함수에 대한 설명은 거의 유사하다.\n그런데, eval() 함수는 \u0026ldquo;Expression\u0026quot;을, exec() 함수는 \u0026ldquo;statements\u0026quot;를 받는다는 것을 알 수 있다.\n다시 위 코드로 돌아가서,\neval()과 exec()이 의도한 대로 실행된 경우는,\neval()은 eval(\u0026quot;a\u0026quot;) 를 작성했던 경우고,\nexec()은 exec(\u0026quot;a=2\u0026quot;) 를 작성했던 경우다.\n만약 Python에서 단순하게 a 라고 작성한다면, print()가 아닌 output에 변수 a의 값이 튀어나오고,\na=2 라고 작성한다면, output은 없지만 a가 2로 변경된다.\n따라서, 우리는 \u0026ldquo;아, a와 같이 output이 있으면 expression이고,\na=2와 같이 output이 없는, 값의 변경과 같은 경우라면 statement 구나\u0026rdquo; 라고 유추해볼 수 있다.\n2. Expression \u0026amp; Statement Difference between expression and statement : 이 가설을 검증하기 위해, 구선생님께 여쭤본 결과는 다음과 같다.\n In programming language terminology, an “expression” is a combination of values and functions that are combined and interpreted by the compiler to create a new value, as opposed to a “statement” which is just a standalone unit of execution and doesn’t return anything. One way to think of this is that the purpose of an expression is to create a value (with some possible side-effects), while the sole purpose of a statement is to have side-effects.\n 짧은 번역 실력으로 해석해보면, 다음과 같다.\n 프로그래밍 언어의 용어 중에서, epxression은 값 또는 함수의 조합으로서, 새로운 값을 만들기 위해 컴파일러에 의해 조합되거나 해석된다. 반면, statemnet는 독립적인 실행의 단위이며, 아무것도 return 하지 않는다. expression은 새로운 값을 만드는 것이 목적이고(side-effect가 있을 수 있다), statement는 side-effect를 갖는 것 자체가 목적이라고 생각해볼 수 있다.\n 즉, 우리가 변수 a를 그대로 파이썬에 작성해서 넣으면, output으로 변수 a에 해당하는 값이 튀어나온다.\n혹은, 1+2 라고 작성하면, 3이라는 값이 튀어나온다. 이런식으로, \u0026ldquo;새로운 값\u0026quot;을 만드는 것이 expression이다.\n반대로, a=1 과 같이 작성하면, 아무것도 return되는 것이 없지만, a에는 1이라는 값이 할당된다.\n다시 말해, side-effect가 생긴다.\nAre they exclusive? : 이렇게보면 expression과 statement는 서로 배타적인 관계라고 생각할 수 있지만,\n사실은 statement가 expression의 superset이다.\n아까의 코드로 다시 돌아가서 보면,\nprint(eval(\u0026quot;a=2\u0026quot;)) 는 에러를 내뱉은 반면,\nprint(exec(\u0026quot;a\u0026quot;)) 는 아무것도 return되지 않을지언정, 에러가 발생하지는 않았다.\n즉, 다시 말해서,\n모든 expression은 statement지만, 모든 statement가 expression은 아니다. 라는 것을 알 수 있다.\n3. Usage : 이렇게까지 알았다면, 우리는 이제 동적으로 변수명을 정할수도 있다.\nsome_json = {  \u0026#34;0\u0026#34; : {  \u0026#34;title\u0026#34; : \u0026#34;some_title\u0026#34;,  \u0026#34;content\u0026#34; : \u0026#34;some_content\u0026#34;  },  \u0026#34;1\u0026#34; : {  \u0026#34;title\u0026#34; : \u0026#34;some_second_title\u0026#34;,  \u0026#34;content\u0026#34;: \u0026#34;some_second_content\u0026#34;  } }  for v in some_json:  title = some_json[v][\u0026#39;title\u0026#39;]  content = some_json[v][\u0026#39;content\u0026#39;]  exec(f\u0026#34;{title}=content\u0026#34;)  print(some_title) # -\u0026gt; some_content print(some_second_title) # -\u0026gt; some_second_content 위의 코드에서, exec() 함수 내부를 보면,\ntitle이라는 변수 안에는 some_title 혹은 some_second_title 이 들어있으므로,\n최종적으로는 exec(\u0026ldquo;some_title=some_content\u0026rdquo;) 혹은 exec(\u0026ldquo;some_second_title=some_second_content\u0026rdquo;) 가 실행된다.\n4. 의문점 : if문을 영어로 검색하게되면, \u0026ldquo;if statement\u0026rdquo; 라고 하는데,\n역시 생각해보면, if문의 결과는 어떤 return 값이 주어지지 않으므로, statement 라고 하는 것은 타당하다.\n그런데, 지난 Java Hasmap으로의 여행 편을 읽어보면,\n이러한 작성법을 볼 수 있다. (혹은, C 계열 언어를 자주 쓰는 사람은 이런 작성법도 종종 볼 수 있을 것이다.)\nif ((tab = table) == null || (n = tab.length) == 0) tab=table 을 실행하면, 이는 expression이 아닌 statement이므로, null일텐데,\n이를 어떻게 비교할 수 있는 것일까?\nPython에서 또한, 다음과 같이 작성하는 것은 허용되지 않는다\nif (a=someFunc()) == 1:  # do something PEP 572 에서, python 3.8 이후로,\nNamed Expression 이라는 이름으로 := 를 이용해서 이런 작성 방법이 허용되지만,\njava에서 위와 같이 사용하는게 허락되는 것이 어떻게 가능한건지 잘 이해가 되지 않는다.\n나중에 여유가 되면 disassemble 이라도 해봐야 하나..\nReference  Expressions vs. statements 코드 단위인 Expression과 Statement의 차이를 알아보자  ","permalink":"http://cjlee38.github.io/post/tech/btb/2020-09-25-expression_and_statement/","summary":"0. 들어가며 : 코드를 작성하다보면 한번쯤은, 그런 생각을 해본다.\n물론, Key-Value 를 갖는 Java의 Hashmap, Python의 Dictionary가 있지만,\n때로는 편의성 때문에 변수명 자체가 그 값에 의해서 자동으로 선언될 수 있으면 좋겠다는 생각을 해본다.\n이럴때, Python에서는 eval() 혹은 exec() 이라는 내장함수를 이용해볼 수 있는데,\n쓰다보면 expression과 statement 라는 용어가 등장한다.\n생각해보니, expression 이라는 단어도, statement라는 단어도, 둘 다 한 번쯤은\n어디선가 들어본 용어인데, 갑자기 두 개의 차이가 있다고 하니 당혹스러울 수 밖에 없다.","title":"# Expression과 Statement의 차이 ( feat. Python, Java )"},{"content":"문제 링크\nPROBLEM : 문제 설명\nLeo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.\nLeo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.\nLeo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n제한사항\n갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.\n입출력 예\n   brown yellow return     10 2 [4, 3]   8 1 [3, 3]   24 24 [8, 6]    SOLVE : 문제를 해결하는 방법은, 두 가지가 있을 것으로 보였다.\n 방정식을 통해 해결하는 방법 약수를 구해 해결하는 방법.  1) 약수 이용 문제가 완전 탐색이니 이는 방정식의 방법은 나중으로 미뤄두고,\n약수를 통해 구하는 방법을 먼저 고민해봤다.\n입출력 예를 보면, brown+yellow = width*height 임을 알 수 있다.\n따라서, brown+yellow 를 나누었을 때 0이 남는, 즉 약수를 이용하면 될 것으로 보였다.\n이 때, brown 10, yellow 2, 즉 합이 12일 때를 생각해보면,\n생성될 수 있는 약수는 (1, 12), (2, 6), (3, 4), (4, 3), (6, 2), (12, 1) 이 된다.\n카펫의 가로 길이는 세로 길이와 같거나, 더 길다고 하였으므로,\n대충 반 잘라내서 (4, 3), (6, 2), (12, 1) 중 하나를 골라야 한다.\n물론, width 혹은 height는 최소 3 이상이므로\n(yellow의 최소 값인 1일때, brown은 8개 이고, 따라서 width가 되었든, height가 되었든 최소 3 이상이어야 한다.)\n이에 근거해 2와 1을 포함하고 있는 (6, 2), (12, 1)을 쳐낼 수도 있지만,\n카펫이 좀 넓어진다면, 이러한 방법론은 절대 통하지 않을 것으로 보였다.\n그러나, 고민을 하던 중 하나의 패턴을 발견했는데,\n약수의 합이 최소가 되는 순간이 답이 될 것으로 보였다.\npublic static int solution2(int brown, int yellow) {  int sum = brown+yellow;  int xySum = Integer.MAX_VALUE;  int x;  int y;  for(int i=(sum/2)-1; i\u0026gt;3; i--) {  if (sum%i == 0 \u0026amp;\u0026amp; i+(sum/i) \u0026lt; xySum) {  x = i;  y = (sum/i);  xySum = i+(sum/i);  }  }   if (x \u0026lt; y) {  int tmp = x;  x = y;  y = tmp;  }   int[] answer = {x, y};  return answer;  } 신나서 후다닥 대충 쓰고 제출했는데,\n4, 6, 7 번을 통과하지 못했다.\n한참을 고민하다가, 결국 질문하기 탭에서 다음과 같은 글을 보았다.\n{: .alignCenter}\n이걸 보고, 생각을 해보니, 50+22인 72의 약수 중, 합이 최소가 되는 값은 **(9, 8)**이고,\n9*8의 brown은 절대로 50이 될 수 없다는 사실을 깨닫게 되었다.\nShit\u0026hellip;\n차분하게, brown = (width * 2) + (height * 2) - 4 를 상기하면서\n코드를 다시 작성하였다.\npublic static int[] solution(int brown, int yellow) {  int x = -1;  int y = -1;  int sum = brown+yellow;   for (int i=1; i\u0026lt;sum; i++) {  if (sum%i == 0 \u0026amp;\u0026amp; (i*2) + ((sum/i)*2) - 4 == brown) {  x = i;  y = sum/i;  break;  }  }   return new int[]{Math.max(x, y), Math.min(x, y)};  } sum%i 가 0 이라면, i와 sum/i 는 당연히 sum의 약수가 된다.\n그 약수 중에서도,\n*(i*2) + ((sum/i)2) - 4 == brown 즉\nbrown = (width * 2) + (height * 2) - 4 를 만족하는 조건문을 추가하였다.\n2) 방정식 이용. : 이 또한, 질문하기 탭의 다른 분의 도움을 받았다.\n기본적으로, 다음과 같은 식 두개를 구할 수 있다.\nw = width, h = height, b = brown, y = yellow\n$$w+h = (b+4) / 2$$\n$$wh = b+y$$\n이를 다음과 같이 이차 방정식으로 유도해낼 수 있다. 여기서, 보기가 별로 안좋으니\n(b+4)/2 는 X로,\nb+y 는 Y로 치환하자.\n$$w = X - h$$\n$$ h*(X - h) = Y$$\n$$ h^2 - hX + Y = 0$$\n여기서 근의 공식을 이용하면,\n$$ width = (X + \\sqrt{X^2 + 41Y}) / 2 $$\n$$ height = (X + \\sqrt{X^2 - 41Y}) / 2 $$\n풀어서 쓰면, 다음과 같다.\n$$ width = (((b+4)/2) + \\sqrt{((b+4)/2)^2 + 41(b+y)}) / 2 $$\n$$ height = (((b+4)/2) + \\sqrt{((b+4)/2)^2 - 41(b+y)}) / 2 $$\n코드는 다음과 같다.\npublic static int[] solution(int brown, int yellow) {  int term = (int) Math.sqrt(Math.pow((brown+4),2) /4 - 4 * (brown + yellow));  int w = ((brown + 4) / 2 + term) / 2;  int h = ((brown + 4) / 2 - term) / 2;   return new int[]{w, h};  } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-23-problem_solving_9/","summary":"문제 링크\nPROBLEM : 문제 설명\nLeo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.\nLeo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.\nLeo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n제한사항","title":"# 프로그래머스[Lv.2] - 카펫 ( java )"},{"content":"배열 다루기. : 원래 이번 편에서 곧바로 Application / Session / Cookie 에 대해서 다루려고 했는데,\n생각해보니 데이터를 배열로 주고 받는 법에 대해서 다루지 않아서, 잠깐 짚고 가자.\n지난 편에서 다뤘던 firstServlet.html은 다음과 같다.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;  \u0026lt;form action=\u0026#34;firstServlet\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your title \u0026lt;/label\u0026gt;  \u0026lt;input name = \u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your title \u0026lt;/label\u0026gt;  \u0026lt;input name = \u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your content \u0026lt;/label\u0026gt;  \u0026lt;textarea name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;click here to submit\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 여기서, 대충 title을 두 개를 넣고 싶다고 해보자.\n소제목으로 구분하자 뭐 이런게 아니라,\n그냥 말 그대로 똑같은 title이라는 input을 하나 더 추가해보자는 것이다.\n간단하게,\n\u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your title \u0026lt;/label\u0026gt;  \u0026lt;input name = \u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; 요 코드를 복사해서 그 바로 밑에 붙여넣으면 된다.\n그러면, firstServlet에서 첫 번째 title을 받을까, 두 번째 title을 받을까 ?\n이 질문에 대한 내 대답은 \u0026ldquo;배열로 받으면 되지, 왜 그걸 고민해\u0026rdquo; 이다.\n기존의 req.getParameter(\u0026quot;title\u0026quot;); 에서, 6글자만 추가하면 된다.\nreq.getParameterValues()\n그러면, 여러개의 Parameter가 넘어오므로, String의 배열로 받아주고,\n이를 for문을 돌려서 출력해보자.\n코드는 다음과 같다.\n@WebServlet(\u0026#34;/firstServlet\u0026#34;) public class firstServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  PrintWriter out = resp.getWriter();   String[] title = req.getParameterValues(\u0026#34;title\u0026#34;);  String content = req.getParameter(\u0026#34;content\u0026#34;);   for (int i=0; i\u0026lt;title.length; i++) {  out.println(i + \u0026#34; 번째 타이틀 : \u0026#34; + title);  }   out.println(\u0026#34;컨텐츠 : \u0026#34; + content);  } } 그리고, localhost:8080/firstServlet.html 로 들어가서 대충 작성해보자.\n {: .alignCenter}\n {: .alignCenter}\n 잘 동작하는 모습을 볼 수 있다.\nApplication, Session, Cookie 이론 : Application, Session, Cookie 는 셋 모두\n어떤 상태를 유지하기 위하여,\n다시 말해 \u0026ldquo;데이터를 보존하기 위해서\u0026rdquo; 사용한다. 그러나, 같은 목적을 가지고 있더라도, 다른 방법을 지향하기 때문에, 상황에 따라 적절히 사용해야 한다.\n    Application Session Cookie     사용범위 전역 범위 *세션 범위 특정 URL 범위(여러 개 가능)   생명주기 WAS의 시작\u0026amp;종료와 함께 세션의 시작\u0026amp;종료와 함께 TimeOut까지   저장위치 WAS 메모리 WAS의 메모리 Client의 Memory 혹은 File    *세션 범위 : 특정 사용자만 사용할 수 있는 범위\n가령, Cookie 같은 경우, 데이터가 Client에게 저장되어 있기 때문에,\nClient가 악의적인 목적으로 이를 수정하는 것을 막기 위해,\nApplication 혹은 Session을 활용해야 한다.\n혹은, 오랫동안 갖고 있어야 할 (중요치 않은) 어떤 Data가 있다면, 이는 Cookie로 저장해야지,\nSession이나 Application에 갖고 있다면 감당하지 못할 것이다.\n또한, 어떤 Data를 Application 으로 설정했을 경우,\n다른 사용자가 접속했을 때 해당 Data를 볼 수 있으므로, 이러한 경우를 방지하기 위해\nSession을 사용해야 한다.\n비유하자면, Application은 전역변수고, Session은 지역변수라고 볼 수 있다.\n  Note. 위 개념을 잡기 위해, 얄코님의 영상에 큰 도움을 받았다.\n헷갈리는 사람은 이를 참고하자.\n  활용 Application : Application을 사용하려면, 다음과 같이 작성하면 된다.\nServletContext app = req.getServletContext(); 그리고, HashMap의 put을 사용하는 것처럼, 다음과 같이 사용하면 된다.\napp.setAttribute(\u0026#34;value\u0026#34;, someValue); Session : Session 또한, Application과 비슷하다.\nHttpSession session = req.getSession(); session.setAttribute(\u0026#34;value\u0026#34;, somevalue); Cookie : Cookie는 위 두가지와 약간 궤를 달리하기 때문에, 사용법 또한 조금 다르다. 단순히 put()만 해주면 안되고, 쿠키 객체를 만들어서 이를 resp에 덧붙여줘야 한다.\n// 기존 Cookie 읽기 Cookie[] cookies = req.getCookies();  // Cookie 만들어서 추가하기 Cookie cookie = new Cookie(\u0026#34;value\u0026#34;, someValue) // key value resp.addCookie(cookie);  // Cookie 경로 설정 cookie.setPath(\u0026#34;/\u0026#34;); // 모든 Path cookie.setPath(\u0026#34;/firstServlet\u0026#34;); // firstServlet 이 포함된 Path 전부 다 하기엔 시간적 여유가 없으니,\nCookie만 다뤄보자.\n예상 Flow는 다음과 같다.\n localhost:8080/firstServlet.html에서 입력받은 Title Array를, 각각 Title_1, Title_2 라고 이름 붙여서 쿠키에 추가한다. lolcahost:8080/firstServlet 페이지에서, 쿠키를 확인한다. Path는 \u0026ldquo;/firstServlet\u0026rdquo; 으로 정한다. 따라서, 캐시된 쿠키를 지우고 다른 페이지를 가면 쿠키가 없어야 한다.  firstServlet.java\n@WebServlet(\u0026#34;/firstServlet\u0026#34;) public class firstServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  PrintWriter out = resp.getWriter();   String[] title = req.getParameterValues(\u0026#34;title\u0026#34;);  String content = req.getParameter(\u0026#34;content\u0026#34;);   for (int i=0; i\u0026lt;title.length; i++) {  out.println(i + \u0026#34; 번째 타이틀 : \u0026#34; + title[i]);  }   Cookie cookie_1 = new Cookie(\u0026#34;Title_1\u0026#34;, title[0]);  Cookie cookie_2 = new Cookie(\u0026#34;Title_2\u0026#34;, title[1]);   cookie_1.setPath(\u0026#34;/firstServlet\u0026#34;);  cookie_2.setPath(\u0026#34;/firstServlet\u0026#34;);   resp.addCookie(cookie_1);  resp.addCookie(cookie_2);  } } {: .alignCenter}\n먼저, 정상적으로 작동하는 모습을 볼 수 있다. 캐시된 쿠키를 지우고 루트 페이지로 가보자.\n{: .alignCenter}\n아무리 새로고침을 해봐도 쿠키는 들어오지 않는다.\n","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-09-22-jsp_learning_05/","summary":"배열 다루기. : 원래 이번 편에서 곧바로 Application / Session / Cookie 에 대해서 다루려고 했는데,\n생각해보니 데이터를 배열로 주고 받는 법에 대해서 다루지 않아서, 잠깐 짚고 가자.\n지난 편에서 다뤘던 firstServlet.html은 다음과 같다.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;  \u0026lt;form action=\u0026#34;firstServlet\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your title \u0026lt;/label\u0026gt;  \u0026lt;input name = \u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your title \u0026lt;/label\u0026gt;  \u0026lt;input name = \u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your content \u0026lt;/label\u0026gt;  \u0026lt;textarea name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;click here to submit\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 여기서, 대충 title을 두 개를 넣고 싶다고 해보자.","title":"# 5. JSP 학습기록 - Array 와 Application, Session, Cookie"},{"content":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n지난 Stack편 에 이어집니다.\n1. 이론 편 : Queue는, 편의점의 냉장고를 생각하면 된다.\n편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.\n창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다.\n즉, A,B,C,D 를 넣으면, 편의점 손님이 이것을 꺼낼 때도 A,B,C,D 순서로 꺼낸다.\n이를, FIFO(First in, First out)(선입선출) 라고 한다.\n2. 구현 편 - ADT : Queue의 ADT는 다음과 같다.\n init()  Queue의 초기화를 진행 Queue 생성 후, 가장 먼저 호출되어야 하는 함수   size()  해당 Queue에 데이터가 몇 개 쌓여 있는지 확인.   isEmpty()  해당 Queue가 비어 있는가를 확인. 비었으면 true, 아니면 false를 반환.   enqueue(data)  Queue에 데이터를 저장. 당연히, 가장 마지막에 저장한다.   dequeue()  Queue에 있는 데이터를 반환 꺼낸 데이터는 Queue에서 삭제한다. 역시 당연히, 가장 오래된 데이터를 꺼낸다. Queue에 데이터가 최소 하나는 있어야 한다.   peek()  Queue에 있는 데이터를 반환. 꺼낸 데이터는 삭제하지 않는다. 물론 역시 당연히, 가장 오래된 데이터를 꺼낸다. Queue에 데이터가 최소 하나는 있어야 한다.    3. 구현 편 - Code : 역시, Queue 또한, LinkedList로 구현한다.\n  Note. 구현에 앞서\nStack과 달리, Queue에서 앞, 뒤를 구분하는 것은 헷갈린다.\nFront와 Rear로 표현하는 사람도 있고, Head와 Tail로 표현하는 사람도 있다.\n우리가 구현하는 큐는, 다음과 같은 그림을 갖고 있다고 생각하고 보자.\n {: .alignCenter}\n Stack과 마찬가지로, 구조체부터 만들자.\ntypedef struct Queue {  int size;  struct Node* head;  struct Node* tail; }Queue;  typedef struct Node {  int data;  struct Node* prev; }Node; 지난 Stack 구조체에 비해서, 추가 된 것은 tail 하나다.\nStack에서는 최상단의 대상만 삭제하고, 추가했지만,\nQueue에서는 추가할 때는 Tail, 삭제할 때는 Head를 이용할 것이므로,\nHead와 Tail이 둘다 필요하다.\n다음으로, Init() 함수는 다음과 같다.\nvoid QInit(Queue *pqueue) {  pqueue-\u0026gt;size = 0;  pqueue-\u0026gt;head = NULL;  pqueue-\u0026gt;tail = NULL; } 역시, size는 0으로, head와 tail은 모두 NULL로 우선 초기화 해준다.\nint QSize(Queue *pqueue) {  return pqueue-\u0026gt;size; }  int QIsEmpty(Queue *pqueue) {  if (pqueue-\u0026gt;size == 0) { // if (Qsize(pqueue) == 0) 으로 대체해도 무방.  return 1;  } else {  return 0;  } } QSize()와 QIsEmpty() 또한 간단하다.\nIsEmpty() 그대로, 비어 있는지를 묻고 있으므로,\n비어 있다면, 즉 size가 0 이라면 참인 1을,\n비어 있지 않다면 거짓인 0을 return 하면 된다.\n다음으로, 핵심이 되는 Enqueue()와 Dequeue() 작업이다.\nvoid QEnqueue(Queue *pqueue, int data) {  Node* newNode = (Node*)malloc(sizeof(Node));  newNode-\u0026gt;data = data;  newNode-\u0026gt;prev = NULL;   if(QIsEmpty(pqueue)) {  pqueue-\u0026gt;head = newNode;  } else {  pqueue-\u0026gt;tail-\u0026gt;prev = newNode; // 그림 1번  }  pqueue-\u0026gt;tail = newNode; // 그림 2번  pqueue-\u0026gt;size++; } {: .alignCenter}\n만약, 처음으로 데이터를 넣는 것이라면, pqueue의 head와 tail은 둘다 newNode를 가리킨다.\n그러나, 두 번째부터는, 조금 다르다.\n원래 tail이 가리키고 있던 Node가 갖고있는 prev 포인터를, 새로운 Node인 newNode를 가리키게 한다.(그림의 1번)\n그리고, Tail은 새로운 Node인 newNode를 가리킨다. (그림의 2번)\n그리고, pqueue가 갖고 있는 size라는 속성을 하나 증가시킨다.\nint QDequeue(Queue *pqueue) {  int data = pqueue-\u0026gt;head-\u0026gt;data;   Node* delNode = pqueue-\u0026gt;head;  pqueue-\u0026gt;head = pqueue-\u0026gt;head-\u0026gt;prev;  free(delNode);   pqueue-\u0026gt;size--;   return data; } {: .alignCenter}\n삭제를 하는 경우는, stack과 같다.\n가장 먼저, pqueue-\u0026gt;head 의 Node가 갖고 있는 data를 int data에 저장한다.\n그리고, delNode가 pqueue의 head를 가리키게 하고(그림의 1번)\npqueue head는 하나 이전의 요소(prev)를 가리키게 한다.(그림의 2번)\n마지막으로, free(delNode)를 통해, delNode가 가리키는 요소를 삭제하게 하면 된다.\n이후, pstack의 data를 하나 감소시키고, data를 return 해주면 된다.\n마지막으로, peek() 또한 stack과 같다\nint QPeek(Queue *pqueue) {  return pqueue-\u0026gt;head-\u0026gt;data; } 역시, 잘 돌아가는지 한번 테스트 해보자.\nint main() {  Queue queue;  QInit(\u0026amp;queue);   QEnqueue(\u0026amp;queue, 3);  QEnqueue(\u0026amp;queue, 5);  QEnqueue(\u0026amp;queue, 4);  QEnqueue(\u0026amp;queue, 1);   printf(\u0026#34;Q size : %d\\n\u0026#34;, QSize(\u0026amp;queue));  // Q size : 4  printf(\u0026#34;Q peek : %d\\n\u0026#34;, QPeek(\u0026amp;queue));  // Q peek : 3   while(!QIsEmpty(\u0026amp;queue)) {  printf(\u0026#34;Dequeue : %d\\n\u0026#34;, QDequeue(\u0026amp;queue));  }  // Dequeue : 3  // Dequeue : 5  // Dequeue : 4  // Dequeue : 1   return 0; } 잘 동작하는 모습을 볼 수 있다. 역시, 전체 코드는 최하단에 작성하였다.\n4. 응용 편 - 다리를 지나는 트럭 : 다리를 지나는 트럭 문제는 java 로 한번 풀었으나,\nC로도 한번 풀어보자.(프로그래머스에서 C를 지원하지 않으므로, 제시된 테스트 케이스만 통과하면 맞았다고 보자.)\n이를 위해선, 트럭이 다리에 얼마나 올라와 있었는가? 를 구분하기 위해,\nTruck 구조체를 하나 만들어야 한다.\ntypedef struct Truck {  int weight;  int time; }Truck; 또한, 이 Truck 을 Queue에 담을 것이므로,\nint 대신 Truck 구조체를 담을 수 있도록 적절히 바꿔주자.\ntypedef struct Node {  Truck truck;  struct Node* prev; }Node; 당연히, 다른 관련 함수들 또한 Truck으로 적절히 바꿔주어야 한다(e.g. QDequeue())\nmain() 함수는 다음과 같다.\nint main() {  Queue waitQ;  QInit(\u0026amp;waitQ);   Queue bridgeQ;  QInit(\u0026amp;bridgeQ);   int bridge_length = 100;  int weight = 100;   int truck_weights[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};  int array_length = sizeof(truck_weights) / sizeof(int);   int answer = solution(\u0026amp;waitQ, \u0026amp;bridgeQ, bridge_length, weight, truck_weights, array_length);  printf(\u0026#34;answer : %d\\n\u0026#34;, answer);   return 0; } **\u0026ldquo;진입을 대기하는 waitQ\u0026rdquo;**와, \u0026ldquo;다리에 해당하는 bridgeQ\u0026rdquo; 를 만들어주고,\n문제에서 주어지는 값들과 함께 solution() 함수로 넘겨주었다.\nint solution(Queue *waitQ, Queue *bridgeQ, int bridge_length, int weight, int truck_weights[], int array_length) {  int flag = 0; // 다리를 나가야 하는 트럭이 존재하는지 확인하는 flag  int bridge = 0; // 현재 다리에 올라가 있는 트럭 무게의 합  int answer = 0;   // 처음엔 모두 Truck 구조체로 만들어서 waitQ에 넣어준다.  for(int i=0; i\u0026lt;array_length; i++) {  Truck truck;  truck.weight = truck_weights[i];  truck.time = bridge_length;  QEnqueue(waitQ, truck);  }   // waitQ와 bridgeQ가 모두 비어있다면, 모든 트럭이 통과한 것이므로 중단한다.  while(!QIsEmpty(waitQ) || !QIsEmpty(bridgeQ)) {  // bridgeQ를 돌면서, 다리 위에 올라가 있는 시간인 time을 1씩 감소시킨다.  // time이 0 이하 인 경우, 즉 다리를 나가야 하는 트럭이 존재하는 경우, flag는 1을 추가시킨다.  Node* p = bridgeQ-\u0026gt;head;  while(p != NULL) {  p-\u0026gt;truck.time--;  if (p-\u0026gt;truck.time \u0026lt;= 0) {  flag = 1;  }  p = p-\u0026gt;prev;  }   // flag가 존재하는 경우, 무조건 가장 앞에 있는 트럭이 나가야 하므로,  // 트럭을 하나 빼내고, 현재 다리에 올라가 있는 트럭 무게의 합인 bridge를, 빠져나가는 트럭 무게 만큼 감소시킨다.  if (flag) {  Truck outTruck = QDequeue(bridgeQ);  bridge -= outTruck.weight;  flag = 0;  }   // waitQ가 비어있지 않다면, 들어갈 수 있는지를 확인해보고,  // 들어갈 수 있다면, waitQ에서 빼서 bridgeQ에 추가한다.  // 역시, 현재 다리에 올라가 있는 트럭 무게의 합인 bridge를, 들어가는 트럭 무게 만큼 증가시킨다.  if (!QIsEmpty(waitQ)) {  Truck inTruck = QPeek(waitQ);  if (bridge + inTruck.weight \u0026lt;= weight) {  QEnqueue(bridgeQ, QDequeue(waitQ));  bridge += inTruck.weight;  }  }   answer++;  } // end of while    return answer; } 역시, 코드에 대한 설명은 주석으로 달아놓았다.\n마치며. : C 자체로는, 생산성이 많이 떨어짐을 느꼈다. 한 번 풀었던 문제인데도,\n이렇게 시간이 오래 걸릴줄은 몰랐다 ㅠ.\n역시 나는 Java가 좋다.\n구현 코드들. queueImpl.c\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct Queue {  int size;  struct Node* head;  struct Node* tail; }Queue;  typedef struct Node {  int data;  struct Node* prev; }Node;  void QInit(Queue *pqueue); int QSize(Queue *pqueue); int QIsEmpty(Queue *pqueue); void QEnqueue(Queue *pqueue, int data); int QDequeue(Queue *pqueue); int QPeek(Queue *pqueue);   int main() {  Queue queue;  QInit(\u0026amp;queue);   QEnqueue(\u0026amp;queue, 3);  QEnqueue(\u0026amp;queue, 5);  QEnqueue(\u0026amp;queue, 4);  QEnqueue(\u0026amp;queue, 1);   printf(\u0026#34;Q size : %d\\n\u0026#34;, QSize(\u0026amp;queue));  printf(\u0026#34;Q peek : %d\\n\u0026#34;, QPeek(\u0026amp;queue));   while(!QIsEmpty(\u0026amp;queue)) {  printf(\u0026#34;Dequeue : %d\\n\u0026#34;, QDequeue(\u0026amp;queue));  }   return 0; }    void QInit(Queue *pqueue) {  pqueue-\u0026gt;size = 0;  pqueue-\u0026gt;head = NULL;  pqueue-\u0026gt;tail = NULL; }  int QSize(Queue *pqueue) {  return pqueue-\u0026gt;size; }  int QIsEmpty(Queue *pqueue) {  if (pqueue-\u0026gt;size == 0) {  return 1;  } else {  return 0;  } }  void QEnqueue(Queue *pqueue, int data) {  Node* newNode = (Node*)malloc(sizeof(Node));  newNode-\u0026gt;data = data;  newNode-\u0026gt;prev = NULL;    if(QIsEmpty(pqueue)) {  pqueue-\u0026gt;head = newNode;  } else {  pqueue-\u0026gt;tail-\u0026gt;prev = newNode;  }  pqueue-\u0026gt;tail = newNode;  pqueue-\u0026gt;size++; }  int QDequeue(Queue *pqueue) {  int data = pqueue-\u0026gt;head-\u0026gt;data;   Node* delNode = pqueue-\u0026gt;head;  pqueue-\u0026gt;head = pqueue-\u0026gt;head-\u0026gt;prev;  free(delNode);   pqueue-\u0026gt;size--;   return data; }  int QPeek(Queue *pqueue) {  return pqueue-\u0026gt;head-\u0026gt;data; } Trucks.c\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct Truck {  int weight;  int time; }Truck;  typedef struct Queue {  int size;  struct Node* head;  struct Node* tail; }Queue;  typedef struct Node {  Truck truck;  struct Node* prev; }Node;    void QInit(Queue *pqueue); int QSize(Queue *pqueue); int QIsEmpty(Queue *pqueue); void QEnqueue(Queue *pqueue, Truck truck); Truck QDequeue(Queue *pqueue); Truck QPeek(Queue *pqueue); int solution(Queue *waitQ, Queue *bridgeQ, int bridge_length, int weight, int truck_weights[], int array_length);  int main() {  Queue waitQ;  QInit(\u0026amp;waitQ);   Queue bridgeQ;  QInit(\u0026amp;bridgeQ);    int bridge_length = 2;  int weight = 10;   int truck_weights[] = {7, 4, 5, 6};  int array_length = sizeof(truck_weights) / sizeof(int);   int answer = solution(\u0026amp;waitQ, \u0026amp;bridgeQ, bridge_length, weight, truck_weights, array_length);  printf(\u0026#34;answer : %d\\n\u0026#34;, answer);   return 0; }    void QInit(Queue *pqueue) {  pqueue-\u0026gt;size = 0;  pqueue-\u0026gt;head = NULL;  pqueue-\u0026gt;tail = NULL; }  int QSize(Queue *pqueue) {  return pqueue-\u0026gt;size; }  int QIsEmpty(Queue *pqueue) {  if (pqueue-\u0026gt;size == 0) {  return 1;  } else {  return 0;  } }  void QEnqueue(Queue *pqueue, Truck truck) {  Node* newNode = (Node*)malloc(sizeof(Node));  newNode-\u0026gt;truck = truck;  newNode-\u0026gt;prev = NULL;    if(QIsEmpty(pqueue)) {  pqueue-\u0026gt;head = newNode;  } else {  pqueue-\u0026gt;tail-\u0026gt;prev = newNode;  }  pqueue-\u0026gt;tail = newNode;  pqueue-\u0026gt;size++; }  Truck QDequeue(Queue *pqueue) {  Truck truck = pqueue-\u0026gt;head-\u0026gt;truck;   Node* delNode = pqueue-\u0026gt;head;  pqueue-\u0026gt;head = pqueue-\u0026gt;head-\u0026gt;prev;  free(delNode);   pqueue-\u0026gt;size--;   return truck; }  Truck QPeek(Queue *pqueue) {  return pqueue-\u0026gt;head-\u0026gt;truck; }  int solution(Queue *waitQ, Queue *bridgeQ, int bridge_length, int weight, int truck_weights[], int array_length) {  int flag = 0;  int bridge = 0;  int answer = 0;   for(int i=0; i\u0026lt;array_length; i++) {  Truck truck;  truck.weight = truck_weights[i];  truck.time = bridge_length;  QEnqueue(waitQ, truck);  }     while(!QIsEmpty(waitQ) || !QIsEmpty(bridgeQ)) {  Node* p = bridgeQ-\u0026gt;head;   while(p != NULL) {  p-\u0026gt;truck.time--;  if (p-\u0026gt;truck.time \u0026lt;= 0) {  flag = 1;  }  p = p-\u0026gt;prev;  }   if (flag) {  Truck outTruck = QDequeue(bridgeQ);  bridge -= outTruck.weight;  flag = 0;  }   if (!QIsEmpty(waitQ)) {  Truck inTruck = QPeek(waitQ);  if (bridge + inTruck.weight \u0026lt;= weight) {  QEnqueue(bridgeQ, QDequeue(waitQ));  bridge += inTruck.weight;  }  }   answer++;  }   return answer; } ","permalink":"http://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_queue/","summary":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n지난 Stack편 에 이어집니다.\n1. 이론 편 : Queue는, 편의점의 냉장고를 생각하면 된다.\n편의점 알바를 해보면, 우리가 보고 있는 냉장고 뒤편은 냉장창고라는 것을 알 수 있다.\n창고 뒤편에서, 냉장고에 음료수를 넣으면, 반대편에선 가장 먼저 넣은 것을 우선으로 꺼낼 수 있다.","title":"# 마음으로 이해하는 자료구조 : Queue ( feat. C )"},{"content":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n1. 이론 편 : Stack 이란 말 그대로, \u0026ldquo;쌓는 것\u0026quot;이다. 접시쌓기를 생각해보면 된다.\n접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, 가장 상위에만 쌓아야 한다.\n반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, 가장 상위에서만 꺼내야 한다.\n이를,LIFO(Last in, First out)(후입선출) 라고 한다.\n2. 구현 편 - ADT   Note. ADT란, Abstract Data Type의 약자로, 프로그램의 대상이 되는 사물이나 현상을 추상화 하여 정의 한 것을 의미한다. 이는, 해당 기능의 완성과정이 아닌 기능의 종류를 나열한 것이다. 예를 들면, 지갑의 ADT는 \u0026ldquo;현금 넣기, 현금 꺼내기, 카드 넣기, 카드 꺼내기 \u0026hellip;\u0026rdquo; 등이 된다.\n  : Stack의 ADT는 다음과 같다.\n init()  Stack의 초기화를 진행 Stack 생성 후, 가장 먼저 호출되어야 하는 함수.   size()  해당 Stack에 데이터가 몇 개 쌓여 있는지 확인.   isEmpty()  해당 Stack이 비어있는가를 확인. 비었으면 true, 아니면 false 를 반환   push(data)  Stack에 데이터를 저장. 당연히, 가장 맨 위에 저장한다.   pop()  Stack에 있는 데이터를 반환. 꺼낸 데이터는, Stack에서 삭제한다. 역시 당연히, 가장 맨 위에서 꺼낸다. Stack에 데이터가 최소 하나는 있어야 한다.   peek()  Stack에 있는 데이터를 반환 꺼낸 데이터는 삭제하지 않는다. 물론 역시 당연히, 가장 맨 위에서 꺼낸다. Stack에 데이터가 최소 하나는 있어야 한다.    3. 구현 편 - Code : 지난 편에, LinkedList를 배웠으므로, 배열이 아닌 LinkedList 를 이용해 구현할 것이다.\n먼저, Stack을 위한 구조체를 만들어야 한다.\ntypedef struct Stack {  int size;  struct Node* head; }Stack;  typedef struct Node {  int data;  struct Node* prev; }Node; Stack 구조체는 Stack의 크기, 그리고 가장 상위에 있는 Node를 가리키는 구조체이다.\nNode 구조체는, data를 담고 있고, Pop이 되었을 경우, 이전 데이터를 가리켜야 하기 때문에, struct Node* prev; 를 가진다.\n먼저, 초기화를 시켜주는 init() 함수를 만들어보자.\nvoid SInit(Stack* pstack) {  pstack-\u0026gt;size = 0;  pstack-\u0026gt;head = NULL; } 처음에는 아무런 데이터도 들어있지 않으므로, size는 0, head는 NULL로 초기화 시킨다.\n그리고, 가장 단순한, size() 함수와 IsEmpty() 함수를 구현해보자.\nint SSize(Stack* pstack) {  return pstack-\u0026gt;size; }  int SIsEmpty(Stack *pstack) {  if (pstack-\u0026gt;size == 0) { // if (SSize(pstack) == 0) 으로 대체해도 무방.  return 1;  } else {  return 0;  } } 이정도는 코드에 대한 주석이 없어도 이해가 될 것이라 생각한다.\n다음으로, 핵심이 되는 push()와 pop() 함수를 구현해보자.\nvoid SPush(Stack *pstack, int data) {  Node* newNode = (Node *)malloc(sizeof(Node));   newNode-\u0026gt;data = data;  newNode-\u0026gt;prev = pstack-\u0026gt;head;   pstack-\u0026gt;head = newNode;  pstack-\u0026gt;size++; } {: .alignCenter}\npush() 함수는, stack 이외에 data라는 int형 변수를 하나 받는다.\n그리고 Node 만큼의 공간을 새로이 할당하고, 이를 newNode가 가리키도록 한다.\nnewNode의 data는 인자로 전달받은 data를,\n그리고 newNode의 prev는 기존에 가장 상위에 있던 pstack-\u0026gt;head 를 가리키도록 한다. (그림의 1번)\n마지막으로,pstack-\u0026gt;head 가 newNode를 가리키도록 하고, (그림의 2번) pstack의 size를 하나 증가시킨다.\nint SPop(Stack *pstack) {  int data = pstack-\u0026gt;head-\u0026gt;data;   Node* delNode = pstack-\u0026gt;head;  pstack-\u0026gt;head = pstack-\u0026gt;head-\u0026gt;prev;  free(delNode);   pstack-\u0026gt;size--;   return data; } {: .alignCenter} pop() 함수는 삭제하는 작업이 필요하다.\n가장 먼저, pstack-\u0026gt;head 의 Node가 갖고 있는 data를 int data에 저장한다.\n그리고, delNode가 pstack의 head를 가리키게 하고(그림의 1번)\npstack의 head는 하나 이전의 요소를 가리키게 한다.(그림의 2번)\n마지막으로, free(delNode)를 통해, delNode가 가리키는 요소를 삭제하게 하면 된다.\n이후, pstack의 data를 하나 감소시키고, data를 return 해주면 된다.\n마지막으로, peek()은 아주 간단하다.\nint SPeek(Stack *pstack) {  return pstack-\u0026gt;head-\u0026gt;data; } head가 가리키고 있는 data를 return 하면 된다.\n이를 테스트 하는 코드는 다음과 같다.\nint main() {  Stack stack;  SInit(\u0026amp;stack);   printf(\u0026#34;is stack Empty ? : %d\\n\u0026#34;, SIsEmpty(\u0026amp;stack));  // is stack Empty ? : 1  // stack이 비어있으므로, true인 1을 반환한다.   SPush(\u0026amp;stack, 1);  SPush(\u0026amp;stack, 4);  SPush(\u0026amp;stack, 3);  SPush(\u0026amp;stack, 15);  // 순서대로 1,4,3,15를 Push한다.   printf(\u0026#34;stack size : %d\\n\u0026#34;, SSize(\u0026amp;stack));  // stack size : 4  // push 이후 size는 4   int data = SPop(\u0026amp;stack);  printf(\u0026#34;data : %d, current stack size : %d\\n\u0026#34;, data, SSize(\u0026amp;stack));  // data : 15, current stack size : 3  // 데이터를 하나 꺼내보면, 가장 마지막에 넣은 15가 return 되고, size는 3으로 감소하였음을 볼 수 있다.   printf(\u0026#34;peek : %d\\n\u0026#34;, SPeek(\u0026amp;stack));  printf(\u0026#34;peek : %d\\n\u0026#34;, SPeek(\u0026amp;stack));  // peek : 3  // peek : 3  // peek 함수는 여러 번 실행해도, 같은 값을 보여준다.  // 현재 Stack에는 1, 4, 3 이 들어있다.   while(!SIsEmpty(\u0026amp;stack)) {  printf(\u0026#34;pop data : %d\\n\u0026#34;, SPop(\u0026amp;stack));  }  // pop data : 3  // pop data : 4  // pop data : 1  // stack이 빌 때까지, pop 하면 역순으로 3,4,1이 출력된다.   printf(\u0026#34;After all, Stack Size : %d\\n\u0026#34;, SSize(\u0026amp;stack));  // After all, Stack Size : 0  // Stack이 비어있으므로, size는 0이 된다.   return 0; } 전체 코드는 포스팅 가장 하단에 작성하였다.\n4. 응용 편 - 괄호 여닫기 : 우리가 프로그래밍을 할 때, () 의 소괄호가 되었든, {} 의 중괄호가 되었든, []의 대괄호가 되었든,\n괄호는 항상 열렸으면 닫아줘야 한다.\n이 소괄호가 올바르게 열고 닫혔는지 확인하는 방법은,\nStack을 이용하면 아주 간단하게 해결할 수 있다.\n프로그래머스에도 이러한 문제가 있는데,\n지난 번에 푼 여기 를 참고하자.\n  주의 : 단순히 괄호의 개수를 세는 것만으로는 이 문제를 해결할 수 없다!\n가령, 다음과 같이 괄호가 열고 닫혔다고 해보자.\n())(\n열린건 한번인데, 두번을 닫아버리면, 이는 잘못된 괄호이다.\n이럴 경우에는, 에러로 처리해야 한다.\n  Stack으로 어떻게 해결할 수 있는가, 하면\n \u0026lsquo;(\u0026rsquo; 의 여는 괄호가 들어오면, stack에 Push 한다. \u0026lsquo;)\u0026rsquo; 의 닫는 괄호가 들어오면, stack에서 Pop 한다. 정상적으로 끝났다면, 이는 올바른 괄호다. 만약 정상적으로 처리가 되지 않는다면, 이는 잘못된 괄호다.  기존의 코드를 살짝 수정해보자.\nint형 data 대신, char 형 data를 받도록 하고, 로직에 맞게 코드만 작성해주면 된다.\ntypedef struct Node {  char data;  struct Node* prev; }Node; 당연히, data와 관련된 다른 녀석들도 int에서 char로 바꿔주면 된다(e.g. SPop())\nchar brackets[] = \u0026#34;((()))\u0026#34;; int answer = isCorrectBrackets(\u0026amp;stack, brackets, strlen(brackets));  if (answer) {  printf(\u0026#34;It\u0026#39;s correct !\\n\u0026#34;); } else {  printf(\u0026#34;It\u0026#39;s wrong !\\n\u0026#34;); } 먼저, brackets 라는 char 형 data의 변수를 만들고,\nisCorrectBrackets() 라는 함수를 통해, 이것이 올바른 괄호인지 아닌지 확인할 것이다.\nint isCorrectBrackets(Stack *pstack, char brackets[]) {  int answer = 1;  for (int i=0; i\u0026lt;strlen(brackets); i++) {  char current = brackets[i];  if (current == \u0026#39;(\u0026#39;) { // \u0026#39;(\u0026#39; 이 들어오면 무조건 push  SPush(pstack, current);  } else { // \u0026#39;)\u0026#39;이 들어왔다면  if (SIsEmpty(pstack)) { // \u0026#39;)\u0026#39;이 들어왔는데, stack이 비어있다면, 즉 열린 괄호가 없는데 닫으려 한다면  answer = 0; // 잘못된 괄호이므로 false  break;  } else {  SPop(pstack); // stack이 비어 있지 않다면, pop  }  }  }    // 다 돌았는데, Stack이 남아있다면, 열린 괄호가 남아 있다는 뜻.  if (!SIsEmpty(pstack)) {  answer = 0;  }   return answer; } strlen() 함수를 사용하기 위해, #include \u0026lt;string.h\u0026gt; 또한 작성하였다.\n또한, 코드에 대한 설명은 주석으로 달아두었다.\n구현 코드들. stackImpl.c\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct Stack {  int size;  struct Node* head; }Stack;  typedef struct Node {  int data;  struct Node* prev; }Node;  void SInit(Stack *pstack); int SSize(Stack *pstack); int SIsEmpty(Stack *pstack); void SPush(Stack *pstack, int data); int SPop(Stack *pstack); int SPeek(Stack *pstack);   int main() {  Stack stack;  SInit(\u0026amp;stack);   printf(\u0026#34;is stack Empty ? : %d\\n\u0026#34;, SIsEmpty(\u0026amp;stack));   SPush(\u0026amp;stack, 1);  SPush(\u0026amp;stack, 4);  SPush(\u0026amp;stack, 3);  SPush(\u0026amp;stack, 15);   printf(\u0026#34;stack size : %d\\n\u0026#34;, SSize(\u0026amp;stack));   int data = SPop(\u0026amp;stack);  printf(\u0026#34;data : %d, current stack size : %d\\n\u0026#34;, data, SSize(\u0026amp;stack));   printf(\u0026#34;peek : %d\\n\u0026#34;, SPeek(\u0026amp;stack));  printf(\u0026#34;peek : %d\\n\u0026#34;, SPeek(\u0026amp;stack));   while(!SIsEmpty(\u0026amp;stack)) {  printf(\u0026#34;pop data : %d\\n\u0026#34;, SPop(\u0026amp;stack));  }   printf(\u0026#34;After all, Stack Size : %d\\n\u0026#34;, SSize(\u0026amp;stack));   return 0; }  void SInit(Stack* pstack) {  pstack-\u0026gt;size = 0;  pstack-\u0026gt;head = NULL; }   int SSize(Stack* pstack) {  return pstack-\u0026gt;size; }  int SIsEmpty(Stack *pstack) {  if (pstack-\u0026gt;size == 0) {  return 1;  } else {  return 0;  } }   void SPush(Stack *pstack, int data) {  Node* newNode = (Node *)malloc(sizeof(Node));   newNode-\u0026gt;data = data;  newNode-\u0026gt;prev = pstack-\u0026gt;head;   pstack-\u0026gt;head = newNode;  pstack-\u0026gt;size++; }  int SPop(Stack *pstack) {  int data = pstack-\u0026gt;head-\u0026gt;data;   Node* delNode = pstack-\u0026gt;head;  pstack-\u0026gt;head = pstack-\u0026gt;head-\u0026gt;prev;  free(delNode);   pstack-\u0026gt;size--;   return data; }  int SPeek(Stack *pstack) {  return pstack-\u0026gt;head-\u0026gt;data; } Brackets.c\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct Stack {  int size;  struct Node* head; }Stack;  typedef struct Node {  char data;  struct Node* prev; }Node;  void SInit(Stack *pstack); int SSize(Stack *pstack); int SIsEmpty(Stack *pstack); void SPush(Stack *pstack, char data); char SPop(Stack *pstack); char SPeek(Stack *pstack); int isCorrectBrackets(Stack *pstack, char brackets[], int length);   int main() {  Stack stack;  SInit(\u0026amp;stack);   char brackets[] = \u0026#34;((()))\u0026#34;;  int answer = isCorrectBrackets(\u0026amp;stack, brackets);   if (answer) {  printf(\u0026#34;It\u0026#39;s correct !\\n\u0026#34;);  } else {  printf(\u0026#34;It\u0026#39;s wrong !\\n\u0026#34;);  }     return 0; }  void SInit(Stack* pstack) {  pstack-\u0026gt;size = 0;  pstack-\u0026gt;head = NULL; }   int SSize(Stack* pstack) {  return pstack-\u0026gt;size; }  int SIsEmpty(Stack *pstack) {  if (pstack-\u0026gt;size == 0) {  return 1;  } else {  return 0;  } }  void SPush(Stack *pstack, char data) {  Node* newNode = (Node *)malloc(sizeof(Node));   newNode-\u0026gt;data = data;  newNode-\u0026gt;prev = pstack-\u0026gt;head;   pstack-\u0026gt;head = newNode;  pstack-\u0026gt;size++; }  char SPop(Stack *pstack) {  char data = pstack-\u0026gt;head-\u0026gt;data;   Node* delNode = pstack-\u0026gt;head;  pstack-\u0026gt;head = pstack-\u0026gt;head-\u0026gt;prev;  free(delNode);   pstack-\u0026gt;size--;   return data; }  char SPeek(Stack *pstack) {  return pstack-\u0026gt;head-\u0026gt;data; }  int isCorrectBrackets(Stack *pstack, char brackets[]) {  int answer = 1;  for (int i=0; i\u0026lt;strlen(brackets); i++) {  char current = brackets[i];  if (current == \u0026#39;(\u0026#39;) {  SPush(pstack, current);  } else {  if (SIsEmpty(pstack)) {  answer = 0;  break;  } else {  SPop(pstack);  }  }  }     if (!SIsEmpty(pstack)) {  answer = 0;  }   return answer; } ","permalink":"http://cjlee38.github.io/post/algorithm/data_structure/2020-09-21-what_is_stack/","summary":"0. 들어가며 : Stack과 Queue는 아주 기본 중의 기본인 자료구조이다.\n아주 간단하므로, 사실 Stack과 Queue가 무엇인지에 대해서 이야기할 부분은 많지 않다.\n따라서, 이번 포스팅은 코드 구현 위주로 작성할 것이다.\n쓰다보니, 생각보다 포스팅이 또 길어져서, Stack과 Queue를 나누어서 작성했다.\n1. 이론 편 : Stack 이란 말 그대로, \u0026ldquo;쌓는 것\u0026quot;이다. 접시쌓기를 생각해보면 된다.\n접시를 쌓을 때에는, 처음 혹은 중간에 끼워 넣을 수 없으며, 가장 상위에만 쌓아야 한다.\n반대로, 꺼낼 때에도, 처음 혹은 중간에서 꺼낼 수 없으며, 가장 상위에서만 꺼내야 한다.","title":"# 마음으로 이해하는 자료구조 : Stack ( feat. C )"},{"content":"POST 다루기 : 지난 3편에 이어서, POST를 다뤄보자.\n이를 위해, 지난 편에 작성했던 html 코드를 조금 더 업그레이드 시켜보자.\n\u0026lt;div\u0026gt;  \u0026lt;form action=\u0026#34;firstServlet\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your title \u0026lt;/label\u0026gt;  \u0026lt;input name = \u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your content \u0026lt;/label\u0026gt;  \u0026lt;textarea name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;click here to submit\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 기존과 달라진 점이라면\n 입력을 받는 area가 title과 content로 구분되었고, \u0026lt;form\u0026gt; 태그에 method=\u0026ldquo;POST\u0026quot;가 추가 되었다.  이렇게하면, title과 content과 POST를 통해 넘어가게 된다.\n한번 테스트 해보자.\n{: .alignCenter}\n위와 같이, 작성하고, submit을 누르기 전에,\nF12를 눌러 개발자도구를 열고, Network 탭을 열어놓자.\n그리고, submit을 누르자.\n{: .alignCenter}\nsubmit을 누르고 나면, 위와 같이, Network tab에 firstServlet이라는 document가 있는 것을 볼 수 있다.\n아래 쪽을 보면, Form data라고 쓰인 부분에,\ntitle: some title here\ncontent: this is content\n를 볼 수 있다.\n그렇다면, 이를 서버에서 받아보자. 받는 법은 get을 받을 때와 같다.\n@WebServlet(\u0026#34;/firstServlet\u0026#34;) public class firstServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  PrintWriter out = resp.getWriter();   String title = req.getParameter(\u0026#34;title\u0026#34;);  String content = req.getParameter(\u0026#34;content\u0026#34;);   out.println(\u0026#34;title : \u0026#34; + title);  out.println(\u0026#34;content : \u0026#34; + content);    } } 똑같이 getParameter()를 활용해서, String으로 받은 뒤, 이를 출력하면 된다.\n그 결과는 다음과 같다.\n{: .alignCenter}\n잘 나타나는 모습을 볼 수 있다.\n이렇게 GET과 POST의 차이는 다음과 같다.\n   GET POST     상대적으로 빠름 상대적으로 느림   데이터를 URL로 전송 데이터를 Body로 전송   256Byte 제한 데이터 제한 없음    Encoding \u0026amp; Content-Type : 그런데, Title과 Content에 한글을 넣어서 submit을 해보자.\n{: .alignCenter}\n{: .alignCenter}\n위와 같이, 결과가 깨져서 나오는 것을 볼 수 있다.\n이는 Client와 Server의 Encoding이 서로 달라 발생하는 문제이다.\n이 외에도, ContentType의 문제가 발생할 수 있다.\n지금 당장의 문제는 encoding이 원인인데, 겸사겸사 해서 ContentType 문제까지 해결해보자.\n1. Encoding : 간단하다. request와 response에 둘다 setCharacterEncoding을 통해 setting 해주면 된다.\n주의할 점은, \u0026ldquo;둘 다\u0026rdquo; 해줘야 한다는 것이다.\nreq.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); resp.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); 가령, response에만 encoding 을 설정하고, out.println(\u0026quot;안녕하세요\u0026quot;); 를 작성하고 실행하게 되면,\n\u0026ldquo;안녕하세요\u0026rdquo; 는 정상적으로 출력 된다. 그러나, 위 예시와 같이 입력을 받는다면,\nUTF-8이 아니기 때문에 애초에 받을 때부터 String이 깨지게 된다.\n따라서, 이를 주의해야 한다.\n2. ContentType : Content Type이란, \u0026ldquo;이 문서가 무슨 형식으로 되어있는지\u0026rdquo; 와 관련되어 있다.\n우리가, txt 파일을 읽으면, 메모장가 열려서 txt파일을 해석해준다.\ndocx 파일을 열면, Microsoft Word(혹은 다른 편집기)가 열려서 이를 해석해준다.\n웹도 마찬가지다. 우리가 보낸것이, 단순 txt인지, 혹은 html 인지를 알려줘야 한다.\n한번 테스트 해보자.\nout.println(\u0026#34;this is content-Type test\u0026lt;br\u0026gt;\u0026#34;); 기존 코드에 위 코드를 추가하고, (구시대의 유물인)Internet Explorer에서 열어보자.\n{: .alignCenter}\n{: .caption} 익스플로러 결과\n{: .alignCenter}\n{: .caption} 크롬 결과\n위와 같이, 익스플로러에서는 줄바꿈도 이루어지지 않았고, br 태그 또한 보이지 않는다.\n(url에 곧바로 접근했으므로 null이 나타나는 것은 정상이다.)\n이는, 받은 문서를 **익스플로러는 \u0026ldquo;HTML\u0026rdquo;**로 해석했고,\n**크롬은 \u0026ldquo;TEXT\u0026rdquo;**로 해석했기 때문이다.\n따라서, 이런 브라우저 간 차이를 막기 위해, ContentType을 지정해야 한다.\nhtml로 지정하는 방법 또한 간단하다.\nresp.setContentType(\u0026#34;text/html; charset=UTF-8\u0026#34;); 이 코드를 추가해주면 된다.\n3. 뭔가 좀 아쉽다. : 이렇게만 하면, 굉장히 뭔가 아쉽다.\n만약 우리가, 실제 프로젝트를 진행한다면, 돌아다닐 페이지가 한 두개가 아닐텐데,\n이를 각각 다 set, set, set.. 해주는 것은 너무 귀찮다.\n또한, 일종의 configuration 인데, 이렇게 class 마다 지정해주는 것도 조금 이상하다.\n그런데 그렇다고해서, 모~~든 서비스에 인코딩을 지정해주고자 톰캣 자체에 세팅을 하는것 또한 이상하다.\n따라서, 우리는 서블릿 필터를 활용해서, **\u0026ldquo;하나의 컨텍스트에 설정\u0026rdquo;**을 해줄 것이다.\nServlet Filter : filter란 이름 그대로, 무언가가 행해지기 전에,\n이 filter를 반드시 거쳐야 한다.\n모든 컨텐츠에 대해서, 우리는 위와 같은 Encoding과 ContentType을 설정할 것이므로,\n이 Filter에다가 해당 코드를 집어넣어보자.\n먼저, myProject/src/main/java 하위에, 다음과 같이 myFilter 라는 java file을 하나 만들자.\n{: .alignCenter}\n그리고, 이 myFilter class는, javax.servlet.Filter를 구현해야 한다.\nimport javax.servlet.*;  public class myFilter implements Filter {  } 이때, doFilter 라는 method를 구현해야 하므로, IDE의 도움을 받아 자동완성 시켜보자.\n@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {  } 기존의 다른 코드들과 다르게, FilterChain 이라는 인자가 하나 더 늘어났다.\n이 filterChain.doFilter()를 통해서,\n\u0026ldquo;야, 지금 이 request와 response 의 설정을 적용해라\u0026rdquo; 라고 지정해주는 것이다.\n그리고, 필터를 적용한 후에 뭔가 해야할 일이 있으면, 이 filterChian.doFilter() 뒤에 넣어주면 된다.\n어쨌든, 우리가 하고자 하는 Encoding과 ContentType 설정은 필터에 적용할 대상이므로,\nfilterChain.doFilter이전에 작성하면 된다.\n그리고 마지막으로, 역시 이 Filter 또한 url을 mapping 시켜줘야 한다.\n똑같이 WebServlet을 쓰면 안되고, 이번에는 WebFilter라는 것이 필요하다.\n우리는, 해당 Context의 모든 page에 적용할 것이므로, \u0026ldquo;/*\u0026rdquo; 의 와일드카드를 통해 적용시키자.\n그리고, 기존의 firstServlet 안에 있는 setCharacterEndoing, setContentType을 다 지워주고,\n잘 동작하는지 확인해보자.\n완성된 코드는 다음과 같다.\nmyFilter.java\n@WebFilter(\u0026#34;/*\u0026#34;) public class myFilter implements Filter {  @Override  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {  servletRequest.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;);  servletResponse.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;);  servletResponse.setContentType(\u0026#34;text/html; charset=UTF-8\u0026#34;);   filterChain.doFilter(servletRequest, servletResponse);  }  } firstServlet.java\n@WebServlet(\u0026#34;/firstServlet\u0026#34;) public class firstServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  PrintWriter out = resp.getWriter();   String title = req.getParameter(\u0026#34;title\u0026#34;);  String content = req.getParameter(\u0026#34;content\u0026#34;);   out.println(\u0026#34;title : \u0026#34; + title);  out.println(\u0026#34;content : \u0026#34; + content);   out.println(\u0026#34;this is content-Type test\u0026lt;br\u0026gt;\u0026#34;);    } } {: .alignCenter}\n위와 같이, html로 지정되었기 때문에, 태그가 보이지 않게 되었고,\n한글도 깨지지 않는 모습을 확인할 수 있다.\n다음 포스팅에선, application, session, cookie에 대해서 다뤄보자.\n","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-09-21-jsp_learning_04/","summary":"POST 다루기 : 지난 3편에 이어서, POST를 다뤄보자.\n이를 위해, 지난 편에 작성했던 html 코드를 조금 더 업그레이드 시켜보자.\n\u0026lt;div\u0026gt;  \u0026lt;form action=\u0026#34;firstServlet\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your title \u0026lt;/label\u0026gt;  \u0026lt;input name = \u0026#34;title\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your content \u0026lt;/label\u0026gt;  \u0026lt;textarea name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;click here to submit\u0026#34;/\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 기존과 달라진 점이라면","title":"# 4. JSP 학습기록 - POST handling과 Servlet Filter"},{"content":"Output : 지난 2편 에서 작성했던 코드는 다음과 같다.\nimport javax.servlet.*; import javax.servlet.http.*; import java.io.*;  public class myServlet extends HttpServlet {  public void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {  System.out.println(\u0026#34;This is myServlet.\u0026#34;);  } }   Note. 다른 작업을 하기 전에, 여기 를 참고해서,\nIDE의 도움을 받자. 하나하나 직접 작성하는 것도 꽤 수고스러운 일이다.\n학생의 경우 인증을 통해 무료로 Ultimate 버전을 구할 수 있으나, 불가능 할 경우 Eclipse를 사용하면 된다. Eclipse 설정 방법은 Intellij와 조금 다르니 유의할 것.\n  위 코드를, Project/src/main/java 하위에 새로 만들고, 이름을 firstServlet 으로 변경하였다.\n{: .alignCenter} {: .caption}\n그리고, 여기서 이제 브라우저, 즉 클라이언트 쪽으로 print 를 하기 위해서는, 다음과 같이 사용하면 된다.\npublic class firstServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  PrintWriter out = resp.getWriter();  out.println(\u0026#34;This is first servlet.\u0026#34;);  } } 역시, 지난 편처럼, web.xml을 수정해줘야 하는데,\nweb.xml 을 수정하는 것은 설정파일을 수정하는 것이므로, 귀찮기도 할 뿐더러,\n해당 코드가 어디에 위치해있는지 찾아 나가는 것 또한 수고스러우므로,\nannotation (@) 을 통해, 코드 내에서 직접 연결해줄 수 있다.\n따라서, public class firstServlet extends HttpServlet 위에,\n@WebServlet(\u0026quot;/firstServlet\u0026quot;) 이라고 넣어주자.\n{: .alignCenter}\n{: .caption} 이런식으로\n그리고, IDE의 run 버튼을 통해 Tomcat을 실행시켜서 결과를 보자.\n{: .alignCenter}\n처음에는 이렇게, index.jsp를 바탕으로 한 Hello world! 가 나타난다.\nurl 뒤에, /firstServlet을 붙여서 찾아가보자.\n{: .alignCenter}\n위와 같이, 결과가 잘 나타나는 모습을 볼 수 있다.\nInput : 이제 출력은 해봤으니, 입력도 한번 받아보자.\n입력을 받는 방법은 두 가지가 있다.\n url에 query string을 직접 넣어주는 방법. html 에서 입력을 받는 form을 만들어서, query string으로 자동으로 넘겨주는 방법.  2번 안에 1번이 포함되어 있으므로, 1번을 먼저 해보고, 2번을 진행해보자.\n먼저, 기존의 주소인 http://localhost:8080/firstServlet 의 뒤에,\n?count=3 을 붙여보자. 현재로서는, 아무런 변화도 없다. 우리는 즉, 최종 url은 http://localhost:8080/firstServlet?count=3 이 된다.\n현재로서는, servlet에서 무언가를 처리하는 것이 없기 때문에 당연히 아무런 변화도 없다.\nservlet으로 넘어와서, 코드를 다음과 같이 수정해보자.\n@WebServlet(\u0026#34;/firstServlet\u0026#34;) public class firstServlet extends HttpServlet {  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  PrintWriter out = resp.getWriter();   int iCount = 1;  String sCount = req.getParameter(\u0026#34;count\u0026#34;);   if (sCount != null \u0026amp;\u0026amp; !sCount.equals(\u0026#34;\u0026#34;)) {  iCount = Integer.parseInt(sCount);  }   for(int i=0; i\u0026lt;iCount; i++) {  out.println(\u0026#34;This is first Servlet.\u0026#34;);  }  } } 기본 iCount 라는 int 변수를 1로 초기화 시켜놓고, req에서 getParameter()를 통해 전달받은 count를 받는다.\n이 떄, 다음을 주의해야 한다.\n req.getParameter()로 받은 변수는 반드시 String으로 넘어온다. req.getParameter()를 했을 때, 반드시 \u0026ldquo;숫자로 파싱 가능한 String이 넘어올 것이라는 보장은 없다.  1번은 Integer.parseInt() 등으로 파싱하면 되지만, 2번의 경우 다음과 같은 케이스들이 있을 수 있다.\n /fristServlet?cnt=something 인 경우 -\u0026gt; String \u0026ldquo;something\u0026quot;이 넘어옴 /firstServlet?cnt= 인 경우 -\u0026gt; \u0026ldquo;\u0026quot;(빈 문자열)이 넘어옴 /firstServlet? 인 경우 -\u0026gt; null이 넘어옴 /firstServlet 인 경우 -\u0026gt; null이 넘어옴  2-1번의 경우는 제외하고, 나머지 케이스를 핸들링하기 위해, null과 **빈 문자열인 \u0026ldquo;\u0026rdquo;**를 검사해준다.\n정상적으로 Integer 형으로 parsing이 되면, 해당 count만큼 출력이 될 것이다. 실행해보자.\n{: .alignCenter}\n잘 나오는 것을 볼 수 있다.\n여기서, 조금만 더 나가서, 사용자가 url이 아닌 html을 통해서 입력을 받을 수 있도록 해보자.\n먼저, webapp 폴더 하위에, firstServlet.html 을 새로 만들고, 다음의 내용을 body 안에 넣어보자.\n\u0026lt;div\u0026gt;  \u0026lt;form action=\u0026#34;firstServlet\u0026#34;\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;label\u0026gt; input your count\u0026lt;/label\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;count\u0026#34; /\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;click here to submit\u0026#34;/\u0026gt;  \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; 그리고, 톰캣을 다시 실행시킨 뒤, firstServlet.html 로 이동하면, 다음과 같은 화면이 보일 것이다.\n{: .alignCenter}\n여기에, 내가 원하는 임의의 숫자 값을 입력하고, submit을 해보자.\n{: .alignCenter}\n잘 나타나는 것을 볼 수 있다.\n이렇게 전달되는 값은, get 함수를 통해 요청된 것이다.\n다음 편에서는, post 요청을 받고, 이를 파싱하는 방법에 대해서 알아보자.\n","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-09-19-jsp_learning_03/","summary":"Output : 지난 2편 에서 작성했던 코드는 다음과 같다.\nimport javax.servlet.*; import javax.servlet.http.*; import java.io.*;  public class myServlet extends HttpServlet {  public void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {  System.out.println(\u0026#34;This is myServlet.\u0026#34;);  } }   Note. 다른 작업을 하기 전에, 여기 를 참고해서,\nIDE의 도움을 받자. 하나하나 직접 작성하는 것도 꽤 수고스러운 일이다.\n학생의 경우 인증을 통해 무료로 Ultimate 버전을 구할 수 있으나, 불가능 할 경우 Eclipse를 사용하면 된다.","title":"# 3. JSP 학습기록 - Servlet을 이용한 입출력"},{"content":"문제 링크\nProblem {: .alignCenter}\nSolve : 문제 자체를 푸는데도 꽤 걸렸지만, 쓸데 없는 부분에서 고생했던 문제라서, 살짝 열받아서 가져왔다.\n문제의 지문 자체가 그리 어렵지는 않지만, 시뮬레이션해서 이를 만들어줘야 하기 때문에, 이 부분에서 난이도가 좀 오르는 것 같다.\n접근 방법 : 다음의 순서를 반복하면 된다\n 행과 열 중, size가 더 긴 곳(같다면 행)을 선택한다. 더 긴 곳을 기준으로 돌면서(즉, 행이라면 하나의 행을 가져와서) 정렬을 수행한다.  정렬은 \u0026ldquo;숫자의 등장 횟수를 기준으로 오름차순\u0026rdquo; 숫자의 등장 횟수가 같다면, 숫자 자체의 크기를 기준으로 오름차순   각 정렬을 수행하면서, 달라진 최대 길이를 구한다. 최대 길이만큼, 짧은 길이를 0으로 채워서 늘려준다. 1로 가서 반복한다. 만약, 반복 횟수가 100 이상이면 -1을 리턴한다.  구현 첫 번째 설계 - 이중배열 : 주어진 이중배열을 다루기 위해, 두 가지 방법이 존재한다.\n 이중배열의 크기를 100,100으로 고정시키고, 이를 계속 변경시키는 방법 반복이 진행될때마다, 배열을 새로 만들어서 갈아끼우는 방법  두 가지 방법 중, 1번 방법을 선택했는데, 그 이유는\n 최대 100번 반복하는 동안, 배열을 새로 만드는 작업은 자원의 낭비라고 생각했다. 배열의 최대 크기가 100,100 이고 나머지는 버린다고 문제에서 제시했으므로, 이를 따르지 않을 이유가 없었다.  1번 방법을 택했으므로, 계속해서 배열의 \u0026ldquo;실제 사이즈\u0026rdquo; 를 track 할 수 있는 변수인 rSize와 cSize를 만들었다.\nint rSize = 3; int cSize = 3; 그리고, 최대 길이를 구하고 나면, 한번의 반복이 끝났을 때 최대 길이로 기존의 길이를 바꿔줘야 한다.\nint newCSize = 0; // 새로 구한 최대 길이는 기존의 길이보다 짧을 수 있기 때문에, cSize로 초기화 하면 안된다. newCSize = PQ.size() * 2 \u0026gt; newCSize ? Math.min(PQ.size() * 2, 100) : newCSize; PriorityQueue에서 두개의 요소를 꺼낼 것 이므로 * 2 를 해줘야 한다.\n또한, 최대 길이는 100을 넘으면 안되므로,\n현재 line의 길이 vs 지금까지 나온 최대 길이 vs 100 을 비교해야 한다.\n두 번째 설계 - 정렬 : 정렬을 할 때, 어떤 방법으로 정렬할지에 대해서 고민했다.\n우선순위큐라는 지금 문제에 딱 걸맞는 자료구조가 있으므로, 이를 사용하지 않을 이유가 없었다.\n문제를 풀고 나서 다른 사람들의 코드를 보니, 그냥 List를 정렬하는 사람도 있었는데, 이는 취향의 차이라고 생각한다.\n어쨌든, 우선순위큐를 만드려면, 이를 비교할 수 있도록 Comparable 인터페이스를 구현해야 하고,\n우리는 1. 숫자의 등장 횟수, 2. 숫자의 크기 순서대로 비교할 것이므로,\nComparable 인터페이스를 구현하는 Number 클래스를 만들었다.\nclass Number implements Comparable\u0026lt;Number\u0026gt; {  private int num;  private int count;   public Number(int num, int count) {  this.num = num;  this.count = count;  }   public int getNum() {  return num;  }   public int getCount() {  return count;  }   @Override  public int compareTo(Number number) {  if (this.count == number.count) {  return this.num \u0026gt; number.num ? 1 : -1;  } else {  return this.count \u0026gt; number.count ? 1 : -1;  }  } } 세 번째 설계 - 정렬을 위한 Counter : Python에서는 collections 모듈에 Counter라는 편리한 방법이 있지만, 자바에서는 딱히 없으므로 이를 흉내내기 위해 HashMap을 사용했다.\nMap\u0026lt;Integer, Integer\u0026gt; KV = new HashMap\u0026lt;\u0026gt;(); for(int i=0; i\u0026lt;size; i++) {  if (values[i] != 0) {  KV.compute(values[i], (k, v) -\u0026gt; v == null ? 1 : v + 1);  } } 이쯤 되면, 거의 다 끝났다. 이제 계산을 해서 PriorityQueue를 만든 후, 하나씩 꺼내서 배열의 요소를 하나하나 바꿔주기만 하면 된다.\n이 때, 바꾼 요소 이외의 나머지 요소들은 0으로 초기화 해야 함을 잊지 말자.(길이가 기존보다 짧아질 수 있으므로)\n가령, 1 1 1 이라는 line이 들어왔다면, 1 3 으로 바꿔주고, 나머지는 0으로 초기화 해야 한다.\n그렇지 않는다면, 1 3 1 \u0026hellip; 이런식으로 되기 때문에, 문제가 된다.\n코드 전체는 다음과 같다.\npackage BOJ;  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.*;  public class bj17140 { // need to be renamed as main   static Solution init() throws IOException{    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int r = Integer.parseInt(st.nextToken()) - 1;  int c = Integer.parseInt(st.nextToken()) - 1;  int k = Integer.parseInt(st.nextToken());   int[][] map = new int[101][101];  for (int i = 0; i \u0026lt; 3; i++) {  st = new StringTokenizer(br.readLine());  for (int j = 0; j \u0026lt; 3; j++) {  map[i][j] = Integer.parseInt(st.nextToken());  }  }   return new Solution(r, c, k, map);  }   public static void main(String[] args) throws IOException {  Solution s = init();  int answer = s.run();  System.out.println(answer);   } }  class Solution {  private int r;  private int c;  private int k;  private int[][] map;   public Solution(int r, int c, int k, int[][] map) {  this.r = r;  this.c = c;  this.k = k;  this.map = map;  }   public int run() {  int time = 0;  int rSize = 3;  int cSize = 3;  while(true) {  if (time \u0026gt; 100) {  time = -1;  break;  }  else if (map[r][c] == k) {  break;  } else {  if (rSize \u0026gt;= cSize) {  cSize = operateR(rSize, cSize);  } else {  rSize = operateC(rSize, cSize);  }  }  time++;  }  return time;  }   private PriorityQueue\u0026lt;Number\u0026gt; countValues(int[] values, int size) {  Map\u0026lt;Integer, Integer\u0026gt; KV = new HashMap\u0026lt;\u0026gt;();  PriorityQueue\u0026lt;Number\u0026gt; Q = new PriorityQueue\u0026lt;\u0026gt;();  for(int i=0; i\u0026lt;size; i++) {  if (values[i] != 0) {  KV.compute(values[i], (k, v) -\u0026gt; v == null ? 1 : v + 1);  }  }   for(Integer key : KV.keySet()) {  Q.offer(new Number(key, KV.get(key)));  }   return Q;   }   private int operateR(int rSize, int cSize) {  int newCSize = 0;  for (int i = 0; i \u0026lt; rSize; i++) {  PriorityQueue\u0026lt;Number\u0026gt; PQ = countValues(map[i], cSize);  newCSize = PQ.size() * 2 \u0026gt; newCSize ? Math.min(PQ.size() * 2, 100) : newCSize;  int idx = 0;  while(idx \u0026lt; 100) {  if (!PQ.isEmpty()) {  Number number = PQ.poll();  map[i][idx++] = number.getNum();  map[i][idx++] = number.getCount();  } else {  map[i][idx++] = 0;  }  }  }   return newCSize;  }    private int operateC(int rSize, int cSize) {  int newRSize = 0;  for(int i=0; i\u0026lt;cSize; i++) {  int[] col = new int[rSize];  for(int j=0; j\u0026lt;rSize; j++) {  col[j] = map[j][i];  }  PriorityQueue\u0026lt;Number\u0026gt; PQ = countValues(col, rSize);  newRSize = PQ.size()*2 \u0026gt; newRSize ? Math.min(PQ.size() * 2, 100) : newRSize;  int idx = 0;  while(idx \u0026lt; 100) {  if (!PQ.isEmpty()) {  Number number = PQ.poll();  map[idx++][i] = number.getNum();  map[idx++][i] = number.getCount();  } else {  map[idx++][i] = 0;  }  }   }  return newRSize;  }   }   class Number implements Comparable\u0026lt;Number\u0026gt; {  private int num;  private int count;   public Number(int num, int count) {  this.num = num;  this.count = count;  }   public int getNum() {  return num;  }   public int getCount() {  return count;  }   @Override  public int compareTo(Number number) {  if (this.count == number.count) {  return this.num \u0026gt; number.num ? 1 : -1;  } else {  return this.count \u0026gt; number.count ? 1 : -1;  }  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-18-problem_solving_8/","summary":"문제 링크\nProblem {: .alignCenter}\nSolve : 문제 자체를 푸는데도 꽤 걸렸지만, 쓸데 없는 부분에서 고생했던 문제라서, 살짝 열받아서 가져왔다.\n문제의 지문 자체가 그리 어렵지는 않지만, 시뮬레이션해서 이를 만들어줘야 하기 때문에, 이 부분에서 난이도가 좀 오르는 것 같다.\n접근 방법 : 다음의 순서를 반복하면 된다\n 행과 열 중, size가 더 긴 곳(같다면 행)을 선택한다. 더 긴 곳을 기준으로 돌면서(즉, 행이라면 하나의 행을 가져와서) 정렬을 수행한다.  정렬은 \u0026ldquo;숫자의 등장 횟수를 기준으로 오름차순\u0026rdquo; 숫자의 등장 횟수가 같다면, 숫자 자체의 크기를 기준으로 오름차순   각 정렬을 수행하면서, 달라진 최대 길이를 구한다.","title":"# 백준[No.17140] - 이차원 배열과 연산 ( Java )"},{"content":"1. 기본 개념 : Web server, Web application server, Servlet, Servlet Container\u0026hellip;\n처음 봤을 때에는, 각각이 무엇을 의미하는지, 무슨 차이가 있는지에 대해서 알지 못했다.\n이에 대해서 기본 개념을 정립하면 다음과 같다.\n1) Web server, Web application server(WAS) {: .alignCenter}\n : 우리가 html 파일을 만들고, 이를 더블클릭해서 열면, (대체로) 브라우저가 이 화면을 보여준다.\n이 때에는 Client와 Server의 개념이 딱히 없다. html이라는 양식을 통해 구성된, 어떤 화면을 Browser가 해석해서 우리에게 보여주는 것이다.\n이를 다른 사람에게 보여주려고 하면, 이 때부터 client와 server의 개념이 등장한다.\nclient는 말 그대로, 사용자다.\n우리가 네이버나 구글에 크롬 같은 Web browser로 접속을 하면,\nhttp 라는 프로토콜(규약)을 통해 해당 server. 즉 네이버 본사에 인터넷으로 요청을 하게 된다.\n그리고, web server는 요청을 받고,\n해당 사용자가 어떤 브라우저를 쓰는지 등의 데이터를 바탕으로 우리에게 화면을 보여준다.\n2) Static Page, Dynamic Page : 그리고 이 때, Static(정적) 페이지와, Dynamic(동적) 페이지로 구분이 된다.\nStatic Page는, 우리가 어떤 요청을 하면, 항상 같은 결과를 보여준다.\n현재 지금 포스팅을 작성하고 있는 이 페이지도, 정적인 페이지이므로, 우리가 뭔가 특별한 행동을 할 수는 없다.\nDynamic Page는, 우리가 요구하는 사항에 걸맞게 Contents를 반환한다.\nStatic Page는 마치 비유하자면, Java로 System.out.println(\u0026quot;안녕하세요\u0026quot;); 를 작성하는 것과 같다\n반대로 Dynamic Page는, Scanner sc = new Scanner(System.in); 과 같이,\nconsole에서 입력을 받고, 해당 내용을 System.out.println(sc.next()); 로 출력하는 것과 같다.\n똑같이 안녕하세요를 출력할 수 있지만,\n정적인 페이지의 경우 코드를 수정하지 않는 한 내가 무슨 짓을 하더라도 \u0026ldquo;안녕하세요\u0026rdquo; 만 출력될 것이고,\n동적인 페이지의 경우, 내가 \u0026ldquo;반갑습니다\u0026rdquo; 를 입력하면, \u0026ldquo;반갑습니다\u0026quot;를 출력할 것이다.\nStatic Page를 돌려주는 Server를 Web Server, 그리고 Dynamic Page를 돌려주는 Server를 Web application Server(WAS)라고 한다.\nWeb server에는 Apache Server, Nginx, IIS 등이 있고,\nWeb application Server는 Tomcat, JBoss, Jeus, Web Sphere 등이 있다.\n3) Web server and Web application are not exclusive : 또한, Web server와 WAS는 배타적으로 서로 하나를 선택해야 하는 관계는 아니다.\n만약, 누가 언제 들어와도 같은 결과를 보여줘야 하는, 즉 Static Page가 있는데,\n이를 DB에서 읽어와서, 이를 코드 레벨에서 html로 잘 바꿔서 돌려주는 작업을 하는 것은 자원의 낭비이다.\n즉, 굳이 WAS로 구성할 필요가 없다.\n(이에 더해, 물리적으로 분리해서 보안을 강화시키거나, 하나의 Web server에 여러개의 WAS를 붙여서 부하를 감당하게 할 수 있다.)\n따라서, 기본적으로 Web server를 앞에 하나 두고,\nStatic Page 일 경우 Web server가 처리하고,\nDynamic Page일 경우 Web server가 Web application server로 넘겨줘서 처리하면 된다.\n  Note. 여기를 참고하면,\nTomcat은 정확하게는 Web application server보다는 Servlet Container에 가깝다고 한다.\n아직 배움이 부족해서, EJB가 무엇인지 몰라 그런갑다 하고 넘겼다..\n  4) Servlet, Servlet Container : Servlet이란, Server Application + let(조각) 의 약자라고 한다.\n즉, 어떤 요청이 들어왔을 때, 이에 담당하는 하나의 프로그램(가시적으로는 .java, .class 파일)을 말한다.\n내가 Home directory에서 갈 수 있는 페이지가 A page, B page의 두 개의 Dynamic page라고 한다면, 각 페이지를 담당하는 프로그램을 servlet이라고 한다.\n그리고,Servlet Container는, 이렇게 여러 개의 Servlet을 갖고 있다가, A page에 대한 요청이 들어오면, A servlet으로 Mapping해서,\n요청사항(request)을 전달 한 뒤, 결과 값을 반환(response) 해주는 역할을 한다.\n이 또한, 음식점으로 비유해볼 수 있을 것 같다.\n만약 어떤 중국집에서, 짜장, 짬뽕과 같은 면 요리를 담당하는 요리사,\n그리고 탕수육, 깐풍기와 같은 튀김 요리를 담당하는 요리사가 둘이 있다고 해보자.\n이 각각의 요리사는 하나의 Servlet이다.\n고객으로부터 짜장이라는 요청이 들어오면, 면 요리사가 짜장을 요리해서 return한다.\n그리고, 매니저가 Servlet Container가 될 것이다.\n짜장이라는 Request가 들어왔다면, 짜장 요리사에게 전달해준다.\n그리고, 조리가 완료되면 이를 받아서 다시 고객에게 잘 플레이팅해서 Response 해준다.\n2. Tomcat 실행해보기 : 우선, Tomcat을 공식홈페이지 에서 다운받았다.\n작성일자(2020.09.17) 기준 최신 버전은 9.0.38 이다.\n{: .alignCenter}\n압축을 푼 뒤, 폴더를 열어서, /bin/startup.bat를 더블클릭해서 실행해보자.\n(실행이 안될 경우, 8080 port가 사용중인지, java 환경변수 설정을 했는지 확인해보자.)\n그리고, localhost:8080 으로 웹브라우저에 접속하면, 다음과 같은 화면을 볼 수 있다. {: .alignCenter}\n다음 포스팅에서, Tomcat 을 직접 수정하면서 다뤄보자.\nReference  Web Server와 WAS의 차이와 웹 서비스 구조  ","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-09-17-jsp_learning_01/","summary":"1. 기본 개념 : Web server, Web application server, Servlet, Servlet Container\u0026hellip;\n처음 봤을 때에는, 각각이 무엇을 의미하는지, 무슨 차이가 있는지에 대해서 알지 못했다.\n이에 대해서 기본 개념을 정립하면 다음과 같다.\n1) Web server, Web application server(WAS) {: .alignCenter}\n : 우리가 html 파일을 만들고, 이를 더블클릭해서 열면, (대체로) 브라우저가 이 화면을 보여준다.\n이 때에는 Client와 Server의 개념이 딱히 없다. html이라는 양식을 통해 구성된, 어떤 화면을 Browser가 해석해서 우리에게 보여주는 것이다.","title":"# 1. JSP 학습기록 - 기본 개념과 Tomcat 실행해보기."},{"content":"Directory : Tomcat을 직접 사용하면서, 우리가 쳐다봐야 할 부분은 크게 세 곳으로 나뉜다.\n bin conf webapps  bin 폴더는, tomcat을 실행하기 위한 여러 batch file 들이 저장된 곳이다.\nstartup.bat을 통해 tomcat을 실행시킬 수 있다.\nconf 폴더는, configuration의 약자로, 말 그대로 어떤 설정하는 파일들이 구성된 곳이다.\nwebapps 폴더는, 우리가 페이지를 구성하기 위한 파일들을 모아놓는 곳이다. 주로 이곳을 다루게 된다.\nwebapps : 먼저, webapps 폴더, 그리고 그 안에 있는 ROOT 폴더에 들어가보자.\n눈치가 빠르면 알겠지만, 우리가 localhost:8080 으로 접속했을 때 보이는 문서는\n여기에 있는 파일들을 통해서 이루어진 것이다.\nlocalhost:8080/index.jsp 를 입력해보면, localhost:8080 으로 접속했을 때와 같은 화면이 보인다는 것을 알 수 있다.\n그렇다면, demo.txt 라는 text 파일을 하나 만든 뒤, \u0026ldquo;This is demo.txt\u0026rdquo; 라고 적어보자.\n그리고, localhost:8080/demo.txt로 접속하면, This is demo.txt 라는 문서가 보일 것이다.\n{: .alignCenter}\nContext : Context란, 일종의 카테고리라고 생각하면 될 것 같다.\n혹은, 영어 이름 그대로의 \u0026ldquo;맥락\u0026rdquo; 이라고 이해해도 무관하다.\n네이버의 홈페이지를 보면, 메일, 카페, 블로그 등등의 여러 개의 sub 요소들이 존재한다.\n이를 하나의 프로젝트, 하나의 디렉토리에서 관리하고자 한다면,\n이를 개발하는 개발 팀들이 관리하기가 어려울 것이다.\n따라서, 이를 나누어서, 여러 개의 프로젝트, 여러 개의 디렉토리로 나눠서 개발하게 된다.\n이를 위해, 우리는 ROOT 폴더 하위에, myFolder 라는 이름의 폴더를 만들고, demo.txt를 해당 폴더로 옮겨보자.\n{: .alignCenter}\n잘 동작하는 모습을 볼 수 있다.\n그러나, 이것만으로는 만족할 수 없다. 프로젝트를 여러 개로 나눈다는 것은,\n완전히 다른 directory에서도 작업을 할 수 있어야 한다.\n따라서, 디렉토리를 다른 곳에서 만든 뒤에,\nTomcat에서는, \u0026ldquo;이게 내가 관리해야 하는 폴더 중 하나구나\u0026rdquo; 라는 것을 알 수 있도록\nconf 폴더의 파일에서 설정해줘야 한다.\n테스트를 위해, C:/ 바로 하위에 myFolder를 이동시켜보자.\n당연하게도, 이 상태에서는 localhost:8080/myFolder/demo.txt 를 입력하면\n404 Error가 나게 된다. Tomcat에서 \u0026ldquo;야 니가 말한거 없는데?\u0026rdquo; 라고 에러를 보내주는 것이다.\nconf 폴더로 이동해서, server.xml을 열어보자.\n밑으로 쭉 내려가다보면,\n\u0026lt;Host name=\u0026#34;localhost\u0026#34; appBase=\u0026#34;webapps\u0026#34;  unpackWARs=\u0026#34;true\u0026#34; autoDeploy=\u0026#34;true\u0026#34;\u0026gt;  ...  \u0026lt;/Host\u0026gt; 이와 같이 생긴 Host tag가 보인다. 이 사이에 한줄 추가해주자.\n\u0026lt;Context path=\u0026#34;My\u0026#34; docBase=\u0026#34;C:\\myFolder\u0026#34; privileged=\u0026#34;true\u0026#34;/\u0026gt; {: .alignCenter}\n{: .caption} 대소문자를 주의하자.\n저장하고, 톰캣을 재시작한뒤, localhost:8080/My/demo.txt 를 입력해보면,\n잘 동작하는 것을 확인할 수 있다.\n즉, My 라는 가상의 경로를, C:\\myFolder 라는 실제 경로로 mapping 시켜준 것이다.\nServlet : 오케이, 이제 이 Context라는 곳에서 우리가 개발을 하면 된다는 것을 알았다.\n이제, Servlet이라는 것을 한번 만들어보자.\nC:\\myFolder 하위에, myServlet.java 라는 파일을 하나 만들어보자.\nimport javax.servlet.*; import javax.servlet.http.*; import java.io.*;  public class myServlet extends HttpServlet {  public void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {  System.out.println(\u0026#34;This is myServlet.\u0026#34;);  } } 아래와 같이 코드를 작성하고, 이를 컴파일 시켜줘야 한다.\n이 때, HttpServlet 이라고 하는 클래스는, 자바에 기본적으로 내장된 클래스가 아니다.\n따라서, 이 클래스를 갖고 있는 라이브러리와 함께 컴파일 해줘야, myServlet이 올바르게 컴파일 될 수 있다.\ncmd를 열어서, 다음과 같이 작성하자.\njavac -cp C:\\TOOLS\\apache-tomcat-9.0.37\\lib\\servlet-api.jar C:\\myFolder\\myServlet.java\n이 때, C:\\TOOLS\\apache-tomcat-9.0.37\\lib\\servlet-api.jar 라고 하는 부분은,\n본인이 갖고 있는 tomcat 폴더로 작성해야 한다.\n이렇게 컴파일 하고 나면, myServlet.class 를 확인할 수 있다.\n{: .alignCenter}\n이 class file은, myFolder/WEB-INF/classes/ 라는 예약된 곳에 위치해야 하는데,\n해당 폴더를 그냥 만들게되면, 여러 web.xml과 같은 설정파일이 없으므로,\n일단은 ROOT/WEB-INF/classes 라는 폴더(classes는 기존에 없으므로 만들자)에 옮겨놓자.\n(IntelliJ 같은 IDE의 도움을 받으면, 이런 파일들이 자동으로 생성되어서,\nmyFolder에서 곧바로 사용할 수 있지만, 우리는 아직 IDE를 사용하지 않으므로 ROOT 폴더를 활용하자)\n{: .alignCenter}\n그리고, 여기서 끝이 아니다.\n방금전에 언급한 webapps/ROOT/WEB-INF/web.xml에서,\n우리가 해당 서블릿을 만들었다는 사실을 톰캣에게 알려줘야 한다.\n\u0026lt;servlet\u0026gt;  \u0026lt;servlet-name\u0026gt;my\u0026lt;/servlet-name\u0026gt;  \u0026lt;servlet-class\u0026gt;myServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt;  \u0026lt;servlet-mapping\u0026gt;  \u0026lt;servlet-name\u0026gt;my\u0026lt;/servlet-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/theServlet\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 위 코드를 조금만 들여다보면 알 수 있다 시피, servler-name 이라는 태그를 통해\n\u0026ldquo;my 라는 name의 서블릿을 만들었고, 이 서블릿을 실행하는 클래스는 myServlet 입니다\u0026rdquo;\ntheServlet이라는 이름의 url이 들어왔을 때, 해당하는 my 라는 name을 가진 서블릿을 호출하겠습니다.\n라고 두 가지를 알려줘야 한다.\n이렇게 하고, 톰캣을 실행시켜서 결과를 확인해보자.\n{: .alignCenter}\n그러나, 보면 실행 결과는 아무것도 없다.\n왜 그런가 하면, 우리가 해당 class로 하는 일은,\nSystem.out.println 으로 콘솔에 찍어주는 일 밖에 없기 때문이다.\n따라서, 실행시켰던 Tomcat을 확인해보자.\n{: .alignCenter}\n보면, 가장 마지막에 This is myServlet 이라는 서블릿이 정상적으로 호출되었음을 확인할 수 있다.\n다음 포스팅에서는, Servlet을 통해 \u0026ldquo;브라우저에\u0026rdquo; 입출력 하는 방법에 대해서 알아보자.\n","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-09-17-jsp_learning_02/","summary":"Directory : Tomcat을 직접 사용하면서, 우리가 쳐다봐야 할 부분은 크게 세 곳으로 나뉜다.\n bin conf webapps  bin 폴더는, tomcat을 실행하기 위한 여러 batch file 들이 저장된 곳이다.\nstartup.bat을 통해 tomcat을 실행시킬 수 있다.\nconf 폴더는, configuration의 약자로, 말 그대로 어떤 설정하는 파일들이 구성된 곳이다.\nwebapps 폴더는, 우리가 페이지를 구성하기 위한 파일들을 모아놓는 곳이다. 주로 이곳을 다루게 된다.\nwebapps : 먼저, webapps 폴더, 그리고 그 안에 있는 ROOT 폴더에 들어가보자.","title":"# 2. JSP 학습기록 - Tomcat 구조 파악부터 Servlet 만들기까지"},{"content":"들어가며 : Python을 다루다 보면, 어떤 함수에서 여러개의 인자를 받고 싶을때가 있다.\n이럴 때는 보통, list로 묶어서 보내는 경우가 대부분이다.\n그러나, Python을 계속해서 쓰다가 보면, 일종의 debugging을 위해 print()함수를 쓸 때가 종종 있는데,\nprint() 함수에 다음과 같이 여러개의 인자를 넘겨줄 때에는 list로 묶어서 보내지 않는 것을 볼 수 있다.\nprint(\u0026#34;안녕하세요, 제 이름은\u0026#34;, myName, \u0026#34;입니다.\u0026#34;) # \u0026#34;안녕하세요, 제 이름은 홍길동 입니다\u0026#34; 위 코드는, \u0026ldquo;안녕하세요, 제 이름은\u0026rdquo; 이라는 문자열, myName이라는 변수, 그리고 \u0026ldquo;입니다.\u0026rdquo; 라는 문자열의\n총 세개의 변수를 넘겨줬는데, 정상적으로 처리가 되는 모습을 볼 수 있다.\n이것이 어떻게 가능한 것일까? 이에 대해서 알아보자.\nWhat is Asterisk ? : Asterisk 라는 거창한 이름이 붙었지만, 한글로는 결국 \u0026ldquo;별표\u0026quot;다.\n2*3과 같은 곱하기나, 2**3과 같은 제곱을 제외하고,\n이 asterisk를 가장 대표적으로 많이 쓰는 케이스는, 함수다.\n다음의 예시를 보자.\ndef myFunction(*args):  print(type(args))  print(args)  print(*args)  myFunction(\u0026#39;alice\u0026#39;, \u0026#39;tom\u0026#39;, \u0026#39;john\u0026#39;) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # (\u0026#39;alice\u0026#39;, \u0026#39;tom\u0026#39;, \u0026#39;john\u0026#39;) # alice tom john 위와 같이, 여러개의 인자를 넘기더라도, 이를 tuple로 받을 수 있고,\nprint(*args)를 통해 unpacking이 이루어 지는 모습을 볼 수 있다.\n(다시 말해, print(*args) 는 print('alice', 'tom', 'john') 으로 변환된 것이다)\n즉, \u0026ldquo;내가 인자를 몇 개 받아야 할 지 모를 때\u0026rdquo; 사용할 수 있다.\n그러나, 다음의 코드를 보면, \u0026ldquo;그냥 리스트를 써도 되는거 아닌가?\u0026rdquo; 싶을 수 있다.\ndef sayHello(*nameList):  for name in nameList:  print(\u0026#34;Hello\u0026#34;, name) sayHello(\u0026#39;alice\u0026#39;, \u0026#39;tom\u0026#39;, \u0026#39;john\u0026#39;) # Hello alice # Hello tom # Hello john  def sayHello(nameList):  for name in nameList:  print(\u0026#34;Hello\u0026#34;, name) # Hello alice # Hello tom # Hello john 그러나, 만약 Hello 뒤에 Hello alice tom john과 같이 여러 개의 이름을 붙이고 싶다면 어떻게 해야 할까?\n아마 asterisk를 쓰지 않는다면, 이렇게 무식한 방법을 취할 수도 있다.\ndef sayHello(nameList):  print(\u0026#34;Hello\u0026#34;, end=\u0026#39; \u0026#39;)  for name in nameList:  print(name, end = \u0026#39; \u0026#39;) # Hello alice tom alice 이렇게 하는 것보단, 다음과 같이 쓰는 것이 깔끔하게 쓸 수 있다.\ndef sayHello(nameList):  print(\u0026#34;Hello\u0026#34;, *nameList) # Hello alice tom alice 또 다른 사용법으로는, 여러 개의 vector를 받아서, 이를 덧셈 연산하는 것에 활용할 수도 있다.\ndef sumVector(vectorList):  ret = []  for pos in range(len(vectorList[0])):  sum_ = 0  for vector in vectorList:  sum_+= vector[pos]  ret.append(sum_)  return ret sumVector([[1, 3], [2, 4], [6, 5]]) # [9, 12] 별로 보기 좋은 코드는 아니다. zip() 함수를 응용하자.\ndef sumVector(vectorList):  return [sum(i) for i in zip(*vectorList)] sumVector([[1, 3], [2, 4], [6, 5]]) # [9, 12] 아주 간단명료하게 해결할 수 있다.\n또한, asterisk를 두 개 써서, dictionary와 같은 key-value의 형태로도 받을 수 있다.\nkwargs 는 keyword arguments의 약자다.\ndef introduce(**kwargs):  print(\u0026#34;제 이름은\u0026#34;, kwargs[\u0026#39;name\u0026#39;], \u0026#34;입니다.\u0026#34;)  print(\u0026#34;제 나이는\u0026#34;, kwargs[\u0026#39;age\u0026#39;], \u0026#34;입니다.\u0026#34;) introduce(name=\u0026#34;홍길동\u0026#34;, age=25) # 제 이름은 홍길동 입니다. # 제 나이는 25 입니다. 이렇게 알고 나면, print() 함수가 어떻게 구성되어 있는지에 대한 감이 잡힐 것이다.\n","permalink":"http://cjlee38.github.io/post/language/python/2020-09-17-asterisk_of_python/","summary":"들어가며 : Python을 다루다 보면, 어떤 함수에서 여러개의 인자를 받고 싶을때가 있다.\n이럴 때는 보통, list로 묶어서 보내는 경우가 대부분이다.\n그러나, Python을 계속해서 쓰다가 보면, 일종의 debugging을 위해 print()함수를 쓸 때가 종종 있는데,\nprint() 함수에 다음과 같이 여러개의 인자를 넘겨줄 때에는 list로 묶어서 보내지 않는 것을 볼 수 있다.\nprint(\u0026#34;안녕하세요, 제 이름은\u0026#34;, myName, \u0026#34;입니다.\u0026#34;) # \u0026#34;안녕하세요, 제 이름은 홍길동 입니다\u0026#34; 위 코드는, \u0026ldquo;안녕하세요, 제 이름은\u0026rdquo; 이라는 문자열, myName이라는 변수, 그리고 \u0026ldquo;입니다.","title":"# Python Asterisk(*) 다루기"},{"content":"Prerequisite  Intellij Ultimate JDK Tomcat Environment Variable Settings  Create :\n  Welcome 화면에서, 새 프로젝트(New Project) 만든다.\n  Java - Project SDK에서 JDK를 설정하고,\n  Additional Libraries and Frameworks에서 JAVE EE - Web Application - WebService를 체크하고 Next 버튼을 누른다..?\n  {: .alignCenter}\n왠지 모르겠는데 나는 없다.\n공식 문서에도 이렇게 하라고 하는데, 나는 없다.\n각고의 구글링 끝에, 나와 비슷한 문제가 있던 질문 글을 발견\n얘기인즉, 좌측 Java Enterprise로 가서, SDK를 설정하고 Next 버튼을 누르면, 이를 선택할 수 있는 옵션이 나온다.\n(추가)\n스택오버플로우에 따르면, 2020.2 버전부터 사라졌다고 한다. 다음을 참고하자\n  It\u0026rsquo;s no longer possible. The only option is to downgrade to 2020.1 version.\nThe previous wizard was using obsolete technologies and frameworks with the libraries hosted on JetBrains servers always lagging updates and extremely hard to maintain. Now \u0026gt; we moved to Gradle/Maven projects where all the dependencies can be fetched from the public servers and the project can use up-to-date Java EE and library versions.\n  {: .alignCenter}\nWeb Profile을 체크한 후 Next.  {: .alignCenter}\n 적당히 이름을 붙여주고 프로젝트 생성\n  상단의 Run - Edit Configurations 클릭\n  좌측 상단의 + 버튼 누른 후, Tomcat Server - local 클릭\n  {: .alignCenter}\n 위 사진처럼, Application Server의 Configure 를 클릭하여 톰캣이 설치된 위치 설정\n  우측 하단의 Fix 클릭 -\u0026gt; artifact를 projectName:war 로 선택\n  Deployment 탭으로 넘어와서, Application context를 /ProjectName_war 를 /로 변경\n  webapp 우클릭 -\u0026gt; new -\u0026gt; JSP/JSPX로 index.jsp 생성\n  body 태그 사이에 Hello world! 작성 {: .alignCenter}\n  Run \u0026amp; 브라우저 열어서 localhost:8080\n  {: .alignCenter}\n잘 된다. 중간에 이상했던 부분때문에 꽤 애를 먹었다 ㅠ.\nif 안될 경우.. Check list\n JDK 경로 설정 확인 Tomcat 경로 설정 확인 환경변수 확인(cmd.exe -\u0026gt; java -version , javac -version) 기존에 Tomcat을 실행시켰는지 확인 8080 port가 이미 사용중인지 확인.  끝!\n","permalink":"http://cjlee38.github.io/post/tech/jsp/2020-09-11-jsp_project_with_intellij/","summary":"Prerequisite  Intellij Ultimate JDK Tomcat Environment Variable Settings  Create :\n  Welcome 화면에서, 새 프로젝트(New Project) 만든다.\n  Java - Project SDK에서 JDK를 설정하고,\n  Additional Libraries and Frameworks에서 JAVE EE - Web Application - WebService를 체크하고 Next 버튼을 누른다..?\n  {: .alignCenter}\n왠지 모르겠는데 나는 없다.\n공식 문서에도 이렇게 하라고 하는데, 나는 없다.\n각고의 구글링 끝에, 나와 비슷한 문제가 있던 질문 글을 발견","title":"# 0. JSP 학습기록 - Intellij JSP 프로젝트 생성"},{"content":"0. 들어가며 : 나는 프로그래밍에서 Naming이 정말 Critical한 중요성을 갖는다고 생각한다.\n새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,\n왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.\nPython에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는\n데이터를 저장하는 가장 대표적인 클래스다.\nPython의 dictionary 라는 이름을 보면,\n\u0026ldquo;음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!\u0026rdquo;\n이라고 유추해 볼 수 있지만,\nJava의 HashMap을 보면 잘 이해가 되지 않는다.\nMap이야 Key랑 Value를 Mapping한다는 의미로 쓰인것 같은데,\n\u0026ldquo;Hash? 내가 아는 그 Hash의 의미로 쓴게 맞나? 왜 Hash라는 이름을 쓴거지?\u0026rdquo;\n라는 의구심이 든다.\n또한, 흔히 \u0026ldquo;Key-Value의 시간복잡도는 O(1) 이다\u0026rdquo; 라고 한다. 왜일까?\nKey라고 하는 것은 결국, Index나 Memory의 위치가 아니라, Object일텐데,\n어떻게 O(1)이 나올 수 있을까?\n궁금증을 해결하기 위해,\n세계 모든 지식을 총망라하신 구선생님께 여쭤보았다.\n(공부하면서 작성한 것이니, 틀린 부분이 있다면 말씀해주세요.)\n1. Hash : Hash 자체에 대한 내용은 이 포스팅에서 다루지 않는다.\nHash에 대한 이해가 없으면, 이 글을 읽기가 조금 어려울 수 있다.\n(2020.09.25 수정)\nHash 맛보기\nHash에 관해서 포스팅했습니다.\n2. HashMap의 구조 : HashMap에 왜 Hash라는 이름이 붙었는지 이해하기 위해선,\n먼저 그 구조를 파악하는 것이 우선이다.\n{: .alignCenter}\n사진 출처\n먼저, bucket 이라는 Array가 있고,\n그 Array 내부에는 Node로 구성된 \u0026ldquo;LinkedList\u0026rdquo; 가 존재한다.\n즉, 이렇게 생긴 것을 \u0026ldquo;Hash table\u0026rdquo; 이라고 하고, Hash table을 통해 Key-Value를 관리하게 된다.\n기수정렬(Radix Sort) 할 때의 모습을 상상해보면 된다.\n3. HashMap의 동작 (이론편) : 대충 어떻게 생겨 먹었는지는 알겠으니, 어떻게 동작하는지에 대해서 한번 간략하게 익혀보자.\n데이터를 집어 넣는 과정을 이해하면, 꺼내는 것을 이해하는 것은 당연하게 여겨진다.\nHashMap에 put() 함수를 사용해서, 데이터를 넣고자 하면, 다음과 같은 과정이 일어난다.\n Key로 들어온 Object를 Hash화를 한다 Hash화한 값을 \u0026ldquo;배열의 인덱스\u0026rdquo; 로 지정한다. 해당 배열에 값이 존재하지 않으면, 그 위치에 Node라는 클래스로 Key-Value Object를 저장한다. 해당 배열에 값이 존재하면, 그 다음 위치에 새로운 Node를 연결하고 Key-Value Object를 저장한다.(즉, LinkedList로 관리한다.) List가 너무 길게 이어진다면, Tree로 변환한다. Hash충돌(Collision)이 너무 많이 발생한다면, Bucket. 즉 배열의 크기를 늘린다.  이해력이 좋은 사람이라면, 여기까지만 봐도 아하 할 수 있다.\n나같은 멍청이는 뭔소리야? 싶어서 결국 코드를 뜯어보고야 만다.\n4. HashMap의 동작 (코드편) : HashMap 에 데이터를 넣고자 하는, put() 함수로 이동해보자.\npublic V put(K key, V value) {  return putVal(hash(key), key, value, false, true); } 보는 바와 같이,\n hash()라는 함수를 실행한 key 원래 key value 뭔지 모를 false 뭔지 모를 true  가 있다.\nhash() 함수로 슬쩍 발 하나 담궈보자.\nstatic final int hash(Object key) {  int h;  return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } key가 null이라면 0을, null이 아니라면 key의 hashCode() 라는 함수를 실행한 값과, key의 Hash코드를 unsigned로 쉬프트 연산한 값을 XOR 연산한 것을 확인할 수 있다.\n이렇게 하면 어떤 값이 나온다는 것을 예측할 수 있다.\n이번 포스팅에서의 목적은 Hash가 어떻게 구현되는지가 아니므로,\n뭐 대충 어떤 숫자가 나왔다고 이해하고 넘어가자.\n다시 돌아와서, 이제 putVal() 이라는 곳으로 구경 가보자.\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,  boolean evict) {  Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i;  if ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length;  if ((p = tab[i = (n - 1) \u0026amp; hash]) == null)  tab[i] = newNode(hash, key, value, null);  else {  Node\u0026lt;K,V\u0026gt; e; K k;  if (p.hash == hash \u0026amp;\u0026amp;  ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))  e = p;  else if (p instanceof TreeNode)  e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value);  else {  for (int binCount = 0; ; ++binCount) {  if ((e = p.next) == null) {  p.next = newNode(hash, key, value, null);  if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash);  break;  }  if (e.hash == hash \u0026amp;\u0026amp;  ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))  break;  p = e;  }  }  if (e != null) { // existing mapping for key  V oldValue = e.value;  if (!onlyIfAbsent || oldValue == null)  e.value = value;  afterNodeAccess(e);  return oldValue;  }  }  ++modCount;  if (++size \u0026gt; threshold)  resize();  afterNodeInsertion(evict);  return null; } 꽤 길다. 그리고 복잡하다. 코드를 머릿속으로 Deserialize 하는데 좀 시간이 걸렸다.\nSection을 조금 나눠서 살펴보자.\nif ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length; 첫 if문에서 table, 즉 Hash테이블이 null 인지를 물어본다. 즉, \u0026ldquo;데이터를 처음 넣는거냐?\u0026rdquo; 라고 물어보는 것이다.\n참이라면, resize() 함수를 실행하고, 그 결과를 tab에, 그리고 그 길이를 n에 넣는다.\nif ((p = tab[i = (n - 1) \u0026amp; hash]) == null)  tab[i] = newNode(hash, key, value, null); 다음으로, table의 ((n-1) \u0026amp; hash) 위치. 즉 배열의 특정 index에 위치한 값이 null 이라면,\n다시 말해, 자리가 비어있다면, 해당 위치에는 새로운 Node를 만들어서 집어넣는다.\nelse {  Node\u0026lt;K,V\u0026gt; e; K k;  if (p.hash == hash \u0026amp;\u0026amp;  ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))  e = p; 아니라면, 즉 해당 위치에 무언가가(Node) 이미 존재한다면, else문으로 진입하게 된다.\n그 이후 등장하는 첫번째 if문은 \u0026ldquo;hash만 같은게 아니라, key 자체도 같은거야?\u0026rsquo; 라고 물어본다.\n맞다면, 해당 key를 교체하게 된다.\nelse if (p instanceof TreeNode)  e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); 그게 아니라면, 우선 해당 LinkedList가 Tree인지를 물어본다.\nTree라면, Tree에 맞게 값을 추가한다.\nelse {  for (int binCount = 0; ; ++binCount) {  if ((e = p.next) == null) {  p.next = newNode(hash, key, value, null);  if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash);  break;  }  if (e.hash == hash \u0026amp;\u0026amp;  ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k))))  break;  p = e;  } } 트리가 아니라면, LinkedList란 뜻이다. 그렇다면 해당 LinkedList를 돌면서,\n\u0026ldquo;Key까지 같으면, replace\u0026rdquo; 해주고, 처음 들어오는 놈이라면, 맨 끝에 이어붙이게 된다.\n그 과정속에서, bin. 즉 LinkedList의 길이가 너무 길다면, 이를 Tree로 바꿔준다.\nif (e != null) { // existing mapping for key  V oldValue = e.value;  if (!onlyIfAbsent || oldValue == null)  e.value = value;  afterNodeAccess(e);  return oldValue; } 여기서 e는 우리가 새로이 추가하고자 하는 Node를 가리킨다.\nelse문으로 분기한 이후, 우리가 지금까지 한 것은, Node를 추가할 위치를 찾는 것이었다.\n이제 값을 넣어야 한다. 해당 코드가 Key 안에 Value를 넣는것이다.\nonltIfAbsent는 \u0026ldquo;키가 이미 있으면, 안넣겠다\u0026quot;를 의미한다. 즉, 우리는 false를 넣어줬고, ! 가 붙었으므로 true이므로, 참이 되니 값을 교체할 수 있다.\n++modCount; if (++size \u0026gt; threshold)  resize(); afterNodeInsertion(evict); return null; 마지막으로, 수정된 횟수를 ++시키고,\nHashTable의 길이 또한 ++ 시킨 뒤, 일정 수준을 넘어서면 resize() 하게 된다.\nafterNodeAccess와 afterNodeInsertion은 LinkedHashMap에서 Override 되는 내용이므로 Pass한다.\nresize() 코드 또한 꽤 복잡하므로, 주석만 따왔다. 여기서는 다음과 같이 설명한다.\n Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.\n 즉, bucket을 초기화 하던지, 충돌이 너무 많이 일어나면 두배로 늘리겠다는 얘기다.\n이렇게 흐름을 읽고 나면, 왜 HashMap이 O(1)에 가까운 접근속도를 보이는지 알 수 있다.\n기본적으로, 데이터의 구조가 배열이므로 O(1)의 접근속도를 가지고, \u0026ldquo;해쉬\u0026quot;라는 것은 결국 일정 길이의 숫자를 return 하므로,\n\u0026ldquo;해쉬값을 통해 index 접근\u0026quot;을 진행하면, 어떤 Object 이던 O(1)으로 접근할 수 있다.\n그런데, 충돌이 아예 안일어난다면 좋겠지만, 이를 위해 배열의 길이를 너무 길게 만들면 공간의 낭비고, 그렇다고 적게 만들자니, 충돌이 일어날 때 문제가 생긴다. 따라서 충돌이 일어나면 LinkedList로 연결지어준다.\n이 LinkedList는 특정 길이를 넘어서면 Tree 형태를 갖게 되고,\n또한 충돌 자체도 많이 일어나면 배열을 늘리므로,\n이 LinkedList 혹은 Tree는 제한된 크기를 갖게 된다.\n5. 마치며 : 기존에 가졌던 궁금증이 모두 해소되었다.\nHash를 왜 사용했는지, 그리고 왜 시간복잡도가 이렇게 빠른 것인지 알 수 있었다.\n그런데, 또 한가지 궁금증이 발생한다.\nPython은 3.7 이후 Dictionary는 Ordered, 즉 순서를 갖는 Dictionary를 Default로 사용한다고 한다.\n얘는 또 어떻게 구현되었을지에 대해 알아보고 싶지만, 일단 여기에서 멈추자.\nReference\n Java HashMap은 어떻게 동작하는가? Hash Table은 프로그래머의 기본기 Java HashMap동작 원리  ","permalink":"http://cjlee38.github.io/post/language/java/2020-09-10-journey_to_java_hashmap/","summary":"0. 들어가며 : 나는 프로그래밍에서 Naming이 정말 Critical한 중요성을 갖는다고 생각한다.\n새로운 무언가에 대해서 배우고 나서, 그 이름을 다시 떠올려보면,\n왜 이걸 만든 사람들이 이 이름을 지었는지에 대해서 가닥이 잡힌다.\nPython에서의 dictionary, 그리고 Java에서의 HashMap은 Key-Value의 구조를 갖는\n데이터를 저장하는 가장 대표적인 클래스다.\nPython의 dictionary 라는 이름을 보면,\n\u0026ldquo;음, 사전이니까, 마치 단어사전 혹은 백과사전처럼, 어떤 이름과 그 안에 내용물을 갖춘 무언가겠군!\u0026rdquo;\n이라고 유추해 볼 수 있지만,\nJava의 HashMap을 보면 잘 이해가 되지 않는다.","title":"# (Java) HashMap 으로의 여행"},{"content":"0. 들어가며 : 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.\n변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),\n주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.\n두 번째로 마주하는 관문은, 자료구조다.\n기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,\n자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.\n물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다.\n이번 포스팅을 통해, 머릿 속에 있는 이 개념을 \u0026ldquo;자연스럽게\u0026rdquo; 머리, 가슴까지만 천천히 흘려보내보자.\n1. Array A. 형태 : 처음 LinkedList, 즉 연결 리스트를 처음 배웠을 때, 가장 많이 비교되는 대상은 배열이다.\n둘 다 연속적인 데이터를 표현하고 있기에 큰 차이가 없는 것으로 생각할 수도 있지만, 실제로 동작하는 방식은 꽤나 다르다.\n먼저, 기존의 C로 만든 배열에 대해서 이해해보자.\n#include \u0026lt;stdio.h\u0026gt; int main() {  int numbers[5] = {1, 2, 3, 4, 5};  int i = 0;   for(i = 0; i \u0026lt; 5; i++) {  printf(\u0026#34;%d\\n\u0026#34;, numbers[i]);  }   return 0; } // 1, 2, 3, 4, 5가 순서대로 출력. 위 간단한 코드에서, 우리가 쳐다봐야 할 부분은 printf() 함수를 사용하는 부분이다.\n배열의 요소를 순차적으로 탐색하고 있다. 이는 우리가 자연스럽게 이해하고 있는 부분이다.\n그러나, 기존의 printf()를 printf(\u0026quot;%p\\n\u0026quot;, \u0026amp;numbers[i]); 로 바꾸면 어떻게 되는가?\n이 코드는 기존의 \u0026ldquo;값\u0026quot;을 출력하던 것을, 대신에 \u0026ldquo;주소값\u0026quot;을 출력하게 해준다. 결과는 다음과 같다.\n 0x7ffc5c6f9810\n0x7ffc5c6f9814\n0x7ffc5c6f9818\n0x7ffc5c6f981c\n0x7ffc5c6f9820\n 뭔가 복잡해 보이지만, 아주 잠깐만 자세히 들여다보면, 뭔가 패턴이 있는 것을 알 수 있다.\n그 패턴은, 가장 끝 두자리만 바뀔 뿐, 앞은 똑같다는 것이다.\n또한, 16진수로 표기되어 있다는 점을 감안하면, 4씩 늘어나는 것도 알 수 있다.\n이것으로 우리는 \u0026ldquo;아, 배열은 여러 개의 변수를 만드는 건데, 이것들이 이어서 붙어있다\u0026rdquo; 라는 것을 알 수 있다.\nB. 장점 : 이 배열이라는 녀석의 특징이 \u0026ldquo;이어서 붙여져\u0026rdquo; 있다는 것을 알았다면,\n우리는 내가 찾고자 하는 녀석의 위치를 알고 있다면, 아주 순식간에 찾아낼 수 있다 는 장점을 알 수 있다.\n즉, 10개의 서랍이 있는 서랍장에서,\n3번째에 내가 찾고 있는 빨간 옷이 있다는 것을 이미 알고 있다면,\n3번째 서랍장을 바로 열면 되는 것이다.\n{: .alignCenter}\n{: .caption} \u0026lt; DRAWER \u0026gt;\nC. 단점 : 이렇게 아주 간단하고 유용한 배열은, 삽입과 제거에서 문제점을 안고 있다.\n가령, 위 [1, 2, 3, 4, 5] 라는 배열에서, 나는 중간에 10이라는 숫자를 집어넣고 싶다고 해보자 -\u0026gt; [1, 2, 10, 3, 4, 5]\n뭔가 간단해보인다. 그냥 넣으면 되는거아닌가? 하지만, 컴퓨터는 그렇게 똑똑하지 않다.\n이는 현실로 비유하면, 아주 좁은 간격으로 세워놓은 도미노에, 새로운 블럭 하나를 중간에 집어넣는것으로 생각해 볼 수 있다.\n기존에 세워놓은 블럭에, 새로운 블럭을 집어넣고 싶다면(기존에는 이를 집어넣을 공간이 충분하지 않다면) 그 뒤에 있는 블럭들을 다 뒤로 밀어줘야 한다.\n{: .alignCenter}\n{: .caption} \u0026lt; DOMINO \u0026gt;\n즉, 5번째(컴퓨터에서의 index는 4) 에 있는 5라는 숫자를 6번째으로 밀어주고,\n4번째에 있는 4라는 숫자를 5번째로 밀어줘야 한다.\n언제까지? 10이 들어갈 여유가 될 때 까지.\n지금은 예시가 간단하지만, 만약 배열 안에 원소가 1억 개가 있다고 해보자.\n그리고 더 최악으로, 우리는 \u0026ldquo;첫 번째\u0026quot;에 새로운 원소를 추가해야 한다고 해보자. 1억 번을 다 밀어야 한다.\n제거의 경우도 마찬가지다. [1, 2, 3, 4, 5] 에서, 3을 지우고 싶다. 어떻게 해야 할까?\n아마 3번째에 있는 3이라는 숫자를, 4번째에서 가져와서 4로 바꿔주고,\n그렇다면 4번째에 있는 4라는 숫자를, 5번째에서 가져와서 5라는 숫자로 바꿔주면 될 것이다.\n이 또한, 도미노로 생각해보면, 중간에 블럭 하나를 치우겠다고 하면,\n그 뒤에 있는 모든 블럭을 앞으로 가져와야 한다. 그래야 도미노가 제대로 쓰러질테니까\n2. LinkedList A. 형태 : 연결 리스트는, 위 배열에서 등장한 문제를 아주 손쉽게 해결해 줄 수 있다. 이를 구현하기 위해선, 포인터가 필요하다.\n왜인지는 다음의 예시를 차분히 읽어가면서 이해해보자.\n 가령, 학교에서 선생님이 방학 중에 각 학생들에게 어떤 공지사항을 알려주고 싶다고 해보자. 선생님은 방학 중이어도 일을 하기 때문에, 너무 바빠서 모든 학생들에게 공지를 해 줄 시간이 없다. 그래서, A라는 한 명의 학생에게 전화를 해서 알려주면, A 학생은 내용을 전달받고, B 학생에게 전화해서 공지사항을 전달해준다. 이렇게 해서 모든 학생들에게 전화를 돌리고 싶다고 해보자.\n 그럼 배열을 안쓰고 이렇게 전화를 한다고 하면, 어떻게 구현해야 할까?\n어떻게 해야 할지 계획은 세우지 못해도, 일단 각 학생들의 변수를 만들고 보면, int A, int B, int C\u0026hellip; 이런식으로 만들 것이다.\n근데 이렇게만 하면, int A가 int B와 연결고리. 즉 전화번호가 없다. 무슨 수로 공지사항을 전달할 것인가?\n이 때, 포인터라는 개념이 등장한다. 이 포인터라는 녀석이 다음 학생의 전화번호가 되는 셈이다.\n어떻게 포인터가 전화번호의 개념이 될까? 코드로 한번 살펴보자.\ntypedef struct Node { \tint called = 0; // 공지사항을 안내 받았는가? 0이면 받지 않음, 1이면 받음.  struct Node *next; // 다음 학생의 전화번호. }Node;   Note. 이 Node라는 녀석은, int, float 등등의 primitive 데이터 타입이 아닌, 우리가 새로 정의한 데이터 타입이다.\n따라서, 다음과 같이 사용해야 한다.\nNode *newNode = (Node*)malloc(sizeof(Node)); // newNode만큼의 공간을 확보 newNode-\u0026gt;called = 0; // newNode의 called를 0으로 정의 newNode-\u0026gt;next = existingNode; // newNode의 포인터(전화번호)를 다음 Node를 가리키도록 함.   이 구조체 Node 라는 녀석은 학생이다. 학생은 공지사항을 안내 받았는지에 대한 called 변수, 그리고 \u0026ldquo;다음 학생의 전화번호. 즉 Node를 가리키는 포인터\u0026rdquo; 를 갖고 있다.\n즉, 학생을 int A 라고 하는 정수형 변수로 만드는 것이 아니라, Node 라고 하는 녀석으로 만든다면, \u0026ldquo;서로 간의 연결고리가 이어진다\u0026rdquo;.\n이렇게 연결된 Data들을 묶어서 이름 그대로의 \u0026ldquo;Linked List\u0026rdquo; 라고 부르는 것이다.\nB. 장점 : 그렇다면, 이 LinkedList라는 것을 활용하면, 배열의 단점을 해소할 수 있지 않을까?\n학생의 예시로 다시 돌아와보자. 공지를 하려고 하는데, C 라는 학생이 전학을 가버려서 더 이상 해당 반의 학생이 아니게 되었다. 10명의 학생이 있었다면, 이제는 9명인 셈이다.\n이를 배열로 해결하려 한다면, 꽤 골머리 아픈 일인 것임을 아까 배웠다. LinkedList는 어떨까?\n아주 간단하다. C라는 학생의 전화번호를 알고 있는 학생은 B 학생이므로, B 학생이 갖고 있던 C의 전화번호를, D 라는 학생으로 바꿔주기만 하면 된다!\n그러면 끝이다.\nC. 단점 : 그러나, 이렇게 대단해 보이는 LinkedList에도 단점이 있다. 이는, 배열에서의 장점이었던 부분이다. 무엇일까?\n내가 **\u0026ldquo;몇 번째에 데이터가 있는지 알더라도, 곧바로 접근할 수 없다\u0026rdquo;**는 것이다.\n왜일까? 아주 단순하다. 사람이 됐건, 컴퓨터가 됐건, 특정 index에 있는 데이터를 \u0026ldquo;곧바로 접근\u0026quot;할 수는 없기 때문이다.\n아까 1-B에서 들었던 서랍을 생각해보자. 이번에는, 서랍이 아니라, 바구니라고 해보자.\n우리는 검은색 바구니에 우리가 찾는 빨간 옷이 있다는 것을 알고 있다.\n근데, 정작 중요한 검은색 바구니가 어디에 위치한지 모른다.\n왜일까? 이 검은색 바구니. 즉, 변수는 \u0026ldquo;컴퓨터가 알아서 빈 공간에 배치\u0026rdquo; 하기 때문이다.\n학생의 예시로 생각해보면, Z라는 학생에게 도달하기 위해서는,\n반드시 A가 갖고 있는 B의 전화번호라는 포인터를 통해서, B에게 가고,\nB가 갖고 있는 C의 전화번호라는 포인터를 통해서, C에게 가고.. 를 반복해야 한다.\n끝이 아니다. 첫 번째 문제 : 지금까지의 내용을 읽고, 다음과 같은 의문을 가질 수 있다.\n\u0026ldquo;C의 전화번호는 B가 갖고있고, B의 전화번호는 A가 갖고 있는데, 그럼 A의 전화번호는 누가 갖고있어요?\u0026quot;\n물론, 선생님이 전화번호를 알고 있기는 하다. 근데, 선생님도 같은 Node로 표현할 것인가?\n선생님은 학생들과 달리 조금 특별한데, 이걸로 될까? 학생을 추가하고, 삭제하고, 관리하는 녀석이 있었으면 좋겠다.\n내가 자료구조 수업을 들었을 당시 받았던 과제는, \u0026ldquo;웹 브라우저 흉내내기\u0026rdquo; 였다.\n즉, 우리가 웹페이지를 돌아다니면서, 뒤로가기를 누르면 이전 웹페이지가 나오고, 또 뒤로가기를 누르면 그 이전.. 뭐 이런식이다.\n또한, 앞으로가기, 홈페이지 가기 등등을 만드는 것이 필요했다.\n그렇다면, 뒤로가기를 했다가, 다시 앞으로 가기 등의 행위를 하려면, 무엇이 필요할까? 정답은 다음과 같다.\n 다음 Node를 가리키는 포인터 뿐만 아니라, \u0026ldquo;이전 Node를 가리키는 포인터도 필요하다.\u0026rdquo; 이런 형태를 Doubly Linked List\u0026quot;라고 부른다! \u0026ldquo;현재 페이지\u0026rdquo; 가 어디인지를 알아야 한다.  1번 문제를 해결하기 위한 Node의 구조체는 다음과 같다.\n#define LEN 100  typedef struct Node { \tchar data[LEN]; // 웹페이지의 주소를 저장(e.g. www.naver.com) \tstruct Node *next; // 다음 페이지를 가리키는 포인터 \tstruct Node *prev; // 이전 페이지를 가리키는 포인터 }Node; 또한, 2번 문제를 해결하기 위한 Node의 구조체는 다음과 같다.\ntypedef struct LinkedList { \tNode *head; // 첫 페이지를 가리키는 포인터 \tNode *cur; // 현재 페이지를 가리키는 포인터 \tNode *last; // 마지막 페이지를 가리키는 포인터 \tint NumOfData; // 방문 페이지의 개수 }List; 위 내용을 다 이해 했다면, 해당 코드를 이해하기는 수월할 것이다.\n두 번째 문제 : 학생 예시에서, 이러한 의문 또한 가질 수 있다. 무엇이냐?\n\u0026ldquo;학생 C가 전학을 가서, B가 갖고있는 C의 전화번호를 D의 전화번호로 바꾸어줬다면, C에 앞으로 접근 못하는 것 아닌가요?\u0026rdquo;\n맞다. 이를 Memory Leak. 메모리 누수라 한다. 메모리 누수는 중요하다.\n바구니를 아무리 안쓴다고 한들, 그 내용이 쓰레기라면 집 구석에 박아 놓으면 안된다.\n쓰레기가 암만 소량이라고 하더라도, 쌓이게 되면 결국 버려야 하는 것이다.\n잘 분리수거하고, 종량제 봉투에 깔끔하게 담아 버려야 한다.\n코드로는 어떻게 버려야 할까? 순서는 다음과 같다.\n 버릴 대상을 가리키는 임시 포인터 delNode를 만든다. (주의하자. delNode는 Node가 아닌 pointer다.) B학생의 전화번호를 D학생으로 바꾼다. free(delNode) 를 통해, delNode라는 포인터가 가리키는 노드(즉, C학생)를 삭제한다.  Node *delNode;  delNode = plist-\u0026gt;last; bNode-\u0026gt;next = dNode; free(delNode) 이렇게 하면, 쓰레기를 잘 분리수거해서 버리게 된다.\nArray? LinkedList? : 그렇다면, 언제 무엇을 사용할까?\n\u0026ldquo;결국 과정은 다르지만 결과는 같으니, 어려운 리스트보다는 배열을 사용할래요\u0026rdquo; 하면 안된다.\n이는 컴퓨터 알고리즘의 기초 중 기초인 시간복잡도에서 차이가 난다.\nArray의 시간복잡도는, 특정 index 접근은 O(1), 삽입/제거는 O(N) 이다. LinkedList의 시간복잡도는, 특정 index 접근은 O(N), 삽입/제거는 O(1) 이다.\n따라서, \u0026ldquo;내가 데이터의 변경을 자주 할 것 같으면 LinkedList, index 접근을 자주 할 것 같으면 array\u0026quot;를 선택하면 된다.\n  Note. O(1), O(N)은 최악의 경우를 가정한 시간복잡도를 나타내는 \u0026ldquo;빅오 표기법\u0026quot;으로 나타낸 수치이다.\nO(1)은, 최악의 경우에도 연산을 1번만 하고, O(N)은 최악의 경우에 N번, 즉 데이터의 개수만큼 연산을 한다는 의미이다.\n빅오 표기법에 대해서는 추후에 작성하겠다.\n  마치며 : 가볍게 쓰자고 마음 먹었는데, 아무래도 쉽게 쓰려다 보니 포스팅이 많이 길어졌다.\n그래도 뭐, 나쁘게 생각하지는 않는다. 이렇게 한번 이해하고 나면,\n본인이 작성한 코드가 잘못 되더라도, \u0026ldquo;왜 잘못되었는지에 대한 추론\u0026rdquo; 이 가능해지기 때문이다.\n어디서 잘못되었는지를 알아야, 머리가 살짝 고생하더라도 몸이 편해지는 것 같다.\n","permalink":"http://cjlee38.github.io/post/algorithm/data_structure/2020-09-10-what_is_linked_list/","summary":"0. 들어가며 : 개인적으로, C로 코딩을 시작했을 때 마주하는 가장 첫 번째 관문은 포인터라고 생각한다.\n변수에 값을 담는다는 것은 알겠는데(그마저도 자유자재로 다루기가 어려웠지만),\n주소값을 가리킨다는 말은, 번지 수라는 말을 붙여도 쉽게 와닿지는 않는 개념이다.\n두 번째로 마주하는 관문은, 자료구조다.\n기존에 변수, 배열, 구조체 등등이 충분히 모든 역할을 해줄 수 있을 것 같은데,\n자료구조가 왜 필요한지, 무엇을 도와줄 수 있는지에 대해서 알기가 어렵다.\n물론, 엄청난 과제와 학습량은 머릿속에 갓 넣은 지식을 강제로 손가락에 주입시켜준다.","title":"# 마음으로 이해하는 자료구조 : LinkedList ( feat. C )"},{"content":"들어가며 : 휴학을 한 이후, 스스로의 진로에 대해서 심도 깊은 고민을 난생 처음으로 하게 되었다. 사실 4학년이 되기 이전에는, 마치 내가 고3이 되어서 그제서야 \u0026ldquo;어느 대학을 가고 싶은지, 가야 하는지, 갈 수 있는지\u0026rdquo; 를 고민하기 시작한 것과 맥락이 비슷하다. 잠깐, 지난 몇 년간을 회고해보자.\n고등학교 : 거짓말이 아니고, 나는 고등학교 2학년 때까지만 하더라도, 소위 말하는 \u0026ldquo;스카이, 서성한\u0026rdquo; 밑의 대학은 무엇이 있는지 조차 몰랐다. 그 밑의 대학은 관심 줄 가치도 없다, 뭐 이런 대단한 이야기가 아니라, 정말 말 그대로 대학이란 것 자체에 관심이 없었다. 그냥 학교 다니면서 주변 친구들과 같이 피시방 가서 게임하는 것이 재미 있었을 뿐이었다. 소위 말해서 \u0026ldquo;게임에 인생을 갈아 넣었었다.\u0026rdquo; 고3이 되서야, 다른 여러 대학에 대해서 무슨 대학이 있었는지 알게 되었고, 지금 내 성적으로는 수시는 답이 없다는 점, 그나마 모의고사에서 성적이 조금 나온다는 점을 따져, 수시는 단 하나도 쓰지 않고 정시에 올인했다. 그 결과, 개인적으로 만족할 만한 대학에 합격했다.\n이 때는 정말 이것이 \u0026ldquo;천운\u0026rdquo; 이라는 것을 몰랐다.\n대학교 : 이제 와서, 1,2학년 때를 돌이켜보면, 세상 그렇게 어리석을 수가 없었다. 차라리, 동아리나 학교 행사 등에 참여했으면 몰랐을까(아싸라서 그럴 자신도 없었지만), 게임과 당구에 미쳤었다. 시험 2주전부터 벼락치기를 시작했고, 시험이 끝나면 수업만 적당히 듣고 다 내팽개쳤다. 미래에 내가 무엇을 할 지에 대해서는 \u0026ldquo;가볍게\u0026quot;만 걱정했지, 진지하게 대해본 기억이 거의 없다.\n공익 생활을 마친 이후, 학교로 돌아와 알 수 없는 이유에 쫓겨, 학교 공부에 매진했다. 그 때 배웠던 과목들이 재밌어서 였는지, 혹은 불안감에 쫓겨서인지는 지금도 단언할 수 없지만, 그래도 꽤 열심히 했다. 그 덕에, 내 노력을 알아준 교수님 몇 분이 알바나 인턴 자리도 제의해주셨다.\n대학교 4학년 : 나는 개인적으로, 심리학, 혹은 교육학에서 진지하게 연구해줬으면 하는 주제가 있다.\n나는 이를 \u0026ldquo;대4병\u0026rdquo; 이라고 명칭하고 싶다.\n왜 4학년이 되어서야, 사회로 진출한다는 것에 대한 두려움이, 왜 꼭 4학년이 되어서야 발생하는가? \n농담하는 것이 아니라, 내 주변의 모든 지인들은 4학년이 되면 본인의 방향성에 대해서 미친듯이 고민한다. 저학년 때는 잘 모른다. 머리로는 알아도, 가슴으로 와닿지 않는다. 체감이 안되는 것이다. 혹여나 이 글을 읽고 있는 1,2,3 학년이 있다면, 이 말을 다시 한번 생각해보길 바란다.\n왜? : 고등학교 때의 삶과, 대학교의 삶이 비슷한 맥락으로 흘러 간다면, 왜 대학교 4학년이 되어서야 이러한 걱정을 하게 되었을까? 개인적으로는 다음과 같은 이유가 있다고 생각한다.\n 고등학교 때에는, 정시라는 획일화된 제도가 존재했다. 고등학교 때에는, 나를 끌어주는 시스템과 주변인들이 존재했다. 고등학교 때에는, 지금 결정하는 내 판단이 내 미래를 얼마나 좌지우지 할지에 대해서 현실감이 없었다.  무엇이 얼마나의 원인을 차지했던 간에, 결국 대학교 4학년이라는, 올 것이 오고야 만 것이다.\n데이터 분석 : 블로그를 개설하기 이전에, 나는 데이터 분석에 관심이 있었다. 애초에, 마케팅 분야에서 제시하는, 인문학적으로 추론해내고, 이를 범주화 하여 네이밍하고, 교육하는 방식은 마음에 들지 않았다. 이중전공인 융복합소프트웨어 전공에서는 데이터 분석을 다루지 않았었지만, 1전공인 경영에서는 종종 데이터 분석과 관련된 수업이 개설되어, 3학년때부터 이 수업들 위주로 들었다. 그러나, 공부하면 공부할 수록, 바로 \u0026ldquo;수학\u0026rdquo; 이라는 태생적인 한계에 마주쳤다.\n기로 : 나는 컴퓨터와 관련된 것이라면, 어느 하나 빠지지 않고 관심이 생긴다. 최신 컴퓨터, 각종 IT 장비, 하드웨어, 소프트웨어 뭐 하나 가리는 것이 없다. 본투비 공돌이인가 싶기도 하다.\n이러한 점을 미루어 봤을 때, 데이터 분석이 과연 나에게 알맞은 직업일까? 나는 그저 컴퓨터로 **\u0026ldquo;분석\u0026rdquo;**을 하는 것이 아닌, **\u0026ldquo;컴퓨터\u0026rdquo;**로 분석을 하는 것이 재미가 있었던 것 아닐까? 하는 생각이 들었다.\n이와 더불어, 데이터 사이언스 계에서 알만한 사람은 안다는, 파 모 회사의 대표님이 운영하시는 블로그가 이 생각에 불을 지폈다.\n(여담이지만, 대표님이 자주 언급하시는(나쁜 말로, 종종 비하에 가까운) 두 전공을, 딱 내가 전공하고 있다. ㅋㅋㅋ)\n그렇다고 해서, 단순 코딩만 하는 삶을 살고 싶지는 않았다. 코딩을 잘 하는 것도 아니지만, 나는 문제의 원인을 찾아서 해결하는데에 희열을 느낀다. 또, 컴퓨터의 동작 원리나 설계가 어떻게 구성되어 있는지 등에 대한 \u0026ldquo;기초 지식\u0026quot;에 재미를 느낀다. 더불어, 데이터 분석이라는 분야도 먼 나라 일인 것처럼 대하고 싶지는 않고, 오히려 가까이 등을 맞대고 싶다.\n그렇다면, 남은 선택지는 데이터 엔지니어가 된다.\n도망? : 좋은 말로 포장하고, 합리적으로 선택한 것 같아 보이지만, 결국 수학이라는 학문으로부터 도망치는 것 같이도 보인다.\n그러나, 혹여 경영학전공이나 컴퓨터전공에서 출발하여 데이터 분석을 희망하는 사람이 있다면, 이렇게 묻고 싶다.\n당신은 학부 4년, 혹은 더 넘어서 석,박사 과정을 거친 전문가들을 이길 수 있나? \n통계학, 계량경제학 등의 머신러닝에 유망한(혹은 적합한) 전공을 하는 사람들은 , 말 그대로 해당 분야를 \u0026ldquo;전공\u0026rdquo; 했다.\n당신이 4년동안 경영,컴공에서 들인 노력 만큼, 그 사람들도 그 시간 만큼 노력했다. 근데, 내가 과연 몇 달, 혹은 길면 1~2년을 공부 한다고 해서, 그 사람들을 따라 잡거나, 혹은 이길만큼 실력이 될까? 된다고 말하면 할 말은 없다. 나는 그렇지 못해서 데이터 분석을 포기했다.\n지난번에 입상한 공모전만 떠올려 보더라도, 아주 많은 문제가 있다.\n같이 공모전을 했던 친구들과 가끔씩, 우리가 얼마나 멍청했었는지에 대해서 이야기 하곤 한다.\n당장 문제를 떠올려 보더라도, \u0026ldquo;null값인 데이터가 랜덤으로 등장했는가, 아닌가\u0026rdquo;, \u0026ldquo;이상치는 무엇으로 정할 것이며, 그것이 타당한가?\u0026ldquo;라는 사소한 것 부터, \u0026ldquo;cardinality가 높은 데이터를 어떻게 처리하는 것이 올바른가?\u0026rdquo;, \u0026ldquo;로그 데이터와 매치가 되지 않는 유저 데이터는 그냥 버려도 되는 것인가?\u0026rdquo; 등등이 떠오른다. 이보다 더 나아가면, 어떤 변수를 선택하고, 버릴것인지? 왜 그 변수를 선택했는지? 그렇게 결정한 데이터로 어떤 모델을 사용할 건지? 본인이 선택한 모델과 데이터가 적합하게 Fitting 되는지, 단순 Accuracy만 높은것은 아닌지? 데이터의 형태가 모델에 걸맞지 않다면, 이를 재구성하기 위해 어떤 preprocessing을 할 것인지, 그리고 이 모든 과정이 수학적으로 \u0026ldquo;엄밀하게\u0026rdquo; 검증되었는지 라는.. 끝이 없는, 원론적이며 당연한 이야기가 줄줄이 흘러나온다. 하물며 나같이 모르는 사람도 이런 이야기들이 떠오르는데, 잘 아는 사람이 보면\u0026hellip;\n혹은, 반대로 생각해볼 수 있다. 데이터 분석을 공부하거나, 공모전에 나가거나, 혹은 실무에 적용하려고 할 때, 경영/컴공적 지식들이 얼마나 활용되었을까? 운영체제를 알아서, 메모리가 터져나가는 걸 보면서 가상 메모리 할당도 해보고, Online으로 Model Training 시켜보기도 할 수 있다. 근데, 그건 엔지니어링의 영역이지 분석의 영역이 아니지 않나? 주피터 노트북을 열어서 데이터 분석을 할 때, 흔히 말하는 객체지향설계, 디자인패턴 등의 Code Level의 철학을 깊게 고민하고 작성해본 적이 얼마나 될까? 그리고 그게 모델링에, 내 분석결과에 도움을 주었는가? 엔지니어링과 분석의 영역은 엄연히 나눠야 한다고 생각한다.\n또한, 컴퓨터 과학쪽에도 엄연히 수학적 사고가 필요하다. 그러나, \u0026ldquo;내가 데이터 사이언티스트가 되기 위해 필요한 수학적 지식의 수준\u0026quot;과, \u0026ldquo;데이터 엔지니어가 되기 위해 필요한 수학적 지식의 수준\u0026quot;은 아무래도 차이가 있을 것이라고 생각한다.\n그렇다면 : 앞으로의 로드맵을 그려본다면, 어떻게 될까?\n데이터 엔지니어가 하는 일에는, 본질적으로 데이터가 있다. 데이터가 어디서 오는가? 서비스에서 온다. 서비스의 규모가 커질수록, 데이터의 규모도 커지고, 데이터 엔지니어링의 업무가 발생한다. 즉, 학생 수준에서는 이러한 데이터를 얻기가 어렵다. 그렇다면? 우선은 서비스다.\n하여, 당장 추상적인 생각으로는, 서비스를 직접 개발하던, 혹은 백엔드 개발자로 취직을 하던, 데이터가 발생하는 곳으로 취업을 한 뒤, 데이터 엔지니어로 보직을 변경하는 것이 나에게 걸맞은 수순이라고 본다.\n아직 갈 길이 너무 멀다. ㅠ\n","permalink":"http://cjlee38.github.io/post/diary/2020-09-09-why_data_engineer/","summary":"들어가며 : 휴학을 한 이후, 스스로의 진로에 대해서 심도 깊은 고민을 난생 처음으로 하게 되었다. 사실 4학년이 되기 이전에는, 마치 내가 고3이 되어서 그제서야 \u0026ldquo;어느 대학을 가고 싶은지, 가야 하는지, 갈 수 있는지\u0026rdquo; 를 고민하기 시작한 것과 맥락이 비슷하다. 잠깐, 지난 몇 년간을 회고해보자.\n고등학교 : 거짓말이 아니고, 나는 고등학교 2학년 때까지만 하더라도, 소위 말하는 \u0026ldquo;스카이, 서성한\u0026rdquo; 밑의 대학은 무엇이 있는지 조차 몰랐다. 그 밑의 대학은 관심 줄 가치도 없다, 뭐 이런 대단한 이야기가 아니라, 정말 말 그대로 대학이란 것 자체에 관심이 없었다.","title":"# 왜 나는 데이터 엔지니어를 바라보는가"},{"content":"문제 링크\nPROBLEM {% raw %} 문제 설명\n셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.\n(a1, a2, a3, \u0026hellip;, an)\n튜플은 다음과 같은 성질을 가지고 있습니다.\n중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)\n원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.\nex : (1, 2, 3) ≠ (1, 3, 2)\n튜플의 원소 개수는 유한합니다.\n원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, \u0026hellip;, an)이 주어질 때(단, a1, a2, \u0026hellip;, an은 자연수), 이는 다음과 같이 집합 기호 \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026lsquo;를 이용해 표현할 수 있습니다.\n{{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, \u0026hellip; {a1, a2, a3, a4, \u0026hellip;, an}}\n예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는\n{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}\n와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로\n{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}\n{{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}\n{{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}\n는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.\n특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.\n[제한사항]  s의 길이는 5 이상 1,000,000 이하입니다. s는 숫자와 \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;,\u0026rsquo; 로만 이루어져 있습니다. 숫자가 0으로 시작하는 경우는 없습니다. s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다. s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다. return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.  [입출력 예]  \u0026ldquo;{{2},{2,1},{2,1,3},{2,1,3,4}}\u0026rdquo; -\u0026gt; [2, 1, 3, 4] \u0026ldquo;{{1,2,3},{2,1},{1,2,4,3},{2}}\u0026rdquo; -\u0026gt; [2, 1, 3, 4] \u0026ldquo;{{20,111},{111}}\u0026rdquo; -\u0026gt; [111, 20] \u0026ldquo;{{123}}\u0026rdquo;\t-\u0026gt; [123] \u0026ldquo;{{4,2,3},{3},{2,3,4,1},{2,3}}\u0026rdquo; -\u0026gt; [3, 2, 4, 1]  SOLVE : 문제에서 설명하는대로, 튜플은 **\u0026ldquo;순서\u0026rdquo;**를 따져야 한다. 처음 30초간은 \u0026ldquo;그냥 가장 긴놈 return하면 되는거 아닌가?\u0026rdquo; 싶었는데, 예제 2번과 같이, \u0026ldquo;set 내에서의 순서는 무관\u0026rdquo; 하다는 걸 보고 아니라는 것을 알았다.\n1. 접근 방법 : 즉, 어떻게 접근해야 하느냐?\n\u0026ldquo;길이가 1인 set에서 등장하는 녀석\u0026rdquo; -\u0026gt; \u0026ldquo;길이가 2인 set에서 처음 등장하는 녀석\u0026rdquo; -\u0026gt; \u0026hellip; \u0026ldquo;길이가 n인 set에서 처음 등장하는 녀석\u0026rdquo; 순서로 담아줘야, 올바른 tuple이 된다.\n다시, 입출력 예제 2번을 보자\n\u0026ldquo;{{1,2,3},{2,1},{1,2,4,3},{2}}\u0026rdquo;\n원소의 길이가 1인 set은 {2} 이므로, 처음에 2를 담는다.\n다음으로, 원소의 길이가 2인 set은 {2,1} 이므로, 처음 등장하는 1을 담는다.\n다음으로, 원소의 길이가 3인 set은 {1,2,3} 이므로, 처음 등장하는 3을 담는다.\n마지막으로, 원소의 길이가 4(n)인 set은 {1,2,4,3} 이므로, 처음 등장하는 4를 담는다.\n따라서, 최종적으로 [2, 1, 3, 4]가 된다.\n이를 위해선, 다음의 두 가지 과정이 필요하다.\nA. 입력이 \u0026ldquo;문자열\u0026rdquo; 이므로, 이를 잘 나눠서 이중 배열에 담아야 한다.\nB. 위에서 언급한대로, tuple에 잘 담는다.\n문자열 파싱하기 : 간단하게, set을 구분하는 구분자는 \u0026ldquo;},{\u0026rdquo; 이므로, 이 구분자를 기준으로 split 한 뒤에, 남은 brackets를 삭제하고, 담으면 된다. 즉\nArrayList\u0026lt;String[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); String str = \u0026#34;{{1,2,3},{2,1},{1,2,4,3},{2}}\u0026#34;; // String[] sets = str.split(\u0026#34;},{\u0026#34;); // wrong. String[] sets = str.split(\u0026#34;\\\\},\\\\{\u0026#34;); // split 할 때, bracket을 character로 받으려면 이와 같이 escape를 붙여줘야 한다. sets = sets.replace(\u0026#34;{\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;}\u0026#34;); list.add(sets.split(\u0026#34;,\u0026#34;)); 문자열을 파싱하는 방법은 이것 말고도 여러 방법이 있을 것이다.\n2. 첫 번째 방법 위 순서를 그대로 따르는 전체 코드는 다음과 같다.\npackage Programmers;  import java.util.ArrayList; import java.util.LinkedList;  public class p64065 {  public int[] solution(String s) {  ArrayList\u0026lt;String[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();  LinkedList\u0026lt;String\u0026gt; tuple = new LinkedList\u0026lt;\u0026gt;();  String[] sets = s.split(\u0026#34;\\\\},\\\\{\u0026#34;);   for (String set : sets) {  set = set.replace(\u0026#34;{\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;}\u0026#34;,\u0026#34;\u0026#34;);  list.add(set.split(\u0026#34;,\u0026#34;));  } // 문자열 파싱 \u0026amp; 배열형태로 ArrayList에 담는다.   for(int i = 1; i \u0026lt;= sets.length; i++) { // set의 개수 만큼 i번 반복  for (String[] set : list) {  if (set.length == i) { // set 중에서, 현재의 길이(i)와 같다면  for (String num : set) {  if (!tuple.contains(num)) { // 새로 등장하는 요소를 추가.  tuple.add(num);  break;  }  }  }  }  }   int[] answer = new int[tuple.size()]; // LinkedList를 Array로 변환해서 제출  for(int i=0; i\u0026lt;tuple.size(); i++) {  answer[i] = Integer.parseInt(tuple.get(i));  }    return answer;  } } } 3. 두 번째 방법 : 근데, 뭔가 찝찝하다. 중간에 배열에 담는 과정을 보면, for문이 세번이나 중첩되어 있다. if문까지 보면 indentation이 5번이나 되는데, 이런 코드를 보고 있노라면 굉장히 심적으로 불안해진다.\n물론, list를 돌 때마다, 이미 확인한 set은 삭제하는 방법을 사용할 수도 있지만, 근본적인 해결책은 되지 않는다.\n문제를 해결하자마자, 다른 사람의 코드를 찾아 보니, HashMap을 쓰는 방법도 있다는 것을 알게 되었다.\njson(혹은 dictionary) 형태로 HashMap을 들여다보면 다음과 같이 생겼다. Key는 원소로, Value는 원소의 등장 횟수로 보는 것이다.\nmap = {  2 : 4,  1 : 3,  3 : 2,  4 : 1 } 처음에 주어진 문자열에서, curly brackets가 한 개이던, 두 개이던 신경쓰지 않는다(즉, flatten 한다.)\n그리고, 등장하는대로, 없으면 새로 만들고, 있으면 ++ 시킨다.\n이제 tuple이라는 이름의 배열에 담을 때에는, \u0026ldquo;숫자가 많은 순서\u0026quot;대로 담기만 하면 되는 것이다.\n아주 신묘한 해결책인 것 같다. 이를 코드로 표현하면 다음과 같다.(원 코드는 Java 8 문법을 사용해서 아주 우아하고 멋있게 짰지만, 그대로 copy \u0026amp; paste 하기엔 양심에 찔려서.. 동일 아이디어로, 나만의 아주아주 허접한 방식대로 코드를 작성했다.)\npackage Programmers;  import java.util.HashMap;  public class p64065 {  public int[] solution(String s) {  HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  String[] elements = s.replace(\u0026#34;{\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;}\u0026#34;,\u0026#34;\u0026#34;).split(\u0026#34;,\u0026#34;); // 문자열 파싱   // HashMap에 저장  for (String e : elements) {  Integer key = Integer.parseInt(e);  Integer value = map.get(key);  if (value == null) { map.put(key, 1); }  else { map.put(key, value + 1); }  }   // Key-Value를 Reversing  HashMap\u0026lt;Integer, Integer\u0026gt; reversed = new HashMap\u0026lt;\u0026gt;();  for (Integer i : map.keySet()) {  reversed.put(map.get(i), i);  }   // 배열의 0번부터 n번까지, element의 개수가 n개부터 1개인 녀석까지 담음.  int[] answer = new int[reversed.size()];  for(int i = 0; i \u0026lt; reversed.size(); i++) {  answer[i] = reversed.get(reversed.size() - i);  }  return answer;  } } 마치며 : 아마 첫 번째 코드는 실제로 효율성까지 체크 했다면 바로 나가리였을 것이다. 항상 느끼지만, 문제를 곧이 곧대로 받아들이기보다는, 한 단계 더 Develop 해서 다른 각도에서 쳐다볼 수 있어야 진정한 PS 고수로 거듭날 수 있지 않을까 싶다.\n{% endraw %}\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-07-problem_solving_7/","summary":"문제 링크\nPROBLEM {% raw %} 문제 설명\n셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.\n(a1, a2, a3, \u0026hellip;, an)\n튜플은 다음과 같은 성질을 가지고 있습니다.\n중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)\n원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다.\nex : (1, 2, 3) ≠ (1, 3, 2)","title":"# 프로그래머스[Lv.2] - 튜플 ( java )"},{"content":"0. 서론 : 파이썬 사용자에게, 파이썬에서 가장 자주 사용하는 자료형이 무엇이냐고 물어보면, 원시 타입(Primtive type)을 제외하고는, list라고 답할 것이다.\n  Note. 사실, 파이썬에서는 원시타입이 존재하지 않는다. 우리가 사용하는 int, float .. 등등은 사실 객체이다. 이는 당장 python에서 help(int) 라고만 입력해보면, 다음과 같이 나타난다.\n  Help on class int in module builtins:\n  class int(object)\n| int([x]) -\u0026gt; integer\n| int(x, base=10) -\u0026gt; integer\n| | Convert a number or string to an integer, or return 0 if no arguments\n| are given. If x is a number, return x.int(). For floating point\n| numbers, this truncates towards zero.\n  \u0026hellip; 이하 생략\n  이러한 list는 다양한 잡기술이 존재하는데, 이를 하나하나 살펴보자.\n1. list indexing : 리스트를 indexing 하는 법에 대해서는 많은 사람들이 알고 있다.\n그런데, 이렇게 사용하는 것은 흔하게는 보지 못하였을 것이라 생각한다.\n_list = [1,2,3,4] print(_list[::2])  -\u0026gt; ??? 기존에는 colon(:) 을 한번만 사용했는데, 두개를 사용한다. 어떤 결과가 나타날까? 정답은 다음과 같다.\nprint(_list[::2]) -\u0026gt; [1, 3] indexing 없이 그냥 print 했다면 [1,2,3,4] 가 나와야 할텐데, 첫 번째와 세 번째가 나타났다. 즉, colon을 두 번 쓰고 숫자를 입력하면, 이는 step이 된다.\n즉, _list[start : end : step] 인 셈이고, start와 end가 생략되었으니 전체 list에 대해 순회하면서, step만큼 움직인다.\n다시 말해, 기존에 계단을 한 칸씩 오르던 것을, 이제는 두 칸씩 오르겠다는 말이다.\n이를 조금 응용하면, 다음과 같이 사용할 수도 있다.\nprint(_list[::-1]) -\u0026gt; [4,3,2,1] 기존에 계단을 한 칸씩 오르던 것을, 이제는 한 칸씩 내려가겠다는 의미가 된다.\n2. list 합치기 : list 를 합치는 방법에는, 다음의 세 가지 방법이 사용된다.\n + operator append() extend()  1. + operator : + 연산자는 말 그대로, list끼리 더하는 역할을 해준다.\n다음과 같은 list가 존재한다고 해보자.\n_list = [1,2,3,\u0026#39;a\u0026#39;] 그리고, 여기에 새로이 4.5 라는 요소를 추가하고 싶다면, 다음과 같이 사용하면 된다\n_list += [3.5] 아주 명료하다.\n2. append() : append는 영어로 덧붙이다, 추가하다.. 이런 뜻을 가지고 있다.\n개인적으로는 덧붙이다 라는 표현이 좀 더 걸맞는 듯 하다. 위 list에서, 3.5를 추가하는 방법은 다음과 같다.\n_list.append(3.5) 이 또한, 아주 간단명료하다.\n그러나, 눈썰미가 좋은 분은, 한 가지 차이점을 발견하였을 것이다.\n\u0026quot; 1번에서는 list를 더해줬는데, 2번에서는 3.5라는 float을 더해주네요?\u0026quot; {: .caption}\n이는, list 자료형의 append 함수를 help(list.append)를 통해 살펴보면 알 수 있다.\nappend(self, object, /) : Append object to the end of the list. 즉, list의 끝에 float이라는 object를 붙였기 때문에 이와 같이 나타나는 것이다.\n따라서, 다음과 같이 사용할 경우, 의도한 대로 결과가 나타나지 않는다.\n_list.append([3.5]) print(_list) -\u0026gt; [1,2,3,\u0026#39;a\u0026#39;,[3.5]] 3. extend() extend() 함수는 결과적으로 1번의 덧셈 연산자와 같은 결과를 내놓는다. 그러나, 다음과 같은 차이점이 있다.\n위와 같은 list에서, 역시 3.5를 추가하고 싶다고 해보자.\n_list.extend(3.5) -\u0026gt; TypeError: \u0026#39;float\u0026#39; object is not iterable 무슨 에러인고 하니, float은 iterable하지 않다는 뜻이다. 즉, 반복할 수 없다는 말이 된다.\n이 또한 help(list.extend)를 통해 설명을 보면 알 수 있는데, append와 달리 extend는 object가 아닌 iterable한 객체를 받기 때문에 발생하는 일이다.\nextend(iterable, /) method of builtins.list instance Extend list by appending elements from the iterable. 즉, 다음과 같이 사용해야 한다.\n_list.extend([3.5])  Note. extend()와 append()는 객체 내에 있는 요소를 변경시키기 때문에, return 값을 반환하지 않는다.(사실 null을 반환한다) 따라서, _list2 = _list.append(3.5) 혹은 _list2 = _list.extend([3.5]) 이와 같이 사용해서는 안되고, 마찬가지로 _list + [3.5]라고 사용한다면, _list에는 3.5가 들어가지 않을 것이다.\n 4.1 extend() + String 그렇다면, extend()에 string을 넣는다면 어떻게 될까?\nString은 결국 char의 sequential이므로, iterable한 객체이다. 따라서, 다음과 같이 사용할 수 있다.\n_list.extend(\u0026#34;Hello\u0026#34;) print(_list) -\u0026gt; [1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] 보는 바와 같이, Hello가 각각의 character로 나누어져 하나씩 들어간 모습을 볼 수 있다.\n3. list comprehension : list comprehension은 정말 유용하면서도, 몇 번을 사용해도 손가락이 순차적으로 움직이지 않고, 커서가 Home과 End를 들락거리는 마성을 가진 녀석이다.\n1) 기본 : 일반적인 형태는 다음과 같다.\n_list2 = [e for e in _list] # e는 element의 약자이다. print(_list2) -\u0026gt; [1, 2, 3, \u0026#39;a\u0026#39;] 단순히 이렇게 생긴 것만 봐서는, 얘가 뭘 의미하는 건지 모른다.\n일반적인 for문과 차이점이라면, for문 앞에 e라는 녀석이 있고, 그 for문 전체를 []로 감싸고 있다는 것만 보인다.\n2) 조건문 : 이 list comprehension의 파워는 if/else의 조건문이 붙었을 때 힘을 발휘한다. 예시를 위해, 우리가 _list에서 int형인 녀석만 뽑아오고 싶다고 해보자. 그러면 다음과 같이 작성했을 것이다.\n_list2 = [] for e in _list:  if isinstance(e, int) == True:  _list2.append(e)  # 혹은 _list2 += e print(_list2) -\u0026gt; [1, 2, 3]   Note. isinstance()는 내장함수로써, \u0026ldquo;이 instance가 해당 class 소속인가요?\u0026rdquo; 하고 물어보는 것이다. 첫 번째 인자로 instance를, 두 번째 인자로 class를 넣어주면, True/False의 boolean으로 return된다. java의 instanceof와 비슷하다.\n  위 코드를 list comprehension으로 바꾸면, 다음과 같이 작성할 수 있다.\n_list2 = [e for e in _list if isinstance(e, int)] print(_list2) -\u0026gt; [1, 2, 3] print문을 제외하고, 4줄인 코드가 1줄로 감소하였다. 또한, 이 문법을 알고 있다면, 가독성도 훨씬 늘어난다.\n단순 if문 뿐만 아니라, else문도 다음과 같이 추가할 수 있다. 다만, if 하나만 넣는 것과 달리, if else를 같이 쓰면 위치가 다르다는 것을 명심하자.\n_list2 = [e if isinstance(e, int) else 0 for e in _list] print(_list2) -\u0026gt; [1, 2, 3, 0] if문의 조건에 맞으면 e를 그대로 사용하고, 아니라면 0을 집어넣겠다는 의미가 된다.\n  Note 1. 사실, list comprehension에서 사용되는 if else문은 list comprehension에 종속된 문법이 아니라, 변수를 할당할 때에도 사용될 수 있는 문법이다. 다음의 예시를 참고하자.\na = 1 b = a if a \u0026gt; 10 else 0 print(b) -\u0026gt; 0    Note 2. Note 1의 문법을 참고하면, 다음과 같이 사용할 수도 있다. 파이썬의 함수를 정의할 때, default 값을 줄 수 있다는 것을 알고 있을 것이다.\ndef myFunc(a = 1, b = 2):  # do something 헌데, default 값에 조건문을 주고 싶다면, 이를 조금 응용하면 된다..\ndef myFunc(a = 1, b = 2):  a = a if b == 2 else 0  # do something 이렇게 작성하면, b가 2일 경우에는 a를 그대로 사용하고, 2가 아닐 경우에는 a에는 어떤 값이 들어왔었더라도, 0이 할당될 것이다.\n  3) 중첩 : list comprehension은 중첩해서 쓸 수도 있다. 다음과 같은 list가 있다고 해보자.\n_list = [[1,2,3], [4,5,6], [7,8,9]] 이를 일반적인 list comprehension을 사용해 접근한다면, 첫 번째 요소는 [1,2,3] 이라는 list고, 두 번째 요소는 [4,5,6], 세 번째 요소는 [7,8,9]가 된다.\n각각의 1, 2, 3 \u0026hellip; 9 의 int data를 접근하고 싶다면, 다음과 같이 사용하면 된다.\n[e for l in _list for e in l] 첫 번째 for문에서, 접근하는 요소인 l에 대해서, 다시 한번 for문을 통해 e라는 객체에 접근하겠다는 뜻이다.\n이 또한, if else문을 섞어줄 수 있다.\nprint([e for l in _list for e in l if e \u0026lt; 5]) -\u0026gt; [1, 2, 3, 4] print([e if e \u0026lt; 5 else 0 for l in _list for e in l ]) -\u0026gt; [1, 2, 3, 4, 0, 0, 0, 0, 0]  _list2 = [[1,2,3], [4,5], [7,8,9]] # 두 번째 list element의 6 제거 print([e if e \u0026lt; 5 else 0 for l in _list2 if len(l) \u0026lt;= 2 for e in l ]) -\u0026gt; [4, 0] 그런데, 이렇게 쓰면 쓰면 쓸수록 복잡해지고, 가독성도 떨어진다. 따라서, 이렇게 nested list comprehension을 사용하는 경우는 중첩 list를 flatten 하는 상황이 대부분이다.\nprint([e for l in _list for e in l]) -\u0026gt; [1, 2, 3, 4, 5, 6, 7, 8, 9]   Note 1. 그러나, 사실 이 flatten 하는 과정 마저도, sum() 함수를 통해 쉽게 해결할 수 있다.\n_list2 = sum(_list, []) 이 또한 help(sum)을 입력해보자.\nHelp on built-in function sum in module builtins: sum(iterable, start=0, /)\nReturn the sum of a \u0026lsquo;start\u0026rsquo; value (default: 0) plus an iterable of numbers\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types.\nsum 또한 iterable 객체를 첫 번째 인자로 받고, 두 번째 인자는 start = 0 으로 default는 숫자이다. 따라서, start를 빈 객체로 바꿔준다면, 위 2-1 번에서 설명한 덧셈 연산자와 같은 효과를 발휘하게 된다.\n   Note 2. 다음과 같이 사용하는 것을 \u0026ldquo;최대한 지양\u0026rdquo; 해야 한다.\n[_list2.append(e) for e in _list] 위 코드를 실행하면, append는 null을 return하므로, list comprehension을 받는 변수가 있다면, 이는 null로 이루어진 list가 된다. 이렇게 사용하는 것을, 파이썬 사용자들은 최대한 피하기를 권하고 있는데, 그 이유는\n 위 코드를 실행하면, null 값이 들어있는 list object가 생성되었다가 소멸되므로, 자원의 낭비가 생기며 Explicit 하게 작성하는 것을 목표로 하는, 파이썬의 이념(혹은 convention)에 어긋나기 때문이다.  한마디로, 저렇게 쓰는 것은 \u0026ldquo;쓸데없는 겉멋\u0026rdquo; 이라는 것이다.\n  결론적으로, list comprehenson은 정말 유용한 문법임은 맞지만, 이를 남용하는 일이 없도록 주의해야 한다.\n끝.\n","permalink":"http://cjlee38.github.io/post/language/python/2020-09-05-play_with_python_list/","summary":"0. 서론 : 파이썬 사용자에게, 파이썬에서 가장 자주 사용하는 자료형이 무엇이냐고 물어보면, 원시 타입(Primtive type)을 제외하고는, list라고 답할 것이다.\n  Note. 사실, 파이썬에서는 원시타입이 존재하지 않는다. 우리가 사용하는 int, float .. 등등은 사실 객체이다. 이는 당장 python에서 help(int) 라고만 입력해보면, 다음과 같이 나타난다.\n  Help on class int in module builtins:\n  class int(object)\n| int([x]) -\u0026gt; integer\n| int(x, base=10) -\u0026gt; integer\n| | Convert a number or string to an integer, or return 0 if no arguments","title":"# Python list 다뤄보기 ( a.k.a. 잡기술 )"},{"content":"문제 링크\nPROBLEM {: .alignCenter}\n예제 입력 4\n1 1 5 31\n1 1 6 30\n5 15 8 31\n6 10 12 10\n예제 출력 2\nSOLVE 1) 주의점 : 처음에는 \u0026ldquo;꽃들의 총 개수\u0026rdquo; 라는 말이, literal 하게 꽃의 count 인 줄 알았는데, 곰곰히 생각해보니 \u0026ldquo;꽃의 종류의 개수\u0026rdquo; 라는 말이 더 정확한 것 같다. 즉, \u0026ldquo;3월 1일부터 11월 30일까지 최소 한 가지 이상의 꽃이 피어있어야 함을 의미한다.\n아무튼, 해당 문제에서 주의해야 할 점은 다음과 같다.\n 꽃이 지는 날짜는, 그 날에는 꽃이 이미 져있다는 것을 의미한다. 즉, 6월 13일이라고 표시되어 있다면, 6월 12일까지만 꽃이 피어 있다. 정원에 심을 꽃의 개수는 \u0026ldquo;최소한\u0026rdquo; 이어야 한다. 3월1일부터 11월 30일까지 꽃이 피어있어야 한다. 주어진 꽃들이, 조건을 만족할 수 없는 경우가 존재할 수 있다.  2) 접근 방법 : 두 가지의 아이디어를 코드로 녹여내는 것이 중요하다.\nA. 날짜를 어떻게 비교할 것인지? (즉, 대소비교를 어떻게 할 것인지?)\nB. 최소 개수를 어떻게 구할 것인지?\nA. 날짜 비교 : 우선, 입력을 받은 후에, 입력 받은 각 시작날짜와 종료날짜를 대소비교를 위해 month와 date를 Integer로 바꾼 뒤, month에 100을 곱했다.\n우리가 원하는 것은 \u0026ldquo;날짜 간의 비교\u0026rdquo; 이지, \u0026ldquo;날짜 간의 연산\u0026quot;이 아니기 때문에, 이렇게 해도 문제가 없다. 날짜 간의 연산이었다면, month를 date에 통합하는 과정이 필요했을 것이다.\nB. 최소 개수 : 꽃의 개수가 최소한이어야 한다는 말은, 바꿔 말하면 꽃이 최대한 오래 살아남을 수록 좋다는 의미가 된다.\n따라서, 그리디 알고리즘의 아이디어를 적용하면, 다음과 같은 순서를 반복하면 된다.\n 3월 1일을 초기 기준으로 잡는다. 3월 1일보다 앞선(이른) 날짜가 start인 꽃 들(즉, 3월 1일을 포함하여, 그 이전에 피는 꽃들) 중에서, 가장 늦게 지는 꽃의 end 날짜를 구한다. 2번에서 구한 가장 늦게 지는 꽃의 날짜를 기준으로 잡는다. 3번에서 정한 기준보다 앞선 날짜가 start인 꽃(e.g. 5월20일 이었다면, 5월 20일 이전이 start인 꽃 들 중에서, 가장 늦게 지는 꽃)의 날짜를 구한다\u0026hellip;. 이 과정을 반복한다. 가장 늦게 지는 꽃의 날짜가 11월 30일 초과인 경우, 이를 중단하고, 그 때 까지의 count를 센다.  이를 그림으로 표현하면 다음과 같다.(문제의 예제 입력을 토대로 진행한다.)\n(S : 3월1일 / E : 11월 30일 / C : 기준)\n\u0026ndash;\u0026gt; 1. 초기는 아래와 같다.\n 　S　E\n------------------\nC(3월 1일)\n \u0026ndash;\u0026gt; 2. 3월1일보다 앞서서 피는 꽃들 중(1 1 5 31, 1 1 6 30), 가장 늦게 지는 꽃의 end 날짜를 구한다. 해당 예제에서는, 6월 30일이다.\n\u0026ndash;\u0026gt; 3. 6월 30일이 새로운 기준이 된다. 또한, 6월 30일은 11월 30일 이전이므로, 중단하지 않고 계속 진행된다. 따라서, 아래 그림과 같이 된다.\n 　S　E\n------------------\nC(6월30일)\n \u0026ndash;\u0026gt; 4. 6월 30일보다 일찍 피는 꽃들(1 1 5 31, 1 1 6 30, 5 15 8 31, 6 10 12 10) 중에서, 가장 늦게 지는 꽃의 end날짜를 구한다. 여기서는 12월 10일이 된다.\n\u0026ndash;\u0026gt; 5. 12월 10일이 새로운 기준이 된다. 그러나, 11월 30일 이후이므로, loop를 중단한다.\n 　S　E\n------------------\nC(12월10일)\n 이런식으로 반복하면, 정상적인 경우의 꽃 종류의 최소 개수를 구할 수 있다.\n그러나,\n주어진 꽃들이, 조건을 만족하지 않는 경우가 존재한다.\n가령,\n3월1일 이전에 피는 꽃이 없다거나,\n혹은 중간에 계속 연결되어서 필 수 있는 꽃이 없다거나,\n혹은 11월30일까지 피는 꽃이 없다거나..\n따라서, 우리가 고려해야 할 Case는 다음과 같다.\n[정상 처리되는 경우] Case 1. 일반적으로 연결되는 경우\ne.g.\n문제의 예제 입력과 같음\nCase 2. 한번에 연결되는 경우\ne.g.\n2\n1 5 12 20\n3 5 8 3\n(출력 : 1)\n[비정상 처리되는 경우] Case 3. 앞쪽이 없는 경우 (모든 시작일이 3월1일 이후)\ne.g.\n3\n3 5 5 20\n5 15 8 20\n6 10 12 20\n(출력 : 0)\nCase 4. 중간에 연결이 안되는 경우\ne.g.\n2\n1 1 5 20\n5 25 12 20\n(출력 : 0)\nCase 5. 뒤쪽이 없는 경우 (모든 종료일이 11월 30일 이전)\ne.g.\n2\n1 5 5 20\n5 15 11 30 (출력 : 0)\nCase 3, 4, 5 인 경우는 loop를 중단하고 count를 0으로 초기화시켜야 한다.\n해당 Case인지 알아내는 방법은 간단하다. 위 순서를 반복하면서, 만약 \u0026ldquo;새로운 기준이 정해진다면\u0026rdquo; (즉, 위 예시에서는 기존의 3월1일이라는 기준에서 6월 30일이라는 기준으로 새로이 변경되는 경우를 의미한다.), 이는 곧 정상적으로 처리되었음을 의미한다.\n바꿔 말해서, 기준이 변하지 않는다면, 모두 비정상적인 상황이므로 count는 0이 되어야 한다.\n위 5가지 상황을 고려해서, 코드로 구현하면 다음과 같다.\npackage BOJ;  import java.util.Scanner; import java.util.HashMap;  public class p2457 {   public static int getCalendarDate(String month, String date) {  return (Integer.parseInt(month) * 100) + Integer.parseInt(date);   }   public static void main(String[] args) {  final int START_DATE = 301;  final int END_DATE = 1201;   Scanner sc = new Scanner(System.in);  int N = Integer.parseInt(sc.nextLine());  int count = 0;   HashMap\u0026lt;Integer, Integer\u0026gt; flower = new HashMap\u0026lt;\u0026gt;();   // data를 입력 받아서 HashMap에 저장함.  // 이 때, key는 중복될 수 있으므로, 중복되는 경우 end_date(지는 날짜)가 더 긴 flower가 put 되야함.  for (int i = 0; i \u0026lt; N; i++) {  String[] rawDate = sc.nextLine().split(\u0026#34; \u0026#34;);  int start = getCalendarDate(rawDate[0], rawDate[1]);  int end = getCalendarDate(rawDate[2], rawDate[3]);   if (flower.get(start) == null || flower.get(start) \u0026lt; end) { // 새로운 end가 기존의 end보다 길다면  flower.put(start, end);  }  }   boolean flag = false;  int current = START_DATE; // 기준. 초기값은 301(3월1일)  while (current \u0026lt; END_DATE) { // 기준이 11월30일을 넘어서면 stop  int max = current;  for (int key : flower.keySet()) { // 전체 꽃을 돌면서  if (key \u0026lt;= current \u0026amp;\u0026amp; max \u0026lt; flower.get(key)) {  // 여기가 핵심이다.  // 기준 날짜보다 먼저 피는(기준날짜도 포함해서) 꽃들 중에서, 가장 날짜가 멀리 있는 꽃을 찾는다.  max = flower.get(key);  flag = true;  }  }   if (flag) { // 정상처리 되었다면, 가장 먼 날짜를 기준으로 변경한다.  current = max;  flag = false;  count++;  } else { // flag가 false라는 것은, 기준이 변경되지 않았음을 의미한다.  // 따라서, 비정상인 경우이므로 count를 0으로 초기화하고 loop를 중단한다.  count = 0;  break;  }   }   System.out.println(count);  sc.close();  }  } 마치며. : 문제 자체의 난이도는 그리 높지 않으나, 구현하기가 꽤 까다로운 문제이다.\n또, 두 개의 꽃이 (1 1 5 20,5 20 12 20)과 같이, 딱 알맞게 떨어지는 경우도 고려해야 하고, 여러모로 신경써야 할 부분이 많다.\n여담으로, 문제를 풀고나서 다른 사람들은 어떻게 했나 구글링해보니 죄다 C++ 이어서 약간 당혹스러웠다. 진정한 알고리즘 고수들은 C++을 쓰는건가..?\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-04-problem_solving_6/","summary":"문제 링크\nPROBLEM {: .alignCenter}\n예제 입력 4\n1 1 5 31\n1 1 6 30\n5 15 8 31\n6 10 12 10\n예제 출력 2\nSOLVE 1) 주의점 : 처음에는 \u0026ldquo;꽃들의 총 개수\u0026rdquo; 라는 말이, literal 하게 꽃의 count 인 줄 알았는데, 곰곰히 생각해보니 \u0026ldquo;꽃의 종류의 개수\u0026rdquo; 라는 말이 더 정확한 것 같다. 즉, \u0026ldquo;3월 1일부터 11월 30일까지 최소 한 가지 이상의 꽃이 피어있어야 함을 의미한다.\n아무튼, 해당 문제에서 주의해야 할 점은 다음과 같다.","title":"# 백준[No.2457] - 공주님의 정원 ( Java )"},{"content":"문제 링크\nPROBLEM 오픈채팅방 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.\n신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.\n[닉네임]님이 들어왔습니다.\n채팅방에서 누군가 나가면 다음 메시지가 출력된다.\n[닉네임]님이 나갔습니다.\n채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.\n 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다. 채팅방에서 닉네임을 변경한다.  닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.\n예를 들어, 채팅방에 Muzi와 Prodo라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.\nMuzi님이 들어왔습니다.\nProdo님이 들어왔습니다.\n채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.\nMuzi님이 들어왔습니다.\nProdo님이 들어왔습니다.\nMuzi님이 나갔습니다.\nMuzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.\nProdo님이 들어왔습니다.\nProdo님이 들어왔습니다.\nProdo님이 나갔습니다.\nProdo님이 들어왔습니다.\n채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.\nProdo님이 들어왔습니다.\nRyan님이 들어왔습니다.\nProdo님이 나갔습니다.\nProdo님이 들어왔습니다.\n채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.\n제한사항\n record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다. 다음은 record에 담긴 문자열에 대한 설명이다.  모든 유저는 [유저 아이디]로 구분한다. [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - Enter [유저 아이디] [닉네임] (ex. Enter uid1234 Muzi) [유저 아이디] 사용자가 채팅방에서 퇴장 - Leave [유저 아이디] (ex. Leave uid1234) [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - Change [유저 아이디] [닉네임] (ex. Change uid1234 Muzi) 첫 단어는 Enter, Leave, Change 중 하나이다. 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다. 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다. 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다. 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.    입출력 예\n record : [\u0026ldquo;Enter uid1234 Muzi\u0026rdquo;, \u0026ldquo;Enter uid4567 Prodo\u0026rdquo;,\u0026ldquo;Leave uid1234\u0026rdquo;,\u0026ldquo;Enter uid1234 Prodo\u0026rdquo;,\u0026ldquo;Change uid4567 Ryan\u0026rdquo;] result : [\u0026ldquo;Prodo님이 들어왔습니다.\u0026rdquo;, \u0026ldquo;Ryan님이 들어왔습니다.\u0026rdquo;, \u0026ldquo;Prodo님이 나갔습니다.\u0026rdquo;, \u0026ldquo;Prodo님이 들어왔습니다.\u0026rdquo;]  SOLVE 위 문제에서, 신경써야 할 부분은 다음과 같다.\n 닉네임을 몇 번을 변경을 해도, 최종적인 닉네임이 해당 user에게 모두 적용되어야 한다. 닉네임은 중복이 가능하다. 유저는 고유의 id값을 갖는다.  위 내용을 보았을 때, Map을 이용해야겠다는 생각이 들었는데, 그 이유는 다음과 같다.\n Key-value structure에서, Key는 중복이 불가능, Value는 중복이 가능하다. 따라서, user ID는 key로, 닉네임은 Value로 사용하면 될 것이다. User ID를 tracking 하면, 닉네임을 알 수 있어야 한다.  따라서,\n세 개의 명령어 (Enter, Leave, Change) 중, 가장 먼저 신경써야 할 부분은 Enter와 Change 에 따른 최종 map을 우선 구성하는 것이고, 이를 Enter와 Leave에 따라 문자열을 list에 add 하면 된다.\n  Note. 만약 이게 실시간 시스템이었다면, record의 list를 그대로 진행하면서 만약 Change가 생긴다면 그 앞에 등장한 Enter와 Leave에서, Change에 해당하는 ID를 찾아서 그 옆에 있는 닉네임 String을 다 새로 바꿔주고.. 해야할 수도 있지만\n일단은 문제에서 최종적으로 방을 개설한 사람이 보게 되는 메시지 가 관건이므로, Change를 모두 적용 시킨뒤, 그 다음 Enter와 Leave에 따라 문자열을 채워 넣는 방식을 택했다.\n  이를 코드로 작성하면 다음과 같다.\nimport java.util.LinkedList; import java.util.HashMap;  class Solution {  public String[] solution(String[] record) {  HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;();   // Change 혹은 Enter인 경우 {userID - nickname}를 map에 등록  for (int i = 0 ; i \u0026lt; record.length; i++) {  String[] spt = record[i].split(\u0026#34; \u0026#34;);  if (spt[0].equals(\u0026#34;Change\u0026#34;) || spt[0].equals(\u0026#34;Enter\u0026#34;)) {  map.put(spt[1], spt[2]);  }  }   // 다시 list를 돌면서, id 값에 해당하는 nickname을 list에 추가  LinkedList\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;();  for (int i = 0; i \u0026lt; record.length ; i++) {  String[] spt = record[i].split(\u0026#34; \u0026#34;);  if ( spt[0].equals(\u0026#34;Enter\u0026#34;) ) {  list.add(map.get(spt[1]) + \u0026#34;님이 들어왔습니다.\u0026#34;);  } else if ( spt[0].equals(\u0026#34;Leave\u0026#34;)) {  list.add(map.get(spt[1]) + \u0026#34;님이 나갔습니다.\u0026#34;);  } else {  continue;  }  }   // 최종 결과를 array로 바꿔서 return  return list.toArray(new String[list.size()]);  } } ","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-09-03-problem_solving_5/","summary":"문제 링크\nPROBLEM 오픈채팅방 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.\n신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.\n[닉네임]님이 들어왔습니다.\n채팅방에서 누군가 나가면 다음 메시지가 출력된다.\n[닉네임]님이 나갔습니다.\n채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.\n 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.","title":"# 프로그래머스[Lv.2] - 오픈채팅방 ( java )"},{"content":"0. 들어가며 : 2020년 1학기에 수강했던 종합설계 과목에서, 우리 조의 주제는 \u0026ldquo;시간표 추천 시스템\u0026rdquo; 이었다.\n본인이 원하는 공강시간, 학점 범위, 그리고 내가 미리 골라놓은 듣고자 하는 수업을 선택하면, 이전에 내가 수강했던 과목들을 기반으로 \u0026ldquo;남는 시간에, 이걸 듣는건 어때?\u0026rdquo; 라는 개념으로 시간표를 구성해서, 제공해주는 시스템을 제작하고자 하였다.\n그 과정에서, \u0026ldquo;비즈니스프로그래밍2\u0026rdquo; 수업에서 배웠던 \u0026ldquo;연관규칙\u0026quot;을 활용할 수 있을 것이라 판단했고, 이에 대해서 공부하기 시작하였다.\n1. 연관규칙이란? : 흔히, 장바구니 분석이라고도 한다. 경영학을 전공하고 있는 사람이라면, 마케팅 수업에서 \u0026ldquo;맥주를 사는 사람은 대개 기저귀도 같이 산다\u0026rdquo;(혹은 반대로, 기저귀를 사는 사람은 대개 맥주도 사더라) 라는 이야기를 들어본 적이 있을 것이다.\n전혀 연관이 없어 보이는 두 item이 왜 자주 같이 등장하는가? 를 살펴봤더니, 퇴근한 아빠가 집에서 아이를 돌보던 엄마로부터 \u0026ldquo;기저귀좀 사와라\u0026rdquo; 라는 말에 마트를 들리면서, 겸사겸사 맥주도 한 캔 산다는 이야기다.\n즉, \u0026ldquo;하나의 item을 샀을 때, 다른 item이 얼마나 자주 등장하는가?\u0026rdquo; 를 다루는게 연관규칙 분석이다.\n조금 어려운 말로는, \u0026ldquo;연관규칙은 데이터베이스에서 Transaction(거래)의 동시출현성향에 대한 관계성을 표현한다\u0026rdquo; 고 한다.\n  Note. Transaction 이란?\nTransaction이란 \u0026ldquo;하나의 거래\u0026quot;를 의미한다. 위 예시에서는, \u0026ldquo;맥주와 기저귀를 구매한 이력\u0026quot;이 된다.\n달리 말하면, 하나의 영수증이 Transaction이 된다.\n  2. 연관규칙의 평가척도 : 그렇다면, 단순하게 \u0026ldquo;A를 샀을 때, B가 자주 등장한다\u0026rdquo; 면, 이를 무조건 연관지어서 생각할 수 있을까? 이를 평가하는 방법에는 여러가지가 있을 것이다.\n이를 찾아보면 정말 다양한 분석 기법이 있지만, 이번 포스팅에서는 이 평가 척도를 \u0026ldquo;지지도(Support), 신뢰도(Confidence), 향상도(Lift)\u0026rdquo; 의 세가지만 다룬다.\n1) 지지도(Support) : 먼저, 지지도란 물건 X와 Y가 있을 때, **\u0026ldquo;X와 Y가 동시에 등장하는 비율\u0026rdquo;**을 의미한다. 가령, 전체 거래수가 1,000 건인데, 이 중에서 X와 Y가 동시에 등장하는 횟수가 200이라면, Support는 20%, 즉 0.2 가 된다.\n따라서, Support의 범위는 0 부터 1까지가 된다.\n  Note 1. 간혹, Support를 \u0026ldquo;단순등장횟수\u0026quot;로, 즉 위 예시라면 200으로 표현하는 경우도 있긴 한데, 이는 비즈니스 전문가가 판단할 영역이라고 본다.\n그러나, 내가 진행하는 시간표 추천 시스템은 새로이 제작하는 시스템이고, 이 이용자의 수를 측정할 수 없기 때문에, 전체 Transaction 수로 나누어주었다.\n   Note 2. \u0026ldquo;다른 물건과의 비교\u0026quot;가 필요한 다른 평가 척도와 달리, Support는 단독으로 측정될 수도 있다.\n즉, 물건 X에 대한 Support, 물건 Y에 대한 Support를 따로 구할 수 있다.\n  2) 신뢰도(Confidence) : 다음으로, 신뢰도란, 물건 X와 Y가 있을 때, \u0026ldquo;X를 구매한 Transaction 중, Y가 얼마나 포함되는가?\u0026rdquo; 를 이야기 한다.\n즉, 전체 Transaction이 1,000 건인데, X를 구매한 Transaction이 200건이고, 이 중 Y가 포함된 거래가 100건이라면, 100/200 인 0.5가 된다.\n따라서, Support와 마찬가지로 Range는 0부터 1까지가 된다.\n  Note. 위와 같이 \u0026ldquo;X를 구매했을 때, Y를 얼마나 구매한다.\u0026rdquo; 라고 할 때,\n\u0026ldquo;X를 구매했을 때\u0026rdquo; 부분을 조건절(Antecedent)\n\u0026ldquo;Y를 얼마나 구매한다\u0026rdquo; 부분을 결과절(Consequent) 이라고 칭한다.\n  3) 향상도(Lift) : 마지막으로 향상도란, 물건 X와 Y가 있을 때, \u0026ldquo;Y가 없을 때 X를 구매한 횟수 vs Y가 있을 때 X를 구매한 횟수\u0026rdquo; 가 된다. 팀원은 이를 기울기로 비유했다.\n마찬가지로, 전체 Transaction이 1,000 건인데, X를 구매한 Transaction이 200건, Y를 구매한 Transaction이 400건이라고 해보자.\n이 때, Y를 구매했을 때 X가 50건, Y를 구매하지 않았을 때 X가 150건이라면,\n((50/1000) / (200/1000) * (400/1000)) = (0.05 / 0.08) = 0.625가 된다.\n따라서, Lift 값이 1이라는 것은 서로 연관이 없다는 것을 의미한다.\n이를 수식으로 표현하면 다음과 같다.\n{: .alignCenter}\n이러한 평가 척도는 비즈니스 전문가가 이를 섞어서 사용한다. 즉, 상황에 맞춰서 여러 평가척도를 결합하여 활용해야 한다는 것이다.\n가령, 무조건 신뢰도가 높은 itemset만을 활용한다면, 전체 Transaction에서 얼마 등장하지도 않은(극단적으로, 한 번만 등장한) itemset에 대해서 유의미하다고 판단할 것이다.\n혹은, 높은 지지도, 낮은 신뢰도의 itemset에 집중하는 것이, 낮은 지지도, 높은 신뢰도의 itemset에 집중하는 것 보다 더욱 높은 수익을 안겨줄 수도 있다.\n3. Apriori Algorithm 1) Assocation Rule as Vanilla : 위와 같이 평가척도가 존재하는 것을 알았다. 그렇다면, 이에 대해서 연관규칙을 분석 하려면 얼마나 많은 경우의 수가 생길까?\n가령, 다루고 있는 item이 A,B,C,D의 4개가 있다고 해보자. 그러면, 이에 대한 집합은\nLevel 1. [(A),(B),(C),(D)] \u0026ndash;\u0026gt; 4개\nLevel 2. [(A,B), (A,C), (A,D), (B,C), (B,D), (C,D)] \u0026ndash;\u0026gt; 6개\nLevel 3. [(A,B,C), (A,B,D), (A,C,D), (B,C,D)] \u0026ndash;\u0026gt; 4개\nLevel 4. [(A,B,C,D)] \u0026ndash;\u0026gt; 1개\n총 15개, 즉 24-1 개가 생긴다. 다루고 있는 item이 10개만 되더라도 210-1 , 즉 1023개가 생긴다.\n  Note. (A), (B), (C) \u0026hellip; (A,B,C,D)와 같은 집합을, 연관규칙에선 항목집합(Itemset) 이라고 부른다.\n  또한, 이 Itemset들에 대한 연관규칙을 분석하는 것도 상당히 많다.\n가령, (A,B,C) 라는 항목집합에 대해서 Confidence를 구한다고 생각해보자.\n조건절 A \u0026amp; 결과절 B,C\n조건절 B \u0026amp; 결과절 A,C\n조건절 C \u0026amp; 결과절 A,B\n즉, A를 구매했을 때, B,C 가 같이 구매될 확률을 구하는 것이다.\n앞서, 2n-1 개의 경우의 수에, 위와 같은 경우의 수가 추가된다면, 이를 계산하는 것은 대단한 미친짓이다.\n여기를 참고하면, 이러한 Rule의 개수는 3n-2n+1+1 개가 된다고 한다.\n2) Association Rule with Apriori Algorithm : 위와 같은 참사가 발생하는 것을 막기 위해, Apriori Algorithm이 고안되었다.\n  Note 1. 연관규칙에서, 연산을 줄이는 전략은 Apriori Algorithm뿐만이 아니라, FP-growth, DHP 등의 다른 알고리즘이 있다. 그러나, Apriori의 장점은, 구현하기가 용이하고, 다른 사람에게 설명하기 좋다는 장점이 있다.\n   Note 2. Apriori Algorithm과 Association Rule을 동일시하는 글도 본 적이 있는데, 내가 봤을 때에는 엄연히 다르다. Association Rule은 여러 평가 척도를 기반으로 한 분석 기법이고, Apriori는 Association Rule의 비효율성을 방지하기 위한 Algorithm이다.\n  이 알고리즘은 \u0026ldquo;한 항목이 비빈발(infrequent)집합이라면, 이 항목집합(subset)을 포함하는 모든 항목집합(superset)은 비빈발 항목집합이다\u0026rdquo; 라는 원칙을 갖고 있다.\n무슨말이냐 하면, 위와 같은 A,B,C,D 의 예시에서, 만약 (A) 라는 Itemset이 자주 등장하지 않는다면, 이 (A) 를 포함하는 Itemset[ (A,B), (A,C) \u0026hellip; (A,B,C,D) ]은 쳐다보지도 않는 것이다.\n또한, (A)와 같은 단일항목집합에만 해당하는 것이 아니고, (A,B)와 같은 여러개의 item을 포함하고 있는 Itemset에서 출발할 수도 있다.\n그렇다면, 비빈발(infrequent)의 기준은 어떻게 정할까? 이 또한 비즈니스 전문가가 정한다. 이를 \u0026ldquo;최소지지도\u0026rdquo; 라 한다. (어찌보면, 도메인 지식을 갖고 있는 사람이 이 기준을 정하는 것은 당연하기도 하다.)\n그러나, \u0026ldquo;통상적\u0026rdquo; 으로, 0.5를 기준으로 둔다고 \u0026ldquo;카더라.\u0026rdquo;\n따라서, Apriori 알고리즘의 순서는 다음과 같다.\n 최소 지지도는 0.5 이다. Level.1의 Itemset[(A),(B),(C),(D)]를 만든다. (이를 C1 이라 한다.) Level.1 에서, 최소지지도를 만족하지 못하는 Itemset을 쳐낸다. 여기선, A와 B가 살아남았다고 해보자. 다음으로, 살아남은 녀석들에 대한 Level.2 의 Itemset [(A,B), (A,C), (A,D), (B,C), (B,D)] 를 만든다. (C2) Level.2에서, 최소지지도를 만족하지 못하는 Itemset을 쳐낸다. Level이 item의 개수(A,B,C,D의 4개)가 될 때까지 계속해서 반복.  이를 그림으로 표현하면 다음과 같다.\n{: .alignCenter}\n사진 출처\n위 그림에서, 우리가 앞으로 \u0026ldquo;연관규칙분석 할 대상\u0026quot;은 L1, L2, L3 이다.\n4. 코드로 구현해보자. : 자바에 익숙치 않아, 클래스 설계를 이렇게 하는 것이 맞는지는 모르겠다.\nApriori.java\nimport com.google.common.collect.Sets; import java.util.*;  /** * Apriori Algorithm implementation * @author cjlee * @see cjlee38.github.io */ public class Apriori {  /** * Example : * * Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; transactions = getTransactions(); // superset : set of transactions, subset : set of items * Float minSupport = (float) 0.5; * Apriori apriori = new Apriori(minSupport, transactions) * apriori.run(); */  private Float minSupport;  private Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; dataset;  private Map\u0026lt;Set\u0026lt;String\u0026gt;, Float\u0026gt; result;   public Apriori(Float minSupport, Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; dataset) {  this.minSupport = minSupport;  this.dataset = dataset;  this.result = new HashMap\u0026lt;\u0026gt;();  }  public Map\u0026lt;Set\u0026lt;String\u0026gt;, Float\u0026gt; getResult() {  return result;  }   public void run() {  Set\u0026lt;String\u0026gt; itemset = createSet(dataset);  Integer level = 1;  Integer maxLevel = itemset.size();   while (level \u0026lt; maxLevel) {  Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; combinations = getCombinations(itemset, level);  Map\u0026lt;Set\u0026lt;String\u0026gt;, Float\u0026gt; supportedItemset = getSupportedItemset(combinations);  result.putAll(supportedItemset);  itemset = createSet(supportedItemset.keySet());  level++;  if (itemset.size() \u0026lt;= 1) { // means current itemsets are all pruned  break;  }  }   }   public Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; getCombinations(Set\u0026lt;String\u0026gt; set, Integer level) {  return Sets.combinations(set, level);  }   // 중복없는 데이터를 구하는 함수  public Set\u0026lt;String\u0026gt; createSet(Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; data) {  Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;();  for (Set\u0026lt;String\u0026gt; transaction : data) {  for ( String item : transaction) {  set.add(item);  }  }  return set;  }   public Float calcSupport(Set\u0026lt;String\u0026gt; itemset) {  Integer occurence = 0;  for( Set\u0026lt;String\u0026gt; transaction : dataset) {  if (transaction.containsAll(itemset)) {  occurence++;  }  }  return occurence / ((float)dataset.size());  }   public Map\u0026lt;Set\u0026lt;String\u0026gt;, Float\u0026gt; getSupportedItemset(Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; itemset) {  Map\u0026lt;Set\u0026lt;String\u0026gt;, Float\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  for (Set\u0026lt;String\u0026gt; comb : itemset) {  Float support = calcSupport(comb);  if (support \u0026gt; minSupport) {  map.put(comb, support)  }  }   return map;  } } AssociationRule.java\n import com.google.common.collect.Sets; import java.util.*;   /* * 참고문헌 * Association Rule implementation * @author cjlee * @see cjlee38.github.io * @refer 김용, Apriori 알고리즘 기반의 개인화 정보 추천 시스템 설계 및 구현에 관한 연구(한국비블리아학회지 VOL.23. NO.4 (2012):283-308,) * */ public class AssociationRule {  /** * Example : * * String metric = \u0026#34;lift\u0026#34;; * Float minLift = (float)1.0; * AssociationRule associationRule = new AssociationRule(apriori.getResult(), metric, minLift); // apriori initialized * associationRule.run(); */  private Map\u0026lt;Set\u0026lt;String\u0026gt;, Float\u0026gt; itemset;  private String metric;  private Float min_threshold;  private List\u0026lt;AssociationRuleObj\u0026gt; rules;    public AssociationRule(Map\u0026lt;Set\u0026lt;String\u0026gt;, Float\u0026gt; itemset, String metric, Float min_threshold) {  this.itemset = itemset;  this.metric = metric;  this.min_threshold = min_threshold;  this.rules = new LinkedList\u0026lt;\u0026gt;();  }   public List\u0026lt;AssociationRuleObj\u0026gt; getRules() {  return rules;  }   private Float scoreByMetric(String metric, Float sAC, Float sA, Float sC) {  Float score;  if (metric.equals(\u0026#34;support\u0026#34;)) { score = getSupport(sAC); }  else if (metric.equals(\u0026#34;confidence\u0026#34;)) { score = getConfidence(sAC, sA); }  else if(metric.equals(\u0026#34;lift\u0026#34;)) { score = getLift(sAC, sA, sC); }  else { score = null; }   return score;  }  private Float getSupport(Float sAC) { return sAC; }  private Float getConfidence(Float sAC, Float sA) { return sAC / sA; }  private Float getLift(Float sAC, Float sA, Float sC) {  return (sAC/sA) / sC;  }  private void filterItemset() {  itemset.entrySet().removeIf(x -\u0026gt; x.getKey().size() \u0026gt; 2);  }   public void run() {  filterItemset();  for (Set\u0026lt;String\u0026gt; item : itemset.keySet()) {  Float sAC = itemset.get(item);  for (Integer idx = item.size()-1; idx \u0026gt; 0; idx--) {  Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; combination = Sets.combinations(item, idx);  for (Set\u0026lt;String\u0026gt; comb : combination) {  Set\u0026lt;String\u0026gt; antecedent = comb;  Set\u0026lt;String\u0026gt; consequent = Sets.difference(item, comb);   Float sA = itemset.get(antecedent);  Float sC = itemset.get(consequent);  Float score = scoreByMetric(metric, sAC, sA, sC);  if (score \u0026gt;= min_threshold) {  rules.add(new AssociationRuleObj(antecedent, consequent, sAC, getConfidence(sAC, sA), getLift(sAC, sA, sC)));  }  }  }  }  }   } AssociationRuleObj.java\nimport lombok.Getter; import java.util.Set;  /** * Apriori Algorithm implementation * @author cjlee * @see cjlee38.github.io */ @Getter public class AssociationRuleObj {  private Set\u0026lt;String\u0026gt; antecedent;  private Set\u0026lt;String\u0026gt; consequent;  private Float support;  private Float confidence;  private Float lift;   public AssociationRuleObj(Set\u0026lt;String\u0026gt; antecedent, Set\u0026lt;String\u0026gt; consequent,  Float support, Float confidence, Float lift) {  this.antecedent = antecedent;  this.consequent = consequent;  this.support = support;  this.confidence = confidence;  this.lift = lift;  } } 사용법은 코드 내에 작성하였다.\n또한, AssociationRule은 python의 mlxtend 라이브러리를 참고하였다.\n5. 활용 : 이렇게 구현한 연관 규칙을, 어떻게 활용할까?\n우리 시스템 상에서의 목적은, 연관규칙을 통해, \u0026ldquo;해당 사용자\u0026quot;에게 걸맞는 \u0026ldquo;과목별 점수\u0026quot;를 부여하는 것이다.\n따라서, 최소 지지도를 0.5, 향상도가 1 이상인 연관규칙에 대하여, 신뢰도를 점수로 부여하였다.\n또한, 참고논문에 근거하여, 한 itemset의 item이 2인 경우로 한정하였다.\n그 결과의 예시는 다음과 같다.(지난 발표자료에서 가져왔다.)\n{: .alignCenter}\n위와 같이 1,2,3,4의 인물이 기존 사용자로 존재한다. 그리고, 5번의 새로운 인물이 새로이 들어왔다고 해보자. 이에 대한 결과는 다음과 같다.\n{: .alignCenter}\n위와 같은 가중치를 기반으로, \u0026ldquo;수강가능 과목\u0026quot;에 대한 List를 정렬한 뒤, 앞쪽에서부터 시작하여 Backtracking 기법을 활용해 시간표를 구성하고, 이를 추천하였다.\n6. 마치며 : Association Rule, Apriori의 library가 존재하기는 하지만, 대부분 Database와 연동해서 가져오는 것으로 보았다.\n또한, 우리 입맛에 맞게 Customizing을 할 수 없었기 때문에, 직접 구현하는.. 사서 고생을 했다.\n또한, \u0026ldquo;가중치\u0026quot;라는 결과로 내뱉기 위한 metric을 어떻게 설정할 것인가에 대해서도 팀원과 논의하면서 어려움을 좀 겪었다.\n혹여나 이 글, 그리고 이러한 방법론이 누군가에게 도움이 된다면 뿌듯하겠다.\nReference  https://ratsgo.github.io/machine%20learning/2017/04/08/apriori/ https://rfriend.tistory.com/191 김용, Apriori 알고리즘 기반의 개인화 정보 추천 시스템 설계 및 구현에 관한 연구\n한국비블리아학회지 VOL.23. NO.4 (2012):283-308  ","permalink":"http://cjlee38.github.io/post/data/data_mining/2020-08-30-association_rule_with_java/","summary":"0. 들어가며 : 2020년 1학기에 수강했던 종합설계 과목에서, 우리 조의 주제는 \u0026ldquo;시간표 추천 시스템\u0026rdquo; 이었다.\n본인이 원하는 공강시간, 학점 범위, 그리고 내가 미리 골라놓은 듣고자 하는 수업을 선택하면, 이전에 내가 수강했던 과목들을 기반으로 \u0026ldquo;남는 시간에, 이걸 듣는건 어때?\u0026rdquo; 라는 개념으로 시간표를 구성해서, 제공해주는 시스템을 제작하고자 하였다.\n그 과정에서, \u0026ldquo;비즈니스프로그래밍2\u0026rdquo; 수업에서 배웠던 \u0026ldquo;연관규칙\u0026quot;을 활용할 수 있을 것이라 판단했고, 이에 대해서 공부하기 시작하였다.\n1. 연관규칙이란? : 흔히, 장바구니 분석이라고도 한다. 경영학을 전공하고 있는 사람이라면, 마케팅 수업에서 \u0026ldquo;맥주를 사는 사람은 대개 기저귀도 같이 산다\u0026rdquo;(혹은 반대로, 기저귀를 사는 사람은 대개 맥주도 사더라) 라는 이야기를 들어본 적이 있을 것이다.","title":"# Java로 구현하는 연관규칙분석(Association Rule) ( feat. Apriori Algorithm )"},{"content":"PROBLEM 문제 설명\n괄호가 바르게 짝지어졌다는 것은 \u0026lsquo;(\u0026rsquo; 문자로 열렸으면 반드시 짝지어서 \u0026lsquo;)\u0026rsquo; 문자로 닫혀야 한다는 뜻입니다. 예를 들어\n ()() 또는 (())() 는 올바른 괄호입니다. )()( 또는 (()( 는 올바르지 않은 괄호입니다.  \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;)\u0026rsquo; 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.\n제한사항\n 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;)\u0026rsquo; 로만 이루어져 있습니다.  SOLVE : 전형적인 Stack 문제이다. 순서는 다음과 같다.\n 입력 받은 String을 char로 나누어 array에 담는다. array를 돌면서, char가 \u0026ldquo;(\u0026rdquo; 이면 stack에 Push, \u0026ldquo;)\u0026rdquo; 이면 Pop 한다. 이 때, stack이 비어 있는데 pop을 하려고 한다면, 잘못된 괄호이므로 answer는 false가 된다. 또한, array를 전부 돌았는데, stack이 비어 있지 않다면, 이 또한 잘못된 괄호다.  Level2 인데, 오히려 생각할 내용은 지난 프로그래머스 문제보다 간단해서 살짝 당황했다. Level이 잘못 배치된 것 아닌가 싶었다.\n해서, 처음에는 이렇게 짰다.\nimport java.util.Stack; class Solution {  boolean solution(String s) {  boolean answer = true;  Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;();   for (int i = 0; i \u0026lt; s.length() ; i++) {  char c = s.charAt(i);  if (c == \u0026#39;(\u0026#39;) { // 여는 괄호라면, 무조건 Push  stack.push(c);  }  else { // 닫는 괄호일 때,  if ( !stack.empty() \u0026amp;\u0026amp; stack.peek() == \u0026#39;(\u0026#39;) { // stack이 비어 있지 않고, 최상단이 열린 괄호라면 pop  stack.pop();  } else { // stack이 비어있거나, 최상단이 여는괄호가 아니라면 답은 무조건 false  answer = false;  break;  }  }  }   // 모든 array를 다 돌았음에도, stack이 비어 있지 않다면 답은 false (4번에 해당)  if ( !stack.empty()) { answer = false; }  return answer;  } } 근데, 시간 초과가 났다. 당황에 황당이 더해졌다. 시간복잡도는 어떻게 해도 O(N) 일텐데..\n고민해보니, 문제가 될 부분은 아마 Stack Object 때문이라는 생각이 들어, 대신 int형으로 수정해서 제출해보았다.\n (수정) 기존에 peek() 함수를 사용했더니, 시간 초과가 났다.\n생각해보면, peek() 함수를 사용할 일은 전혀 없는데, 왜 넣었을까.. peek() 함수를 빼고 실행하니 효율성 문제도 통과했다.\n class Solution {  boolean solution(String s) {  int iStack = 0;  for (int i = 0; i \u0026lt; s.length() ; i++) {  char c = s.charAt(i);  if (c == \u0026#39;(\u0026#39;) { iStack++; }  else { iStack--; }  if ( iStack \u0026lt; 0 ) { return false; }  }  if (iStack \u0026gt; 0) { return false; }  else { return true; }  } } 이렇게 하니 성공했다. 아마 이 부분 때문에 Level 2로 선정되었나 싶기도 하다.\n근데, 이렇게까지 공간복잡도를 최소화하는 이유가 뭐지\u0026hellip; 잘 모르겠다.\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-08-29-problem_solving_4/","summary":"PROBLEM 문제 설명\n괄호가 바르게 짝지어졌다는 것은 \u0026lsquo;(\u0026rsquo; 문자로 열렸으면 반드시 짝지어서 \u0026lsquo;)\u0026rsquo; 문자로 닫혀야 한다는 뜻입니다. 예를 들어\n ()() 또는 (())() 는 올바른 괄호입니다. )()( 또는 (()( 는 올바르지 않은 괄호입니다.  \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;)\u0026rsquo; 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.\n제한사항\n 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;)\u0026rsquo; 로만 이루어져 있습니다.","title":"# 프로그래머스[Lv.2] - 올바른 괄호 ( java )"},{"content":"문제 링크\nPROBLEM {: .alignCenter}\nSOLVE : 이번 문제는 이해 하기에 그리 어렵지 않으므로, 바로 해결 방법으로 진행한다.\n1) 첫 번째 방법 ( feat. Out of Memory ) : 첫 번째 잘못된 접근은, 모든 숫자를 다 구해서 String으로 캐스팅해서 리스트에 담은 뒤, 이를 모두 concatenate 하는 것이다. 문제를 그대로 이해하고 그대로 해결하고자 하는 것이다. N = int(input()) numbers = [str(i) for i in range(1, N+1)] print(len(\u0026#39;\u0026#39;.join(numbers))) 그러나, 입력의 최대 값이 1억이므로, 이를 모두 이어 붙이게 되면 굉~장히 긴 String이 등장할 것이다.\n  여담으로, python의 String 크기에 대해서 구글링 해보니, 메모리 상의 String의 크기는 \u0026ldquo;Overhead + 실제 String\u0026quot;으로 구성되고, 직접 확인해보니 Overhead는 Python version 3.7.4 기준 49로 나타났다. 실제 String이 차지하는 bytes의 크기는 character의 종류에 따라 다르고 ( 가령, 알파벳은 1, 한자는 2, 이모지는 4를 차지한다고 한다. ) 숫자의 문자열의 크기는 1 임을 확인할 수 있었다. 입력이 1억일 때의 숫자의 길이는 788888898이고, 따라서, 788888898 + 49 = 788888947 약 752메가로 나타났다. 간단한 문제를 해결하기엔 너무 큰 메모리 소모다.\n이에 더해, Python의 String은 immutable 객체다. 1억 번의 메모리를 할당하는 것은 잠깐만 생각해도 비효율적으로 느껴진다.\n  2) 두 번째 방법 ( feat. Time Complexity ) : 두 번째 잘못 된 접근법은, 곧바로 하나하나 계산해서 더하는 것이다.\n예제의 입력이 120이므로, 1부터 120까지 loop를 돌면서\n\u0026lsquo;1의 자릿수의 길이(1)\u0026rsquo; + \u0026lsquo;2의 자릿수의 길이(1)\u0026rsquo; + \u0026hellip; + \u0026lsquo;10의 자릿수의 길이(2)\u0026rsquo; + \u0026lsquo;11의 자릿수의 길이(2)\u0026rsquo; + \u0026hellip; + \u0026lsquo;119의 자릿수의 길이(3)\u0026rsquo; + \u0026lsquo;120의 자릿수의 길이(3)\u0026rsquo; = 252\n를 구하게 되면, 아주 간단해 보인다.\nN = int(input()) result = 0 for i in range(1, N + 1):  result += len(str(i)) print(result) But, 역시 입력의 최대 값은 1억이다. 따라서, 이를 모두 계산하게 되면 매우 긴 시간이 걸릴 것은 자명하다. 이 역시 한번 실제로 테스트를 해보니, 1억번 연산하는데 약 50초 가량이 걸렸다. 3) 세 번째 방법  : 이 문제의 아주 자명하면서도 간단한 사실은 바로 \u0026ldquo;특정 자릿수의 길이\u0026quot;를 갖고 있는 숫자의 범위를 파악하기가 매우 쉽다는 것이다.\n 1 - 9 까지의 숫자의 자릿수의 길이는 1이다.\n 10 - 99 까지의 숫자의 자릿수의 길이는 2이다.\n 100 - 999 까지의 숫자의 자릿수의 길이는 3이다.\n따라서, 다음과 같이 해결하면 된다.\n 입력값의 \u0026lsquo;최대 자릿수의 길이 미만\u0026rsquo;의 \u0026lsquo;자릿수의 길이\u0026rsquo;를 계산할 때는, 최종 값에 **\u0026lsquo;해당 자릿수의 길이 * 해당 자릿수의 개수\u0026rsquo;**를 더해준다. \u0026lsquo;최대 자릿수의 길이\u0026rsquo;를 계산할 때에는, **\u0026lsquo;최대 자릿수의 길이 * 나머지 자릿수의 개수\u0026rsquo;**를 더해준다.  말로 설명하니 무슨 말인지 헷갈린다. 문제의 예시를 통해 풀어서 설명하면 다음과 같다.\n \u0026ldquo;최대 자릿수의 길이\u0026quot;는 3이다. 따라서, 그 미만의 길이일 때에는 ( 즉, 1, 2 일 때에는 각 자릿수의 개수인 9와 90을 각각 곱한 뒤 더해준다 )  따라서, 처음 1부터 9까지를 더하면, 1(길이) * 9(개수)이므로, result는 9다. 10부터 99까지를 더하면, 2(길이) * 90(개수) 인 180이 더해지므로, result는 189다. 마지막으로 100부터 120까지를 더하면, 3(길이) * 21(개수) 인 63이 더해지므로, result는 252이다.  이를 코드로 구현하면 다음과 같다.\nN = int(input()) nines = [int(\u0026#39;9\u0026#39;+\u0026#39;0\u0026#39;*i) for i in range(0, len(str(N)))] # if 120 --\u0026gt; [9, 90, 900] result = 0  for i, s in enumerate(nines):  if s == nines[-1]: # 마지막 자릿수를 계산할 때  result += len(str(s)) * (N - sum(nines[:-1])) # result += 3 * 21  else :  i += 1  result += i*s  print(result) 252번의 iteration이 발생하는 첫 번째 방법이나, 두 번째 방법과 달리, 단 3번의 iteration만으로 답을 구할 수 있다. 1억까지 계산하더라도 9번의 연산으로 끝낼 수 있다.\n마치며 아직도 부족한 점이 느껴진다. 머릿속으로 세 번째 방법에 대해서 떠올리고 설계하는 데에는 오래 걸리지 않았지만, 이를 코드로 구현함에 있어서 손가락이 자꾸 멈추니 스스로가 답답하게 느껴진다.\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_3/","summary":"문제 링크\nPROBLEM {: .alignCenter}\nSOLVE : 이번 문제는 이해 하기에 그리 어렵지 않으므로, 바로 해결 방법으로 진행한다.\n1) 첫 번째 방법 ( feat. Out of Memory ) : 첫 번째 잘못된 접근은, 모든 숫자를 다 구해서 String으로 캐스팅해서 리스트에 담은 뒤, 이를 모두 concatenate 하는 것이다. 문제를 그대로 이해하고 그대로 해결하고자 하는 것이다. N = int(input()) numbers = [str(i) for i in range(1, N+1)] print(len(\u0026#39;\u0026#39;.join(numbers))) 그러나, 입력의 최대 값이 1억이므로, 이를 모두 이어 붙이게 되면 굉~장히 긴 String이 등장할 것이다.","title":"# 백준[No.1748] - 수 이어 쓰기 1 ( Python )"},{"content":"문제 링크\nPROBLEM {: .alignCenter} {: .alignCenter}\nSOLVE ** 1) 주의사항** : 해당 문제에서 주의해야 할 요소는 다음과 같다.\n 참외밭은 ㄱ자 모양, 혹은 이를 회전한 ┏, ┗, ┛ 모양의 육각형이다. 참외밭의 둘레를 돌면서 지나는 변의 방향은 반시계방향으로 주어진다. 변의 방향은 동,서,남,북 순서로 1,2,3,4의 값을 가진다. 출발 꼭지점은 \u0026ldquo;임의\u0026quot;로 주어진다.  2) 해결법 : 처음 문제를 보았을 때, 위 두가지 방법이 떠올랐다.\n 1. 해당 모형의 육각형을 3등분하여 각 넓이를 구한뒤, 합산한다.\n 2. 육각형을 직사각형의 모양으로 확장한 뒤, 비어 있는 부분을 분리해낸다.\n 1번 방법은 코드로 구현해낼 수 있는 방법이 떠오르지 않았고, 2번 방법이 정답으로 보였는데, 당최 어떻게 해야 할지 고민하다가, 다음과 같은 규칙성을 찾아낼 수 있었다. 풀이법을 상술하기 전에, 먼저 \u0026ldquo;전체 박스는 큰 박스, 비어 있는 부분은 작은 박스\u0026quot;로 명명하자.\n** A. 큰 박스의 넓이를 구하는 법**\n 먼저, 해당 그림은 \u0026ldquo;육각형\u0026quot;이므로 6개의 변을 갖는다. 그리고 각 변은 동서남북의 네 방향으로만 움직인다. 따라서, 그림의 모양을 살펴보면, **\u0026ldquo;동서남북의 방향으로 이동하는 변이 한 번만 등장할 경우, 해당 변이 가로, 혹은 세로의 전체 길이\u0026rdquo;**라는 것을 알 수 있다.\n따라서, 위 예시로 나타난 그림에서, 단 한번만 등장하는 \u0026ldquo;방향\u0026quot;은 4, 2번의 북, 서 방향이고, 따라서 세로 50, 가로 160의 길이임을 확인할 수 있다.\n** B. 작은 박스의 넓이를 구하는 법**\n 작은 박스의 변을 구하려면, 가로 60, 세로 20의 변을 도출해내야 한다. 그런데, 큰 박스를 구할 때 사용한 4 50과 2 160을 제외한 나머지로는 구하기가 영 어려워 보인다. 게다가, ㄱ자 모양만 갖는 것이 아니라, 위에서 언급한 4가지의 모양을 가지고, 게다가 \u0026ldquo;임의의\u0026rdquo; 점에서 출발하기 때문에, 나머지 네 변만을 이용하여 작은 박스의 가로 세로를 구할 수는 없다.\n 그러나, 출발점에서 선을 그려나간 이후에, 최종적으로 본래의 점으로 돌아오기 때문에, Circular Linked List로 생각해 볼 수 있다.  또, 그림을 유심히 보면, **\u0026ldquo;큰 박스의 가로 혹은 세로 길이의 변에서, 세 번째 이동하는 변이 작은 박스의 세로 혹은 가로 변이다\u0026rdquo;**는 것을 알 수 있다.\n 즉,\n 큰 박스의 세로 변 4 50 이후, 다음 세 번째 변은 작은 박스의 가로 변 60이고,\n 큰 박스의 가로 변 2 160 이후, 다음 세 번째 변은 작은 박스의 세로 변 20이다.\n** C. 최종 답**\n 따라서, 최종 답 = ( 1m^2 당 참외 개수 K ) * ( 큰 박스 넓이 - 작은 박스 넓이 ) 로 답을 구해낼 수 있다. 이를 코드로 구현하면 다음과 같다.\n** 3) 구현** melon = int(input()) # 참외 개수 K values = [input().split() for _ in range(6)] # 나머지 2~7 line의 6 줄을 입력 받는다. directions = [int(v[0]) for v in values] # 방향을 뽑아내서 저장한다. lengths = [int(v[1]) for v in values] # 길이를 뽑아내서 저장한다. max_lengths, box_lengths = [], [] # 큰 박스의 길이, 작은 박스의 길이를 담을 배열  for i in range(1, 5):  if directions.count(i) == 1: # direction이 한번만 존재한다 == 큰 박스의 변  max_lengths.append(lengths[directions.index(i)]) # 큰박스의 변 길이 저장  temp = directions.index(i) + 3 # 큰 박스 + 3 == 작은 박스의 변  if temp \u0026gt;= 6:  temp -= 6 # cycle을 위해 6 이상일 경우 -6  box_lengths.append(lengths[temp])  area = max_lengths[0] * max_lengths[1] - box_lengths[0] * box_lengths[1] print(melon * area) 위 코드를 통해 문제를 해결할 수 있었다.\n** 4) 아쉬운 점.**  1. 좀 더 우아하게 코드를 작성할 수 있을 것 같은데, 파이썬에서는 Circular Linked List의 library가 존재하지 않아서 ( itertools의 cycle을 이용하는 방법이나, 직접 Circular Linked List를 구현할 수도 있지만, 배보다 배꼽이 커지는 격일 것 같아서 하지 않았다. 어떻게 하면 더 pythonic하게 구현할 수 있었을까? 흠.. 아무래도 아쉽다\n 2. 규칙성을 발견한게 우연의 산물인 것 같아서 조금 아쉽다. 근거에 기반하여 규칙성을 발견해낸 것이 아니라, \u0026ldquo;그렇게 규칙이 있으니까\u0026rdquo; 이를 구현한 것이 아무래도 찝찝하다. 혹여 누군가가 개선점을 발견한다면, 꼭 한마디 남겨주면 고맙겠다. 끝\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_2/","summary":"문제 링크\nPROBLEM {: .alignCenter} {: .alignCenter}\nSOLVE ** 1) 주의사항** : 해당 문제에서 주의해야 할 요소는 다음과 같다.\n 참외밭은 ㄱ자 모양, 혹은 이를 회전한 ┏, ┗, ┛ 모양의 육각형이다. 참외밭의 둘레를 돌면서 지나는 변의 방향은 반시계방향으로 주어진다. 변의 방향은 동,서,남,북 순서로 1,2,3,4의 값을 가진다. 출발 꼭지점은 \u0026ldquo;임의\u0026quot;로 주어진다.  2) 해결법 : 처음 문제를 보았을 때, 위 두가지 방법이 떠올랐다.\n 1. 해당 모형의 육각형을 3등분하여 각 넓이를 구한뒤, 합산한다.","title":"# 백준[No.2477] - 참외밭 ( python )"},{"content":"문제 링크\n알고리즘 공부를 어제부터 시작해서, Lv.1 문제부터 차근차근 풀어나가고 있다. 첫 번째 문제로 선택한 크레인 인형뽑기 게임 문제의 다음과 같다.\nPROBLEM  게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.\n죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.\n{: .alignCenter}\n게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.\n{: .alignCenter}\n만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.\n{: .alignCenter}\n크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)\n게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.\n[제한사항]  board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.   SOLVE 1) 접근 방법 : 먼저, 가장 핵심이 되는 내용들과 주의해야할 점들을 기억했다.\n  정사각 격자에서, 인형들은 가장 아래부터 \u0026ldquo;쌓여\u0026rdquo; 있다.  오른쪽 바구니의 크기에는 모든 인형이 들어갈 만큼 충분히 크다 ( ≒ 바구니의 크기에는 제약이 없다 )  인형 **두개 **가 만나면 터뜨려지면서 **두개 다 **사라진다.  인형이 없는 곳에서 크레인을 작동시키면, 아무런 일도 일어나지 않는다.  2) 첫 번째 방법 다음으로, 인형을 뽑아서 바구니에 담는 과정과, 바구니에 들어 있는 인형이 터지는 상황을 구분하여 고려한 뒤, 다음과 같이 작성하였다.\ndef solution(board, moves):  # SECTOR A  basket = []  for move in moves: # 크레인 동작  for row in board: # 2차원배열 board를 vertically 접근하므로  if row[move - 1] != 0: # 0이면 empty이므로 pass  basket.append(row[move - 1])  row[move - 1] = 0 # 인형은 사라지게 함  break # 같은 열(column)의 다음 인형을 뽑지 않기 위해 break  # SECTOR B  count = 0 # 인형 터짐 횟수  escape_flag = 0 # 탈출 flag  while escape_flag == 0:  if len(basket) \u0026lt;= 1:  break  for pos in range(len(basket)): # index와 index + 1 을 비교하여, 같으면 pop  if basket[pos] == basket[pos + 1]:  basket.pop(pos)  basket.pop(pos)  count += 1  break  if pos == len(basket) - 2: # index 이므로 -1 \u0026amp; IndexError(out of range) 방지를 위해 -1  escape_flag = 1  break   return count * 2 가장 먼저, 첫 for문을 돌면서 basket이라는 빈 배열을 만들어 준 뒤, 뽑은 인형들을 전부 담았다. ( Sector A )\n다음으로, basket의 크기가 2 이상, escape_flag가 0 인 동안 반복하는 while loop 내에서, basket for문을 돌면서\n조건에 맞을 경우 제거 및 count, 그리고 최종적으로 count * 2 (인형이 두 개가 터지므로)를 return 하도록 하였다. ( Sector B )\n결과는 all clear. {: .alignCenter}\n3) 두 번째 방법 : 그러나, 뭔가 찜찜하다. 첫 번째 방식에는 분명히 문제가 있다.\n처음에 위 방식과 같이 구분을 한 이유는, 코드 상 line 15 - 20 에서, 본디 다음과 같이 구현하고자 하였기 때문이다.\n[ 1차적으로 터뜨릴 인형을 모은 뒤, 한번에 터뜨리고, 그 이후에 터져야 할 인형이 남아있다면 2차적으로 인형을 터뜨리고\u0026hellip; 최종적으로 터뜨릴 인형이 없을 때 결과 출력.]\n( 마치, 애니팡 게임에서 하나를 움직였는데, 새로운 줄이 추가되면서 연쇄적으로 터지듯이 )\n그런데, 이렇게 할 경우에는 문제가 발생한다.\n만일, A 인형을 뽑은 뒤, 같은 모양의 인형 B 세 개를 연속으로 뽑는다고 해보자.\n[A, B, B, B]\n그렇다면, 정상적으로 진행이 되었을 경우에는 다음과 같은 모양이 남아 있어야 한다.\n[A, B]\n그런데, 방금 말한 방식대로 하면 모든 B가 사라지고, A만 남게 될 것이다.\n[A]\n왜냐면, index 1, 2의 B는 터뜨릴 인형이지만, 2, 3도 조건에 부합하기 때문에 터뜨릴 인형에 포함되기 때문이다.\n이런 현상이 발생할 수 있기 때문에, break( line 20 )을 넣어서, 터뜨릴 인형을 발견한다면, 곧바로 터뜨리고, 다시 처음부터 검사하는 방식으로 진행하였다.\n그러나, 이렇게 break를 걸고, 동작한다고 해서 좋아할 게 아니다. 왜냐면, 이러한 방식은 검사를 처음부터 다시 시작하기 때문에, 멀쩡한 부분 또한 다시 검사하기 때문이다. 상상해보자. 바구니에 서로 다른 인형 100개가 들어 있고, 101번 째부터 폭발할 인형들이 모여 있다. 그렇다면 100번째 인형까지는, 검사할 필요가 있을까? 전혀 없다.\n따라서, 결론적으로 첫 번째 방식은 잘못 되었고, 다음과 같이 다시 수정하였다.\ndef solution(board, moves):  basket = []  count = 0   for move in moves:  for row in board:  if row[move -1] != 0:  basket.append(row[move-1])  row[move-1] = 0   if len(basket) \u0026gt;= 2 and basket[-1] == basket[-2]:  basket.pop()  basket.pop()  count += 1  break   return count * 2 훨씬 간결하고, 보기도 좋다. 어렵지도 않으니 따로 설명할 필요는 없으리라 생각된다.\n이에 더해, 다음과 같은 장점도 있다\n 첫 번째 방법에 비해, 중복 연산이 훨씬 적다. 만약, \u0026ldquo;실시간으로 board를 확인하고 싶어요.\u0026rdquo; 혹은 \u0026ldquo;실시간으로 basket\u0026quot;을 확인하고 싶어요\u0026quot;라는 추가 요구 사항이 생겼을 때, 해결하기 쉽다.   마치며 : 첫 알고리즘 문제를 푸는데, 머릿 속에서 여러 가지 해결 방법이 떠올랐고, 두 번째 방법보다는 첫 번째 방법이 구현하기에 용이할 것 같아서 작성했는데, 쓰고 보니 훨씬 복잡하고, 보기에도 좋지 않았다. 또한, 학교 수업에서 배웠던 알고리즘을 실제로 연습해보니, 생각보다 까다롭고 쉽지 않음을 깨달았다. 최소 일주일에 세 문제, 일반적으로 하루에 한문제를 잡고 매일 연습하는 습관을 들여야겠다.\n","permalink":"http://cjlee38.github.io/post/algorithm/problem_solving/2020-08-27-problem_solving_1/","summary":"문제 링크\n알고리즘 공부를 어제부터 시작해서, Lv.1 문제부터 차근차근 풀어나가고 있다. 첫 번째 문제로 선택한 크레인 인형뽑기 게임 문제의 다음과 같다.\nPROBLEM  게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.\n죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.\n{: .alignCenter}\n게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다).","title":"# 프로그래머스[Lv.1] - 크레인 인형 뽑기 ( python )"},{"content":"#0. 서버의 필요성 저번 방학 때, 공모전을 진행하면서 여러가지 난관에 부딪혔다. 지금도 아직 많이 부족한 나부랭이이지만, 그때 당시에는 서로가 갖고 있는 노트북으로 작업을 진행하기에는, 컴퓨팅 파워도, 시간도 부족했다. 그래서 서버의 필요성을 느꼈다. 결국에는 아마존에서 EC2를 하나 빌려다가 쓰긴 했지만, 그 전에 \u0026ldquo;이거부터 한번 해보고, 안되면 아마존을 쓰자\u0026rdquo; 라는 생각으로 개인 데스크탑을 서버로 열었다. #1. 본론으로 여러가지 이야기는 제쳐두고, 그래서 어떻게 하느냐..\n일단 아나콘다 프롬프트를 열어서\n$ jupyter notebook --generate-config 로 configuration 파일을 생성한다.\n{: .alignCenter}\n그리고 자기 사용자폴더 안에\n(윈도우라면 C:/Users/\u0026ldquo;사용자이름\u0026rdquo;/.jupyter 리눅스라면 /home/\u0026ldquo;사용자이름\u0026rdquo;/.jupyter)\njupyter_notebook_config.py 라는 파일이 생성된다.\n이 파일을 수정해야 하는데, 일단은 잠시 미뤄놓자.\n#2. DDNS 네트워크를 조금이라도 공부해보신 분은 알겠지만, 가정집에서 사용하는 IP는 유동IP이다. 고정되어 있지 않다.\n이 IP 주소가 결국 내 집주소라는 이야기 인데, 내가 매일 택배를 시키는데 3일마다 이사를 다닌다고 생각하면, 택배기사는 매일 바뀌는 내 집 주소를 Track 할 수 없다.\n하지만 만약, 어떤 사람이 전국민의 주소를 실시간으로 꿰뚫고 있다면, 전화한통걸어서 \u0026ldquo;ㅇㅇㅇ씨 집이 어딘가요?\u0026ldquo;를 물어보면 된다.\nDDNS가 그런 역할을 해준다. 내 실제 IP가 바뀌더라도, 내 IP 주소가 어디인지 알려준다.\n이는 본인이 DDNS를 사용하는 공유기를 쓰고 있다면(모르면 모델명 넣어서 검색해보자) 해결할 수 있다.\n나는 그냥 우연히 받은 iptime 공유기를 쓰고 있기에, 이를 기준으로 설명할 것이다.\n일단 아무 웹브라우저나 열어서 192.168.0.1을 친 뒤에, 로그인을 해보자.\n비밀번호를 까먹었으면, 공유기를 초기화시켜서 admin으로 만들고, 로그인하자\n다음으로, 고급 설정 - 특수기능 - DDNS 설정 으로 가서 내 DDNS를 등록하자.\n만약 iptime 공유기가 아니라면, 무료로 도메인 서비스를 제공해주는 사이트에서 등록을 따로 해야하는 불편함을 감수해야 할 수 있다.\n{: .alignCenter}\n#3. 포트 포워딩 여기까지 했으면 일단 대~충 주소는 알려준 정도이다. \u0026ldquo;진짜\u0026rdquo; 우리집으로 오려면, 몇번지 몇호인지 알려줘야 한다.\n다른 비유를 하자면, 우리집 주소는 알려줬는데, \u0026ldquo;어디로 들어와야 내가 문을 열어줄지\u0026rdquo; 를 정하는 것이다.\n해서, 다시 고급설정 - NAT/라우터 관리 - 포트포워드 설정으로 들어가서,\n규칙 이름은 본인이 원하는 네이밍을 해주고, 내부 IP 주소는 현재 접속된 IP 주소를 선택한다.\n프로토콜은 TCP, 포트는 내외부 둘다 3389로 해주자. 임의의 높은 숫자를 택해도 상관 없다.\n#4. 방화벽 개방 아까 설정한 포트는, 어디로 오세요 주소만 알려준 상태이지, 문을 열어놓은 상태는 아니다. 각 OS마다 포트 개방하는 법이 다르고, 쉬우니까 구글링을 해보자..\n#5. 주피터 설정 자 이제, 주피터노트북을 키던, 혹은 아나콘다 프롬프트를 열어서 ipython을 치던 한 다음에,\nfrom notebook.auth import passwd passwd() 를 입력하여 비밀번호를 input해주자. sha256(맞나? 암튼 sha임)으로 해싱된 암호가 튀어나온다.\n이걸 잘 복사해놓자.\n그리고, 아까 만들었던 configuration 파일을 열어서 다음과 같이 수정한다.\nc.NotebookApp.password = u\u0026#39;(방금 만든 해싱된 암호)\u0026#39; c.NotebookApp.allow_origin = \u0026#39;*\u0026#39; c.NotebookApp.ip = \u0026#34;(아까 포트포워드 설정에서 만든 규칙의 내부IP)\u0026#34; c.NotebookApp.port = 3389 그리고 이부분은 선택사항\nc.NotebookApp.open_browser = False #주피터 노트북 실행시켰을 때, 웹브라우저 열리는걸 막음 c.NotebookApp.notebook_dir = \u0026#39;(디렉토리)\u0026#39; # 주피터 노트북이 처음으로 열리는 디렉토리. 특정 디렉토리로 제한시키기 위해 쓰일 수 있음 저장하고, 주피터 노트북 연다음에, 서버를 열은 컴퓨터 혹은 아무 곳에서나 아까 본인이 설정한 DDNS( ~.iptime.org:3389 ) 를 입력하면 접속이 될 것이다.\n#6. 여기서 끝나면 아쉽다 가정집에서 쓰는 데스크탑을 항상 켜놓는다면 상관이 없지만, 보통 밖에 나가면 집 컴퓨터는 끄기 마련이다. 쓸때 키고 안쓸때 끄는게 정상이니까.\n근데, 밖에 나가 있을때 내가 실수로 컴퓨터를 안키고 나왔다면, 다시 집으로 돌아가기는 귀찮다. 이를 위해서 WOL이란게 존재한다.\nWake on LAN의 약자로, 즉 내가 컴퓨터를 인터넷을 통해서 키겠다는 얘기다.\n그 전에, 먼저 본인 컴퓨터가 \u0026ldquo;WOL을 지원하는지\u0026quot;에 대해서 한번 검색해보고, 지원한다면 ON 시켜놓자\n#7. WOL (Wake on LAN) 아까 들어갔던 192.168.0.1로 다시 들어가보자.\n고급설정 - 특수기능 - WOL 기능이 있다. 눌러보자.\n보면 MAC주소와 PC 설명을 넣고 \u0026ldquo;추가\u0026quot;를 할 수가 있다. 당연하게도, \u0026ldquo;현재 접속된 PC의 주소로 설정\u0026quot;을 체크하면 본인이 사용하고 있는 MAC주소가 입력되고\nPC설명은 그냥 대충 붙인다음에 추가를 하자.\n다음으로, 고급설정 - 보안 기능 - 공유기 접속/보안관리 를 들어가보자.\n아까 설정한 포트는 \u0026ldquo;주피터 노트북을 위해 개방한 포트\u0026rdquo; 이고, 지금 설정할 포트는 \u0026ldquo;공유기한테 명령을 내리기 위해 개방하는 포트\u0026quot;이다.\n외부접속보안 밑에 \u0026ldquo;원격 관리 포트 사용\u0026quot;을 체크하고, 적당한 1024 이상의 번호를 집어넣고, 적용을 누른다.\n그럼 이제 내 컴퓨터에 뭘로 명령을 줄 것이냐? 항상 갖고 다니는 핸드폰으로 하자.\n{: .alignCenter}\niptime wol을 다운받고, \u0026ldquo;공유기 수동 추가\u0026quot;를 누르자.\n이름은 적당히 아무거나 붙이고,\n외부 IP or DDNS 주소 : 내가 설정한 DDNS 주소( ~.iptime.org )\n원격접속 포트 : 1024 이상의 내가 설정한 포트 (주피터 포트 아님 ! 유의 )\nLogin ID와 암호 \u0026ndash;\u0026gt; 내가 192.186.0.1에서 관리자 로그인할때 사용한 ID와 비밀번호\n공유기 연결을 하자. 아까 내가 7번의 WOL 기능에서 설정한 이름이 보인다.\n#8. 시작프로그램 설정 컴퓨터만 키면 뭐하나, 주피터를 열어야지. 리눅스의 경우 startup application(아마도)\n윈도우의 경우 실행(윈+R 단축키) \u0026ndash;\u0026gt; shell:startup에서 뜨는 폴더에 jupyter 바로가기를 집어넣자.\njupyter 바로가기를 못찾겠다면, 윈도우 키를 누른 뒤에 jupyter 까지만 쳐도 자동완성으로 보일 것이다.\n이러면 준비는 끝났다. #9. 테스트 컴퓨터를 끄고, 먼저 휴대폰으로 컴퓨터를 깨워보자.\n켜진다. Good.\n컴퓨터는 아무것도 건들지 말고, 주피터가 켜지는지 확인해보고,\n외부(다른 컴퓨터 혹은 핸드폰)에서 내 DDNS를 입력해봐서, 성공하면 끝이다.\n{: .alignCenter} 잘 된다.\n#10. 디렉토리 설정이 안될 경우 왜인진 모르겠는데 내가 config 파일에서 설정을 했는데도, 그냥 사용자 폴더가 열려버렸었다.\n구글링에 시간을 좀만 투자해보니, 다음과 같은 해결책이 있었다.\n내가 아까 시작프로그램에 넣어놓은 jupyter notebook 바로가기를 속성으로 열은 뒤에, 대상 부분의 맨 뒤로 가면 어떤 경로가 있다. 이걸 수정해주면 된다.\n만약 내가 바탕화면으로 설정하고 싶다면\n\u0026ldquo;C:\\Users\\(사용자이름)\\Desktop/\u0026rdquo;\n(\\랑 /를 잘 구분해야 함)\n로 집어넣으면 된다.\n#11. 여담 이번에 이사가면서 인터넷을 새로 달면서 공유기를 받았는데, DDNS 주소를 고칠수가 없게 되어 있었다.\n즉, iptime.org 부분이 다른걸로 고정되어 있었는데, 그 도메인 서비스 제공하는 홈페이지를 들어가보니 유료였다.\n어떻게 방법이 없을까 한참 애먹다가, 결국 기존에 갖고있던 iptime 공유기를 이중으로 달았다.\n근데 또 서버가 안들어가져서, 찾아보니까 뭐 받은 IP를 iptime으로 넘겨줘야 하느니\u0026hellip;.\n몇시간에 걸쳐서 간신히 해결하고 나니까, 더이상 손도대기 싫고, 잘 기억도 안나고, 해서.. 여기서는 스킵했다.\n만약 누군가가 도움을 요청한다면 다시 찾아보겠읍니다..\n아무튼, 끝!\n","permalink":"http://cjlee38.github.io/post/data/data_mining/2020-08-27-how_to_run_jupyter_server/","summary":"#0. 서버의 필요성 저번 방학 때, 공모전을 진행하면서 여러가지 난관에 부딪혔다. 지금도 아직 많이 부족한 나부랭이이지만, 그때 당시에는 서로가 갖고 있는 노트북으로 작업을 진행하기에는, 컴퓨팅 파워도, 시간도 부족했다. 그래서 서버의 필요성을 느꼈다. 결국에는 아마존에서 EC2를 하나 빌려다가 쓰긴 했지만, 그 전에 \u0026ldquo;이거부터 한번 해보고, 안되면 아마존을 쓰자\u0026rdquo; 라는 생각으로 개인 데스크탑을 서버로 열었다. #1. 본론으로 여러가지 이야기는 제쳐두고, 그래서 어떻게 하느냐..\n일단 아나콘다 프롬프트를 열어서\n$ jupyter notebook --generate-config 로 configuration 파일을 생성한다.","title":"# 주피터 노트북 서버 열기"},{"content":"0. 서론 : 데이터 수집 모듈을 작성했던 인턴쉽 과정 동안, 파이썬을 많이 애용했다. 초기 작성은 그럭저럭 잘 되가나 싶었는데, 가장 해결하기 힘들었던 문제 두가지를 꼽자면, 비동기와 인코딩이 되겠다.\n비동기란 개념을 이번에 처음 알게되었는데, 각고의 구글링과, 테스트를 통해 어찌어찌 기워넣는 수준으로 비동기를 적용하였다. 여담이지만 체감상, 구글링해서 나오는 자료의 대부분은 자바스크립트에서 개념을 갖고와 설명해줬고, 나머지 대부분은 코드만 보여주고 \u0026ldquo;이게 비동기 요청입니다\u0026rdquo; 하는데, 제각기 사용법도 다르고, 실제 몇번 테스트를 해봤을 때도 성능이 다른 것을 확인할 수 있었다. 일부 아주 훌륭하신 분들이 작성한 게시글에 큰 도움을 받았다.\n인코딩은 추후에 다시 공부해서 작성하겠지만, 직접적으로 해결한 것이 아닌, 간접적으로 우회해서 해결하는 방식을 채택했기 때문에 해결했다고 보기도 어려울 것 같다. 와중에, 계속해서 눈에 밟히던 string prefix에 대해서 가볍게 다뤄보고자 한다.\n1. What is the string prefix ? : 별 거창한 건 아니고, 문자열 앞에 붙는 알파벳을 말한다.\n가령, 근래에 파이썬을 배우신 분들은 이런 코드를 본 적이 있을것이라 생각한다.\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Jack\u0026#34; \u0026gt;\u0026gt;\u0026gt; string = f\u0026#34;Hi, my name is {name}\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(string)  Hi, my name is Jack string에 문자열을 할당할 때 앞에 보이는 f 가 바로 prefix의 일종이다.\n이러한 prefix의 종류는 파이썬 3.7 기준 4가지로, r, b, u, f가 있다. 이에 대해서 살펴보자.\n편의상 f, b, u, r 순으로 설명한다.\n2. String prefix 1) f - format : 바로 위 예시에서 보이듯, 따옴표 앞에 f를 붙여주니 { } 중괄호가 그대로 쓰이지 않고, 변수를 받는데 사용된 것을 볼 수 있다. 이는 PEP 498, 파이썬 버전으로는 3.6부터 새로 도입된 기능이다.\n이렇게 작성하는 주된 이유는 가독성인데, 위 예제를 좀 더 복잡하게 만들어보자.\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Jack\u0026#34; \u0026gt;\u0026gt;\u0026gt; age = \u0026#34;25\u0026#34; \u0026gt;\u0026gt;\u0026gt; sex = \u0026#34;male\u0026#34; \u0026gt;\u0026gt;\u0026gt; major = \u0026#34;Computer Science\u0026#34; \u0026gt;\u0026gt;\u0026gt; favorite_food = \u0026#34;kimchi\u0026#34; 이름에 더해서, 나이, 성별, 전공, 좋아하는 음식까지 추가했다.\n이를 출력하려면, 다음과 같은 방법들이 사용될 수 있다.\n# A \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hi, my name is \u0026#34; + name + \u0026#34;, I\u0026#39;m \u0026#34; + age + \u0026#34; years old, and my gender is \u0026#34; + sex + \u0026#34;. I\u0026#39;m majoring in \u0026#34; + major + \u0026#34;. I like \u0026#34; + favorite_food) # B \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hi, my name is {}, I\u0026#39;m {}years old, and my gender is {}. I\u0026#39;m majoring in {}. I like {}\u0026#34;.format(name, age, sex, major, favorite_food)) # C \u0026gt;\u0026gt;\u0026gt; print(f\u0026#34;Hi, my name is {name}, I\u0026#39;m {age}years old, and my gender is {sex}. I\u0026#39;m majoring in {major}. I like {favorite_food}\u0026#34;)  Hi, my name is Jack, I\u0026#39;m 25 years old, and my gender is male. I\u0026#39;m majoring in Computer Science. I like kimchi A 방법은 가장 일반적으로 string을 concatenate 하는 방법이지만, 중간중간 쉼표, 띄어쓰기 등을 작성하기가 굉장히 까다롭다. + 대신 , 를 붙이는 방법도 있겠지만, 그래도 쉽지 않다.\nB 방법은 그나마 손이 좀 덜가지만, 각 순서를 따지기가 어렵다. 실수로 age가 들어가야 할 자리에 sex 변수를 할당할 실수의 여지가 있다.\nC 방법은, 손도 그나마 덜가고, 변수 할당의 실수도 적다. 따라서, C 방법을 가장 애용하는 편이다. 결국 작성하는 사람이 편한대로 쓰겠지만, 좋은거 쓰라고 줬는데 안 쓸 이유가 없지 않다.\n여담으로, 요새 자바스크립트를 배우고 있는데, 자바스크립트에서 다음과 같은 템플릿 리터럴과 흡사하다.\nconst value = \u0026#34;20\u0026#34;; console.log(`value is ${value}`) 2) b - bytes : b는 bytes를 의미한다. 우리가 보는 데이터들은 모두 바이트로 저장되어야 한다. 추후에 다른 게시글로 자세히 서술하겠지만, 간단히 이야기하자면, 우리가 다루는 모든 데이터들은 특정 \u0026ldquo;인코딩\u0026quot;을 통하여 바이트로 변환이 되고, 이 바이트를 저장했다가, 필요할 때 다시 \u0026ldquo;디코딩\u0026quot;을 통하여 사람이 알아볼 수 있게 해석해내는 것이다.\n\u0026gt;\u0026gt;\u0026gt; _str = \u0026#34;this is a string\u0026#34; \u0026gt;\u0026gt;\u0026gt; _bytes = b\u0026#34;this is a string\u0026#34;  \u0026gt;\u0026gt;\u0026gt; print(_str) \u0026gt;\u0026gt;\u0026gt; print(_bytes)  this is a string b\u0026#39;this is a string\u0026#39; 위 코드를 보면, \u0026ldquo;어, 바이트인데 앞에 b가 붙은거 말고는 차이가 없는데요?\u0026ldquo;라고 할 수 있다. 그러나, 실상은 바이트코드이고, 사람에게 보여주기 위해서 다시 컴퓨터가 임의로 디코딩한 결과물이다. 이를 명시하기 위에 앞에 b가 붙었다.\n3) u - unicode : unicode를 의미하는 u는 파이썬2에서 사용되던 syntax이다. python3는 default encoding이 unicode이므로, 굳이 붙이지 않아도 상관 없다.\n\u0026gt;\u0026gt;\u0026gt; u\u0026#34;this is a string\u0026#34; == \u0026#34;this is a string\u0026#34; True 헷갈리는 사람은 다음의 두 글을 살펴보는 것도 좋겠다.\n  What\u0026rsquo;s the u prefix in a Python string?\n  What encoding do normal python strings use?\n  4) r - raw : 마지막으로, r 은 raw를 의미한다. 이는 escape 문자를 특별하게 다루지 않는다.\n다음의 예제를 보자.\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;hi.\\nhello.\u0026#34;) hi. hello.  \u0026gt;\u0026gt;\u0026gt; print(r\u0026#34;hi.\\nhello\u0026#34;) hi.\\nhello 줄바꿈이 일어나지 않고, 이스케이프 문자가 그대로 표현된 것을 볼 수 있다.\n3. 비교해보자 : 마지막으로, 각 문자열들을 돌아가면서 간단히 비교해보자.\nfrom itertools import combinations  def compare(dct, x, y):  return dct[x] == dct[y]  string_dict = {  \u0026#34;_default\u0026#34; : \u0026#34;string\u0026#34;,  \u0026#34;_format\u0026#34; : f\u0026#34;string\u0026#34;,  \u0026#34;_bytes\u0026#34; : b\u0026#34;string\u0026#34;,  \u0026#34;_unicode\u0026#34; : u\u0026#34;string\u0026#34;,  \u0026#34;_raw\u0026#34; : r\u0026#34;string\u0026#34; }  for c in combinations(string_dict.keys(), 2):  print(f\u0026#34;compare {c[0]}\u0026amp; {c[1]}-\u0026gt; {compare(string_dict, c[0], c[1])}\u0026#34;) 결과는 다음과 같다.\ncompare _default \u0026amp; _format -\u0026gt; True compare _default \u0026amp; _bytes -\u0026gt; False compare _default \u0026amp; _unicode -\u0026gt; True compare _default \u0026amp; _raw -\u0026gt; True compare _format \u0026amp; _bytes -\u0026gt; False compare _format \u0026amp; _unicode -\u0026gt; True compare _format \u0026amp; _raw -\u0026gt; True compare _bytes \u0026amp; _unicode -\u0026gt; False compare _bytes \u0026amp; _raw -\u0026gt; False compare _unicode \u0026amp; _raw -\u0026gt; True bytes를 제외한 나머지는 전부 같은 것을 확인할 수 있다.\nraw와 다른 문자열들이 왜 같은지 의구심을 가질 수 있는데, 이는 차후에 str() 과 repr()의 차이를 다루면서 설명하겠다.\n- Reference\nhttps://docs.python.org/ko/3/reference/lexical_analysis.html#literals\nhttps://stackoverflow.com/questions/2464959/whats-the-u-prefix-in-a-python-string/2464968#2464968\nhttps://stackoverflow.com/questions/54533637/rstring-bstring-ustring-python-2-3-comparison\nhttps://stackoverflow.com/questions/2592764/what-does-a-b-prefix-before-a-python-string-mean\nhttps://stackoverflow.com/questions/3547534/what-encoding-do-normal-python-strings-use\n","permalink":"http://cjlee38.github.io/post/language/python/2020-08-27-python_prefix/","summary":"0. 서론 : 데이터 수집 모듈을 작성했던 인턴쉽 과정 동안, 파이썬을 많이 애용했다. 초기 작성은 그럭저럭 잘 되가나 싶었는데, 가장 해결하기 힘들었던 문제 두가지를 꼽자면, 비동기와 인코딩이 되겠다.\n비동기란 개념을 이번에 처음 알게되었는데, 각고의 구글링과, 테스트를 통해 어찌어찌 기워넣는 수준으로 비동기를 적용하였다. 여담이지만 체감상, 구글링해서 나오는 자료의 대부분은 자바스크립트에서 개념을 갖고와 설명해줬고, 나머지 대부분은 코드만 보여주고 \u0026ldquo;이게 비동기 요청입니다\u0026rdquo; 하는데, 제각기 사용법도 다르고, 실제 몇번 테스트를 해봤을 때도 성능이 다른 것을 확인할 수 있었다.","title":"# Python string prefix에 관하여"},{"content":"1. 왜 다시 우분투로? 리눅스를 지원한다는 프로그램들도, 대부분 데비안이나 레드햇계열의 확장자만 제공해주고, 아치 리눅스는 외면받는 현상을 정말 많이 목격했다. 예를들면 팀뷰어라던가.. 슬랙이라던가.. 덤으로 압도적으로 차이나는 구글링 결과 숫자도.\n기어코 구글링을 할때에도\nfor/on manjaro로 검색하던 것을 for/on linux/manjaro로 검색하는 꼴이 되버리니 이게 뭐하는 짓인가 싶더라.\n결국 다시 우분투로 갈아타니, 상대적으로 이렇게 편할수가 없더라. deb확장자를 볼때에는 눈물이 다 나더라.\n2. 태블릿을 듀얼 모니터로 활용 - 실패담 해야 할 공부는 안하고, 공부를 할 환경만 이것저것 세팅하는데 재미를 붙이다보니, 자주 활용하지 않던 예전 태블릿\n(galaxy tab A(2016) with s pen) 을 듀얼 모니터로 활용할 수 있을까 하는 생각이 들었다.\n별로 그렇게 어려울 것 같지도 않겠다 하는 생각에, 대충 찾아보니 태블릿을 듀얼모니터로 활용하는 프로그램은 세가지가 있었다.\n spacedesk2. 태블릿을 듀얼 모니터로 활용하기 Twomon(SE, USB, Air) displaylink  spacedesk는 무료로 제공되는 프로그램이다. 근데 아무래도 무선으로 활용하는 방식이라 뭔가 많이 느릴 것 같았고, 윈도우에서만 지원하기에, 또 다시 wine으로 골머리 썩기 싫어서(설치파일이 msi 확장자여서) 그냥 스킵했다.\nTwomon은 유료이긴 하지만, 정말 많이 활용되는 소프트웨어인 것 같았다. 영어로 구글링하면 거의 반절 이상은 twomon으로 쏟아져 나왔다. 근데 얘도 윈도우와 맥에서만 지원하길래, 그나마 exe 확장자인걸 보고 와인으로 한번 시도 정도는 해보았으나 (플레이스토어/앱스토어 에서 5000원/10000원으로 판매, 데스크탑 프로그램은 무료인듯) 와인을 윈도우10, 64빗으로 세팅해도 버전이 낮다고 안되길래 \u0026ldquo;역시구나\u0026rdquo; 하면서 스킵했다. 아마 와인 사용법도 제대로 모르는게 흠인듯.\ndisplaylink는 리눅스도 지원한다길래, 옳다구나 하고 바로 시도해보았는데, 얘는 소프트웨어가아니라 드라이버인것 같더라. 장장 8시간 가까이를 시도했는데도, 결국 실패하고 말았다.\n이것저것 구글링해본 최종 결과는 \u0026ldquo;USB Host Mode\u0026quot;가 안되서 인 것 같았다. \u0026ldquo;충전중일 때에는 호스트 모드가 안되고, 호스트 모드가 안되면 사용을 못합니다\u0026rdquo; 라고 하는 것 같았다. 태블릿이 아닌 내 스마트폰으로 시도해보았는데도 안되더라. 후..\n아이패드를 사용하시는 분은 여기를 참고하면 좋을 것 같다.\n결국 외면하고 외면하던 VNC라는 것을 활용해보기로 했다.\n3. 태블릿을 듀얼 모니터로 활용하기 - 성공담 VNC가 뭔가 하고 찾아보니, Virtual Network Programming의 약자로, 한마디로 원격제어로 이해했다.\n원격제어랑 듀얼모니터랑 무슨 상관이지? 싶었는데, 이게 일종의 꼼수인 것 같더라. 무슨말이냐 하면, 내 모니터로 내보내는 해상도를 가상으로 확장시킨 다음에, 빈공간을 원격제어로 접근하는 것이다.\n예를 들어, 내가 현재 모니터를 800600으로 사용하고 있는데, 얘를 강제로 1600600으로 확장해놓고 보면, 내 모니터에서는 800600만 보여주게 되고, 나머지 빈공간의 800600을 원격제어로 접근하는 것이다. 참 기발하더라.\nExtending desktop over VNC, the easy way / Community Contributions / Arch Linux Forums\n처음에는 위의 링크를 따라해보았으나, 똑같이 진행했는데도 에러가 나고, 구글링을 해봐도 별 소득이 없어서 포기할까 하려는 찰나, 한 은인을 뵙게 되었다.\nAndroid tablet as second monitoron Ubuntu 16.04\nmrenrich84/vnc_virtual_display_linker\nApparently, nobody took this seriously.\nSo I decided to create a script that configures your X11 server and creates a VNC server automatically.\nnobody took this seriously\u0026hellip;. 참 공감되는 말이다. 아무튼, 첫번째 링크에 있는 커맨드를 파이썬으로 잘 조립해놓으셨다. 사용하는 방법은 정말 쉽다.\n써있는대로\n$ sudo apt install x11vnc $ x11vnc -storepasswd #비밀번호 설정 $ git clone https://github.com/mrenrich84/vnc_virtual_display_linker $ cd vnc_virtual_display_linker $ ./vnc_virtual_display_linker.py 를 순서대로 진행한다.\n그리고 현재 나는 우분투 18.04.04를 사용하고 있으므로, 다음도 진행해줬다.\nThe solution would be to create the following file: sudo vim /usr/share/X11/xorg.conf.d/20-intel.conf with the following content: Section \u0026#34;Device\u0026#34; Identifier \u0026#34;intelgpu0\u0026#34; Driver \u0026#34;intel\u0026#34; Option \u0026#34;VirtualHeads\u0026#34; \u0026#34;2\u0026#34; EndSection and the logout/re-login. 그리고, C를 타이핑해서 내가쓰고있는 모니터의 width와 height를 설정한뒤, 내가 사용할 가상 모니터의 width와 height를 설정한다.\n그리고 N 타이핑 -\u0026gt; 엔터, 마지막으로 S 타이핑.\n(A의 경우 케이블을 이용하는 방식인 것 같은데, 제대로 안해봐서 모르겠다.)\n이러면 이제 원격제어를 할 수 있는 서버가 열린거다.\n다음으로 VNC Viewer, 즉 클라이언트 역할을 하는 어플리케이션을 플레이스토어에서 다운받았다.\n나는 \u0026lsquo;VNC Viewer - Remote Desktop\u0026rsquo; 이라는 어플을 다운받았다.\n어플을 실행한 뒤, 우측 하단의 + 버튼을 누르면 아이피와 포트, 그리고 임의로 정하는 이름을 입력하는 창이 등장한다.\n아이피는 터미널에서\n$ ip addr show 를 통해서 inet에 해당하는 아이피 번호를,\n포트는 서버를 열었을 때 보이는 포트 (나는 5900이었다) 를 입력하고, 이름은 대충 아무거나 써서 진행했다.\n그리고나서 몇가지 물어보는 부분에 대답을 해주고 나면\u0026hellip;\u0026hellip;\n결실을 맺는다.\n4. 자주 쓸까? 그런데 몇가지 문제점이 있다.\n첫째로는 refreshing rate가 너무 낮다. 생각으로는 유튜브나 강의영상을 태블릿에 띄워놓으려고 했는데, 렉이 너무걸린다. 아마 케이블을 연결하는 방식이 있었으니 이를 활용하면 어떻게 잘 될지도 모르겠다.\n둘째로는 내가 설정해놓은 resolution이 좀 어긋났다. 이건 아마 이것저것 테스트를 해봐야 할 것 같다.\n셋째는\u0026hellip; 첫 번째 문제랑도 연관이 있는데, 결국 인터넷을 사용하는 방식이기 때문에 와이파이가 없으면 사용하기가 어렵다. 이 역시 케이블을 이용해봐야 할 것 같다.\n마지막으로는, 갑자기 팬 소음이 엄청 시끄러워졌다. 그만큼 cpu를 많이 잡아먹는다는 이야기인 것 같은데\u0026hellip; 그럴만 한가? 아무튼, 총합 약 12시간에 걸친 듀얼모니터를 반만 성공했다. 나머지는 다음에 하는걸로..\n다음 포스팅은 겸사겸사 진행했던, 주피터 노트북으로 서버 여는 방법으로 적어야 겠다.\n","permalink":"http://cjlee38.github.io/post/linux/2020-03-20-tablet_as_dual_monitor/","summary":"1. 왜 다시 우분투로? 리눅스를 지원한다는 프로그램들도, 대부분 데비안이나 레드햇계열의 확장자만 제공해주고, 아치 리눅스는 외면받는 현상을 정말 많이 목격했다. 예를들면 팀뷰어라던가.. 슬랙이라던가.. 덤으로 압도적으로 차이나는 구글링 결과 숫자도.\n기어코 구글링을 할때에도\nfor/on manjaro로 검색하던 것을 for/on linux/manjaro로 검색하는 꼴이 되버리니 이게 뭐하는 짓인가 싶더라.\n결국 다시 우분투로 갈아타니, 상대적으로 이렇게 편할수가 없더라. deb확장자를 볼때에는 눈물이 다 나더라.\n2. 태블릿을 듀얼 모니터로 활용 - 실패담 해야 할 공부는 안하고, 공부를 할 환경만 이것저것 세팅하는데 재미를 붙이다보니, 자주 활용하지 않던 예전 태블릿","title":"# 다시 우분투로, 그리고 태블릿을 듀얼 모니터로 활용하기"},{"content":"1. 한글 설정 리눅스에는 여러가지 한글 입력기가 있지만, 대체로 많이 알려진 것은 ibus와 uim인듯 하다. 우분투를 처음 깔았었을 당시만 하더라도 뭣도 모르고 두개를 동시에 다 깔았고, ibus로 한글입력을 했었지만, 이번에 다시 한번 찾아보니 대체로 uim이 오류가 적다고 해서, uim으로 설치했다.\n{: .alignCenter}\n$ sudo pacman -S uim 명령어를 통해서 uim을 설치한 뒤에, vim으로 .xprofile을 다음과 같이 수정하였다. ( xprofile을 처음 열어보는 거라면, 아무 것도 없어서 \u0026lsquo;내가 잘못열은건가?\u0026rsquo; 할 수도 있다. 사실, \u0026ldquo;수정\u0026quot;이라는 단어가 아니라 \u0026ldquo;생성\u0026quot;으로 봐도 무방하다. )\n$ vim ~/.xprofile export GTK_IM_MODULE=uim export QT_IM_MODULE=uim uim-xim \u0026amp; export XMODIFIERS=@im=uim 그리고, 아래의 명령어로 설정창을 열어준 뒤에, 다음 사진들과 같이 세팅을 해주고 재부팅을 하면, 끝이다. 간단하다.\n$ uim-pref-gtk {: .alignCenter}\n{: .alignCenter}\n{: .alignCenter}\n저번에 우분투를 썼을 당시에, 한글 키 입력에 고생을 좀 많이해서, 한영변환을 컨트롤+스페이스로 하는것에 익숙해져있어서 딱히 수정하지 않았는데 (이번에도 또 골머리 아플 것 같아서..)\n만약 이에 익숙해있지 않은 사람이라면, 다음을 테스트해보면 좋을 것 같다. 잘 되는지는 안해봐서 모르겠다.\n$ vim ~/.xprofile xmodmap -e \u0026#39;remove mod1 = Alt_R\u0026#39; xmodmap -e \u0026#39;keycode 108 = Hangul\u0026#39; xmodmap -e \u0026#39;remove control = Control_R\u0026#39; xmodmap -e \u0026#39;keycode 105 = Hangul_Hanja\u0026#39; :wq 그리고 벼루 키 바인딩 1에서 벼루on, off를 기존에 사용하던 한글 버튼으로 grab해주면 된다.\n2. 터치패드 제스처 아무래도 랩탑을 사용하다 보니, 터치패드+마우스를 동시에 사용하는데 적응 되어있었고, 또 윈도우에서도 맥 못지않게 여러손가락으로 터치패드를 사용하도록 제공해줘서 편리하게 사용했는데, 리눅스에서는 이런 부분이 좀 부족하다.\nlibinput-gestures 라는 녀석이 멀티터치 제스쳐를 제공해준다고 한다.\n아주 친절하게 설치 방법을 알려주므로, 고대로 따라하면 된다. 이거보다 더 쉽게 설명하기는 어려울 듯\n3. 카카오톡 사실 카카오톡이 우분투를 메인os로 사용하다가 버리게 된 가장 큰 이유일 것이다. 걸핏하면 죽어버리고, 안되는 것도 많고.. 그렇다고 리눅스를 버릴지언정 카카오톡을 버릴순 없으니, 이번에 다시 한번 깔아보았다. 문제가 생기는건 여전하지만;\n일단 기본적으로 카카오톡은 리눅스를 지원하지 않는다. 해줄게요~ 라는 말이 나온지가 약 2년전인거같은데, 아직도 안해주는거보니까 그냥 말만 해놓고\u0026hellip;. 아무튼, 그래서 wine이라는 녀석이 필요한데 얘는 \u0026ldquo;리눅스에서 윈도우 프로그램을 실행하게 해주는 놈\u0026quot;이라고 생각하면 된다. 물론 완벽하게 호환이 되지는 않는다.\n아무튼, 그래서 설치 방법은\n $ sudo pacman -S wine winetricks cabextract $ WINEARCH=win32 WINEPREFIX=~/.wine wine wineboot $ wget https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks $ chmod 777 winetricks $ winetricks -\u0026gt; Select the default wineprefixaa 체크 -\u0026gt; Install a Windows DLL or component 체크 -\u0026gt; gdiplus, msxml6, riched30, wmp9 체크한 뒤에 설치 (찾기가 상당히 귀찮다) 이렇게까지 마치고 난 뒤에, 카카오톡 홈페이지에 가서 윈도우용 설치파일을 다운받는다.\n설치된 경로로 이동한 뒤에, 터미널에서\n$ wine KakaoTalk_Setup.exe 를 하면 익숙한 설치 절차가 진행된다.\n그런데, 나처럼 영문판을 기본으로 쓰고있다면 한글이 이상하게 깨진다던지, 혹은 한글 자체는 멀쩡하게 보이는데 한글입력기가 제대로 먹지 않는다. 이럴 때에는\n$ cd ~/.local/share/applications/wine/Programs/KakaoTalk $ vim KakaoTalk.desktop 그리고 굵은 글씨로 표시된 부분을 대충 집어넣어주자.\n[Desktop Entry] Name=KakaoTalk Exec=env WINEPREFIX=\u0026quot;/home/cjlee/.wine\u0026rdquo; LANG=\u0026ldquo;ko_KR.UTF-8\u0026rdquo; wine C:\\\\windows\\\\command\\\\start.exe /Unix /home/cjlee/.wine/dosdevices/c:/ProgramData/Microsoft/Windows/Start\\ Menu/Programs/KakaoTalk/KakaoTalk.lnk Type=Application StartupNotify=true Path=/home/cjlee/.wine/dosdevices/c:/Program Files/Kakao/KakaoTalk Icon=12CF_KakaoTalk.0 StartupWMClass=kakaotalk.exe\n이렇게하면 애지간하면 잘 될것으로 보인다.\n근데, 문제는 와인 업데이트하고나니까 갑자기 한글이 안된다\u0026hellip; 한숨이 절로 나오더라.\n그리고 아직 많이 써보지 못했지만, 두 가지의 크리티컬한 문제점을 발견했는데,\n첫 번째는, 알림이 오면 카톡이 죽어버린다. 카톡에서 알림을 꺼놨는데도 자꾸 죽어버리더라\n두 번째는, 사진 전송이 안된다; 파일 전송까지는 괜찮은데 사진을 전송할 수가 없다.\n두 번째 문제야 어떻게 하더라도, 첫 번째 문제가 아주 골머리가 아파서, 아직은 미뤄두고 있는 상태이긴 한데, 시도해볼만한 것으로는 1. PlayOnLinux를 깔고 그 위에 카카오톡을 설치하는 것, 2. (많이 비효율적이지만) 가상머신을 돌리는것.\n사실 가상머신을 띄워놓으면 왠만한 윈도우 프로그램을 사용하는데에는 문제가 없겠지만, 그럼 리눅스를 쓰는 의미가 퇴색되는 것 같아서 최후의 보루로 미뤄놓고 있는 상태이긴 한데, 지금같은 흐름이라면\u0026hellip; 많이 좋지는 않다.\n4. 오피스 사실 wine 을 이용해서 오피스를 설치하려고 했는데, 설치방법 찾아보기도 귀찮고 해서, 나름 마소 오피스와 잘 호환이 된다는 오픈오피스를 사용해보려고 한다. 물론 다시 학기가 시작되고, 여러가지 문서작업이나 pdf에 주석다는 짓거리를 하다보면 언제 또 욕나오는 상황에 맞닥드릴지는 모르겠지만 ..\n5. 배터리 관리 정신없이 이것저것 설치하다보면, 어느새 박살나있는 배터리를 보고 \u0026ldquo;원래 이랬나?\u0026rdquo; 싶은 숫자가 눈앞에 나타나있다. 리눅스 자체에서 배터리 관리에 크게 신경을 쓰지 않는다니, 뭐..( DIY 정신이 너무 많이 깃들어있는거 아닌가 싶기도 한데)\n아무튼, 자세히 잘 알지도 못하고, 알고 싶지도 않아서, 대충 tlp라는 놈을 설치했다\n$ sudo pacman -S tlp $ sudo tlp start 한 번 실행해놓으면 다음부터 자동으로 실행된다니, 잊어버리고 살아도 되는 듯 하다.\n이정도로 대충 기본적인 세팅 정도는 해두었는데, 쓰면서 얼마나 많은 윈도우 프로그램과 마주하고, 또 와인을 얼마나 많이 파악해둬야 할지 감이 안오니, 이건 뭐 가상머신을 진짜 띄워야 하나.. 물론 아직 써보지는 않았지만, 각종 은행 혹은 정부기관의 공인인증서나, 혹은 여러가지 아주 진드기같은 보안 프로그램들을 설치할 상상을 하니 벌써부터 행복해서 죽을 것 같다.\n","permalink":"http://cjlee38.github.io/post/linux/2020-03-09-manjaro_linux_settings/","summary":"1. 한글 설정 리눅스에는 여러가지 한글 입력기가 있지만, 대체로 많이 알려진 것은 ibus와 uim인듯 하다. 우분투를 처음 깔았었을 당시만 하더라도 뭣도 모르고 두개를 동시에 다 깔았고, ibus로 한글입력을 했었지만, 이번에 다시 한번 찾아보니 대체로 uim이 오류가 적다고 해서, uim으로 설치했다.\n{: .alignCenter}\n$ sudo pacman -S uim 명령어를 통해서 uim을 설치한 뒤에, vim으로 .xprofile을 다음과 같이 수정하였다. ( xprofile을 처음 열어보는 거라면, 아무 것도 없어서 \u0026lsquo;내가 잘못열은건가?\u0026rsquo; 할 수도 있다. 사실, \u0026ldquo;수정\u0026quot;이라는 단어가 아니라 \u0026ldquo;생성\u0026quot;으로 봐도 무방하다.","title":"# 만자로 기본 설정"},{"content":"0. 계기 여러가지 공부를 하면서 간간히 접했던 \u0026lsquo;리눅스\u0026rsquo;란 단어에 적응하기 시작할 무렵, 김정국 교수님의 운영체제 수업을 들으면서 처음으로 페도라를 깔았었다. VirtualBox 위에 설치했던 페도라에 묘하게 끌리기 시작하고, 또 답답한 속도에 \u0026lsquo;내 운영체제에 직업 리눅스를 깔면 어떨까?\u0026rsquo; 하는 생각이 들었다.\n처음 다루는 리눅스인지라, 여러가지 어려움과 난항이 많았고, 구글링을 할때마다 등장하던 \u0026lsquo;우분투\u0026rsquo; 라는 이름에 \u0026lsquo;우분투가 더욱 사용자가 많은 리눅스 버전이구나\u0026rsquo; 싶어 며칠내에 우분투로 갈아탔다. 그러나 한글부터 시작해서 이것저것 세팅해줘야할 부분이 많았고, 윈도우와의 호환성에 여러 어려움을 겪어 필요할 때 이외에는 사용하지 않았다.\n머신러닝을 접하고 공부한 뒤로, \u0026lsquo;하둡\u0026rsquo;과 \u0026lsquo;스파크\u0026rsquo;의 존재에 대해서 알고, 그리고 리눅스의 필요성에 따라 \u0026lsquo;다시 한번 적응해보자\u0026rsquo;라는 마음가짐으로 오래전에 깔았던 우분투를 다시 부팅하였지만, 여러가지 불만스러운 점들은 매한가지였다.\n다시 이것저것 알아보다보니, \u0026lsquo;만자로\u0026rsquo;라는 이름의 리눅스가 나를 다시 이끌었다. 이 녀석은 나를 계속 붙잡을 수 있을까\u0026hellip;\n아무튼, 만자로에 관련한 국내 자료는 많지 않으므로, 언젠가, 누군가(나 자신도 포함하여)를 위하여 한 줄 적어본다.\np.s.1 윈도우와의 듀얼부팅을 감안하고 설치하였습니다.\np.s.2 이미 설치 절차에 대해서 다른 분들이 친절하게 설명하기도 하셨고, 작성자의 귀찮음이 더해져서 나름의 \u0026lsquo;특수 케이스\u0026rsquo;에 대해서 어떻게 대처해야 할까에 초점이 맞춰 작성했습니다. 전체적인 설치 절차는 다른 글을 보시고, \u0026lsquo;어, 나는 이렇게 할껀데 이땐 어떻게 해야 하지?\u0026rsquo; 할 때 이 글을 보시면 좋을 것 같습니다.\n1. usb 굽기 https://manjaro.org/download/\n공식 홈페이지에서 Gnome버전을 다운받았다.(작성일자 기준 18.1.5)\nxfce, kde 등이 뭔지 몰라서, 구글링 해본 결과, \u0026lsquo;manjaro\u0026rsquo;라는 운영체제를 표현하는 GUI 환경의 버전임을 알게 되었다. 이전에 우분투를 사용해본 적이 있었고, 우분투는 Gnome을 사용하고 있다는 이야기, 그리고 \u0026lsquo;진짜\u0026rsquo; 만자로는 처음부터 모든 것을 세팅해줘야 한다는 말에 약간의 두려움이 더해져 \u0026lsquo;일단은 익숙한걸로 해보자..\u0026lsquo;라는 마음에 Gnome으로 설치하였다. (실제로 구글링을 몇번 해보니 \u0026lsquo;그놈 버전을 까신분은 스킵하셔도 됩니다 ㅎㅎ\u0026rsquo; 하는 글들이 많다. 다행인가?)\niso파일을 다운받은 뒤, rufus라는 프로그램을 이용하여 usb에 구웠다.\n{: .alignCenter}\n현재 버전이 3.8까지 나온것 같던데, 예전에 깔아두었던 3.6으로 설치해도 큰 상관은 없었다.\nDevice는 내가 설치하고자 하는 usb의 이름이,\nBoot selection에는 내가 설치할 iso파일 ( 방금 받은 iso 파일 )을 우측의 선택 버튼을 통해 선택하였다.\n예전에는 이렇게 선택하고나서 여러가지 다른 설정을 건드릴 수 있었던 것 같은데, 왠진 모르겠지만 전부다 선택이 불가능하게 처리가 되어버렸다.\n공식 홈페이지의 설치 가이드에는 설치 도중 \u0026lsquo;dd mode로 설치\u0026rsquo; 하라는 문구가 있었지만, 그런것도 없었고, 굽기를 시작하고 끝날때 까지도 이와 관련된 옵션은 찾아볼 수가 없었다. 아는 분 있으면 설명좀 해주시면 고맙겠다. (추측하건대, rufus가 \u0026lsquo;알아서 해주는 것\u0026rsquo; 같다..)\n아무튼, 다 굽고나서, BIOS 설정에 들어가서 USB를 1순위로 두는데, 여기서 또 파티션이 두개로 나타났다. 대충 찾아보니 Hybrid라서 그렇다는 말이 나오는데.. \u0026lsquo;그래서 어쩌라고?\u0026rsquo; 에 대한 대답은 찾아보기가 어려워, 그냥 첫번째 파티션으로 실행하니, Welcome to Manjaro 가 나타났다.\n2. 설치\n{: .alignCenter}\n우분투를 설치할 때에는 \u0026lsquo;한번 테스트 해볼래? 아님 그냥 설치할래?\u0026lsquo;를 물어봤는데, 만자로는 일단 한번 실행시킨 뒤에, 그다음에 \u0026lsquo;진짜 설치\u0026rsquo;를 시작한다. 우분투로 따지면 \u0026lsquo;테스트 이후에 설치\u0026rsquo; 인 느낌이다.\n{: .alignCenter}\n(Donate를 보고, \u0026lsquo;제가 아직 학생이라 돈이 없어요.. 써보고 괜찮으면, 여유 생기면 드릴게요..\u0026rsquo; 하는 생각이 들었다)\nLaunch installer를 선택하고, 쭉쭉 뒤로 넘어가다가, manual partitioning 부분에서 다시 한번 멈춰 섰다. 기존에 우분투가 설치된 파티션을 삭제해버리고, 새로운 파티션에 할당해주려고 하니, 다시 또 머리가 아파왔다.\nSWAP은 뭐고, BOOT는 뭐고, GPT, MBR 등\u0026hellip;.\n약 10분 가량 구글링 해본 결과, 나름대로의 결론은 다음과 같다.\n\u0026lt; MBR / GPT \u0026gt;\nMBR은 내가 기존에 알고 있던 마스터 부트 레코드의 약자가 맞다. 그러나 \u0026lsquo;부팅을 하려면 반드시 마스터 부트 레코드에서 출발해야 합니다\u0026rsquo; 가 아니라, \u0026lsquo;GPT에서도 출발할 수 있다\u0026rsquo; 인 것 같다\u0026hellip; 확실하진 않다.\n아무튼, MBR은 2테라바이트 이하의 구버전에서만 사용한다니, 굳이 선택할 이유가 없어 GPT로 선택하였다.\n\u0026lt; 마운트 위치 \u0026gt;\n대충 보니, 세가지의 종류가 있었던 것 같다\n/\n/home\n/swap\n/boot/efi\n편의상 순서대로 1,2,3,4번으로 이야기하자면,\n1번은 윈도우로 따지면 C드라이브다. 뭔가 프로그램을 설치하려고 할 때 주로 사용되는 파티션이다.\n2번은 D드라이브다. 설치하는게 아니라, 뭔가 큰 파일을 다운받았다던가 하면, D드라이브에 저장해두면, 나중에 C드라이브를 포맷하더라도 D에는 영향을 미치지 않으므로, 백업을 해둘 필요가 없다. 이를 목적으로 만드는 파티션이다.\n3번은, 메모리에 올려놓은 데이터를 임시로 내려놓는 파티션이다. (현재 사용하는 노트북의 램이 8G인지라, 머신러닝을 할 때 불편한 점이 많았다. virtual memory를 쓸 생각을 왜 못했을까)\n잠시 메모리와 관련해서 이야기하자면, 나는 누군가에게 설명을 할 때 \u0026lsquo;책상\u0026rsquo;으로 비유를 한다. 책상위에 올려놓고 작업을 하다가, 다 끝나면 잘 정리해서 서랍에 다시 보관해놓는다. 따라서 당연히 하드디스크는 서랍이다. 서랍 속에 있는 자료를 갖고 작업할 수는 없는 노릇이니.\n나는 어차피 리눅스를 위해 약 64기가의 디스크를 여유로 놓았으므로, 8기가(일반적으로 메모리 용량, 혹은 *2 만큼의 공간을 할당하는게 \u0026lsquo;국룰\u0026rsquo;이라 카더라)만큼의 스왑파티션을 놓고, 나머지 약 56기가를 그냥 루트(1번)에 때려 박았다. 프로그램을 얼마나 설치할지 , 얼마나 필요할지를 잘 몰라서..\n마지막으로, 기존에 윈도우에서 사용하던 부트 레코드(file system이 FAT32로 되어있음)를 /boot/efi(4번)\n에 마운트해주면서 마무리 했다.\n그리고 유저/관리자 계정의 비밀번호를 설정해주고, 오피스는 따로 설치하지 않았다.\n참 이게 골때리는게, 리브레오피스를 우분투에서 써봤는데, 마이크로소프트 오피스와 호환은 되는데 저장할 때마다 자꾸 저장이 안되었다고 에러를 내뱉고, 윈도우에서 열리지 않거나, 깨질때가 있어서 골치가 좀 아프다. 확장자도 odt인가 뭐시기 였던거 같은데.. 암튼 짜증나서 wine 위에다가 마소 오피스를 깔아볼 생각으로 No office suite를 선택하고 넘겼다.\n{:. alignCenter}\nsummary에서 설정해놓은 옵션들을 다시한번 확인하고, 설치를 한 뒤, 재부팅을 해보니 정상적으로 설치가 됨을 확인하였다.\n뭔가 자의적으로 \u0026ldquo;괜찮겠지\u0026rdquo; 하고 넘어간 부분이 많아서, 언제 문제가 터져버릴지 모르지만.. 그때 생각하는게 나을 것 같다.\n{: .alignCenter} 이제 설치는 끝났으니, 여러가지 기본 세팅들을 해줘야 한다.\n 한글 설정 터치패드 제스쳐 카카오톡 마소 오피스 배터리 관리  이건 다음 글에서 적어보자.. 시간이 벌써 새벽4시다.\n","permalink":"http://cjlee38.github.io/post/linux/2020-02-23-how_to_install_manjaro_inux/","summary":"0. 계기 여러가지 공부를 하면서 간간히 접했던 \u0026lsquo;리눅스\u0026rsquo;란 단어에 적응하기 시작할 무렵, 김정국 교수님의 운영체제 수업을 들으면서 처음으로 페도라를 깔았었다. VirtualBox 위에 설치했던 페도라에 묘하게 끌리기 시작하고, 또 답답한 속도에 \u0026lsquo;내 운영체제에 직업 리눅스를 깔면 어떨까?\u0026rsquo; 하는 생각이 들었다.\n처음 다루는 리눅스인지라, 여러가지 어려움과 난항이 많았고, 구글링을 할때마다 등장하던 \u0026lsquo;우분투\u0026rsquo; 라는 이름에 \u0026lsquo;우분투가 더욱 사용자가 많은 리눅스 버전이구나\u0026rsquo; 싶어 며칠내에 우분투로 갈아탔다. 그러나 한글부터 시작해서 이것저것 세팅해줘야할 부분이 많았고, 윈도우와의 호환성에 여러 어려움을 겪어 필요할 때 이외에는 사용하지 않았다.","title":"# 만자로 리눅스 설치"},{"content":"1. 블로그를 시작하며 지금까지 \u0026lsquo;넓고 얕게\u0026rsquo; 배운 여러가지 지식들에 대해서 머릿속에 담아두기만 했을 뿐, \u0026lsquo;언젠가 정리 해야지, 해야지\u0026rsquo; 하는 마음만 먹고 아무것도 하지 않았었다. 다만 고스란히 내 life 라는 이름의 폴더에 담아두기만 하였을 뿐.\n블로그의 목적이 무엇이 되었던, 구글링을 할 때마다 나타났던 여러 다른 분들의 블로그는 휘황찬란했고, 그걸 볼때마다 \u0026lsquo;이 사람은 정말 대단하구나\u0026rsquo; 싶고, 또 나는 한없이 초라해지는 기분이었다. 그러나 애초에 블로그라는 것이 누구에게 홍보하며 돈을 벌기 위한 수단도 아니었고, 나라고 못할 것은 무엇이랴, 여차하면 접고말지 라는 마인드로 시작하게 되었다.\n2. 무엇을 쓸까 경영학이라는 전공을 시작하며 일부 과목들에 실망하며, 많은 회의감에 빠졌고, 나쁘게 말하면 주관적, 좋게 말하면 인문학적인 접근에 많은 불만을 가졌었다. 문과에서 출발하였지만, 이과적인 사고회로가 내장되어있다보니, 자연스럽게 어렸을떄부터 관심\u0026rsquo;만\u0026rsquo; 있었던 컴퓨터쪽으로 방향을 꺾었고, \u0026lsquo;무엇이던 될 수 있다\u0026rsquo;는(바꿔 말하면, \u0026lsquo;그 무엇도 될 수없는\u0026rsquo;) 경영과 컴퓨팅을 막연하게 섞어보자는 마인드로 이중전공을 신청했다.\n프로그래밍의 세계는 정말 매력적이었고, 단순하게 스크립트에 몇줄 쳐서 Run 시켜보고 성공했을 때 느껴지는 희열감은 그 무엇과도 비교가 되지 않았다. 그러나, \u0026lsquo;자료구조\u0026rsquo;수업을 마무리 할 때 쯤, \u0026lsquo;그럼, 대체 어디 분야를 선택해야하지?\u0026rsquo; 하는 기로에 놓였다.\n\u0026lsquo;난 그냥 코딩하는게 좋은데\u0026rsquo; 라는 마인드였고, 여기저기 찾아보니 \u0026lsquo;아는게 없어서 그렇다. 뭐라도 해보면 갈피가 잡힐 것이다\u0026rsquo; 라는 글귀에 지난 자료구조 강의에서 배웠던 내용을 복습한 뒤, 곧바로 \u0026lsquo;안드로이드 프로그래밍\u0026rsquo;을 처음 시작하게 되었다. 나름대로의 아이템을 갖고 \u0026lsquo;이거 한번 만들어보자\u0026rsquo;라는 기대감에 부풀어 속성으로 \u0026lsquo;윤성우의 열혈 Java\u0026rsquo; 인강을 2주 반만에 다 들었다. 물론 당시에 너무 deep하다고 생각하는 부분은 과감하게 스킵했지만..\n다음으로 안드로이드프로그래밍 서적을 구매하여, 낮에는 이론공부를, 밤에는 내가 만들고자 했던 어플리케이션 개발에 몰두하였다. 그러나 프로그래밍을 배운지 1년 남짓 된 학부생이 잘한다면 얼마나 잘할까.. 내가 천재가 아닌데. 순식간에 불타올랐던 열정은 정말 말그대로 순식간에 연소되어버리고 말았다. 그렇게 결국 며칠에 한번 백준문제 딸랑 하나 풀어보는 수준으로 열의는 바닥을 쳤다.\n복학하고난 뒤, \u0026lsquo;소셜미디어애널리틱스\u0026rsquo;라는 \u0026lsquo;경영\u0026rsquo;수업에서 처음 데이터 관련 수업을 수강하였다. 매력적이지만 이전만큼 끓어오르는 무언가가 없었다. 그저 \u0026lsquo;만나면 친하지만 잘 연락안하는 친구\u0026rsquo;인 것처럼, 가끔 떠올릴 뿐이었다. 이 때에는 김정국 교수님에게 완전히 빠져있었다. 타이트하면서도 깊이있는 강의스타일과, 컴퓨터의 저수준을 다루는 운영체제 수업은 정말 환상적이었다. 그러나 방학 때는 여전히 갈피를 못잡고 네트워크 공부만 붙잡고, 또 놀았다.\n2학기가 되어서, \u0026lsquo;소셜미디어애널리틱스\u0026rsquo;의 교수님이 개설하신 \u0026lsquo;마케팅애널리틱스\u0026rsquo;수업을 수강하게 되자, 이번에는 또 새로운 눈이 트였다. \u0026lsquo;이게 진짜 마케팅이지\u0026rsquo; 싶은 객관적인 접근 방식에 다시 한번 매료되었고, 데이터 관련 직무에 대해서 찾아보기 시작하였다.\n\u0026lsquo;데이터 사이언티스트\u0026rsquo;, \u0026lsquo;데이터 애널리스트\u0026rsquo;, \u0026lsquo;데이터 엔지니어\u0026rsquo; \u0026hellip;\n결국 나는 어떤 날을 기점으로, \u0026lsquo;나는 데이터 엔지니어를 목표로 해야겠다\u0026rsquo; 싶은 마음을 먹게 되었다. 이 마음이 언제까지 지속될지는 모르겠지만, 당장 눈앞에 목표가 생긴게 어디냐\u0026hellip;\n{:.alignCenter}\n아무튼, 데이터 분석, 그리고 안드로이드 프로그래밍, 언젠가 배우게 될 웹개발 등 까지.. 언제까지 Generalist 로 있게 될지는 모르겠지만, 그래도 이에 대해서 차근차근 하나하나 정리해보고자 한다.\n3. 어떻게 쓸까 사고회로는 이과여도, 전형적인 수포자이며 문과로의 도망자일 뿐인지라, 또 다른 여러가지 \u0026lsquo;원리\u0026rsquo;(수학적인 것이 되었던, 무엇이던..) 에 관한 부분은 구글링 조금만 해도 상위에 찍히는 블로그에 자세하게 서술되어 있기 때문에, 최대한 intuitive한 관점을 섞어서 서술하고자 한다. 물론 원리원칙적인 부분은 계속 공부해야지..\n","permalink":"http://cjlee38.github.io/post/diary/2020-02-23-prologue/","summary":"1. 블로그를 시작하며 지금까지 \u0026lsquo;넓고 얕게\u0026rsquo; 배운 여러가지 지식들에 대해서 머릿속에 담아두기만 했을 뿐, \u0026lsquo;언젠가 정리 해야지, 해야지\u0026rsquo; 하는 마음만 먹고 아무것도 하지 않았었다. 다만 고스란히 내 life 라는 이름의 폴더에 담아두기만 하였을 뿐.\n블로그의 목적이 무엇이 되었던, 구글링을 할 때마다 나타났던 여러 다른 분들의 블로그는 휘황찬란했고, 그걸 볼때마다 \u0026lsquo;이 사람은 정말 대단하구나\u0026rsquo; 싶고, 또 나는 한없이 초라해지는 기분이었다. 그러나 애초에 블로그라는 것이 누구에게 홍보하며 돈을 벌기 위한 수단도 아니었고, 나라고 못할 것은 무엇이랴, 여차하면 접고말지 라는 마인드로 시작하게 되었다.","title":"# 블로그를 시작하며"},{"content":"얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.\n Java의 static method는 왜 overriding이 안되나요 ?\n static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.\n이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.\n예제 아래 코드를 한번 살펴보겠습니다.(해당 코드는 반복해서 사용할 예정이니 구조를 눈여겨보시기 바랍니다.)\npublic class StaticMethodOverride {  public static void main(String[] args) {  Parent whoAreU = new Child();  whoAreU.myInstantMethod();  whoAreU.myStaticMethod();  } }  class Parent {  public static void myStaticMethod() {  System.out.println(\u0026#34;Parent.myStaticMethod\u0026#34;);  }   public void myInstantMethod() {  System.out.println(\u0026#34;Parent.myInstantMethod\u0026#34;);  } }  class Child extends Parent {   public static void myStaticMethod() {  System.out.println(\u0026#34;Child.myStaticMethod\u0026#34;);  }   @Override  public void myInstantMethod() {  System.out.println(\u0026#34;Child.myInstantMethod\u0026#34;);  } } Parent와 Parent를 상속받는 Chid라는 두 개의 클래스를 만들었습니다. 그리고 Child 클래스를 구현체로 갖는 Parent 객체를 생성한 뒤, 각각 static method와 instance method를 호출했습니다. 그리고 그 결과는 예상했던대로, 아래와 같이 출력되었습니다.\nChild.myInstantMethod Parent.myStaticMethod 왜 instance method는 구현체에 따라 호출되었고, static method는 타입에 따라 호출되었을까요? 그 이유는 java bytecode와 JVM이 메소드를 invoke 하는 방식을 살펴보면 알 수 있습니다.\n바이트코드 자바 컴파일러가 .java 확장자를 가진 자바파일을 읽어들이면서, 작성된 자바코드를 자바 bytecode로 변환합니다. 그리고, javap 명령어를 통해 컴파일된 .class 파일, 즉 bytecode를 역어셈블할 수 있습니다.\n사용한 명령어는 아래와 같습니다.\njavac StaticMethodOverride.java \u0026amp;\u0026amp; javap -c -verbose StaticMethodOverride.class 실행 결과를 살펴보면 꽤 복잡한 내용의 코드가 출력됩니다. 그 중, 가장 먼저 살펴볼 부분은 바로 bytecode 명령어가 담긴 부분입니다.\n알아보기가 힘들지만, 중간 즈음에 위치한 public static void main(java.lang.String[]); 부분이 우리의 main method가 호출되는 지점임을 확인할 수 있습니다.\nCode: 부분으로 넘어가서 살펴보죠. 객체를 생성하는 부분을 제외하고, 메소드를 호출하는 부분만 살펴보면 9번, 14번에 위치한 invokevirtual과 invokestatic이 각각 호출했던 instant method와 static method에 대응합니다. 즉, 바꿔말하면 \u0026ldquo;호출하려는 메소드가 static metho인지, instance method인지\u0026quot;에 대해서는 컴파일타임에 알 수 있다는 점입니다.\n 각각의 명령어가 invokevirtual, invokestatic 이었다는 사실을 기억해주세요.\n 그런데 또 자세히 살펴보면, #4 와 #5 라는 숫자가 써있네요. 이 부분은 constant pool 이라고 하는 곳의 index를 나타냅니다. constant pool을 확인해보겠습니다.\n각각의 #4, #5 번은 MethodRef 라는 의미를 내포하면서, 각각 #18.#19, #18.20 에 대한 index를 다시 나타내고 있습니다. 해당 인덱스를 따라가보면, #18은 Class를, #19는 다시 NameAndType을 가리킵니다. 최종적으로 쭉 따라가다보면, 결국 Utf8 이라는 타입으로 귀결됩니다.\nstatic 위와 같은 과정을 통해, 우리는 java의 클래스나 메소드가 위와같이 재귀참조를 통해 시그니쳐를 나타낸다는 것까지 확인했습니다. 그리고, 호출하는 메소드의 클래스는 슈퍼클래스인 Parent 라는 것까지 확인했죠. 그렇다면 여기서 우리는 메소드의 호출은 \u0026ldquo;타입을 따라간다\u0026rdquo; 라고 추론할 수 있습니다. 이를 증명하기 위해, 서브클래스인 Child를 타입으로 객체를 생성하여 static method를 호출해보겠습니다.\nChild.myStaticMethod(); /* 결과 17: invokestatic #6 // Method study/java/staticmethod/Child.myStaticMethod:()V */ 위와같이 자식 타입에 대한 static method를 호출하고, 바이트코드를 살펴보면 아까와는 다르게 Child에 대한 메소드를 호출함을 볼 수 있습니다. 즉, 슈퍼클래스와 서브클래스의 static method signature는 일치할 수 있으며, 우리는 이를 overriding이 아닌 hiding 이라고 부릅니다.\ninvokevirtual, invokestatic 그런데 이상한점이 있습니다. invokestatic이야 Parent 클래스를 가리키는 것은 그렇다 쳐도, invokevirtual 또한 constant pool을 따라가다보면 Parent 클래스를 가리킨다는 점입니다. 그런데 어떻게 Child 메소드가 호출될 수 있을까요? 이 때 JVM이 메소드를 호출하는 방식, 즉 dynamic dispatch(혹은 dynamic binding)이 동작하는 시점입니다.\nJVM Specification에서는 다음과 같이 설명합니다.\n invokevirtual invokes an instance method of an object, dispatching on the (virtual) type of the object. This is the normal method dispatch in the Java programming language.\n 즉, invokevirtual 은 \u0026ldquo;객체\u0026quot;의 타입을 보고 메소드를 호출한다는 것입니다. 그런데 이것만으로도 설명은 부족합니다. \u0026ldquo;객체\u0026quot;의 타입을 어떻게 보고, 어떻게 메소드를 호출한다는 것일까요 ?\n 여기서 virtual 이라는 키워드는 C++ 의 virtual과 연관이 깊습니다. 이와 관련된 내용은 본 포스팅에서 다루지 않습니다. 단, java의 모든 메소드는 final 이나 static 키워드를 붙이지 않았다면 기본적으로 virtual 메소드라는 점만 짚고 넘어가겠습니다.\n 객체에 대한 reference인 whoAreU 변수 그 자체는 사실 내부적으로 두 개의 포인터를 갖고 있습니다. 하나는 우리가 일반적으로 알고 있는, 힙 영역에 존재하는 객체 데이터에 대한 포인터이고, 다른 하나는 객체의 타입과 메소드 테이블을 가지고 있는 포인터입니다.\n그리고 후자에 해당하는 포인터를 따라, 간접적으로 메소드를 호출할 수 있게 되는것입니다. invokevirtual이 동작하는 방식 또한 역시 JVM specification에 명시되어 있습니다.\n Let C be the class of objectref.\nThe actual method to be invoked is selected by the following lookup procedure: If C contains a declaration for an instance method m that overrides (§5.4.5) the resolved method, then m is the method to be invoked, and the lookup procedure terminates.\nOtherwise, if C has a superclass, this same lookup procedure is performed recursively using the direct superclass of C; the method to be invoked is the result of the recursive invocation of this lookup procedure.\nOtherwise, an AbstractMethodError is raised.\n 즉, 어떠한 메소드를 호출할 때 자기 자신이 호출되어야할 메소드를 갖고있는지 확인하고, 그렇지 않다면 슈퍼 클래스로 이동해서 확인하게 됩니다. 하지만 이는 명세일뿐, 실제 JVM이 구현하는 방식은 다릅니다. 아무래도 매번 이러한 호출과정을 거치게 되면 속도가 느려지겠죠. 따라서 C++에서 차용한 개념인 method table 을 이용해 위 과정을 최적화했습니다.\n각 JVM의 밴더사마다 method table의 구현 방식은 다르지만, 대략 아래와 같이 구현되어있을 것이라고 기대할 수 있습니다.\n Object class\n   Name Address Description     Object.getClass() 0x01 Object.getClass()   Object.toString() 0x02 Object.toString()   (기타 다른 메소드는 생략)       ClassLoader(아마 Boostrap)에 의해 Object 클래스가 로딩되고 나면, Object 클래스가 갖고 있는 여러 메소드들에 대한 method table이 초기화됩니다. 그리고, 기타 사용자(개발자)가 정의한 클래스가 런타임중에 로딩되는 순간, 각각의 메소드테이블이 초기화됩니다.\nParent 클래스가 ClassLoader(아마 Application)에 의해 로딩되면, Object 클래스로부터 method table을 복사한뒤, 자기 자신이 갖고있는 signature에 따라 method table을 업데이트합니다. 따라서, Parent의 method table은 아래와 같이 구성될 것입니다.\n Parent class\n   Name Address Description     Object.getClass() 0x01 Object.getClass()   Object.toString() 0x02 Object.toString()   Parent.myInstantMethod() 0x03 Parent.myInstantMethod()   (기타 다른 메소드는 생략)       Child 클래스 역시 마찬가지로, 자신의 슈퍼클래스인 Parent 클래스로부터 method table을 복사한뒤 업데이트 과정을 거칩니다. 그런데 이 때, Child 클래스는 myInstantMethod()를 overriding 합니다. 따라서, method table은 아래와 같이 업데이트됩니다.\n Child class\n   Name Address Description     Object.getClass() 0x01 Object.getClass()   Object.toString() 0x02 Object.toString()   Parent.myInstantMethod() 0x03 Child.myInstantMethod()   (기타 다른 메소드는 생략)       자, 이제 정리해보겠습니다. JVM이 명령어를 실행하던 도중, invokevirtual을 마주하고 target이 되는 object와 arguments 들을 operand stack 에서 꺼냅니다. 그리고, 해당 object의 method table을 뒤져보고, 호출할 대상이 되는 메소드를 찾아냅니다. 그리고, object와 arguments로 새로운 스택 프레임을 구성하면서 메소드 호출이 이뤄지게 됩니다.\n나가며 method table 이란 것에 대해서 막연하게만 알고 있었는데, 이번 기회를 통해 좀 깊게 파볼 수 있었던 경험이 된 것 같습니다. 이 글을 읽으시는 여러분들도 JVM이 어떻게 메소드를 호출하는지에 대해 원리를 이해하는데 조금이나마 도움이 되셨으면 좋겠습니다.\n참고했던 자료들이 조금 오래된 자료들이라, 현재(Java 8, 11, 17 \u0026hellip;)와는 조금 다를수도 있습니다. 틀린 내용이 있으면 언제든 지적 바랍니다. 감사합니다.\n reference  https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokevirtual https://www.artima.com/insidejvm/ed2/jvmP.html https://en.wikipedia.org/wiki/Virtual_method_table https://www.programmingmitra.com/2017/05/how-does-jvm-handle-method-overriding-internally.html  ","permalink":"http://cjlee38.github.io/post/language/java/2022-11-13-override-static-method/","summary":"얼마전 면접을 봤는데, 갑자기 이런 질문을 받았습니다.\n Java의 static method는 왜 overriding이 안되나요 ?\n static method의 overriding이라.. 너무나도 당연하게 안된다고 생각했는데, 갑작스럽게 질문을 받으니 머리가 백지상태가 되었습니다. 순간적으로 머릿속에서 JVM 구조가 얼핏 지나가면서, class loader, compile time, method area 등 여러 키워드가 지나갔으나 그 무엇도 속시원한 대답은 할 수 없을 것 같았습니다.\n이번 포스팅은, JVM 에서 왜 static method를 overriding 할 수 없는지에 대해, 자세하게 알아보고자 합니다.\n예제 아래 코드를 한번 살펴보겠습니다.","title":"# Java의 static 메소드는 왜 overriding이 안되나요?"}]