[{"content":"어디서 처음 봤는지는 정확히 기억 안나지만, 우연히 괜찮은 git 관련 오픈소스를 발견해서 소개해본다. 이름은 git absorb 라고, git 기반의 일종의 extension 인데, commit history를 관리할 때 유용하게 사용할 수 있다. 먼저 어떤 extension 인지 서두에 정리해보자면, 내가 코드를 수정한 뒤, 해당 작업을 과거의 commit 어딘가에 같이 포함시키고 싶을 때, “가장 관련성이 높은 commit을 찾아”서 흡수시킬 수 있다.\nfixup commit 먼저 git absorb 를 알기 전에 먼저 알아둬야 하는 것이 있는데, 바로 fixup commit이다. manpage(man git-commit 1) 에도 설명이 잘 나와있는데, commit 을 수행할 때 단순히 새로운 commit 을 추가하는게 아니라, 이전의 commit 과 “합칠 수 있는” commit을 제공한다.\n가령, 아래와 같이 a.txt 파일을 만들고 commit 한번 b.txt 파일을 만들고 commit 한 번으로, 총 두 번의 commit 을 통해 아래와 같이 commit history가 있다고 가정해보자.\nee8f6a4 second # b.txt 8eb5b88 first # a.txt 이 상황에서, a.txt 파일에 누락된 사항을 뒤늦게 발견했다고 가정해보자. 새로운 commit 을 만들기는 싫고, 과거의 commit 에 그대로 포함시키고 싶다면 어떻게 해야할까 ? 가장 익숙한(?) 방법은 아마 git reset 을 통해 commit history 를 제거하고, git commit --amend 와 같은 명령어를 이용해서 누락된 수정사항을 포함시킨 뒤, 다시 commit 을 수행하는 방법이다.\n하지만, 목표 commit 에 도달하기까지 수많은 commit history 가 이미 존재하는 상황이라면, --fixup commit을 통해 손쉽게 해결할 수 있다. 사용 방법은 간단하다. 아래와 같이 파라미터를 넘겨주면 된다.\ngit commit --fixup=8eb5b88 # `first` commit 그리고 git log 를 통해 살펴보면 다음과 같이 ‘fixup commit’ 이 추가된다\n# git log --oneline e23e811 (HEAD -\u0026gt; main) fixup! first ee8f6a4 second 8eb5b88 first 이후, git rebase -i --autosquash \u0026lt;commit-id\u0026gt; 를 통해 interactive rebase 를 진행하면, 다음과 같이 fixup commit 이 수정하고자 하는 commit 바로 아래에 자동으로 위치하게 된다. (commit-id 는 first commit 보다 이전 commit id 로 지정한다.)\n# vim editor pick 8eb5b88 first fixup e23e811 fixup! first pick ee8f6a4 second 그대로 저장하고 나와서 rebase 를 수행하면 (별도의 conflict 가 없다면) fixup commit 이 first commit 으로 포함되어 들어가게 된다. (이 외에도 squash commit, amend commit 도 존재한다)\ngit absorb git absorb 는 수정사항이 “어느 commit 으로 포함되어야 하는지” 를 알아서 찾아서, fixup commit 단계를 스킵하도록 해준다.\n위 예시에서, fixup commit 을 수행하는 대신, git absorb 를 입력하면, fixup commit 을 대신 수행해준다. 이 때 어떤 commit 으로 fixup 할 것인지에 대한 판단은 file change 를 기준으로 선정한다. (사실 좀 더 정확한 알고리즘은 이곳 에 나와있다)\nThe command essentially looks at the lines that were modified, finds a changeset modifying those lines, and amends that changeset to include your uncommitted changes.\n그렇기에, 앞서 이야기했듯 누락된, 즉 수정된 부분은 a.txt 이고, 해당 commit 은 ‘first commit’ 이므로 아래와 같이 해당 commit 으로의 fixup commit 을 수행한다. 반대로 만약 수정한 파일이 b.txt 였다면 \u0026lsquo;second commit\u0026rsquo; 으로 fixup commit 이 수행되었을 것이다.\n# git log --oneline e23e811 (HEAD -\u0026gt; main) fixup! first ee8f6a4 second 8eb5b88 first 또한, 이 fixup commit 은 hunk 단위로 수행되기 때문에, 여러 파일을 수정했다면 각 hunk에 걸맞는 fixup commit 을 만들어낸다.\n주의사항 단, 이렇게 git absorb 를 사용할 때에는 몇 가지를 고려해야 한다.(사실은 git absorb 보단, fixup commit 자체에 대한 고려사항이다.)\n아마 대부분의 상황에서, 팀 단위의 협업으로 코드를 수정할 때는 Pull Request(Merge Request) 로 코드리뷰를 진행하고, 이를 merge 하는 방식으로 진행할텐데, 이 때 squash merge 를 하는 경우에는 사실 상 이 기능이 필요없을 것이다.\n반대로, merge commit 을 하는 경우에는 유용하게 사용될 수 있다. 피쳐 브랜치에서 수행한 commit 이 main stream 브랜치 commit history 에 그대로 반영되므로, 가급적 깔끔하게 유지해야 할 것이고 이 때 fixup commit 이 도움을 줄 수 있다. 하지만 여전히 코드리뷰 단계에서 fixup commit 을 수행하면 force push 를 해야하는 상황이 발생한다.\n심지어 PR 을 사용하지 않는다면 훨씬 더 심각한 문제(예를 들면 이런 상황)를 초래할 수 있다는 점에 유의하자.\n","permalink":"https://cjlee38.github.io/post/git/git-absorb/","summary":"어디서 처음 봤는지는 정확히 기억 안나지만, 우연히 괜찮은 git 관련 오픈소스를 발견해서 소개해본다. 이름은 git absorb 라고, git 기반의 일종의 extension 인데, commit history를 관리할 때 유용하게 사용할 수 있다. 먼저 어떤 extension 인지 서두에 정리해보자면, 내가 코드를 수정한 뒤, 해당 작업을 과거의 commit 어딘가에 같이 포함시키고 싶을 때, “가장 관련성이 높은 commit을 찾아”서 흡수시킬 수 있다.\nfixup commit 먼저 git absorb 를 알기 전에 먼저 알아둬야 하는 것이 있는데, 바로 fixup commit이다.","title":"Git absorb 소개"},{"content":" 글을 시작하기 전에, 혹시나 노파심에 몇 자 추가하자면, 아래의 내용은 “과거의 내가 미리 알았다면 좋았을 걸” 이라는 자조적인 내용을 담은, ‘현재의 나’가 바라보는 개인적인 의견입니다. 몇 년뒤, 혹은 당장 다음 주라도 제 생각은 바뀔 수 있으니 혹시라도 내용이 거슬리거나 마음에 들지 않는다면 미리 양해를 구합니다.\n정말 오랜만에 블로그 글을 쓰는데 첫 타이틀부터 정신병이라는 과격한 단어를 넣은 스스로가 새삼 우습기도 하다. 이 글을 읽는 사람들이 각기 다른 이유로 제목을 보고 이 글을 클릭했겠지만, 어쨌든 눈길을 끌고 이 글을 클릭하도록 유도했다는 점으로 족하다.\n객체 지향과 클린 코드 최근 한 선배 개발자분과 코드에 대한 이야기를 하다가 “객체지향은 정신병이다” 라는 꽤나 과격한 표현을 들었다. 우아한테크코스 를 진행하면서 정말 ‘객체’ 를 ‘지향’했던 과거의 내가 들으면 상당히 당황스러운 말이었겠지만, 실무를 배우고 있는 현재의 나로서는 차마 대놓고 부정할 수는 없는 발언이었다.\n우아한테크코스에서 학습하는 가장 첫 번째 단계는 객체지향으로, Web 이라는 개념도 없이 가장 먼저 콘솔에서 아주 작은 게임을 만드는 것 부터 시작한다. 객체지향은 어렵기도 하고, 또 우아한테크코스 내부에서는 코치진과 크루들이 모두 서로가 작성한 코드에 대해 “왜?” 라는 질문을 던져대다보니, 한 줄의 코드를 짜더라도 이에 응하는 마땅한 이유가 있어야 한다. 그러다 보니 “어떤 것이 좋은 코드인가?” 에 대한 고민을 수 없이 했고, 우아한테크코스를 수료할 때 즈음에는 명확하게 누군가에게 “이게 객체지향이다” 라고 설명할 수는 없어도 어느 정도 “이 코드는 클린하지 못하군(혹은 객체지향 적이지 못하군)” 이라는 훈수를 둘 정도의 기준이 생기게 되었다.\n그런데 우아한테크코스가 워낙 유명하기도 하고, 클린 코드에 대한 중요성 자체만으로는 누구던 부정할수 없는 사실이다보니 어느 새 클린코드는 취업을 위한 필수 요소로 자리매김하게 된 것 같다. 나를 포함하여, 최근 개발 트렌드에 익숙한 개발자에게 SOLID 에 대해 묻는다면 어떤 약어인지 부터 시작해서 최소 10분은 줄줄이 읊을 수 있다.\n그러나 클린코드에 대해 중요성을 너무 강조하고 매몰되다 보면 부작용이 생기기 마련인데, 첫 번째로는 클린 코드에 대한 과도한 집착이다. 잘 추상화가 되어 있는 코드를 읽다 보면 영어를 읽다가 한글을 읽듯이 머릿속으로 로직이 쏙쏙 들어와 이해하기에 아주 편하다. 그런데 한 편 추상화되지 않은 코드를 읽다 보면 무슨 말인지 잘 이해가 안되고, “코드 X같이 짜놨네” 라는 생각과 함께 창을 닫아버릴 것이다. 그런데 JDK나 스프링과 같은 코드도 읽어보면 흔히 말하는 “클린”하지는 않다. 즉, 클린하지 않다고 해서 문제가 되지는 않는다는 것이다.\n믿거나 말거나 근래 들어 젊은 세대(특히 10대)에서 문해력이 떨어진다는 말이 존재하듯이, 극단적인 객체지향을 추구할수록 코드 해력(解力) 이 떨어지고, 다른 사람이 짜놓은 클린하지 못한 코드에 대한 불평만 늘어놓게 될 것이다.\n한 편으로 더 큰 문제점은 구현 역량의 상대적 경시로 이어질 가능성이 높다. 나는 예전에 구현 역량이란 “내 생각을 코드라는 물리적인 결과물로 만들어내는 능력”이라고 생각했는데, 이는 일부에 불과하다. 개발 공부를 어느 정도 한 사람들은 누구나 할 것 없이 본인의 머릿속에 있는 생각을 코드로 옮기는 데에는 전혀 무리가 없다. 내가 생각하는 진정한 구현 역량이란 예외를 생각해낼 수 있는 능력이다.\n실무를 마주하며 올해 초에, 운이 좋게도 국내 빅테크 기업에 인턴을 거쳐 정규직으로 취업을 하게 되면서, 처음으로 서비스를 개발하는 ‘실무’를 접하게 되었다. 인턴 시절에 처음 git clone 을 치고, intellij 로 서비스를 열었을 때 가장 놀랐던 점은 서비스 클래스 하나에서 수십 개의 다른 서비스 클래스와 레포지토리를 참조하고 있다는 점이었다. 그리고 그 서비스는 또 다시 수십개로 이루어진 메소드를 타고 나가며 저마다의 로직을 수행하고 있었다.\n이 코드를 보고 가장 먼저 든 생각은 당연하게도 “이 코드들은 클린하지 못하군” 이었다. 우아한테크코스 때 만들었던 모락 프로젝트는 날을 잡고 며칠에 걸쳐 리팩토링 작업을 수행했을 만큼 객체지향과 클린코드 중요시했던 나였기에, 리팩토링에 대한 욕구가 내면에서 끊임없이 차올랐다. 하지만 도메인을 잘 모르는 상태로 손을 대는 것 만큼 멍청한 짓도 없기 때문에, 꾹 참았다가 정규직 전환 이후 조심스럽게 건의해보았다.\n가장 간단하게, DTO 에 대한 클래스 이름 규칙부터 시작해서 조금씩 리팩토링하는 것이 어떤지 여쭤보자 돌아온 답변은 “그런 것은 중요한 게 아니다” 였다. 물론 회식자리였기 때문에, 아주 가볍게 질문했고 또 아주 가볍게 답변을 받았기 때문에 기분이 나쁘거나 그렇지는 않았다. 하지만 집으로 돌아오면서 왜 그런 말씀을 하셨을까 곰곰히 생각해 보았지만 결국 당시에는 답을 찾지 못했다.\n시간이 흐르면서, 그나마 “조금은 익숙해졌나 ?” 라는 생각이 들 때 쯤 내 실수로 몇 번 장애가 났다. 물론 실사용자에게 대면하는 작업은 위험한 작업은 아니었고, (지금 와서 생각해보면 이 부분은 팀장님이 의도적으로 나에게 장애가 나도 큰 문제가 발생하지 않는 업무를 주신게 아닐까 싶어 감사한 생각이 든다.) 장애가 날 때마다 팀원분들의 도움으로 다행히 해결할 수 있었다.\n몇 번의 풍파를 겪고나서, 최대한 장애를 내지 말아야겠다는 생각을 하면서 다양한 예외 케이스를 계속 고민하다보니, 어느새 시간에 쫓기는 나를 발견할 수 있었다. 예전에는, 구현 역량(당시에는 구현 역량이 생각을 코드로 옮기는 것으로 끝나는 것인줄 알았으니)은 당연한 것이고, 이에 더해 클린 코드와 같은 개발을 추구해야 하는 것이 돈을 받고 일하는 ‘프로’ 로서, 당연히 수행해야 하는 일이라고 생각했지만, ‘실무’라는 이름 하의 진정한 구현 역량이라는 한계에 부딪혀 클린코드를 챙기기에 어려운 나 자신을 발견한 것이다. (특히, 내가 진행하고 있는 프로젝트는 사용자의 돈을 건드리는 프로젝트이기 때문에 더더욱 조심해야 했다.)\n‘실무’ 가 주는 또 다른 어려움은 바로 협업이다. 팀 내외로 다른 사람들과 소통하는 커뮤니케이션도 협업이지만, 여기서 말하는 협업은 API 연동과 같은 협업을 말한다. 대개 규모가 좀 있는 IT 기업은 프론트엔드와 백엔드를 나누고, 더 나아가 빅테크 급의 기업이 되면 MSA 는 필수가 된다. 다른 기업과 팀이 어떻게 개발을 진행하는지는 모르겠지만, 적어도 우리 팀에서는 어느 상황이 됐던 인터페이스에 대한 변경이 ‘클린 코드 관점에서’ 꽤나 문제가 된다.\n로이 필딩의 “REST API를 위한 최고의 버저닝 전략은 버저닝을 안 하는 것\u0026quot; 이라는 말이 무색하게도, FE/BE 의 인터페이스 변경에 따라 버전이 바뀌거나 혹은 내부 로직이 뒤집어진다. 다른 서비스 개발자분에게 특정 기능을 요구했을 때 그것이 구조적으로 불가능하다는 답변에 우리 테이블에 정규화되지 않은 컬럼이 추가되는 것은 예삿일이다. “값 객체 는 id 를 가지면 안된다” ? 장애가 발생하고나서 각종 로그와 DB 를 역추적하는 짓을 몇 번 하다보면 그 따위 컨벤션은 신경도 안쓰게 된다.\n혹여라도 이에 대해, 팀원들이, 혹은 이를 넘어서 개발 직군 모두가 더 노력하지 않았을 뿐이라고 비난하는 것은 유토피아를 논하는 것과 다를 바가 없다. 하지만 내가 실력이 없는 것이라고 말한다면 이는 사실이기 때문에 할 말은 없다. 그러나 우아한테크코스를 진행할 때까지만 하더라도, 개발 ‘속도’ 는 나름 빠르다고 자부했기 때문에 이렇게 시간이 부족한 상황을 겪는 것은 나에게 제법 충격적인 일이었다.\n클린 코드는 무의미한 짓인가 ? 그렇다고 클린 코드가 하등 쓸모 없는 짓이냐고 묻는다면 전혀 그렇지 않다. 위에서 클린 코드에 대해 마치 안좋은 점만 이야기 한 것 같지만, 실상 말하고자 하는 논지는 “구현 역량은 생각 이상으로 훨씬 더 중요하다” 는 것이다. 프로그래머는 ‘코드’ 라는 도구를 이용해 문제를 해결한 대가로 급여를 받는 사람이고, 클린 코드는 프로그래머로서 ‘살아감’에 있어 갖추어야 할 ‘덕목’이다. 예전에 박재성(포비)님의 내 업의 본질은 무엇인가? 라는 글을 아주 인상깊게 봤었는데, 이를 인용하자면 “교육자로서 갖추어야 할 업의 본질을 놓쳐서는 안된다” 와 마찬가지로, “개발자 이전에 직장인으로서 갖추어야 할 업의 본질을 놓쳐서는 안된다”는 것이 요지인 것이다.\n한 편, 즐겨 보는 유튜브 채널인 개발바닥의 \u0026ldquo;클린코딩 하는데 구현을 못하는 개발자\u0026rdquo; 에서는 클린 코드를 작성했으나 기능 구현이 부족한 지원자 A와 기능 구현은 다 했으나 코드가 클린하지 못한 지원자 B 두 명을 비교하면서 누구의 점수를 더 높게 줄 것인지에 대해 이야기한다. 향로와 호돌맨 두 분 다 내 생각과 비슷하게 B에 상대적으로 점수를 높게 주었다. 여기에 개인적인 의견을 첨언하자면, 그럼에도 불구하고 클린 코드를 추구하는 사람이 저평가될 수 없는 이유는 “클린코드를 목적한다는 그 사실보다, 더 나은 개발자로서 발전하려는 동기가 기저에 내재되어 있다” 는 믿음 때문일 것이라고 생각한다.\n더 읽기 쉬운 코드를 작성함으로서 나를 포함한 다른 사람들의 개발 생산성을 증대시키고, 이를 위해 ORM 과 같은 프레임워크를 이용하면서, 왜 과거에 DB 에 박혀있던 프로시져 로직이 미들웨어인 어플리케이션으로 이동했고, 그 과정에서 무슨 이유로 ORM 이 등장하게 되었는지와 같은 역사적인 관점, 그리고 이를 해결하기 위한 다양한 테크닉의 발견과 그 기저에 있는 다양한 CS 지식에 대한 호기심을 자극한다는 관점에서 보면 클린 코드는 “구현을 놓치지 않는다는 가정 하에” 반드시 갖춰야 할 역량으로도 볼 수 있다.\n나의 기준 그렇다면 도대체 어느 정도까지 클린 코드를 지향해야 할까 ? “나의 기준”이 다른 누군가에게는 과하다고 평가받을 수도 있고, 또 다른 누군가에게는 부족하다고 느껴질 수 있다. 2023년의 마무리를 앞두고 있는 내가 현재 생각하는 클린 코드에 대한 대원칙은 두 가지로, “적확(的確)함” 과 “단순함” 이다.\n‘가담항설’ 이라고, 네이버 웹툰 중 즐겨보는 작품이 있다. 평소 웹툰을 즐겨보는 편이라, 누군가가 볼 만한 웹툰 있냐고 물어보면 꼭 리스트에 포함되는 작품 중 하나인데, 무료 대여권을 이용해 한 3번 쯤은 정독을 한 적이 있을 정도로 재미있는 웹툰이라고 생각한다.\n‘가담항설’ 을 보던 도중 아주 인상깊은 문구를 본 적이 있는데, 내용이 너무 길어 스크린 캡쳐를 하기는 좀 그렇고 나왔던 대사만 적어보면 다음과 같다.\n정기 씨. 아까 제가 꽃을 버려서 슬펐나요 ? 그건 신발이 진창에 빠졌을 때만큼 슬펐나요. 아니면 가까운 이가 아플 때만큼 슬펐나요.\n어떤 슬픔은 어렴풋한 슬픔이고, 어떤 슬픔은 처절한 슬픔이죠. 소소한 슬픔도, 아련한 슬픔도, 잊혀가는 슬픔도, 문득 기억이 떠올라 때때로 가슴이 아파지는 슬픔까지, 같은 슬픔조차도 사실은 전부 달라요.\n책을 읽고 풍부한 단어를 알게 된다는 건, 슬픔의 저 끝에서부터, 기쁨의 저 끝까지. 자신이 가지고 있는 수많은 감정들의 결을 하나하나 구분해내는 거에요. 정확히 그만큼의 감정을 정확히 그만큼의 단어로 집어내서 자신의 마음을 선명하게 들여다보는 거죠.\n내가 얼마큼 슬픈지, 얼마큼 기쁜지. 내가 무엇에 행복하고, 무엇에 불행한지. 자신의 마음이 자신을 위한 목적을 결정하도록. 그리고 자신의 마음을 타인에게 정확히 전달하도록.\n나무도, 바위도 없이 숨을 곳 하나 없는 산 복판에서 매에게 쫓기는 까투리의 마음이, 망망대해 한가운데 배에 곡식 가득 싣고, 노도 잃고, 닻도 잃고, 돛줄도 끊어지고, 돛대도 꺾어지고, 바람에 물결치고 안개는 자욱이 뒤섞이며, 사방은 어두워지고 풍랑 일 노을 뜨는데 해적을 만난 사공의 마음이, 엊그제 임을 잃은 제 마음에 비할 수 있을까요.\n같은 단어를 알고 있다면, 감정의 의미를 공유할 수 있고, 같은 문장을 이해할 수 있다면, 감정의 흐름을 공유할 수 있어요. 그리고 그건 서로를 온전히 이해할 수 있게 만들죠.\n갑자기 왠 ‘시’ 같은 글을 가져왔나 싶겠지만, 나는 저 글을 읽고 객체지향을 떠올렸다.(나도 어쩔 수 없는 개발자인가보다.) 적절한 단어가 자신의 감정을 정확하게 집어낼 수 있듯이, 적확한 모델링이 클린 코드를 짚어낼 수 있다. 개발자는 기획자에게 업무에 대한 개요와 스펙을 충분히, 상세하게 논의하고 이를 코드에 녹여내야 한다.\n종종 우발적인 중복을 착각하여 공통 로직으로 뽑아내려고 하는 실수를 범하는데, 우발적인 중복인지 아닌지 구분이 잘 되지 않는다면 아직 머리 속에서 이러한 모델링이 명확히 이루어지지 않은 것이다. 개발 단계에서의 스펙은 계속 변화하므로 진짜 중복이라고 확신이 들 때에만 공통화 해야 한다.\n두 번째 대원칙은 단순함이다. 클린 코드를 하는 목적이 무엇인가 ? 결국 “사람이 읽기 쉽게 하기 위함”이다. 간단한 로직을 “함수는 한 가지 일만 하라”는 원칙을 지키기 위해 수 없이 쪼갠 메소드보다, 하나의 함수에 몰아넣고 명백히 의미가 드러나는 이름을 붙이는 것이 훨씬 낫다고 생각한다.\n설계의 미덕은 단순함과 명확함으로부터 나온다. 단순하고 명확한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하다. 유연한 설계는 이와는 다른 길을 걷는다. 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다.\n오브젝트(조영호 저), p.305\n클린 코드, 디자인 패턴, 객체지향 생활체조 원칙과 같은 교보재들은 객체지향과 클린코드를 이해함에 있어 훌륭한 가이드를 제시하지만 잘 못 이해하면 결과지향적인 방법론만 취하게 된다. 객체지향과 클린코드가 목적하는 바를 명확하게 바라보고 있다면 필요한 것만 취하고, 필요하지 않은 것은 버릴 수 있다. 마치 비유하자면 우리가 덧셈을 알고 있으면 1 + 2 가 주어지든, 수억 단위의 덧셈이 주어지든 어렵지 않은 것과 같다.\n위 교보재들을 오해하여 흔히 하는 실수중 하나는, 추상화의 강점을 한 번 맛보게 되서 어떤 코드이던 추상화를 하려고 든다는 점이다. 변경 가능성이 낮은 클래스를 인터페이스로 추상화하게 되면 컴파일타임과 런타임 의존성 차이로 인해 읽는 사람이 오히려 번거로워 진다. 단순히 무리하게 웹플럭스를 도입하는 것과 같은 아키텍쳐 관점의 오버엔지니어링만 있는 것이 아니라, 코드 관점에서도 오버엔지니어링은 존재한다는 것을 잊지 말자.\n","permalink":"https://cjlee38.github.io/post/code/oop-is-psychotic-disorder/","summary":"글을 시작하기 전에, 혹시나 노파심에 몇 자 추가하자면, 아래의 내용은 “과거의 내가 미리 알았다면 좋았을 걸” 이라는 자조적인 내용을 담은, ‘현재의 나’가 바라보는 개인적인 의견입니다. 몇 년뒤, 혹은 당장 다음 주라도 제 생각은 바뀔 수 있으니 혹시라도 내용이 거슬리거나 마음에 들지 않는다면 미리 양해를 구합니다.\n정말 오랜만에 블로그 글을 쓰는데 첫 타이틀부터 정신병이라는 과격한 단어를 넣은 스스로가 새삼 우습기도 하다. 이 글을 읽는 사람들이 각기 다른 이유로 제목을 보고 이 글을 클릭했겠지만, 어쨌든 눈길을 끌고 이 글을 클릭하도록 유도했다는 점으로 족하다.","title":"객체지향은 정신병이다."},{"content":"개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.\npublic class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다. 책에서는 이를 OpenJDK의 경우 hoisting에 의한 것일 수 있다고 간단하게만 짚고 넘어간다. 또한, 이와 관련한 많은 자료들을 서치해보면 이는 CPU cache에 의한 문제라고 진단하고 넘어간다. 물론 틀린 말은 아니지만, 그 내부를 들여다보면 이는 간단하지 않은 문제다.\nJIT compiler 위 문제의 원인을 진단하기 위해서는, 우선 JVM 이 java 파일을 실행시키는 과정을 자세히 살펴보아야 한다. 우리가 javac 명령어를 통해 .java 확장자를 가진 파일을 컴파일하게 되면, 이는 곧바로 CPU에서 실행될 수 있는 코드로 변환되지 않는다. 해당 코드는 JVM 이 이해할 수 있는 Java Bytecode 로 변환되고, 이를 java 명령어로 실행할 때가 되어서야 비로소 기계어로 번역되어 실행된다.\n기계어로 번역되는 과정에서 JVM은 Java Bytecode를 CPU가 이해할 수 있는 machine code로 한줄씩 번역하게 된다. 이 과정에서 자주 참조하는 코드가 보이면(이 과정을 warm-up 이라고 표현하기도 한다.) 해당 코드를 통째로 컴파일해 실시간으로 번역하지 않고 컴파일을 진행한다.\nReordering 위와 같은 일련의 과정을 거치면서, JVM은 주어진 Java Bytecode에 대한 최적화를 진행한다. 일례로, 아래의 코드를 살펴보자.\npublic class Reordering { private int a = 0; private int b = 0; public void increase() { a += 1; b += 2; a += 3; } } 위와 같은 코드를 작성하면 우리는 increase 메소드가 호출되었을 때 다음과 같은 순서로 동작하기를 기대한다.\n처음 Reordering 인스턴스를 생성하면, a와 b는 0으로 초기화된다. increase 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다. a에 1을 더한다. b에 2를 더한다. a에 3을 더한다. 이러한 흐름은 사람에게는 자연스럽지만, 조금 더 기계친화적으로 흐름을 살펴보면 아래와 같이 동작한다.\nReordering 인스턴스에 대한 생성을 요청하면 Reordering 인스턴스의 클래스를 분석하고, 해당 인스턴스에 대한 공간을 할당받는다. 공간을 할당받은 뒤, init 메소드(생성자)를 실행하여 변수에 대한 초기화를 진행한다. increase 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다. 변수 a로부터 값을 읽어 CPU register에 올린다. CPU register에 1을 더하는 연산을 수행한다. 1을 더한 연산을 마친 후, a 변수가 위치한 공간에 값을 다시 write 한다. 변수 b 로부터 값을 읽어 CPU register에 올린다. CPU register에 2 를 더하는 연산을 수행한다. 2를 더한 연산을 마친 후, b 변수가 위치한 공간에 값을 다시 write 한다. 변수 a로부터 값을 읽어 CPU register에 올린다. CPU register에 3을 더하는 연산을 수행한다. 3을 더한 연산을 마친 후, a 변수가 위치한 공간에 값을 다시 write 한다. 내용이 조금 길긴 하지만, 자세히 읽어보면 그다지 어려운 내용이 아님을 알 수 있다. 그저, 값을 읽은 뒤 더하기 연산을 한 후, 그 값을 다시 원래 위치에 쓰기 연산을 했을 뿐이다. 하지만 위 과정을 다시 읽어보면, 더 효율적으로 계산할 수 있는 방법이 있다는 것 또한 알 수 있다.\n즉, 2.1 에 해당하는 읽기 연산을 한 후, 2.2에 해당하는 덧셈 연산 직후에 곧바로 2.7 의 덧셈 연산을 연달아 수행하고, 2.8 의 쓰기 연산을 이어나가면 명령어 수행 횟수를 줄일 수 있다. 이를 코드로 표현하면 아래와 같이 변경된다.\npublic class Reordering { private int a = 0; private int b = 0; public void increase() { a += 1; a += 3; b += 2; } } 심지어는 1과 3을 더하는 연산을 묶어서 차라리 4를 더해버리는 연산을 진행할 수도 있다. JVM은 위와 같이 코드의 순서를 변경하는 작업을 수행할 수 있으며, 이를 reordering 이라고 부른다.\n이 reordering 은 JVM이 판단하기에 순서를 바꿔도 영향이 없는 코드에 대해 진행된다. 가령, b += a; 와 같이 a에 대한 덧셈 연산 결과를 바탕으로 b에 대한 연산을 수행하는 경우 해당 코드는 재배치되지 않는다.\nWord Tearing 위에서 소개한 예제 뿐만 아니라, 또 다른 문제도 발생할 수 있다. 아이템 78의 첫 페이지 세 번째 문단을 살펴보면, 아래와 같이 이야기한다.\n언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.(JLS, 174. 17.7)\nlong과 double은 왜 제외되는가 하고 보면, 두 개의 원시타입은 다른 타입들과 다르게 64bit 라는 특성을 가지고 있다. 다음의 코드를 살펴보자.\npublic class WordTearing { long a = 0L; void thread1() { a = 0x0000FFFF; } void thread2() { a = 0xFFFF0000; } } 위 코드를 두 개의 스레드가 동시에 접근하여 수행하면 어떤 결과가 나타날까 ? 일반적으로 생각했을 때에는 0x0000FFFF 혹은 0xFFFF0000 둘 중 하나로 결과가 남을 것으로 기대해볼 수 있을 것이다. 하지만 32bit processor는 CPU register에 최대 32bit 만 올릴 수 있으므로, 총 64 bit 중 앞 쪽 32bit 의 쓰기연산과 뒤 쪽 32 bit의 쓰기 연산의 총 두 개의 연산으로 작업을 수행한다. 따라서 0x0000FFFF, 0xFFFF0000, 0x00000000, 0xFFFFFFFF 의 총 4개의 결과가 가능한 결과 집합이 되고, 이러한 문제를 Word Tearing 이라 부른다.\nJMM 하지만 그렇다고 해서 위 코드들을 실제로 로컬환경에서 수행해봐도 문제가 발견되지 않을 수 있다. 이는 하드웨어 아키텍쳐의 차이로 인해 발생하는 것인데, 가령 64bit processor를 이용하는 경우에는 위와 같은 원자성 문제가 발생하지 않는다.\n위 표는 각 CPU 아키텍쳐 별 optimization 지원 여부를 나타낸다. 가령, intel CPU의 경우 load-load 를 지원하지 않는다. load-load 는 하나의 변수를 읽고 다음 변수를 읽을 때 reordering이 발생하는지 여부를 의미한다. 한편, ARM CPU는 load-load를 지원하며, 이는 곧 두 개의 변수를 읽을 때 순서의 재배치가 발생할 수 있음을 의미한다.\nARM 아키텍쳐의 CPU가 상대적으로 전력을 적게 소모하는 이유 중 하나이다.\nJava Memory Model(이하 JMM) 은 특정 순간에 어떠한 필드를 읽었을 때 우리가 어떠한 값을 관찰할 수 있는지를 설명하는 모델이다. JMM은 약한 메모리 모델을 기반으로 설계되었기 때문에 각각의 CPU core가 바라볼 수 있는 값이 다를 수 있고, 따라서 이를 적절하게 제어하는 규칙에 대한 specification을 제공한다.\n그리고 JMM에서 애플리케이션을 보호하는 개념 중 하나가 바로 오늘 중점적으로 다루게 될 happens-before 관계이다. 여기서 한 가지 반드시 짚고 넘어가야 할 점은 happens-before 관계는 single thread를 기반으로 보장되었다는 점이다. 이를 다시 말하면 multi-thread 환경에서는 사용자가 어느정도는 의식적으로 염두에 두어야 한다는 말이다.\n필드 영역에는 final , volatile, 메소드 영역에는 synchronized, java.util.concurrent.locks.Lock 를 이용해 이를 제어할 수 있으며, 해당 키워드/API 를 사용함으로서 JVM에게 동시성 이슈를 발생시킬 수 있는 최적화를 억제하도록 유도할 수 있다. 하지만 반대로 이야기하면 최적화를 진행하지 않음으로 인해 성능저하를 유발할 수도 있다는 뜻이 된다.\n하나씩 살펴보자.\nvolatile 앞서 맨 처음 보았던 무한루프를 돌았던 코드와 비슷한 코드를 다시 한번 살펴보자.\nclass DataRace { boolean ready = false; int answer = 0; void thread1() { while (!ready); assert answer == 42; } void thread2() { answer = 42; ready = true; } } 두 개의 스레드가 동시에 thread1 메소드와 thread2 메소드를 수행하면 어떻게 될까? assert 부분이 통과할 수 있을까? 앞서 문제점들을 인지했다면, 위 코드는 실패할 가능성이 있다는 것을 알 것이다. 왜냐하면, thread2 의 answer = 42; 코드와 ready = true; 코드의 순서가 바뀌어서 ready가 먼저 true가 되버릴 수 있기 때문이다. 혹은, 앞서 보았던 예시와 마찬가지로 ready 변수가 CPU cache에 저장되어 ready가 true로 변경되었음에도 불구하고 여전히 false로 읽을 수도 있다.\n이 문제를 해결하기 위해서는 아래와 같이 ready 변수에 volatile 키워드를 사용할 수 있다.\nvolatile boolean ready = false;\nJLS 에 나와있듯이, volatile 키워드가 붙은 변수는 모든 스레드가 ‘일관된 값’을 볼 수 있음을 보장해준다.(A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable). 뿐만 아니라, volatile에 대한 쓰기 연산은 읽기연산에 선행(happens-before) 된다.\n한 가지 더 주목할 점은, volatile 키워드를 ready 변수에만 붙여주었다는 점이다.이 또한 JMM이 volatile 변수에 대한 쓰기연산 이전에 선행된 쓰기 연산은, reordering 되지 않음을 보장하기 때문이다. (읽기 연산 또한 마찬가지로, volatile 변수에 대한 읽기가 선행되고 이후에 다른 변수에 대한 읽기가 진행됨이 보장된다.)\n마지막으로, 앞서 보았던 Word Tearing 또한 발생하지 않는다.\n많은 사람들이 volatile 키워드는 메모리에 곧바로 쓸 수 있도록 하는 역할이라고 설명한다. 이것이 틀린 설명은 아니지만, JLS 상에서는 volatile 키워드가 ‘consistence’(일관성)을 유지하도록 보장한다고 설명한다. 즉, ‘명세’ 상으로는 항상 일관된 값을 관찰할 수 있어야 한다는 것이고, 이에 대한 구현(implementation)이 바로 메인 메모리에 대한 flush 라고 볼 수 있다.\n이는 volatile뿐만이 아닌 모든 happens-before 관계를 보장하는 (e.g. synchronized) 키워드에도 해당된다.\nsynchronized synchronized 키워드 또한 happens-before 관계를 성립시키는 도구로 사용될 수 있다. 다음은 역시 마찬가지로 이펙티브 자바 아이템 78 에서 인용한 내용이다.\n많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.\n… 중략\n맞는 설명이지만, 동기화에는 중요한 기능이 하나 더 있다. 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다. 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메소드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.\n즉, synchronized 키워드에는 상호배제(mutual exclusion) 이외에도 스레드 간 통신(앞서 보았던 happens-before) 의 기능을 제공한다는 뜻이다.\n위 DataRace 코드를 synchronized 키워드를 이용해 수정하면 다음과 같다.\nclass DataRace { boolean ready = false; int answer = 0; synchronized void thread1() { // \u0026lt;- 데드락 발생 가능 while (!ready); assert answer == 42; } synchronized void thread2() { answer = 42; ready = true; } } 이 코드를 곧바로 실행하면, 아마 thread1 메소드가 먼저 수행되는 경우에는 데드락이 발생하게 된다. 여기서는 “thread2 코드가 먼저 실행되었다” 라고 가정해보자. 그러면 아래와 같은 흐름으로 진행된다.\n스레드 Thread 1 Thread 2 실행 enter answer = 42; ready = true; exit enter while (!ready); assert answer = 42; exit 이펙티브 자바에서 설명했던 것과 마찬가지로, monitor를 통한 critical section의 진입/탈출 뿐만 아니라 ready 변수와 answer 변수에 대한 순서는 재배치되지 않고 순서대로 (happens-before)수행된다.\nsynchronized 키워드와 관련해서 한 가지 더 짚고 넘어가고 싶은 부분이 있다. 가장 먼저 봤던 StopThread 클래스를 다시 살펴보자.\npublic class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) { i++; System.out.println(\u0026#34;STOP ?\u0026#34;); // (*) } }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드에서, 주석으로 별표(*)를 달아놓은 부분을 새로이 추가하였다. 그리고 이 코드를 실행되면 어떻게 될까? 놀랍게도 이번에는 무한 루프를 돌지 않고 약 1초 뒤 종료된다. 출력문 하나를 추가하였을 뿐인데 왜 갑자기 1초뒤에 중단되었을까? 이는 sout 메소드를 살펴보면 알 수 있다.\npublic void println(String x) { synchronized (this) { print(x); newLine(); } } 보는 바와 같이 synchronized 키워드가 존재한다. 그런데 여기서 한 가지 궁금증이 생긴다. synchronized 는 this 에 걸려있고, 이 this는 결국 System.out 인데, 왜 난데없이 전혀 관련 없어보이는 stopRequested 변수가 초기화되었을까 ? 이는 synchronized block에 진입하는 순간, 해당 스레드가 볼 수 있는 모든 변수가 메모리로 flush 되었기 때문이다.\n아래 코드는 이펙티브 자바에서 보인 StopThread 의 synchronized 키워드를 이용한 개선 버전인데, 이 부분도 자세히 보면 처음에는 “왜 synchronized 키워드를 붙인게 효과가 있지?” 라는 생각이 들었다가, 스레드 간 통신을 지원한다는 점을 떠올리면, 곧 고개를 끄덕일 수 있을 것이다.\npublic class StopThreadSynchronized { private static boolean stopRequested; private static synchronized void requestStop() { stopRequested = true; } private static synchronized boolean stopRequested() { return stopRequested; } public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested()) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); requestStop(); } } final 자바에서 final은 변수에 대한 재할당을 막는 역할로 널리 알려져 있다. 하지만 final 키워드 또한 happens-before 관계와 연관이 있다. 다음 코드를 보자.\npublic class UnsafePublication { private int a; private UnsafePublication() { a = 42; } static UnsafePublication instance; static void thread1() { instance = new UnsafePublication(); } static void thread2() { if (instance != null) { assert instance.a == 42; } } } 흔히 싱글톤 패턴을 구현할 때 자주 볼 수 있는 코드 형태이다. (물론 동시성 문제를 고려하여 개선버전이 존재한다.) 마찬가지로 thread1 과 thread2 메소드가 동시에 수행되었을 때, 해당 코드는 항상 통과할 수 있을까?\n정답은 ‘그렇지 않다’ 이다. 앞서 Reordering 절에서도 언급했듯이, new 키워드를 이용해 객체를 생성하는 행위는 두 가지로 구분된다.\n객체를 생성하기 위한 공간의 할당 객체 변수의 초기화 따라서 1. 객체를 생성하기 위한 공간의 할당이 먼저 선행되고, thread2 메소드가 수행되는 경우, instance는 null을 가리키지 않으므로 if 절 안으로 진입하게 된다. 하지만, 객체 변수의 초기화 (a = 42;) 는 아직 수행되지 않았으므로(int 변수는 초기화되지 않으면, 0을 갖는다.) 해당 assert 절은 실패하게 된다.\n참고로 파이썬에서는 생성자로 사용되는 __init__ 메소드 이외에도 __new__ 라는 메소드가 있는데, 이는 메모리를 할당받을 때 사용된다. 즉, __init__ 메소드보다 반드시 선행된다.\n이를 해결하기 위한 방법으로 final 을 사용할 수 있다. 위 코드에서 private final int a; 과 같이 final을 붙여주게 되면, 생성자 메소드 init 이 끝난 직후에 freeze 라는 작업을 하게 된다. 생성자 내에서 또한 happens-before 관계가 보장되며, 생성자 체이닝(e.g. 부생성자 → 주생성자)이 발생한다면 최종 생성자가 끝나는 시점에 freeze 작업이 수행된다.\n마무리 JVM의 구현체는 명세보다 더 엄격하게 관리한다. 따라서 구현체를 믿고 프로그램을 작성하다보면, Java 진영에서 이야기하는 Cross-Platform Compatibility, 즉 Write Once, Run Anywhere 이 어려워질 가능성이 높다. 따라서 보수적으로 코드를 작성해야 함에 유의하자.\nReference https://youtu.be/qADk_tj4wY8 https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html https://www.geeksforgeeks.org/happens-before-relationship-in-java/ https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true\u0026amp;blogId=jjoommnn\u0026amp;logNo=130037479493 ","permalink":"https://cjlee38.github.io/post/lang/java-memory-model-explained/","summary":"개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.\npublic class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다.","title":"Java Memory Model explained (feat. Effective Java, Item 78)"},{"content":" 주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 \u0026lsquo;정론\u0026rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !\n약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.\n정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다. 그런데 잠깐, 여기서 도메인이란 무엇일까 ?\n도메인에 대한 정의 도메인은 결국, \u0026ldquo;내가 문제를 해결하고자 하는 영역\u0026quot;으로 정의할 수 있다. 가령 쇼핑몰 사이트를 만든다고 하면, 쇼핑의 대상이 되는 상품과 이에 따른 주문/결제 시스템이 바로 도메인이다. 이 과정에서 사용되는 jackson과 같은 라이브러리들은 나의 관심사가 아니다. 한편, jackson과 같은 소프트웨어를 만든다고 하면, 이러한 직렬화/역직렬화 과정을 처리하는 과정이 도메인이다.\n나는 도메인에 도움을 주는 이런 부가 기술들을 \u0026lsquo;코드 레벨\u0026rsquo;, 혹은 \u0026lsquo;코드 관점\u0026rsquo; 이라고 표현하는데, 정확한 용어가 있는지는 모르겠다.\n그렇다면 왜 도메인이 중요할까요 ? 우리가 소프트웨어로 문제를 해결하고자 하는 이유는, 만들어낸 소프트웨어가 가치를 창출해내기 때문이다. 주어진 문제를 코드로 해결하기 위해선 여러 방법이 존재한다. main 메소드에 수천라인의 코드를 박아넣을 수도 있고, 단 하나의 데이터베이스 쿼리로 해결할 수도 있다. 단 한번만 만들어지고, 절대 변하지 않을 예정이라면 이렇게 해도 문제가 되지 않을것이다. 문제가 되는 경우는, 나를 포함한 누군가가 이 코드를 수정해야할 일이 생겼을 때 발생한다.\n그리고 이러한 코드를 특정한 곳에 모아두지 않으면, 새로운 요구사항을 반영하고, 버그를 수정할 때 여러 곳을 살펴봐야 한다. 사람의 인지능력은 한계가 있기 때문에 수백개가 넘어가는 클래스와 수천, 수만 라인의 코드를 모두 파악하는 것은 어렵다. \u0026lsquo;관심사의 분리\u0026rsquo; 라는 개념이 바로 여기서 등장한다.\n이에 비해 단기 기억은 보관돼 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적인 측면 모두에서 제약을 받는다. 공간적인 제약은 조지 밀러(George Miller)의 매직넘버 7(7 ± 2 규칙)로 널리 알려져 있다. 조지 밀러의 이론에 따르면 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 5개에서 많아 봐야 9개 정도를 넘지 못한다고 한다.\n또한 허버트 사이먼(Herbert A. Simon)에 따르면 사람이 새로운 정보를 받아들이는 데 5초 정도의 시간이 소요된다고 한다. 컴퓨터 프로그램을 작성할 때는 시간과 공간의 트레이드오프를 통해 효율을 향상시킬 수 있지만 사람의 경우에는 트레이드오프의 여지가 전혀 없다. 사람의 단기 기억에 있어 시간과 공간의 두 측면 모두가 병목지점으로 작용하는 것이다.\n(출처 : 오브젝트, 조영호 저)\n그리고 이러한 비즈니스 규칙을 모아놓는 곳, 소프트웨어의 본질과 정수를 담아둔 곳이 바로 도메인이다. 그렇기에 우리는 도메인을 보호하고, 변경의 여지가 높은 외부 환경으로부터 격리하는 것을 두 번째 우선순위로 잡아야한다. (당연히 첫 번째는, 올바르게 동작하는 것이다.)\n레이어드 아키텍처 도메인이 가장 중요하고, 우리가 보호해야할 대상이란 점은 알았다. 이번에는 practical 한 이야기를 해보자. 바로 이 글의 타이틀에도 작성되어 있는 레이어드 아키텍쳐이다. 레이어드 아키텍쳐는 Spring MVC 에서 주로(그리고 거의 대부분) 채택되는 아키텍쳐이기도 하다. 우리에게는 @Controller, @Service, @Repository 과 같은 친숙한 어노테이션으로도 알려져있다.\n참고로 위 세 개의 어노테이션을 들어가보면 모두 DDD 에 어느정도 근간을 두고 있음을 알 수 있다.\n구글에 layered architecture 를 검색해보면 여러 글이 나오지만, 결국 논하고자 하는 바는 \u0026ldquo;의존성은 한 쪽으로만 이루어져야 한다\u0026quot;는 것이다. 가령 컨트롤러에서 레포지토리를 곧바로 의존한다고 하더라도 순수한 레이어드 아키텍쳐 관점에서는 문제가 되지 않는다. 컨트롤러는 레포지토리보다 상위에 위치한다.\n이제 각 세 개의 레이어가 중점적으로 다뤄야 할 관심사에 대해서 알아보겠다.\n참고로 본 글에서는 presentation == controller, application == service 로 취급한다.\nController 컨트롤러는 외부 API 요청을 받아내는 역할을 한다. 개발자 입장에서는 외부 통신을 받아내는 가장 첫 번째 관문이기도 하다.(물론 interceptor나 filter 도 있긴 한다만, 여기선 신경쓰지 않겠다.) 컨트롤러 level 에서 주로 처리해야할 사항은 주로 \u0026lsquo;코드 관점\u0026rsquo;에 집중되어 있다. 내가 원하는 올바른 값이 들어 왔는지? 올바른 사용자가 요청을 보낸 것인지? 내가 원하는 양식(e.g. json)대로 값을 요청했는지? 등을 확인하고, 이에 걸맞게 코드의 객체로 역직렬화하는 과정이 주요 관심사이다.\n때로는 컨트롤러의 코드가 너무 짧아서 아무것도 하는 일이 없어보이기도 한다. 그저 서비스로의 메소드를 호출하고, return 받은 결과를 곧바로 상태코드와 함께 넘겨주는 작업밖에 하지 않는다. 하지만 \u0026lsquo;코드 관점\u0026rsquo;의 작업은 \u0026lsquo;라이브러리\u0026rsquo;, 혹은 \u0026lsquo;프레임워크\u0026rsquo;가 개입하기 아주 좋은 환경이기도 한다. 모든 개발자가 json 오브젝트를 역직렬화하고, 모든 개발자가 내가 정의한 URI 에 요청이 들어오기를 바란다. 따라서 \u0026ldquo;하는 일이 없는 것 처럼 보이는 것\u0026rdquo; 일 뿐, 실제로는 여러 작업이 발생하고 있다.\nService 서비스는 도메인의 시작점 역할을 한다. 서비스 상위에 위치하는 컨트롤러로부터 특정한 요청을 받고, 하위에 위치하는 도메인을 모아서, 내가 원하는 비즈니스를 처리한다.\n이 글을 읽는 많은 분들이 객체지향의 5가지 원칙인 SOLID에 대해 알고 계실 것이라 생각한다. 그리고 이러한 SOLID 원칙을 지키기 위한 방법 중 하나로 의존성 주입(Dependency Injection) 이 있다. 의존성을 주입받는다는 것은, A 라는 클래스가 B 라는 클래스를 사용할 때, 어떠한 구현체가 들어오는지에 대해선 관심이 없고, 그저 (A 입장에서)\u0026lsquo;주어진 객체가 내가 원하는 것을 알아서 잘 수행해주기를 바라는 태도\u0026rsquo; 로 이해할 수 있다. 비슷한 주제로 \u0026lsquo;메소드를 호출하는 것이 아니라 메세지를 전달하는 것\u0026rsquo; 이라는 내용도 있는데, 여기서는 생략하겠다.\n아무튼 간에, 이렇듯 의존성을 주입받게 되면, 생성의 책임은 \u0026lsquo;나를 만드는 곳\u0026rsquo;으로 위임하게 된다. 아래 그림과 같이 의존성의 방향성이 있다고 가정해보겠다.\nclass A { B b; public A(B b) { this.b = b; } } class B { C c; public B(C c) { this.c = c; } } 여기서 A 클래스는 B 클래스를, B 클래스는 C 클래스를 의존하고 있다. 위와 같은 구조가 주어졌을 때, A 클래스의 인스턴스를 생성하고, 사용하려면 아래와 같이 작성해야 한다.\nA a = new A(new B(new C())); 그런데 생각해보면, 이렇게 생성하는 것이 괜찮을까 ? 결국 이 A 객체를 사용하는 곳도 의존성을 주입받아야 하는 것은 아닐까? 이를 바꿔 말하면, 이렇게 객체의 생성을 미루고 미루다 보면 최종적으로 도착하는 지점이 어딘가에서 주어져야 한다. 이 지점을 바로 composition root 라고 부른다. 그리고 우리는 DI 컨테이너 라는 이름으로 Composition Root라는 개념을 구현한다.\n참고로, 의존성 주입에는 세 가지 방법이 있는데, 메소드 주입의 경우 composition root 관점으로 바라봤을 때 해결할 수 없기 때문에 논란의 여지가 있다고 말하는 듯 한다.\n따라서 의존성 주입에는 의존성을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.\n생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결 setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결 메서드 주입(method injection): 메소드 실행시 인자를 이용한 의존성 해결 메소드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있다. 개인적으로는 외부에서 객체가 필요로 하는 의존성을 해결한다는 측면에서 의존성 주입의 한 종류로 간주한다.\n(출처 : 오브젝트, 조영호 저) Controller 나 Service와 같은 객체들의 조립은 spring에서 처리해주지만, 우리가 만든 도메인은 조립해주지 않는다.\n모든 도메인 객체를 spring bean으로 등록할 수도 있지만, spring 이라는 프레임워크에 대한 의존성이 생긴다. spring bean 으로 등록하는 것이 반드시 나쁜 것만은 아니다. 하지만 spring 프레임워크에 예기치 못한 버그가 발생한다면 어떨까 ? 도메인이 보호해야 할 중요한 대상이라는 점을 감안하면, 일말의 가능성이라도 배제하는 것이 좋다는 입장이 있는 반면, 생산성을 위해 spring에게 맡기는 것도 하나의 방법이 될 수 있다. 결국은 마법의 단어, \u0026lsquo;트레이드오프\u0026rsquo; 다.\n그리고 제가 생각하는 \u0026lsquo;도메인 객체\u0026rsquo;의 composition root 가 바로 \u0026lsquo;서비스\u0026rsquo; 레이어 이다.\nRepository repository 는 과연 어느 레이어에 속할까요 ? Repository 와 Dao의 차이점에 대해 조금이라도 찾아본 사람은 repository 를 도메인이라고 부른다. 왜 레포지토리는 도메인 레이어에 속할까요? 자꾸 DDD 이야기가 나와서 조금 불편한데, 에릭 에반스의 도메인 주도 설계에서는 레포지토리를 다음과 같이 정의한다.\n“repository is a mechanism for encapsulating storage, retrieval, and search behavior, which emulates a collection of objects.”\n레포지토리는 저장, 검색 및 검색 동작을 캡슐화하는 메커니즘으로, 객체 모음을 모방한다.\n즉, 레포지토리는 \u0026ldquo;어디에 저장되어 있는지는 모르지만 아무튼 내가 원하는 객체가 저장된 곳\u0026rdquo; 으로 이야기할 수 있다. 말인 즉슨, 도메인 객체의 생명 주기를 관리한다는 것이다. 이는 바꿔 말하면 레포지토리는 도메인 객체를 알고 있어야 함을, 즉 도메인을 의존해야 함을 의미한다. (앞서, 레이어드 아키텍쳐가 의존성을 한 방향으로만 향하게 했다는 점을 감안하면, 그 하위 infrastructure layer에 속할 수 없다.)\n하지만 여기서 한 가지 문제가 발생한다. \u0026ldquo;어디에 저장되어 있는지는 모르겠는데\u0026rdquo;, 도대체 어디서부터 데이터를 가져올 수 있을까 ? 우리는 소중하디 소중한 데이터베이스에 객체에 대한 정보가 저장되어 있음을 알고 있다. 그러면 레포지토리가 도메인에 대한 정보를 알고 있으면서 동시에 데이터베이스에 요청을 필요로 하는 모순이 발생한다. 그리고 이 지점에서 객체지향의 특성이 한 가지 발휘된다. 바로 \u0026lsquo;다형성\u0026rsquo; 이다.\n그림 5.2에서 HL1 모듈은 ML1 모듈의 F() 함수를 호출한다. 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않는다. HL1은 단순히 ML1 모듈의 F()를 호출할 뿐이다.\n하지만 ML1 과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.\n(출처 : 클린 아키텍쳐, 로버트 C 마틴 저)\n위 그림에서 HL1 객체를 서비스로, I 인터페이스를 레포지토리 인터페이스로, ML1 객체를 I 인터페이스를 상속하는, 실제 데이터베이스 요청을 진행하는 객체로 바라보면 이야기했던 모순을 해결할 수 있다. 실제 코드를 보더라도, 서비스 객체는 레포지토리 인터페이스를 import할 뿐, 구현체에 대한 정보는 그 어디에서도 찾아볼 수 없다.\n이러한 점에서 객체지향은 절차지향과 차이점을 보인다. 절차지향은 실행 제어 흐름에 따라 의존성의 방향이 일방적으로 향할 수 밖에 없다. ","permalink":"https://cjlee38.github.io/post/code/domain-layered-architecture/","summary":"주의) 본 글은 지극히 개인적이고 주관적인 생각과 성찰 등을 정리한 글입니다. 따라서 실무나 여러 \u0026lsquo;정론\u0026rsquo; 과는 다른 내용을 담고 있을 수 있습니다. 틀린 내용을 발견하면 댓글 부탁드립니다 !\n약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.","title":"도메인과 레이어드 아키텍처"},{"content":"1. 문자 인코딩이란 문자 인코딩이란 사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말한다. 1 우리가 작성한 모든 텍스트는 결국 CPU 상에서 2진수로 처리된다. 사람이 작성한 글을 2진수로 변환하고, 2진수를 다시 사람이 읽을 수 있도록 만드는 작업을 각각 인코딩(encoding)과 디코딩(decoding)이라고 표현한다.\n이러한 인코딩을 하기 위해서는 서로 약속한 \u0026lsquo;문자열 세트\u0026rsquo;가 필요하다. 가장 대표적인 문자열 세트는 ASCII다. ASCII는 1963년 미국 ANSI에서 표준화한 7 bit 부호 체계로 128 개의 기호(33개의 제어문자와 95개의 출력문자)를 표현할 수 있다. 1 bit 은 Parity bit으로 7개의 bit 중 1의 개수가 홀수면 1, 짝수면 0으로 값을 할당하여 전송 과정 중 오류를 탐지하는 용도로 사용한다.\nExtended ASCII는 이러한 parity bit 를 없애고 zone bit 를 추가하여, 8개의 bit로 총 256 개의 문자를 사용할 수 있도록 하였다.\n2. 한글? ASCII 코드는 영문자와 아라비안 숫자를 자유롭게 표현할 수 있었지만, 한글을 비롯한 여러 국가들의 문자를 표기할 수는 없었다. 1 byte만으로 수많은 언어의 문자들을 표현하기에는 아무래도 무리일 것이다.\n이를 개선하기 위해 마이크로소프트사에서 EUC-KR 와 이를 확장한 CP949 를 도입하였다. 두 문자열 세트는 \u0026lsquo;완성형\u0026rsquo; 이라고 하여, 2 byte 로 하나의 완성된 문자를 표현하는 방식이다. 즉, 가, 힣과 같은 특정한 문자에 코드를 할당한다. 이의 반대인 조합형은 한글의 제자 원리에 기반하여 초성, 중성, 종성에 각각 코드를 할당하는 방식이다.\nEUC-KR 은 현대 한글에서 자주 사용하는 2350자 만을 지원하였다. 이는 반대로 말하면 자주 사용하지 않는 글자는 표현을 못한다는 의미가 된다. CP949 는 이를 개선하기 위해 EUC-KR을 확장하여 약 8000여 자를 추가하였다고 하지..만, 사실상 지금은 표준에 밀려 웬만하면 사용을 지양해야 하는 방식이 되어버렸다.\n3. 유니코드 : 이렇듯 한글을 포함하여 여러 국가가 제각기 원하는대로 문자를 표현하고자 하다보니 여러 문제가 발생했다. 즉, 네트워크가 발전함에 따라 다른 국가의 홈페이지를 접속했더니 알 수 없는 글자로 표시되는 것이다. 이러한 문제를 해결하고자, 전 세계의 모든 문자를 표현할 수 있도록 유니코드 라는 표준을 제정하게 되었다.\n유니코드에서 값을 나타내기 위해서는 Code point 를 사용하고, U+ 를 붙여 표시한다. 가령, A 의 유니코드 값은 U+0041 혹은 \\u0041 로 표현한다. 유니코드는 평면이라는 논리적 개념을 이용하여 구획을 나누며, 이 중 0번 평면이 기본 다국어 평면(BMP, Basic Multilingual Plain)으로 쓰이다.\n4. UTF-8 유니코드로 세계의 모든 문자를 표시할 수 있게 되었는데, 이를 결국 \u0026ldquo;어떻게 저장할 것인가?\u0026rdquo; 에 대한 문제가 다시 대두되었다. 우리가 오늘날 대부분 사용하는 인코딩 방식인 UTF-8은 유니코드를 위한 가변 길이 문자 인코딩 방식 중 하나이다.\nUTF-8 인코딩은 유니코드 한 문자를 나타내기 위해 1byte에서 최대 4byte를 사용한다. 가령, a 는 1 byte를 사용하지만, 가 는 3byte를 사용한다. 이를 조금 더 자세히 살펴보겠다.\n우선 UTF-8은 ASCII 와의 호환성을 위해 7 bit 이내의 코드값에는 맨 앞 비트를 0으로 붙이다. 즉, a 를 나타내기 위해서 01000001 를 사용한다.\n7 bit 초과, 11 bit 이내의 코드 값은 (128 ~ 2047)은 총 2 byte로 표현한다. 즉, 110XXXXX 10XXXXXX 로 표현한다. 첫 번째 byte의 110 은 순서대로 \u0026lsquo;이 문자가 1byte를 초과한다\u0026rsquo;, \u0026lsquo;이 뒤에 1개의 byte가 더 있다\u0026rsquo;, \u0026lsquo;여기까지가 범위를 나타낸 것이었고, 앞으로는 실제 값에 해당한다\u0026rsquo;를 의미한다. 두 번째 byte의 10 은 \u0026lsquo;이 byte는 앞선 byte의 후속이다\u0026rsquo; 를 의미한다.\n이렇게 각각의 맨 앞 비트에 몇 byte가 더 추가될것인지에 대한 정보를 공유하고, 남은 11 자리로 문자를 표현하는데 사용한다.\n5. MySQL 에서 문자열 다루기 5.1. utf8mb3 ? utf8mb4 ? 여기까지 간단하게 컴퓨터에서 어떻게 문자열을 처리하는지에 대해 알아보았다. 그렇다면 본 주제인 MySQL 의 인코딩에 대해 알아보자.\nMySQL 5.X 를 기준으로 기본 인코딩은 utf8mb3 를 사용했다. 기존에 사용하던 utf8은 utf8mb3의 alias 이다. MySQL 8.X 로 넘어와서는 utf8mb4를 사용한다.(utf8mb3 는 deprecated 될 예정이다.2) 그렇다면 이 두 인코딩 방식의 차이는 무엇일까 ?\nMySQL 8.0 공식문서에서는 다음과 같이 설명한다.\nutf8mb3 는 BMP 문자만 지원하고, 문자당 3 byte만을 할당한다는 점에서 utf8mb4와 대조된다.\nBMP 문자에 대해서, utf8mb4 와 utf8mb3 는 동일한 특성을 지닌다 : 같은 코드 값, 인코딩, 길이를 가진다. 추가 문자(supplementary character)의 경우, utf8mb4 는 저장을 위해 4 byte를 필요로 하지만, utf8mb3 는 해당 문자를 저장할 수 없다. utf8mb3 칼럼을 utf8mb4 로 바꿀 때, 당신은 추가 문자가 없기 때문에(애초에 저장된 적이 없으므로) 이에 대해 걱정할 필요가 없다. 5.2. MySQL 에서 문자열의 길이 세기 위 내용들을 통해, 우리는 MySQL 에서 왜 length() 와 char_length() 가 따로 존재하는지 알 수 있다. length() 함수는 문자열의 byte 길이를 구하는 반면, char_length() 는 글자의 길이를 구한다.\nlength(\u0026#39;한글\u0026#39;) -- 6 length(\u0026#39;english\u0026#39;) -- 7 char_length(\u0026#39;한글\u0026#39;) -- 2 char_length(\u0026#39;english\u0026#39;) -- 7 5.3. MySQL의 varchar, 그리고 인덱스 MySQL에서 주로 사용하는 varchar 자료형은 첫 2 byte 에 문자열의 길이에 대한 정보를 저장한다. (정확히는 길이가 255 이하인 경우 1 byte를, 초과인 경우 2 byte를 사용한다.) 그리고, 앞서 MySQL 5.X 버전을 기준으로 default 로 사용되던 utf8mb3 는 최대 3 byte를 사용한다는 것을 확인하였다.\nMySQL 에서 문자열을 index로 사용할 경우, 최대 767(3 * 255 + 2) bytes를 사용할 수 있다. 이는 바꿔말하면 utf8mb3 를 기준으로, varchar(255) 자료형을 사용하면 모든 문자열을 인덱스에 담을 수 있다 가 된다. 하지만 8.X 버전에 들어서면서 utf8mb4 를 사용하게 될 경우에는 성립하지 않는다.\n좀 더 정확히는, InnoDB를 기준으로, Dynamic 혹은 Compressed row format 을 사용한다면 3072 byte를, REDUNDANT 혹은 COMPACT row format을 사용하면 767 bytes를 사용할 수 있다. 자세한 내용은 공식문서를 확인하자.\nreference 한글 인코딩의 이해 1편: 한글 인코딩의 역사와 유니코드 What is the difference between utf8mb4 and utf8 charsets in MySQL? MySQL 8.0 Reference Manual, 10.9.1 The utf8mb4 Character Set (4-Byte UTF-8 Unicode Encoding) 위키피디아 : 문자 인코딩\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMySQL 8.0 Reference Manual, 10.9.8 Converting Between 3-Byte and 4-Byte Unicode Character Sets\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cjlee38.github.io/post/database/encoding-with-mysql/","summary":"1. 문자 인코딩이란 문자 인코딩이란 사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말한다. 1 우리가 작성한 모든 텍스트는 결국 CPU 상에서 2진수로 처리된다. 사람이 작성한 글을 2진수로 변환하고, 2진수를 다시 사람이 읽을 수 있도록 만드는 작업을 각각 인코딩(encoding)과 디코딩(decoding)이라고 표현한다.\n이러한 인코딩을 하기 위해서는 서로 약속한 \u0026lsquo;문자열 세트\u0026rsquo;가 필요하다. 가장 대표적인 문자열 세트는 ASCII다. ASCII는 1963년 미국 ANSI에서 표준화한 7 bit 부호 체계로 128 개의 기호(33개의 제어문자와 95개의 출력문자)를 표현할 수 있다.","title":"문자 인코딩과 MySQL varchar"},{"content":"프로젝트를 local에서만 개발하는게 아니라면, 그리고 develop 이나 staging, production 을 구분해서 개발하게 된다면 필연적으로 서로 다른 설정값이 필요하게 된다.\nlocal 에서는 테스트 용도이므로 H2 의 in-memory DB 를 사용할 수 있지만, production 환경에서는 반드시 안정적인 밴더사의 RDBMS와 인스턴스를 사용하게 된다.\n가령, local에서 개발을 마치고, 이제 production 에서 코드를 가져와 실행하려면 당연히 datasource 를 바꿔주어야 한다.\n# as-is (local) spring: datasource: url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE username: sa # to-be (production, or develop ...) spring: datasource: url: jdbc:h2:192.168.XXX.XXX:3306;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE username: sa 그런데 이를 매번 바꿔주려니 여간 귀찮은 일이 아니다. 개인 노트북에서 작업을 끝낸 후, ssh 로 들어가거나, 어찌저찌 자동화해서 정상적으로 github에서 코드를 clone 해왔더라도, 위 설정파일을 수작업으로 매 번 고쳐주어야 한다.\n1.1 Profile 이를 위해 스프링에서는 profile 이라는 개념이 존재한다. 스프링에서는 다음과 같이 설명한다.\nSpring Profiles provide a way to segregate parts of your application configuration and make it only available in certain environments.\n즉, 어플리케이션의 설정의 일부를 분리해서, 특정 환경에서만 사용할 수 있는 기능을 제공한다. 다음은 사용법이다.\nspring: profiles: active: local --- spring: config: activate: on-profile: prd datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://${DATABASE_HOST}:3306/${DATABASE_NAME}?serverTimezone=Asia/Seoul\u0026amp;character_set_server=utf8mb4 username: ${USERNAME} password: ${PASSWORD} --- spring: config: activate: on-profile: local datasource: url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE username: ${USERNAME} h2: console: enabled: true jpa: show-sql: true hibernate: ddl-auto: validate properties: hibernate: format_sql: true 가장 먼저 살펴볼 부분은, 파일이 --- 으로 구분되었다는 점이다. 이 세 개의 dash를 기준으로 각 설정파일이 분리됨을 의미하며, properties 에서는 Springboot 2.4.0 부터 #--- 기호로 구분할 수 있다.\nNote. 파일을 직접 분리해서 여러 개로 관리할 수도 있다. 이 때는 application-${env}.yml 혹은 application-${env}.properties 의 형태로 관리하며, env 가 밑에서 설명할 각각의 profile이 된다.\nspring: profiles: active: local 다음으로는 가장 맨 위의 section 에 있는, active 이다. 이는 현재 내가 실행하고자 하는 profile 을 나타내며, 쉼표로 구분해 여러 개의 profile을 가져올 수도 있다. 즉, 여기서는 local 을 사용하겠다는 의미이다.\n두 번째는 잠시 넘어가고 세 번째 section을 살펴보겠다.\nspring: config: activate: on-profile: local datasource: url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE username: ${USERNAME} h2: console: enabled: true jpa: show-sql: true hibernate: ddl-auto: validate properties: hibernate: format_sql: true 밑에서부터 잠깐 보면, datasource는 memory-db 로 설정되어 있고, h2-console 도 실행하고, sql도 모두 출력하는 등, production 환경에서 사용하지 않을 옵션들을 지정하였다.\n그리고 가장 위쪽을 보면 on-profile 에 local 로 지정되어 있다. 즉, profile이 local로 설정된 경우에 이 section, 즉 세 번째 section을 설정하겠다는 의미이다. 따라서 위 active 키에서 local로 지정하였으므로 해당 section을 설정하게 된다. 반대로 production 환경은 실제 운영 환경에서 사용할 옵션들을 지정한다. 실제 데이터베이스 URL을 통해, 아이디/패스워드를 사용해 로그인하겠다는 설정들이 담겨 있다.\nspring: config: activate: on-profile: prd datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://${DATABASE_HOST}:3306/${DATABASE_NAME}?serverTimezone=Asia/Seoul\u0026amp;character_set_server=utf8mb4 username: ${USERNAME} password: ${PASSWORD} 그런데 보다보면 한 가지 이상하게 생긴 녀석이 있다. ${DATABASE_HOST} 와 같이 생긴 녀석인데, 이는 \u0026ldquo;내가 OS 환경변수로부터 이 정보를 가져오겠다\u0026rdquo; 라는 의미이다.\n환경변수는 ~/.bash_profile 등으로도 관리할 수 있지만, 하나의 인스턴스에 여러 프로젝트를 띄울 수도 있으므로 여기서는 직접 관리하도록 한다. 이러한 설정 방법은 아래 1.3절에서 알아본다.\n1.2 JVM property : Java의 jar 파일은 다음과 같은 형태로 실행할 수 있다.\njava -jar MY_PROJECT-0.0.1.jar 이 때, -D 를 이용해 JVM 의 System property를 설정할 수 있다. 이 property는 스프링에게까지 전달되며, 스프링에 대한 옵션을 지정할 수 있다. 일례로, 다음과 같이 실행하여 스프링의 기본 포트인 8080을 8181로 수정할 수 있다.\njava -jar -Dserver.port=8181 MY_PROJECT-0.0.1.jar 그렇다면, 이런식으로 위에서 보았던 profile도 설정해줄 수 있으리라고 짐작할 수 있다. 즉, 다음과 같이 실행한다.\njava -jar -DSpring.profiles.active=prd MY_PROJECT-0.0.1.jar 스프링의 설정은 대부분 \u0026ldquo;구체적일수록\u0026rdquo; 우선권을 가진다. application.yml 에 설정한 local보다, 실행할 때 지정해준 prd 가 더 구체적이기 때문에, 최종 active 는 prd 가 된다.\n이렇게 우리는 clone해온 코드에 한 줄도 고치지 않고 환경을 바꿔가며 실행할 수 있다.\n1.3 환경변수 어플리케이션을 배포하는 방법에는 여러가지가 있겠지만, 가장 간단한 방법은 쉘스크립트를 작성하는 것이다. 위에서 작성한 명령어에 몇 줄을 추가하여 쉘 스크립트를 작성해보겠다.\nexport DATABASE_HOST=192.168.XXX.XXX export DATABASE_NAME=my_database export USERNAME=my_username export PASSWORD=mypassword java -jar -DSpring.profiles.active=prd MY_PROJECT-0.0.1.jar 위와같이 작성한뒤, 스크립트를 실행하면 앞서 yml 파일에서 작성했던 ${DATABASE_HOST} 와 같은 부분이 작성한 192.168.XXX.XXX 로 변해서 실행되는 것을 확인할 수 있다.\nPlatform : 데이터베이스 스키마, 혹은 데이터 또한 상황에 따라 나눌 수 있다. 위 예시와 같이 production과 local 환경에 따라 기존 테이블을 drop할지 말지, 혹은 더미 데이터를 넣어둘지 말지 등을 결정할 수 있다. 혹은, A 밴더사의 RDBMS에서 제공하는 SQL 문법이 B 밴더사의 RDBMS 에서 동작하지 않을 수 있는 경우도 있다.\n이러한 경우에 활용할 수 있는 것이 바로 platform 이다.\n스프링은 구동시 classpath(여기서는 src/main/resources 혹은 src/test/resources)로부터 schema.sql, 혹은 data.sql 로부터 DDL을 읽어와 실행한다.\n그리고 이 때, 위 application-${env}.yml 과 마찬가지로, schema-${platform}.sql 혹은 data-${platform}.sql 의 형태로 내가 지정한 platform 에 맞는 DDL을 읽어올 수 있다. 다음은 사용 예시이다.\nspring: sql: init: platform: local mode: always 위처럼 platform을 local 이라고 설정해두면, schema-local.sql, data-local.sql 을 찾아 실행하게 된다.\n그 아래에 있는 mode에는 never, embedded, always의 세 가지 옵션이 있다. 각각의 이름에서 유추할 수 있듯이, DDL 스크립트로부터 초기화하지 않으려면 never를, embedded(in-memory)인 경우에만 초기화하려면 embedded, 항상 초기화하려면 always\t를 사용하면 된다.\n단, 이 때 DDL 스크립트가 비어있으면 안된다. 아예 파일 자체가 존재하지 않는건 괜찮지만, DDL 스크립트가 비어있으면 스프링을 구동하는 도중 예외를 던진다.\n역시 profile과 마찬가지로 스프링 실행시 System property 로 설정할 수도 있다. (-Dspring.sql.init.platform=local) 또한, profile과 적절히 조합하여 특정 profile에 걸맞는 DDL 을 실행할 수도 있다.\n","permalink":"https://cjlee38.github.io/post/spring/spring-environment-seperation/","summary":"프로젝트를 local에서만 개발하는게 아니라면, 그리고 develop 이나 staging, production 을 구분해서 개발하게 된다면 필연적으로 서로 다른 설정값이 필요하게 된다.\nlocal 에서는 테스트 용도이므로 H2 의 in-memory DB 를 사용할 수 있지만, production 환경에서는 반드시 안정적인 밴더사의 RDBMS와 인스턴스를 사용하게 된다.\n가령, local에서 개발을 마치고, 이제 production 에서 코드를 가져와 실행하려면 당연히 datasource 를 바꿔주어야 한다.\n# as-is (local) spring: datasource: url: jdbc:h2:mem:testdb;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE username: sa # to-be (production, or develop ...) spring: datasource: url: jdbc:h2:192.","title":"스프링에서 환경을 분리하는 방법"},{"content":"코틀린을 처음 접하면, 익숙한 field 라는 용어 대신 property 라는 용어를 접하게 된다. property 라는 용어는 지난 파이썬 Property까지 가는 길 에서 한번 다뤘던 개념과 사실상 같다고 보아도 무방하다. property는 단순하게 이야기하면 클래스 내에 담겨있는 field, getter , setter 를 통칭하여 의미하다. Java 에서는 이를 private 으로 필드를 숨기고, getter 와 setter 를 제공함으로서 property를 흉내냅니다.\npublic class SomeObject { private int someInteger; private String someString; public int getSomeInteger() { return this.someInteger; } public String getSomeString() { return this.someString; } public void setSomeInteger(int otherInteger) { this.someInteger = otherInteger; } public void setSomeString(String otherString) { this.someString = otherString; } } 코틀린에서 변수는 기본적으로 val 과 var 를 통해 작성하다. val은 value 를 의미하여 한 번 초기화 된 이후로는 read-only 이다. Java 의 final 키워드를 붙인 변수라고 생각할 수 있다. var 는 variable 을 의미하며, ‘변할 수 있는 값’, 즉 ‘변수’ 이라는 의미에 걸맞게 값을 수정할 수 있다. 그리고 이를 property 관점에서 살펴보면 var 는 순수 property , val 은 read-only property 라고 표현하다. 하지만 편의상 둘 다 묶어 property 라고 표현하다.\nclass SomeObject { val someString: String = \u0026#34;string\u0026#34; var someInteger: Int = 123 } property는 겉에서 보기에는 마치 public 으로 열려있는 field 처럼 보이지만, 내부적으로 getter 와 setter 메소드 호출을 통해 이루어집니다.(The syntax for reading and writing of properties is like for fields, but property reads and writes are (usually) translated to \u0026lsquo;getter\u0026rsquo; and \u0026lsquo;setter\u0026rsquo; method calls.) 그리고 이러한 getter, setter 를 묶어서 accessor, 즉 접근자라고 부릅니다.\n하지만 property를 아무런 추가 작업 없이 순수하게 getter, setter 로만 사용한다면 큰 의미가 없겠죠. 뭔가 내가 원하는대로 작업을 할 수 있어야 하다. property 는 다음과 같은 형태를 가지고 있다.\nvar \u0026lt;propertyName\u0026gt;[: \u0026lt;PropertyType\u0026gt;] [= \u0026lt;property_initializer\u0026gt;] [\u0026lt;getter\u0026gt;] [\u0026lt;setter\u0026gt;] 위에 보이는 형태에서 getter, setter 부분을 우리가 직접 정의할 수 있고, 이를 custom accessor 라고 부릅니다. 다음은 Age 라는 \u0026lsquo;나이\u0026rsquo;에 해당하는 클래스에 대한 예제이다.\nclass Age { val value = 20 get() = field + 1 } fun main() { val age = Age() println(age.value) // 21 } 위 코드를 보면, Age 클래스 내부에 value에 대한 값을 20으로 정의하였다. 하지만 그 값을 얻어내는 데 있어 그 값을 1 늘려서 받도록 처리하였다. 그렇기에 age.value 는 20 대신 21이라는 값을 얻어냄을 확인할 수 있다. 여기서 주의해서 볼 점은, custom getter 를 정의할 때 field 라는 키워드를 사용한다는 점이다.\nproperty가 field와 accessor를 묶어서 부른다는 점을 감안하면, field라는 값이 실제로 들어있는 값에 해당함을 직감할 수 있다. 엄밀하게는 공식 문서에서는 이를 backing field 라고 부르며, 다음과 같이 설명하다.\nIn Kotlin, a field is only used as a part of a property to hold its value in memory. Fields cannot be declared directly. However, when a property needs a backing field, Kotlin provides it automatically. This backing field can be referenced in the accessors using the field identifier\n다음은 setter에 대한 예제이다.\nclass Age { var value = 20 get() = field + 1 set(value) { field = value - 2 } } 위 예제에서는 custom setter가 추가 된 것 이외에도, value의 타입이 var 로 바뀌었다는 점에 주목해야 하다. 즉, val 은 앞서 언급했다시피 final에 해당하므로, setter가 동작할 수 없다. 한편 var는 변경가능하므로, setter를 정의할 수 있다.\n또한 property 에 대해 한 가지 더 알아야 할 점은, \u0026ldquo;반드시 field를 가질 필요는 없다\u0026rdquo; 라는 것이다. 위 Age 코드에서, \u0026lsquo;성인인가?\u0026lsquo;에 대한 boolean 값을 메소드가 아닌 property로 저장할 필요가 있다고 가정해보겠다.\nclass Age { var value = 20 get() = field + 1 set(value) { field = value - 2 } val isAdult = value \u0026gt; 20 } fun main() { val age = Age() println(age.value) // 21 println(age.isAdult) // true // #1 age.value = 10 println(age.isAdult) // ? #2 } 위 코드를 실행했을 때, #2 에 해당하는 print문은 어떤 결과물을 내놓을까요 ? 정답은 true 이다. 왜냐하면, instance가 생성되는 시점에 isAdult가 초기화되고, 그 값은 변하지 않기 때문이다.\n#1 에 해당하는 코드 또한 true를 반환하다는 점도 유의해서 살펴보시기 바랍니다. isAdult가 참조하고 있는 대상이 value 이고, custom getter 를 통해 가져오기 때문에 true가 반환된다.\n이 상황에서 우리는 isAdult가 \u0026lsquo;매 번 새로이 계산되는 것\u0026rsquo; 을 원하다. 이를 value의 custom setter에 isAdult를 초기화하는 것 대신 property의 특성을 활용하면 다음과 같이 작성할 수 있다.\nclass Age { var value = 20 get() = field + 1 set(value) { field = value - 2 } val isAdult: Boolean get() = value \u0026gt; 20 } isAdult 에는 아무런 값도 할당되어 있지 않지만, getter를 통해 매 번 새로운 값을 가져올 수 있고, val 이기 때문에 setter를 정의할 수 없으므로 isAdult를 사용함에 있어 전혀 문제가 되지 않다.\n이러한 특성을 활용해 Backing Property 라는 개념도 존재하다. Backing Property는 외부에 드러내는 값을 드러내고, 내부로 숨기고 싶은 값을 private 접근자와 함께 이름 앞에 _(언더스코어)를 붙여줍니다. 공식문서 참고\n","permalink":"https://cjlee38.github.io/post/lang/kotlin-property/","summary":"코틀린을 처음 접하면, 익숙한 field 라는 용어 대신 property 라는 용어를 접하게 된다. property 라는 용어는 지난 파이썬 Property까지 가는 길 에서 한번 다뤘던 개념과 사실상 같다고 보아도 무방하다. property는 단순하게 이야기하면 클래스 내에 담겨있는 field, getter , setter 를 통칭하여 의미하다. Java 에서는 이를 private 으로 필드를 숨기고, getter 와 setter 를 제공함으로서 property를 흉내냅니다.\npublic class SomeObject { private int someInteger; private String someString; public int getSomeInteger() { return this.","title":"kotlin Property"},{"content":"흔히 \u0026ldquo;객체지향\u0026rdquo; 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용한다. Java 에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } public void setAge(int age) { if (age \u0026lt;= 0) throw new IllegalArgumentException(\u0026#34;나이는 0 이하가 될 수 없다.\u0026#34;); this.age = age; } } public class Main { public static void main(String[] args) { Person person = new Person(\u0026#34;Mr.Kim\u0026#34;, 26); System.out.println(person.getName()); // \u0026#34;Mr.Kim\u0026#34;; person.setAge(-62); // IllegalArgumentException(\u0026#34;나이는 0 이하가 될 수 없다.\u0026#34;) } } 그러나 python 에서는 programming language 수준에서 접근 권한을 제어할 수 없다. _(언더스코어) 를 활용하는 방법을 제공하기는 하지만, 결국 _{클래스명}__{변수명} 으로 접근이 가능합니다.(이후 뒤에서 설명할 property도 결국 직접 접근하는 방법은 있다.)\n따라서 python 에서는 기본적으로 모두 public 이라고 생각하면 된다. 하지만 그렇다고 해서 getter/setter를 쓸 필요가 없다는 것은 아니다. 당장 위와 같은 예시만 보더라도, setAge() 메소드를 호출할 때, 나이가 음수인지 아닌지 검증하는 로직이 필요하기 때문이다. 위 코드를 python 으로는 다음과 같이 쓸 수 있다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age # 다른 메소드는 편의상 생략 def set_age(self, new_age) : if new_age \u0026lt;= 0 : raise Exception(\u0026#34;나이는 0 이하가 될 수 없다.\u0026#34;) self._age = new_age if __name__ == \u0026#39;__main__\u0026#39; : person = Person(\u0026#34;Mr.Kim\u0026#34;, 26) person.set_age(-62) # Exception(\u0026#39;나이는 0 이하가 될 수 없다.\u0026#39;) 여기까지는 Java와 똑같다. 하지만, 이런 식의 코드 사용은 explicit 하지 못하다는 단점이 있다. 만약 기존 나이에서 1살을 더해줘야 한다면, 다음과 같이 작성해야 한다.\nperson.set_age(person.get_age() + 1) 뿐만 아니라, person._age = -62 와 같은 코드는 방어할 수가 없어진다는 문제도 여전히 남아있다. 그러나 @property 를 활용하면 다음과 같은 코드가 가능하다.\nperson.age += 1 person.age = -62 # Exception(\u0026#39;나이는 0 이하가 될 수 없다.\u0026#39;) ??? 어떻게 된 일일까? 겉으로 보기에는 변수에 값을 직접 대입하는 것 같은데, 로직에 따른 Exception을 던지고 있다. 어떻게 이것이 가능한지는 차차 알아보기로 하고, 일단 생김새부터 살펴보자. 위 Person 클래스에 @Property를 적용하면 다음과 같이 작성할 수 있다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age @property def age(self) : return self._age @age.setter def age(self, new_age) : if new_age \u0026lt;= 0 : raise Exception(\u0026#34;나이는 0 이하가 될 수 없다.\u0026#34;) self._age = new_age 대충 살펴 봤을때, 눈에 띄는 차이점은 다음과 같다.\n함수의 이름이 get_age 혹은 set_age 가 아니라, 그냥 age 자체로 변경되었다. 계속 언급했던 @property 가 age 메소드 위에 붙었다. 또한, @age.setter 라는 녀석도 두 번째 age 메소드 위에 붙어있다. 이러한 변화가 어떻게 앞서 언급했던 동작에 영향을 미쳤는지 하나씩 알아보자.\n@property를 이해하기 위한 배경지식들은 다음과 같다.\nEverything is Object Decorator Descriptor Object 1. Everything is Object Python에서 다루는 모든 값은 객체이다. Java에서는 일반적으로 값을 Primitive Type, Reference Type 으로 구분한다. 반면 Python에서는 int, bool과 같은 값들도 모두 객체로 다뤄진다.\na = 1 print(id(a)) # 4341049696 id 함수는 Built-in 함수로, 객체가 가지고 있는 주소값을 나타낸다. 따라서 id(a)라는 코드는 1 이라는 값이 할당된 메모리 주소를 반환한다. Java에서는 Integer 와 비슷하다고 생각할 수 있다.\n이에 더해, Python 에서는 함수마저도 객체이다.\ndef my_func() : return \u0026#34;hello world\u0026#34; print(my_func.__str__()) # \u0026#39;\u0026lt;function my_func at 0x7ffd70cf1f70\u0026gt;\u0026#39; 위 예시에서 보시다시피, my_func 이라는 이름의 함수를 만든 뒤, 해당 함수가 갖고 있는 __str__ 이라는 메소드를 호출할 수 있다. 즉, my_func 자체는 Function 이라는 클래스를 상속하는 클래스다.\n간단하게 생각하면, def my_func() 라는 키워드는 my_func = {함수 바디} 와 같이 변수로 정의되는 것을 상상해볼 수 있다.\nNote. 함수가 객체라는 이야기를 할 때, 1급 시민 이라는 키워드가 자주 등장한다. 1급 시민이란, 변수에 할당할 수 있어야 하고, argument로 전달될 수 있으며, return 으로 반환될 수 있는 값들을 말합니다. Java에서 메소드는 일급 객체가 아니지만, 인터페이스를 활용해 1급 시민의 흉내를 낼 수 있다.\n2. Decorator 데코레이터를 이야기하려면 Python 함수가 갖는 또 다른 특징을 알아야 한다.\n1) 함수는 중첩이 가능하다. python은 다음과 같이 함수를 중첩해서 정의할 수 있다.\ndef outer() : def inner() : print(\u0026#39;inner called\u0026#39;) print(\u0026#39;outer called\u0026#39;) inner() return inner var = outer() # outer called \\n inner called (1) var() # inner called (2) outer 함수 안에 inner 함수를 정의한 뒤, inner 함수를 호출했다. 따라서 var = outer() 를 통해 outer함수를 호출할 때, 내부에 있는 inner 함수 (1)도 실행된다.\n다음으로 return inner를 통해 inner 함수 그 자체를 돌려주고, 해당 함수 객체는 var 라는 변수에 저장된다. 따라서 var() 를 통해 함수를 실행하는 것은 결국 inner 함수를 실행하는 것과 같다.\n2) Enclosed Function Locals python의 함수가 갖는 두 번째 특징은, 이러한 중첩 함수로 인해 조금 특별한 변수 scope가 생긴다는 것이다. C를 처음 배웠을 무렵, 지역변수 전역변수와 같은 개념에 대해서 배우고, \u0026ldquo;내가 허용된 범위의 바깥 변수는 알 수 없다\u0026rdquo;, \u0026ldquo;가까운 scope부터 찾아 나간다\u0026rdquo; 정도의 개념으로 정리하고 넘어갔다. python에서는 후자, 즉 \u0026ldquo;가까운 scope부터 찾아 나간다\u0026quot;는 맞는 말이지만, 전자인 \u0026ldquo;내가 허용된 범위 바깥 변수는 알 수 없다\u0026rdquo; 는 조금 다르다. 한마디로, \u0026ldquo;내가 허용된 범위 바깥 변수에 접근할 수는 있지만, 수정할 수는 없다.\u0026rdquo;.\nx = 1 def outer() : y = 2 def inner() : z = 3 print(z, y, x) inner() return inner a = outer() # 3 2 1 a() # 3 2 1 아까 예시를 들었던 outer/inner 함수를 약간 변형해보았다. outer 함수가 실행되던 와중에 inner가 호출되든, 함수 객체를 return 받은 a가 호출되든 상관없이, 모두 3 2 1을 출력한다.\nNote. python에서는 가까운 곳부터 찾아나가는 접근법을 LEGB 규칙 이라고 명명한다. 순서대로 Local, Enclosed function locals, Global, Built-in 의 약자이며, z, y, x 변수가 이에 해당한다. 마지막 Built-in 변수는 __name__과 같이 \u0026ldquo;내가 정의하지도 않았는데 기존에 정의되어 있던 값들\u0026quot;을 말한다.\n하지만 다음의 예시는 쓰기에 대해서는 조금 다른 결과임을 보여준다.\nx = 1 def outer() : y = 2 def inner() : z = 3 y += 1 # UnboundLocalError: local variable \u0026#39;y\u0026#39; referenced before assignment x += 1 # UnboundLocalError: local variable \u0026#39;x\u0026#39; referenced before assignment print(z, y, x) inner() return inner a = outer() a() inner 내부에서 y와 x에 대해서 값을 1씩 더하려고 하자 할당되기 전에 참조되었다는 에러를 발생시킨다. 즉, 자기 자신의 scope 바깥에 있는 변수에 대해서는 \u0026ldquo;쓰기\u0026rdquo; 연산에 대해, 즉 \u0026ldquo;변경\u0026quot;에 대해 제한되어 있다.\nNote. 만약 해당 값을 수정하고 싶다면 nonlocal 혹은 global 키워드를 통해 \u0026ldquo;내가 외부의 값을 수정하고자 한다\u0026rdquo; 라는 의도를 드러내야 한다.\n3) Closure Closure는 위키피디아에서 다음과 같이 설명하고 있다.\n컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 이러한 설명은 처음 Closure를 접한 사람들에게 전혀 도움이 되지 않다. 심지어 Closure라는 네이밍 그 자체에서도 어떠한 힌트를 얻기는 어렵다. 예시를 살펴보면서 이해해보자.\ndef outer(val) : def inner() : print(\u0026#39;inner called\u0026#39;) print(val) print(\u0026#39;outer called\u0026#39;) return inner a = outer(10) # ??? a() # ??? 첫 번째로 실행한 a = outer(10), 두 번째로 실행한 a() 코드가 각각 어떻게 돌아갈지 한번 상상해보자.\na = outer(10)에 의해 outer 함수를 호출했고, argument로 10을 넘겨주고, 이를 val 이라는 이름으로 받아냈다. 그 내부에서 inner 함수를 정의했고, outer called 를 출력한 뒤, inner 함수 객체를 돌려준다.\n두 번째로 a() 를 통해, a 변수가 갖고 있는 inner 함수 객체를 호출한다. inner called를 출력한 뒤, val을 출력하려고 하는데, 여기서 의문점이 하나 생긴다. 해당 함수는 자신 바깥에 있는, 즉 val 변수를 참조하고 있다. 앞서 이야기한 LEGB 규칙에 따르면, L 에서 E를 참조하는 셈이다.\n여기서 val은 살아 있을까? 바꿔말하면, val 변수를 참조해서 아까 넣어준 10 이라는 값을 얻어낼 수 있을까? 정답은 \u0026ldquo;그렇다\u0026rdquo; 입니다.\n이렇게 보니 마치 outer 라는 클래스가 val 이라는 멤버변수를 가지고 있는 것처럼 느껴진다. 여기까지 읽고 나서, 다시 위키피디아의 정의를 살펴보자.\n컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 이렇게 보니 100% 이해하지는 못하더라도, 어떤 느낌으로 설명하고 있는지는 알 수 있다. Closure라는 이름 또한 직역 시 \u0026ldquo;폐쇄\u0026rdquo; 라는 뜻을 갖고 있는데, 조금 과장해서 \u0026ldquo;나만의 구역\u0026quot;과 같은 느낌이 연상되기도 한다.\nNote. 어떠한 함수 A 가 Closure이기 위해서는 다음의 세 가지 조건이 만족되어야 한다.\nA 함수는 다른 함수 B 안에 정의된 함수, 즉 중첩된 함수여야 한다. 자신을 둘러싼 함수 B scope 의 값을 참조해야 한다. B 함수는 A 함수를 반환해야 한다. 여기서 한 단계 더 나아가보자.\ndef outer(func) : def inner() : print(\u0026#39;inner called\u0026#39;) func() print(\u0026#39;outer called\u0026#39;) return inner def my_func() : print(\u0026#39;my_func called\u0026#39;) a = outer(my_func) # outer called a() # inner called \\n my_func called 앞서는 val 이라는 숫자 값을 넣어줬지만, 이번에는 my_func 이라는 함수를 넣어주고 있다. 거듭 반복해서 확인할 수 있듯이, 함수 또한 객체이기 떄문에(a.k.a 1급 시민) 다른 함수의 argument로 전달될 수 있다.\n여기서는 outer 라는 함수의 argument로 my_func을 전달하고 있고, 좀 전과 마찬가지로 my_func는 outer 함수의 호출이 끝나더라도 inner에 의해 참조되고 있다.\n4) Decorator 정리 Decorator를 알기 위한 사전 지식은 준비되었으니, 이제 본격적으로 알아보자.\n바로 위의 예시에서는 a = outer(my_func) 라는 함수를 통해 closure를 만들고, a() 를 통해 inner 함수, 즉 closure 를 호출했다. Decorator를 활용하면 이를 보다 손쉽게 정의할 수 있다.\n즉, 다음의 두 코드는 같다.\n기존\ndef outer(func) : ... def my_func() : ... a = outer(my_func) # outer called a() # inner called \\n my_func called 데코레이터\ndef outer(func) : ... @outer # outer called def my_func() : ... a = my_func() # inner called \\n my_func called 여기서 한 가지 주의할 점은, 데코레이터 버전에서 outer called 는 @outer를 붙여서 my_func를 정의하는 시점에 호출된다는 점이다. 이렇게 보면 Decorator 라는 이름이 왜 Decorator 인지 알 수 있다.\n3. Descriptor Object Descriptor 는 객체 A가 갖고있는 속성인 객체 B를 다룰 때 조회, 저장 및 삭제를 사용자 정의할 수 있는 객체 B를 디스크립터라고 이야기한다. 이 Descriptor라는 녀석은 객체 A의 클래스 변수로서 정의되어야 한다. (the descriptor must be in either the owner’s class dictionary or in the class dictionary for one of its parents)\n역시, 예시를 보면서 진행하겠다.\nclass Age : def __init__(self, age) : self._age = age def __get__(self, obj, objtype) : print(\u0026#34;__get__ method called\u0026#34;) return self._age def __set__(self, obj, val) : print(\u0026#34;__set__ method called\u0026#34;) self._age = val def __delete__(self, obj) : print(\u0026#34;__delete__ method called\u0026#34;) self._age = -1 class Person : age = Age(26) p = Person() print(p.age) # __get__ method called \\n 26 p.age = 20 # __set__ method called del p.age # __delete__ method called print(p.age) # __get__method called \\n -1 Age 라는 클래스를 만들고, __get__, __set__, __delete__ 메소드를 정의했다. 이 세개의 메소드는 스페셜 메소드 라고 불리우며, 객체가 갖는 특성을 지정할 수 있다. 가장 대표적으로 __init__ 메소드는 인스턴스 생성시에 동작하는 행위에 대해서 정의할 수 있다.\n어떠한 객체에 위에서 언급한 세 개의 __get__, __set__, __delete__ 메소드가 정의되었을 경우, 해당 객체를 \u0026ldquo;디스크립터\u0026rdquo; 라고 부르게 된다.\nNote. __get__ 메소드만 정의된 경우에는 Non-data Descriptor, __set__ 메소드 혹은 __delete__ 메소드가 정의된 경우에는 Data Descriptor 라고 부른다. 이 둘의 차이는 우선순위에 있다만, 여기서는 다룰 내용이 아닌지라 넘어가겠다.\n이렇게 Descriptor를 정의할 경우, 해당 객체로 접근할 때 우리가 생각했던 것처럼 값에 직접 접근하는 것이 아니라, 메소드 호출을 통해 접근하게 된다. 그림으로 보면 다음과 같이 상상해 볼 수 있다.\nDescriptor 라는 특별한 개념이 없다면, 코드 상으로는 객체가 위 그림과 비슷한 형태로 구성될 것이라고 예측할 수 있다. Person 안에 Age 객체가, 그리고 Age 객체 안에 _age 라는 멤버변수, __getter__, __setter__ 라는 메소드를 가질 뿐이다. 따라서 p.age 로 접근하게 되면 Age() 객체로 접근할 것처럼 보인다. 하지만 실질적으로는 다음 그림과 같다.\np.age를 호출하게 되는 순간, Person 객체 내에 있는 Age() 객체를 가져오려 하는데, __get__ 메소드가 오버라이드 되어 실질적으로는 Age() 객체가 아닌 그 내부의 self._age를 돌려주게 된다.\n이러한 동작 방식을 보고나면, 왜 Data Descriptor 라는 이름을 갖게 되었는지 알 수 있다. Data Descriptor로 정의된 객체는, 일반적으로 생각하는 것처럼 값을 갖고 메소드라는 행위를 갖지 않고, 대신 내가 원하는 Data(여기서는 _age라는 int 변수)에 대한 톨게이트와 같은 역할을 하게 된다.\n4. Property 장황한 이야기를 끝내고, 드디어 Property에 대한 이야기를 해보자. 앞서 보여드렸던 Property 사용 예시는 다음과 같다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age @property def age(self) : return self._age @age.setter def age(self, new_age) : if new_age \u0026lt;= 0 : raise Exception(\u0026#34;나이는 0 이하가 될 수 없다.\u0026#34;) self._age = new_age Decorator에 대해서 이해하고 왔으니, @property 라는 코드를 통해, property 라는 함수(함수는 다시 객체이니 정확히는 property라는 객체)로 age 라는 메소드를 전달한다는 사실을 알 수 있다.\n따라서, 아래와 같은 코드는\n@property def age( ... ) : ... 실질적으로는 다음과 같다고 볼 수 있다.\nage = property(age) 아까전에 def my_func() 라는 코드는 my_func = {함수바디}와 같이 변수로 정의되는 것을 상상해볼 수 있다고 이야기 했다. 여기서도 같은 맥락임을 확인할 수 있는데, 왜냐하면, @property 데코레이터를 사용해 age = property(age)로, 즉 클래스 변수로 만들었기 때문이다. (Descriptor는 반드시 클래스 변수에 있어야 한다는 사실을 상기하자.)\n파이썬 공식 문서에 있는 property의 생김새는 다음과 같다.\nclass Property: \u0026#34;Emulate PyProperty_Type() in Objects/descrobject.c\u0026#34; def __init__(self, fget=None, fset=None, fdel=None, doc=None): self.fget = fget self.fset = fset self.fdel = fdel if doc is None and fget is not None: doc = fget.__doc__ self.__doc__ = doc def __get__(self, obj, objtype=None): if obj is None: return self if self.fget is None: raise AttributeError(\u0026#34;unreadable attribute\u0026#34;) return self.fget(obj) def __set__(self, obj, value): if self.fset is None: raise AttributeError(\u0026#34;can\u0026#39;t set attribute\u0026#34;) self.fset(obj, value) def __delete__(self, obj): if self.fdel is None: raise AttributeError(\u0026#34;can\u0026#39;t delete attribute\u0026#34;) self.fdel(obj) def getter(self, fget): return type(self)(fget, self.fset, self.fdel, self.__doc__) def setter(self, fset): return type(self)(self.fget, fset, self.fdel, self.__doc__) def deleter(self, fdel): return type(self)(self.fget, self.fset, fdel, self.__doc__) 자, 이제 어떻게 코드가 동작하는지에 대해서 이해할 준비가 되었으니, 한 줄씩 따라가보며 총 정리해보자.\n@property def age( ... ) : ... 위 코드를 통해 age = property(age) 가 실행된다고 언급했다. property의 생성자 인자로 age라는 메소드를 넘겨줬으니, 이 age는 __init__ 메소드 내부에서 fget 이라는 변수에 할당됨을 확인할 수 있다. 그리고 @property를 적용한 Person 클래스의 현재 생김새는 다음과 같다.\nclass Person : def __init__(self, name, age) : self._name = name self._age = age def age(self) : return self._age age = property(age) @age.setter def age(self, new_age) : if new_age \u0026lt;= 0 : raise Exception(\u0026#34;나이는 0 이하가 될 수 없다.\u0026#34;) self._age = new_age 다음으로 @age.setter 부분을 살펴보자. 현재 age는 property 객체인 상태다. 그러면 @age.setter는 다음과 같이 해석된다. age가 계속 나와 헷갈리니 주석을 참고하자.\nage = property(age) # age(1번) = property(age(2번)) # age 라는 이름의 변수(1번)에 \u0026#39;age 메소드\u0026#39;(2번)를 인자로 넘긴 property 객체를 저장. age = age.setter(age) # age(3) = age(1).setter(age(4)) # age라는 이름의 변수(3번)에, property 객체를 갖고 있는 age 변수(1번)의 setter 메소드에 새로운 age 메소드(4)를 넘겨준다. 그리고 setter 메소드를 살펴보면,\ndef setter(self, fset): return type(self)(self.fget, fset, self.fdel, self.__doc__) type(self) 부분은 자기 자신에 대한 type을 구하고 있다. self는 property 이니 다음과 같이 해석된다.\ndef setter(self, fset): return property(self.fget, fset, self.fdel, self.__doc__) 자기 자신에 대해서 생성자를 호출하고 있다. 꼭 마치 자바에서 생성자에 this()와 비슷해 보인다. 또한, 나머지는 self 키워드를 붙여서 자기 자신이 갖고 있던 녀석들을 넘겨주고, fset 위치에만 age(self, new_age) 라는 메소드를 넘겨주고 있다.\n이제 Person 객체에서 age를 접근할 때 무슨일이 일어날까? p.age 로 꺼낸 age는 property 객체라는 사실은 이 쯤 되면 잘 알 것이다. property 객체는 연이어 __get__ 메소드를 호출할 것이다.\ndef __get__(self, obj, objtype=None): if obj is None: return self if self.fget is None: raise AttributeError(\u0026#34;unreadable attribute\u0026#34;) return self.fget(obj) __get__ 메소드의 인자 obj는 자기 자신을 실행한 인스턴스, objtype은 해당 클래스를 의미한다. p.age로 인스턴스를 통해 실행했으니 obj는 p일 것이고, objtype 은 Person 이다.\nobj가 None이 아니고, fget 또한 아까 할당되었으니, return self.fget(obj)가 실행된다.\n즉, fget(obj) 의 fget은 앞서 정의한 def age(self) 이니, 아까 내가 정의한 getter 메소드, 즉 다음 메소드가 실행된다.\ndef age(self) : return self._age 다음으로 __set__ 메소드를 살펴보자. p.age = -10 이라고 작성했다면, 역시 p.age 변수가 갖고 있는 객체는 property 객체이고, 해당 객체의 __set__ 메소드가 호출된다.\ndef __set__(self, obj, value): if self.fset is None: raise AttributeError(\u0026#34;can\u0026#39;t set attribute\u0026#34;) self.fset(obj, value) 마찬가지로 obj는 자기 자신을 실행한 인스턴스, 즉 p 이고, value는 -10 입니다. fset 변수는 앞서 할당한 def age(self, new_age) 함수 객체이고, None이 아니니 self.fset(obj, value)를 실행한다. 즉, 다음 메소드가 실행된다.\ndef age(self, new_age) : if new_age \u0026lt;= 0 : raise Exception(\u0026#34;나이는 0 이하가 될 수 없다.\u0026#34;) self._age = new_age Reference Python의 Closure에 대해 알아보자 Wikidocs 레벨업 파이썬 - 클로저 Python 공식문서 - Descriptor Hardcore in Programming - Descriptor [Python 지식]- Descriptor 우선순위 ","permalink":"https://cjlee38.github.io/post/lang/python-property/","summary":"흔히 \u0026ldquo;객체지향\u0026rdquo; 에서는, 객체가 갖고 있는 Field 를 적절하게 외부로 노출시키거나 숨기기 위해, getter/setter를 사용한다. Java 에서는 private 이라는 키워드로 갖고 있는 멤버변수들을 모두 숨기고, 보여줄 내용은 getter 메소드를, 외부에 의해 변경되어도 되는 변수는 setter 메소드를 활용해 데이터를 관리한다. 따라서 직접적으로 변수에 접근하는 것은 원천적으로 금지되어 있고, 메소드 호출을 통해서만 데이터를 조작할 수 있다.\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.","title":"python property"}]